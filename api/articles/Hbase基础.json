{"title":"Hbase基础","uid":"2f890567b7501c264678f89b083cd223","slug":"Hbase基础","date":"2023-07-19T12:30:44.000Z","updated":"2023-07-19T12:45:04.290Z","comments":true,"path":"api/articles/Hbase基础.json","keywords":null,"cover":[],"content":"<h1 id=\"h-base-jian-jie\">HBase 简介</h1>\n<p>Google 三篇论文</p>\n<table>\n<thead>\n<tr>\n<th>论文名</th>\n<th>说明</th>\n<th>hadoop</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>《GFS》</td>\n<td>分布式文件系统</td>\n<td>HDFS(Hadoop Distributed File System)</td>\n</tr>\n<tr>\n<td>《MapReduce》</td>\n<td>分布式计算模型</td>\n<td>MapReduce</td>\n</tr>\n<tr>\n<td>《Bigtable》</td>\n<td>超级大表</td>\n<td>HBase</td>\n</tr>\n</tbody>\n</table>\n<p>结论：HBase 起源于 Google 的《Bigtable: A Distributed Storage System for Structured Data》这篇论文。</p>\n<p><strong>Hadoop HBase 是一个高可靠、高性能、可伸缩、面向列、随机实时读写的，分布式的数据库</strong>由于 HBase 属于我们的 Hadoop 生态圈，所以 HBase 的底层使用 HDFS 来进行存储，使用 MapReduce 来进行计算。并且主要存储的是“半结构化”与“非结构化”的数据。</p>\n<h2 id=\"h-base-yu-chuan-tong-guan-xi-shu-ju-ku-de-dui-bi-fen-xi\" id=\"HBase-与传统关系数据库的对比分析\">HBase 与传统关系数据库的对比分析</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>数据类型：关系数据库采用关系模型，具有丰富的数据类型和存储方式，HBase 则采用了更加简单的数据模型，它把数据存储为未经解释的字符串；</p>\n</li>\n<li class=\"lvl-3\">\n<p>数据操作：关系数据库中包含了丰富的操作，其中会涉及复杂的多表连接。HBase 操作则不存在复杂的表与表之间的关系，只有简单的插入、查询、删除、清空等，因为 HBase 在设计上就避免了复杂的表和表之间的关系；</p>\n</li>\n<li class=\"lvl-3\">\n<p>存储模式：关系数据库是基于行模式存储的。HBase 是基于列存储的，每个列族都由几个文件保存，不同列族的文件是分离的；</p>\n</li>\n<li class=\"lvl-3\">\n<p>数据索引：关系数据库通常可以针对不同列构建复杂的多个索引，以提高数据访问性能。HBase 只有一个索引——行键，通过巧妙的设计，HBase 中的所有访问方法，或者通过行键访问，或者通过行键扫描，从而使得整个系统不会慢下来；</p>\n</li>\n<li class=\"lvl-3\">\n<p>数据维护：在关系数据库中，更新操作会用最新的当前值去替换记录中原来的旧值，旧值被覆盖后就不会存在。而在 HBase 中执行更新操作时，并不会删除数据旧的版本，而是生成一个新的版本，旧有的版本仍然保留；</p>\n</li>\n<li class=\"lvl-3\">\n<p>可伸缩性：关系数据库很难实现横向扩展，纵向扩展的空间也比较有限。相反，HBase 和 BigTable 这些分布式数据库就是为了实现灵活的水平扩展而开发的，能够轻易地通过在集群中增加或者减少硬件数量来实现性能的伸缩</p>\n</li>\n</ol>\n<h2 id=\"shu-ju-mo-xing-xiang-guan-gai-nian\" id=\"数据模型相关概念\">数据模型相关概念</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>表：HBase 采用表来组织数据，表由行和列组成，列划分为若干个列族；</p>\n</li>\n<li class=\"lvl-3\">\n<p>行：每个 HBase 表都由若干行组成，每个行由行键（row key）来标识；</p>\n</li>\n<li class=\"lvl-3\">\n<p>列族：一个 HBase 表被分组成许多“列族”（Column Family）的集合，它是基本的访问控制单元，创建表的时候创建；</p>\n</li>\n<li class=\"lvl-3\">\n<p>列限定符：列族里的数据通过列限定符（或列）来定位；</p>\n</li>\n<li class=\"lvl-3\">\n<p>单元格：在 HBase 表中，通过行、列族和列限定符确定一个“单元格”（cell）；</p>\n</li>\n<li class=\"lvl-3\">\n<p>时间戳：每个单元格都保存着同一份数据的多个版本，这些版本采用时间戳进行索引；</p>\n</li>\n</ol>\n<h2 id=\"shu-ju-zuo-biao\" id=\"数据坐标\">数据坐标</h2>\n<p><strong>HBase 中需要根据行键、列族、列限定符和时间戳来确定一个单元格，因此，可以视为一个“四维坐标”，即[行键, 列族, 列限定符, 时间戳]</strong></p>\n<h2 id=\"h-base-de-shu-ju-cun-chu-mo-xing\" id=\"HBase-的数据存储模型\">HBase 的数据存储模型</h2>\n<p><strong>HBase 的数据的存储结构不同于传统的关系型数据库，HBase 是一种结构松散，分布式，多维 度有序映射的持久化存储系统</strong>，它索引的依据是行键、列键和时间戳。</p>\n<p>HBase 数据存储结构中主要包括：<strong>表、行、列族、列限定符、单元格和时间戳</strong>，下面将对 HBase 的数据存储模型的概念进行解释：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><strong>表(Table)</strong>：对应于关系型数据库中的一张张表，HBase 以“表”为单位组织数据，表由多行组成。</p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>行(Row)</strong>：行包含在表中，数据以行的形式存储在 HBase 的表中。HBase 的表中的每一行数 据都会被一个唯一标识的行键（RowKey）标识，这个 RowKey 类似于关系型数据库表中的 主键，RowKey 根据字典序进行排序，并且只能存储 64KB 的数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>列族(Colunm Family)</strong>：行中的数据又分为多个列族，并且每个列族下可包含多个列。列族 会在使用前定义，也就是在定义表的时候就定义列族。</p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>列限定符(Column Qualifier)</strong>：通常以列族，和列限定符来确定列族中的某列。</p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>时间戳(Timestamp)</strong>：每个单元格里面可以存储每一份数据的多个版本，时间戳是区分每 一份数据的一个版本号标识，每一个值都会对应一个时间戳，在默认情况下，时间戳表示数 据写入的时间。并且是按照时间倒序进行排序（最新的数据放在最上面）。也可以自己设 置，但是一般情况下不需要。</p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>单元格(Cell)</strong>：单元格由 RowKey、列族、列限定符唯一定位，单元格之中存放一个值**{row key， column(= family + qualifier)， version}** ，并且值以字节形式存储。</p>\n</li>\n</ul>\n<p>下面是一个具体的 HBase 表数据，来研究它的逻辑存储方式 👇</p>\n<p><img src=\"Hbase%E5%9F%BA%E7%A1%80/image-20230613103922334.png\" alt=\"image-20230613103922334\"></p>\n<p>上表展示的是 HBase 中的学生信息表 Student，有三行记录和两个列族，行键分别为 0001、 0002 和 0003，两个列族分别为 Stulnfo 和 Grades，每个列族中含有若干列，如列族 Stulnfo 包括 Name、Age、Sex 和 Class 四列，列族 Grades 包括 BigData、Computer 和 Math 三列。</p>\n<p>在 HBase 中，列不是固定的表结构，在创建表时，不需要预先定义列名，可以在插入数据时临时创建。</p>\n<p>从上表的逻辑模型来看，HBase 表与关系型数据库中的表结构之间似乎没有太大差异，只不过 多了列族的概念。但实际上是有很大差别的，关系型数据库中表的结构需要预先定义，如列名及 其数据类型和值域等内容。</p>\n<p>如果需要添加新列，则需要修改表结构，这会对已有的数据产生很大影响。同时，关系型数据 库中的表为每个列预留了存储空间，即上表中的空白 Cell 数据在关系型数据库中以“NULL”值占 用存储空间。因此，对稀疏数据来说，关系型数据库表中就会产生很多“NULL”值，消耗大量的存储空间。</p>\n<p>在 HBase 中，如上表中的空白 Cell 在物理上是不占用存储空间的，即不会存储空白的键值对。因此，若一个请求为获取 RowKey 为 0001 在 T2 时间的 Stulnfo:class 值时，其结果为空。 类似地，若一个请求为获取 RowKey 为 0002 在 T1 时间的 Grades Computer 值时，其结果也为空。</p>\n<p>下表展示了 Stulnfo 这个列族的实际物理存储方式，列族 Grades 的存储与之类似。在下表中可以看到空白 Cell 是没有被存储下来的。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">行键</th>\n<th style=\"text-align:center\">列标识</th>\n<th style=\"text-align:center\">值</th>\n<th style=\"text-align:center\">时间戳</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">0001</td>\n<td style=\"text-align:center\">Name</td>\n<td style=\"text-align:center\">Tom</td>\n<td style=\"text-align:center\">T2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0001</td>\n<td style=\"text-align:center\">Age</td>\n<td style=\"text-align:center\">18</td>\n<td style=\"text-align:center\">T2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0001</td>\n<td style=\"text-align:center\">Sex</td>\n<td style=\"text-align:center\">Male</td>\n<td style=\"text-align:center\">T2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0002</td>\n<td style=\"text-align:center\">Name</td>\n<td style=\"text-align:center\">Amy</td>\n<td style=\"text-align:center\">T1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0002</td>\n<td style=\"text-align:center\">Age</td>\n<td style=\"text-align:center\">19</td>\n<td style=\"text-align:center\">T1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0002</td>\n<td style=\"text-align:center\">Class</td>\n<td style=\"text-align:center\">01</td>\n<td style=\"text-align:center\">T1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0003</td>\n<td style=\"text-align:center\">Name</td>\n<td style=\"text-align:center\">Allen</td>\n<td style=\"text-align:center\">T1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0003</td>\n<td style=\"text-align:center\">Age</td>\n<td style=\"text-align:center\">19</td>\n<td style=\"text-align:center\">T1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0003</td>\n<td style=\"text-align:center\">Sex</td>\n<td style=\"text-align:center\">Male</td>\n<td style=\"text-align:center\">T1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">0003</td>\n<td style=\"text-align:center\">Class</td>\n<td style=\"text-align:center\">02</td>\n<td style=\"text-align:center\">T1</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"Hbase%E5%9F%BA%E7%A1%80/image-20230613114316010.png\" alt=\"image-20230613114316010\"></p>\n<h1 id=\"h-base-jia-gou\">HBase 架构</h1>\n<p>从下面的架构图可以发现 HBase 里面有这么几个角色：Client、Zookeeper、HMaster、 HRegionServer、HRegion、Store、MemStore、StoreFile、HFile、HLog 等。👇</p>\n<p><img src=\"Hbase%E5%9F%BA%E7%A1%80/image-20230613114452670.png\" alt=\"image-20230613114452670\"></p>\n<h2 id=\"client\" id=\"Client\">Client</h2>\n<p>包含访问 HBase 的接口，Client 访问用户数据前需要首先访问 ZooKeeper，Region 所在的位 置，然后才能找到用户所需要的数据，客户端会通过维护 cache 来加快对 HBase 的访问。</p>\n<h2 id=\"zoo-keeper\" id=\"ZooKeeper\">ZooKeeper</h2>\n<p>我们的 HBase 会使用到<code>zookeeper</code>，这里要注意，我们的 HBase 采用的是“主从结构”，有别于 HDFS 高可用中的“主备模式”，很凑巧它使用的是跟 zookeeper 一样的“主从模式”。在 HBase 中 zookeeper 主要有以下几个作用：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>✅ 为 HBase 提供故障转义机制，选举<code>HMaster</code>，避免单点 HMaster 单点故障问题。</p>\n</li>\n<li class=\"lvl-3\">\n<p>✅ 存储所有 <code>Region</code> 的寻址入口，我们的表在哪台服务器上，也就是这张表的位置信息。</p>\n</li>\n<li class=\"lvl-3\">\n<p>✅ 实时监控<code>RegionServer</code>的状态，将 RegionServer 的上线和下线信息实时通知给 HMaster。</p>\n</li>\n<li class=\"lvl-3\">\n<p>✅ 存储 HBase 的<code>schema</code>和<code>table元数据</code>，包括有哪些 Table，每个 Table 有哪些 Column Family。</p>\n</li>\n</ol>\n<h2 id=\"h-master\" id=\"HMaster\">HMaster</h2>\n<p>HMaster 一般运行在 NameNode 节点上面，它的主要作用有以下几点：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>✅ 为 RegionServer 分配 Region</p>\n</li>\n<li class=\"lvl-3\">\n<p>✅ 负责 RegionServer 的负载均衡</p>\n</li>\n<li class=\"lvl-3\">\n<p>✅ 发现失效的 RegionServer 并重新分配其上的 Region</p>\n</li>\n<li class=\"lvl-3\">\n<p>✅HDFS 上属于 HBase 的垃圾文件回收。</p>\n</li>\n<li class=\"lvl-3\">\n<p>✅ 处理客户端的更新请求（表的创建，删除，修改，列簇的增加等等）。</p>\n</li>\n</ol>\n<h2 id=\"h-region\" id=\"HRegion\">HRegion</h2>\n<p>HBase 的<code>table</code>在行的方向上分隔为多个<code>Region</code>（对应列族）。<code>Region</code>是 HBase 中分布式存储 和负载均衡的最小单元，即不同的<code>region</code>可以分别在不同的<code>Region Server</code>上，但同一个<code>Region</code>是不会拆分到多个 server 上，每个 region 会保存一个表里面某段连续的数据。</p>\n<p><code>Region</code>按大小分隔，表中每一行只能属于一个<code>region</code>。随着数据不断插入表，<code>region</code>不断增大，当<code>region</code>的 某个列族达到一个阈值时(<code>默认256M</code>)就会分成两个新的<code>region</code>。当一个表的数据越来越多的时候，有可能张在表的数据被保存在多个 Regionserver 上。</p>\n<h2 id=\"store\" id=\"Store\">Store</h2>\n<p>每一个<code>region</code>有一个或多个<code>store</code>组成，至少是一个<code>store</code>，hbase 会把一起访问的数据放在一个<code>store</code>里面，即为每个<code>ColumnFamily</code>建一个<code>store</code>（<strong>即有几个<code>ColumnFamily</code>，也就有几个 Store</strong>）。一个<code>Store</code>由一个<code>memStore</code>和<code>0</code>或<code>多个StoreFile</code>组成。<strong>HBase 以 store 的大小来判断是否需要切分 region。</strong></p>\n<p><code>MemStore</code>的值达到某个阈值（<code>默认128MB</code>），<code>RegionServer</code>会启动<code>flashcache</code>进程写入 <code>StoreFile</code>，每次写入形成单独的一个<code>StoreFile</code>，当<code>StoreFile</code>文件的数量增长到一定阈值后，系统会进行合并，在合并过程中会进行版本合并和删除工作，形成更大的<code>StoreFile</code>。</p>\n<p>当一个<code>Region</code>所有<code>StoreFile</code>的大小和数量超过一定阈值后，会把当前的<code>Region</code>分割为两个， 并由 HMaster 分配到相应的 RegionServer 服务器，实现系统的负载均衡。</p>\n<h2 id=\"h-file\" id=\"HFile\">HFile</h2>\n<p>HBase 中的数据的存储格式，HFile 是 Hadoop 的 二进制格式文件，实际上 StoreFile 就是对 HFile 做了轻量级包装，即 StoreFile 底层就是 HFile。</p>\n<h2 id=\"h-log\" id=\"HLog\">HLog</h2>\n<p>HLog(WAL log)：WAL 意为 write ahead log，用来做灾难恢复使用，HLog 记录数据的所有变 更，一旦 region server 宕机，就可以从 log 中进行恢复</p>\n<p>HLog 文件就是一个普通的 Hadoop Sequence File， Sequence File 的 value 是 key 时 HLogKey 对象，其中记录了写入数据的归属信息，除了 table 和 region 名字外，还同时包括 sequence number 和 timestamp，timestamp 是写入时间，sequence number 的起始值为 0，或者是最近 一次存入文件系统中的 sequence number。 Sequence File 的 value 是 HBase 的 KeyValue 对象， 即对应 HFile 中的 KeyValue。</p>\n<p><strong>整体物理结构如下</strong>👇</p>\n<p><img src=\"Hbase%E5%9F%BA%E7%A1%80/image-20230613121317590.png\" alt=\"image-20230613121317590\"></p>\n<p><strong>总结</strong>：</p>\n<p>1️⃣HRegion 是 HBase 中分布式存储和负载均衡的最小单元。最小单元就表示不同的 HRegion 可 以分布在不同的 HRegionServer 上。</p>\n<p>2️⃣HRegion 由一个或者多个 Store 组成，每个 store 保存一个 columns family。</p>\n<p>3️⃣ 每个 Strore 又由一个 MemStore 和 0 至多个 StoreFile 组成，最终 StoreFile 以 HFile 格式保存在 HDFS 上。</p>\n<h1 id=\"h-base-de-shell-cao-zuo\">HBase 的 shell 操作</h1>\n<h2 id=\"cao-zuo-ming-ming-kong-jian\" id=\"操作命名空间\">操作命名空间</h2>\n<p><code>命名空间(namespace)</code>是与关系数据库系统中的数据库类似，我们以前使用 MySQL 的时候会先 创建数据库，然后在这个数据库里面创建表，我们的 HBase 也类似。</p>\n<h3 id=\"cha-kan-suo-you-ming-ming-kong-jian\" id=\"查看所有命名空间\">查看所有命名空间</h3>\n<p>使用“list_namespace”查看命名空间，有点类似于 MySQL 里面的“show databases”来查看系统 里面的所有数据库一样。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看系统里面的所有的命名空间。</span>\nlist_namespace<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"chuang-jian-ming-ming-kong-jian\" id=\"创建命名空间\">创建命名空间</h3>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 创建命名空间的语法</span>\ncreate_namespace <span class=\"token string\">'命名空间的名称'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"xian-shi-ming-ming-kong-jian-xia-de-biao\" id=\"显示命名空间下的表\">显示命名空间下的表</h3>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">list_namespace_tables <span class=\"token string\">'命名空间名称'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"shan-chu-ming-ming-kong-jian\" id=\"删除命名空间\">删除命名空间</h3>\n<p>如果命名空间不需要了可以使用“drop_namespace”命令来删除，要注意删除命名空间的时 候，这个命名空间得是空的。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">drop_namespace <span class=\"token string\">'要删除的命名空间的名称'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"hbase-biao-ge-de-ji-ben-jie-gou\" id=\"hbase-表格的基本结构\">hbase 表格的基本结构</h2>\n<p><img src=\"Hbase%E5%9F%BA%E7%A1%80/hbase-logical-to-phisical-view.png\" alt=\"hbase-logical-to-phisical-view\"></p>\n<p><img src=\"Hbase%E5%9F%BA%E7%A1%80/Snipaste_2023-05-06_17-54-25.png\" alt=\"\"></p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>表(Table)：对应于关系型数据库中的一张张表，HBase 以“表”为单位组织数据，表由多行组 成。</p>\n</li>\n<li class=\"lvl-2\">\n<p>行(Row)：行包含在表中，数据以行的形式存储在 HBase 的表中。HBase 的表中的每一行数 据都会被一个唯一标识的行键（RowKey）标识，这个 RowKey 类似于关系型数据库表中的 主键，RowKey 根据字典序进行排序，并且只能存储 64KB 的数据。</p>\n</li>\n<li class=\"lvl-2\">\n<p>列族(Colunm Family)：行中的数据又分为多个列族，并且每个列族下可包含多个列。列族 会在使用前定义，也就是在定义表的时候就定义列族。</p>\n</li>\n<li class=\"lvl-2\">\n<p>列限定符(Column Qualifier)：通常以列族，和列限定符来确定列族中的某列。</p>\n</li>\n<li class=\"lvl-2\">\n<p>时间戳(Timestamp)：每个单元格里面可以存储每一份数据的多个版本，时间戳是区分每 一份数据的一个版本号标识，每一个值都会对应一个时间戳，在默认情况下，时间戳表示数 据写入的时间。并且是按照时间倒序进行排序（最新的数据放在最上面）。也可以自己设 置，但是一般情况下不需要。</p>\n</li>\n<li class=\"lvl-2\">\n<p>单元格(Cell)：单元格由 RowKey、列族、列限定符唯一定位，单元格之中存放一个值{row key， column(= family + qualifier)， version} ，并且值以字节形式存储。</p>\n</li>\n</ul>\n<h3 id=\"chuang-jian-biao\" id=\"创建表\">创建表</h3>\n<h4 id=\"chang-gui-biao-de-chuang-jian\" id=\"常规表的创建\">常规表的创建</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">  create <span class=\"token string\">'表名'</span>, <span class=\"token string\">'列族名1'</span><span class=\"token punctuation\">[</span>,…<span class=\"token punctuation\">]</span>\n  create <span class=\"token string\">'命名空间:表名'</span>, <span class=\"token string\">'列族名1'</span><span class=\"token punctuation\">[</span>,…<span class=\"token punctuation\">]</span>\n<span class=\"token comment\"># 或者</span>\n  create <span class=\"token string\">'表名'</span>, <span class=\"token punctuation\">&#123;</span>NAME <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token string\">'列族1'</span>,VERSIONS <span class=\"token operator\">=</span><span class=\"token operator\">></span> versionNum<span class=\"token punctuation\">(</span>最多存储的版本数量<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">[</span>, <span class=\"token punctuation\">&#123;</span>NAME <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token string\">'列族2'</span><span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">..</span>. <span class=\"token punctuation\">]</span>\n  create <span class=\"token string\">'命名空间:表名'</span>, <span class=\"token punctuation\">&#123;</span>NAME <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token string\">'列族1'</span><span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">[</span>, <span class=\"token punctuation\">&#123;</span>NAME <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token string\">'列族2'</span><span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">..</span>. <span class=\"token punctuation\">]</span>\n\n <span class=\"token comment\"># =>不是>=的意思</span>\n\n<span class=\"token comment\"># 创建一个test的表，并且指定一个列族cf。</span>\ncreate <span class=\"token string\">'test'</span>, <span class=\"token string\">'cf'</span>\n\n<span class=\"token comment\"># 创建一个学生表“student”，然后指定两个列族，一个是“detail”一个是“grade”。</span>\n create <span class=\"token string\">'student'</span>, <span class=\"token string\">'detail'</span>, <span class=\"token string\">'grade'</span>\n\n<span class=\"token comment\"># 在my_nn命名空间下面创建学生表</span>\ncreate <span class=\"token string\">'my_nn:student1'</span>, <span class=\"token string\">'detail'</span>, <span class=\"token string\">'grade'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>⚠<strong>注意</strong>：建表的时候需要指定表名，并且还需要同时指定至少一个列族。</p></blockquote>\n<h4 id=\"cha-kan-biao-de-xin-xi\" id=\"查看表的信息\">查看表的信息</h4>\n<p>我们可以通过“list”命令查看表是否存在，以及使用“describe”命令来查看表的结构信息。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看'test'表是否存在</span>\nlist <span class=\"token string\">'test'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>我们也可以通过“exists ”来检查表是否存在，他比上面的“list”更加直观。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">exists <span class=\"token string\">'my_tab'</span>\n\n<span class=\"token operator\">=</span><span class=\"token operator\">></span> true/false<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>我们可以通过“describe”查看表的描述信息，这个和以前的 MySQL 里面的“desc”的效果是类似 的。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">describe <span class=\"token string\">'test'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"cao-zuo-biao\" id=\"操作表\">操作表</h3>\n<h4 id=\"cha-ru-shu-ju\" id=\"插入数据\">插入数据</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">put <span class=\"token string\">'表名'</span> <span class=\"token string\">'RowKey'</span>, <span class=\"token string\">'列族名:列名'</span>, <span class=\"token string\">'列对应的值'</span>\n\n<span class=\"token comment\">#使用put语句插入数据</span>\nput <span class=\"token string\">'test'</span>, <span class=\"token string\">'row1'</span>, <span class=\"token string\">'cf:a'</span>, <span class=\"token string\">'value1'</span>\nput <span class=\"token string\">'test'</span>, <span class=\"token string\">'row2'</span>, <span class=\"token string\">'cf:b'</span>, <span class=\"token string\">'value2'</span>\nput <span class=\"token string\">'test'</span>, <span class=\"token string\">'row3'</span>, <span class=\"token string\">'cf:c'</span>, <span class=\"token string\">'value3'</span>\n\n<span class=\"token comment\">#插入数据并且带时间戳。</span>\nput <span class=\"token string\">'test'</span>, <span class=\"token string\">'row4'</span>, <span class=\"token string\">'cf:a'</span>, <span class=\"token string\">'value1'</span>, <span class=\"token number\">1647938469167</span>\nput <span class=\"token string\">'test'</span>, <span class=\"token string\">'row5'</span>, <span class=\"token string\">'cf:b'</span>, <span class=\"token string\">'value2'</span>, <span class=\"token number\">1647938469167</span>\nput <span class=\"token string\">'test'</span>, <span class=\"token string\">'row5'</span>, <span class=\"token string\">'cf:c'</span>, <span class=\"token string\">'value3'</span>, <span class=\"token number\">1647938469167</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"sao-miao-biao-de-shu-ju\" id=\"扫描表的数据\">扫描表的数据</h4>\n<p><strong>scan(全表查询)</strong></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">scan <span class=\"token string\">'表名'</span>\n\n<span class=\"token comment\">#通过版本来获取值：查看最近两个版本的数据。</span>\nscan <span class=\"token string\">'tab_ver'</span>, <span class=\"token punctuation\">&#123;</span> <span class=\"token environment constant\">COLUMNS</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">[</span><span class=\"token string\">'cf:col1'</span><span class=\"token punctuation\">]</span>, VERSIONS <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token number\">2</span> <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>通过 get 查询</strong></p>\n<p>上面的查询是全表查询，有的时候我们是通过 RowId 或者单元(cell)的值来进行查询，这个时候 就可以通过 get。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 获取列族下面的全部数据。</span>\nget <span class=\"token string\">'表名'</span>, <span class=\"token string\">'RowKey'</span>\n<span class=\"token comment\"># 获取列族下面的某一列。</span>\nget <span class=\"token string\">'表名'</span>, <span class=\"token string\">'RowKey'</span>, <span class=\"token string\">'列族名称:列'</span>\n\n<span class=\"token comment\">#使用get命令通过\"RowKey\"查询数据</span>\nget <span class=\"token string\">'test'</span>, <span class=\"token string\">'row1'</span>\n\n<span class=\"token comment\">#通过列来查询数据</span>\nget <span class=\"token string\">'test'</span>, <span class=\"token string\">'row1'</span>, <span class=\"token string\">'cf:a'</span>\n\n<span class=\"token comment\">#通过版本来获取值：查看最近两个版本的数据</span>\nget <span class=\"token string\">'tab_ver'</span>, <span class=\"token string\">'0001'</span>, <span class=\"token punctuation\">&#123;</span> <span class=\"token environment constant\">COLUMNS</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">[</span><span class=\"token string\">'cf:col1'</span><span class=\"token punctuation\">]</span>,VERSIONS <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token number\">2</span> <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"shan-chu-biao-de-shu-ju\" id=\"删除表的数据\">删除表的数据</h4>\n<p><strong>delete</strong></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">delete <span class=\"token string\">'表名'</span>, <span class=\"token string\">'RowKey'</span>, <span class=\"token string\">'列族名称:列'</span> <span class=\"token punctuation\">[</span>, 时间戳<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">#注意:如果不指定时间戳会删除最新的version!</span>\n\n\n<span class=\"token comment\"># 删除'test'表，RowKey为‘row1’的，并且列族“cf”的值为“a”的值。</span>\ndelete <span class=\"token string\">'test'</span>, <span class=\"token string\">'row1'</span>, <span class=\"token string\">'cf:a'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>delete 只会删除指定列中的指定位置的数据,并不会删除这个数据的所在行</strong></p>\n<p><strong>deleteall</strong></p>\n<p>如需删除表中某一行上所有列族的数据，即删除上表中一个逻辑行， 则需要使用 deleteall，如下所示，不需要指定列族和列的名称。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">deleteall <span class=\"token string\">'表名'</span>, <span class=\"token string\">'RowKey'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>truncate</strong></p>\n<p><strong>“truncate”<strong>命令也是删除表的数据，但是它和上面的 delete、deleteall 有不同，它的作用和关 系型数据库里面的作用类似，使用它的效果是：</strong>“使得表无效，然后删除表，再重新创建表”</strong>。使 用场景：就是当表的数据很大时候，可以使用“truncate”来清空表。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">truncate <span class=\"token string\">'表名'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"shan-chu-biao\" id=\"删除表\">删除表</h4>\n<p>先要使用表不可用，然后再使用删除</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 使得表不可用</span>\ndisable <span class=\"token string\">'test'</span>\n\n<span class=\"token comment\"># 删除表</span>\ndrop <span class=\"token string\">'test'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"deng-lu-shell\" id=\"登录-shell\">登录 shell</h2>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">hbase shell<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n","text":"HBase 简介 Google 三篇论文 论文名 说明 hadoop 《GFS》 分布式文件系统 HDFS(Hadoop Distributed File System) 《MapReduce》 分布式计算模型 MapReduce 《Bigtable》 超级大表 HBase 结论...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"NoSQL","slug":"NoSQL","count":2,"path":"api/categories/NoSQL.json"}],"tags":[{"name":"Hbase","slug":"Hbase","count":1,"path":"api/tags/Hbase.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#h-base-jian-jie\"><span class=\"toc-text\">HBase 简介</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#h-base-yu-chuan-tong-guan-xi-shu-ju-ku-de-dui-bi-fen-xi\"><span class=\"toc-text\">HBase 与传统关系数据库的对比分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#shu-ju-mo-xing-xiang-guan-gai-nian\"><span class=\"toc-text\">数据模型相关概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#shu-ju-zuo-biao\"><span class=\"toc-text\">数据坐标</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#h-base-de-shu-ju-cun-chu-mo-xing\"><span class=\"toc-text\">HBase 的数据存储模型</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#h-base-jia-gou\"><span class=\"toc-text\">HBase 架构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#client\"><span class=\"toc-text\">Client</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#zoo-keeper\"><span class=\"toc-text\">ZooKeeper</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#h-master\"><span class=\"toc-text\">HMaster</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#h-region\"><span class=\"toc-text\">HRegion</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#store\"><span class=\"toc-text\">Store</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#h-file\"><span class=\"toc-text\">HFile</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#h-log\"><span class=\"toc-text\">HLog</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#h-base-de-shell-cao-zuo\"><span class=\"toc-text\">HBase 的 shell 操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#cao-zuo-ming-ming-kong-jian\"><span class=\"toc-text\">操作命名空间</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#cha-kan-suo-you-ming-ming-kong-jian\"><span class=\"toc-text\">查看所有命名空间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#chuang-jian-ming-ming-kong-jian\"><span class=\"toc-text\">创建命名空间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xian-shi-ming-ming-kong-jian-xia-de-biao\"><span class=\"toc-text\">显示命名空间下的表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#shan-chu-ming-ming-kong-jian\"><span class=\"toc-text\">删除命名空间</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#hbase-biao-ge-de-ji-ben-jie-gou\"><span class=\"toc-text\">hbase 表格的基本结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#chuang-jian-biao\"><span class=\"toc-text\">创建表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#chang-gui-biao-de-chuang-jian\"><span class=\"toc-text\">常规表的创建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cha-kan-biao-de-xin-xi\"><span class=\"toc-text\">查看表的信息</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#cao-zuo-biao\"><span class=\"toc-text\">操作表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cha-ru-shu-ju\"><span class=\"toc-text\">插入数据</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#sao-miao-biao-de-shu-ju\"><span class=\"toc-text\">扫描表的数据</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#shan-chu-biao-de-shu-ju\"><span class=\"toc-text\">删除表的数据</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#shan-chu-biao\"><span class=\"toc-text\">删除表</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#deng-lu-shell\"><span class=\"toc-text\">登录 shell</span></a></li></ol></li></ol>","author":{"name":"ND_LJQ","slug":"blog-author","avatar":"/svg/head.jpg","link":"/","description":"一位正在摆烂的大四渣滓😋 <br /> @ <b>劉三刀的摆烂生活</b>","socials":{"github":"https://github.com/ND-LJQ","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_52475868?type=blog","juejin":"https://juejin.cn/user/2032336272362109","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/391491132?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/liu-jq"}}}},"mapped":true,"prev_post":{"title":"js学习笔记","uid":"aa70f67d4ef6e029542c043a9994018c","slug":"js学习笔记","date":"2023-07-19T12:53:54.000Z","updated":"2023-07-21T06:58:46.507Z","comments":true,"path":"api/articles/js学习笔记.json","keywords":null,"cover":"/svg/js.jpg","text":"小知识 浏览器内核 Webkit 苹果开发 用于 Safari Blink Webkit 的一个分支,Google 开发,目前应用于 Google Chrome,Edge,Opera 等浏览器 浏览器的渲染过程 Js 引擎 js 引擎将 js 代码翻译成CPU 指令来执行 V8 ...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"前端","slug":"前端","count":12,"path":"api/categories/前端.json"}],"tags":[{"name":"js","slug":"js","count":1,"path":"api/tags/js.json"}],"author":{"name":"ND_LJQ","slug":"blog-author","avatar":"/svg/head.jpg","link":"/","description":"一位正在摆烂的大四渣滓😋 <br /> @ <b>劉三刀的摆烂生活</b>","socials":{"github":"https://github.com/ND-LJQ","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_52475868?type=blog","juejin":"https://juejin.cn/user/2032336272362109","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/391491132?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/liu-jq"}}}}},"next_post":{"title":"Redis6.0学习笔记","uid":"dfbecd5a2d7d99309d0ce29d3d8528f9","slug":"Redis6.0学习笔记","date":"2023-07-19T11:54:00.000Z","updated":"2023-07-19T12:25:21.369Z","comments":true,"path":"api/articles/Redis6.0学习笔记.json","keywords":null,"cover":[],"text":"Redis 是典型的 NoSQL 数据库，支持多种数据结构类型。设计思想是：单线程+多路 IO 复用技术 redis 官方介绍 Redis 是一个开源的 key-value 存储系统。和 Memcached 类似，它支持存储的 value 类型相对更多，包括 string、lis...","link":"","photos":[],"count_time":{"symbolsCount":"57k","symbolsTime":"51 mins."},"categories":[{"name":"NoSQL","slug":"NoSQL","count":2,"path":"api/categories/NoSQL.json"}],"tags":[{"name":"Redis","slug":"Redis","count":1,"path":"api/tags/Redis.json"}],"author":{"name":"ND_LJQ","slug":"blog-author","avatar":"/svg/head.jpg","link":"/","description":"一位正在摆烂的大四渣滓😋 <br /> @ <b>劉三刀的摆烂生活</b>","socials":{"github":"https://github.com/ND-LJQ","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_52475868?type=blog","juejin":"https://juejin.cn/user/2032336272362109","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/391491132?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/liu-jq"}}}}}}