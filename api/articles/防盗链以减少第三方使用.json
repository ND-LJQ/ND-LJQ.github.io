{"title":"防盗链以减少第三方使用","uid":"b8bc55f65f263c1da29bfad5ecf3ec77","slug":"防盗链以减少第三方使用","date":"2023-07-19T13:18:04.000Z","updated":"2023-07-19T14:07:43.810Z","comments":true,"path":"api/articles/防盗链以减少第三方使用.json","keywords":null,"cover":null,"content":"<h1 id=\"xiang-jie-referer\">详解Referer</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>Referer是什么</p>\n<p>Referer 是请求头信息里的一个常见字段，它提供了访问来源的信息</p>\n<p>当客户端向服务端发送请求时，都会携带 Referer 头字段，告知服务器该请求的来源，即 <code>触发请求的页面链接</code></p>\n</li>\n<li class=\"lvl-2\">\n<p>Referer存在的条件</p>\n<p>1、点击页面中的超链接</p>\n<p>2、通过 <code>src</code> 或 <code>href</code> 属性加载静态资源，如图片、视频、脚本、样式等等</p>\n<p>3、通过 <code>get</code> 或 <code>post</code> 发送请求</p>\n</li>\n<li class=\"lvl-2\">\n<p>获取不到Referer的情况</p>\n<p>1、直接在浏览器中输入 <code>URL</code> 地址</p>\n<p>2、在 <code>HTTPS</code> 应用中使用第三方应用的 <code>HTTP</code> 资源</p>\n</li>\n<li class=\"lvl-2\">\n<p>Referer的作用</p>\n<p>1、对应用流量的来源做统计</p>\n<p>2、防止资源被盗链</p>\n</li>\n</ul>\n<p>当页面链接至使用 <code>target=&quot;_blank&quot;</code> 的另一个页面时，新页面将与您的页面在同一个进程上运行。 如果新页面正在执行开销极大的 <code>JavaScript</code>，页面性能可能会受影响。<code>target=&quot;_blank&quot;</code>也是一个安全漏洞。新的页面可以通过<code>window.opener</code> 访问您的窗口对象，并且它可以使用 <code>window.opener.location = newURL</code>将页面导航至不同的网址。</p>\n<p>原来，<strong>当你使用<code>target=&quot;_blank&quot;</code>打开一个新的标签页时，新页面的<code>window</code>对象上有一个属性 <code>opener</code> ,它指向的是前一个页面的<code>window</code>对象，因此，后一个新打开的页面就可以控制前一个页面了，事情就是这么的可怕…</strong></p>\n<p>a标签<code>&lt;a href='https://www.xxx.com'&gt;https://www.xxx.com&lt;/a&gt;</code>,如果<strong>打开的页面的域名和当前页面的域名是在同一个域名下</strong>，在打开后的控制台输入<code>window.opener.alert(1)</code>,你会惊讶的发现，上一个页面竟然弹出个大大的<code>1</code>，自己动手试一下吧！</p>\n<p>而在<strong>跳转到另一个域名的页面</strong>的情况下，使用<code>window.opener.location.replace</code>方法，可以把上一个页面的<code>url</code>给改掉</p>\n<h1 id=\"xiang-jie-dao-lian\">详解盗链</h1>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>什么是盗链</p>\n<p>未经第三方授权或同意，就把其资源引用到了自己的应用上，比如图片、视频、文件下载等等，可以通过消耗第三方应用的流量来在自己的应用中使用这些资源</p>\n<p>浏览器在页面呈现的过程中，拉取非当前应用的资源，就称为是<strong>盗链</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p>实现盗链</p>\n<p>1、在 <code>HTTPS</code> 应用中使用第三方应用的 <code>HTTP</code> 资源</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">\n<p>2、通过设置 a 标签的 rel 属性</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>a</span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>视频资源地址<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">target</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>_blank<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">rel</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>noopener noreferrer<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>通过设置 <code>noreferrer</code> 属性禁用请求头部的 <code>Referer</code> 属性，可在新页面中访问防盗链资源</p>\n<p>通过设置 <code>noopener</code> 属性在新打开的页面中不授予对打开它的文档的访问权限，即 <code>window.opener</code> 属性值返回 <code>null</code>，以此来确保无法通过 <code>window.opener</code> 属性来篡改原始文档<br>\n<code>rel=noreferrer</code> 是为了兼容旧浏览器。</p>\n</li>\n</ul>\n<h1 id=\"zhu-yi-shi-xiang\">注意事项</h1>\n<p>平常在应用中通过 <code>a</code> 标签链接第三方外部资源时（打开新页面），都应该添加以上属性，以增强应用的<code>安全性</code></p>\n<p>从 Chromium 88 版开始，默认情况下，带有 target=“_blank” 的锚点会自动获得 noopener 行为。</p>\n","text":"详解Referer Referer是什么 Referer 是请求头信息里的一个常见字段，它提供了访问来源的信息 当客户端向服务端发送请求时，都会携带 Referer 头字段，告知服务器该请求的来源，即 触发请求的页面链接 Referer存在的条件 1、点击页面中的超链接 2、通过...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"前端","slug":"前端","count":12,"path":"api/categories/前端.json"},{"name":"业务与性能优化","slug":"前端/业务与性能优化","count":10,"path":"api/categories/前端/业务与性能优化.json"}],"tags":[{"name":"业务与性能优化(前端)","slug":"业务与性能优化-前端","count":10,"path":"api/tags/业务与性能优化-前端.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#xiang-jie-referer\"><span class=\"toc-text\">详解Referer</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#xiang-jie-dao-lian\"><span class=\"toc-text\">详解盗链</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#zhu-yi-shi-xiang\"><span class=\"toc-text\">注意事项</span></a></li></ol>","author":{"name":"ND_LJQ","slug":"blog-author","avatar":"https://raw.githubusercontent.com/ND-LJQ/nd-ljq.github.io/master/static/img/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"上传文件校验","uid":"86764947a727ee084db201a1bc419262","slug":"上传文件校验","date":"2023-07-19T13:18:22.000Z","updated":"2023-07-19T13:56:23.563Z","comments":true,"path":"api/articles/上传文件校验.json","keywords":null,"cover":[],"text":"如果把任意的垃圾文件后缀名修改成允许上传的类型，不仅会造成程序崩溃，还有可能会浪费不必要的资源 这种恶意上传的操作，不仅带来安全隐患，还会造成不必要的性能开销 前置知识点 [[File&amp;Blob]] Blob 对象 Blob（Binary Large Object）二进制...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"前端","slug":"前端","count":12,"path":"api/categories/前端.json"},{"name":"业务与性能优化","slug":"前端/业务与性能优化","count":10,"path":"api/categories/前端/业务与性能优化.json"}],"tags":[{"name":"业务与性能优化(前端)","slug":"业务与性能优化-前端","count":10,"path":"api/tags/业务与性能优化-前端.json"}],"author":{"name":"ND_LJQ","slug":"blog-author","avatar":"https://raw.githubusercontent.com/ND-LJQ/nd-ljq.github.io/master/static/img/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"代码中大量ifelse的优化策略","uid":"f5f9f413e1e1b984d70a81caebf4b657","slug":"代码中大量ifelse的优化策略","date":"2023-07-19T13:17:38.000Z","updated":"2023-07-19T13:51:20.480Z","comments":true,"path":"api/articles/代码中大量ifelse的优化策略.json","keywords":null,"cover":[],"text":"单个 if 语句单条件优化 优化前 if (flag) &#123; this.handleFunc() &#125; 优化后 flag &amp;&amp; this.handleFunc() 如果有很多的 if 语句，但执行的功能函数是同一个的情况下，可以使用 &amp; 和...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"前端","slug":"前端","count":12,"path":"api/categories/前端.json"},{"name":"业务与性能优化","slug":"前端/业务与性能优化","count":10,"path":"api/categories/前端/业务与性能优化.json"}],"tags":[{"name":"业务与性能优化(前端)","slug":"业务与性能优化-前端","count":10,"path":"api/tags/业务与性能优化-前端.json"}],"author":{"name":"ND_LJQ","slug":"blog-author","avatar":"https://raw.githubusercontent.com/ND-LJQ/nd-ljq.github.io/master/static/img/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}