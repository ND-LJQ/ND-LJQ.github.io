{"title":"docker的基本使用","uid":"e7498051f03c6ed58194e6874f009871","slug":"docker的基本使用","date":"2023-07-18T05:39:37.000Z","updated":"2023-07-18T05:55:19.043Z","comments":true,"path":"api/articles/docker的基本使用.json","keywords":null,"cover":[],"content":"<h1 id=\"docker-de-ji-ben-shi-yong\">Docker的基本使用</h1>\n<p>docker的意思是容器,是基于Go语言的轻量级的虚拟机</p>\n<h3 id=\"ubuntu-an-zhuang-docker\" id=\"Ubuntu安装Docker\">Ubuntu安装Docker</h3>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> docker.io\n\n<span class=\"token comment\">#也可以使用wget使用官方脚本来进行安装</span>\n<span class=\"token function\">curl</span> <span class=\"token parameter variable\">-fsSL</span> https://get.docker.com <span class=\"token operator\">|</span> <span class=\"token function\">bash</span> <span class=\"token parameter variable\">-s</span> <span class=\"token function\">docker</span> <span class=\"token parameter variable\">--mirror</span> Aliyun<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"jian-cha-docker-shi-fou-an-zhuang-cheng-gong\" id=\"检查docker是否安装成功\">检查docker是否安装成功</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> version<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><img src=\"docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/20190328162445806.jpg\" alt=\"img\"></p>\n<p>注意这里只显示了Client的信息，下面有一个报错: persission denied…，这个是因为我们安装的时候是用的sudo安装，在这里是没有权限连接docker的服务端，解决办法是把当前用户加入到docker组里面去。</p>\n<p>首先新建一个docker组</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">sudo groupadd docker<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>但是很可能已经有了docker组了，已有的话就不用管了，继续下一步<img src=\"docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/20190328164344428.png\" alt=\"img\"><br>\n然后把当前用户加入docker组</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">sudo gpasswd -a $&#123;USER&#125; docker<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>重启docker</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">service</span> <span class=\"token function\">docker</span> restart<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>切换当前会话到新 group</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">newgrp - <span class=\"token function\">docker</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>最后一步是必须的，如果不切换，组信息不会立刻生效的。</p>\n<p>最后测试下效果</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> version<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><img src=\"docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1.png\" alt=\"img\"></p>\n<p>最后的最后，因为国内网速问题，下载镜像比较慢所以可以使用国内大厂提供的加速器，我这里使用的是阿里云提供的加速器，使用镜像加速必须得改一下docker的配置文件 /etc/docker/daemon.json</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#没有则新建</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">vim</span> /etc/docker/daemon.json\n\n<span class=\"token comment\">#在里面加入阿里云镜像加速器地址</span>\n<span class=\"token punctuation\">&#123;</span>\n  <span class=\"token string\">\"registry-mirrors\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"https://4m0bchll.mirror.aliyuncs.com\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>刷新设置,重启docker</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl daemon-reload\n<span class=\"token function\">sudo</span> systemctl restart <span class=\"token function\">docker</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h4 id=\"she-zhi-docker-kai-ji-zi-qi\" id=\"设置docker开机自启\">设置docker开机自启</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">systemctl <span class=\"token builtin class-name\">enable</span> <span class=\"token function\">docker</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"docker-de-ji-ben-zhi-ling\" id=\"Docker的基本指令\">Docker的基本指令</h3>\n<h4 id=\"cha-kan-ban-ben\" id=\"查看版本\">查看版本</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> version<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"cha-kan-docker-xin-xi\" id=\"查看docker信息\">查看docker信息</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> info<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"cha-xun-jing-xiang-xin-xi\" id=\"查询镜像信息\">查询镜像信息</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> search mirrorName\n\n例子\n<span class=\"token function\">docker</span> search nginx<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>镜像给我的感觉就像是安装包</p>\n<h4 id=\"cha-xun-jing-xiang-rong-qi-yuan-shu-ju\" id=\"查询镜像-容器元数据\">查询镜像/容器元数据</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> inspect <span class=\"token punctuation\">[</span>OPTIONS<span class=\"token punctuation\">]</span> NAME/ID <span class=\"token punctuation\">[</span>NAME/ID<span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span>\n\nOPTIONS：\n\t<span class=\"token parameter variable\">-f</span> :指定返回值的模板文件。\n\t<span class=\"token parameter variable\">-s</span> :显示总的文件大小。\n\t<span class=\"token parameter variable\">--type</span> :为指定类型返回JSON。\n\n<span class=\"token comment\">#获取镜像mysql:5.6的元信息</span>\n<span class=\"token function\">docker</span> inspect mysql:5.6<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"xia-zai-jing-xiang\" id=\"下载镜像\">下载镜像</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> pull mirrorName<span class=\"token punctuation\">[</span>:versionNumber<span class=\"token punctuation\">]</span>\n\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>里为可选\n不加具体版本的话默认下载最新版本<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"cha-kan-ben-di-jing-xiang-lie-biao\" id=\"查看本地镜像列表\">查看本地镜像列表</h4>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker images<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"gei-jing-xiang-da-biao-qian\" id=\"给镜像打标签\">给镜像打标签</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> tag source_image<span class=\"token punctuation\">[</span>:tag<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>就是image查询种对应镜像的id<span class=\"token punctuation\">)</span> tartget_image<span class=\"token punctuation\">[</span>:tag<span class=\"token punctuation\">]</span>\n\n镜像结构 registryname/respositoryname<span class=\"token punctuation\">(</span>仓库名<span class=\"token punctuation\">)</span>/imagename<span class=\"token punctuation\">(</span>镜像名<span class=\"token punctuation\">)</span>:tagname<span class=\"token punctuation\">(</span>标签名<span class=\"token punctuation\">)</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"deng-lu-docker\" id=\"登录docker\">登录docker</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> login\n\n<span class=\"token comment\">#登录后的用户信息会保存在 ~/.docker/config.json种</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"jiang-jing-xiang-fa-bu-dao-yuan-cheng\" id=\"将镜像发布到远程\">将镜像发布到远程</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> push userName/imageName:versionTag<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"shan-chu-jing-xiang\" id=\"删除镜像\">删除镜像</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#删除标签(删除指定版本的镜像)</span>\n<span class=\"token function\">docker</span> rmi repository<span class=\"token punctuation\">[</span>:tag<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">#强制删除</span>\n<span class=\"token function\">docker</span> rmi <span class=\"token parameter variable\">-f</span> imageID<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"yun-xing-jing-xiang-chuang-jian-rong-qi\" id=\"运行镜像-创建容器\">运行镜像(创建容器)</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run <span class=\"token punctuation\">[</span>options<span class=\"token punctuation\">]</span> image <span class=\"token punctuation\">[</span>command<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>arguments<span class=\"token punctuation\">]</span>\n\noptions:\n\t-i:表示启动一个可交互的容器,并持续打开标准输入,通常与 <span class=\"token parameter variable\">-t</span> 同时使用\n\t-t:为容器重新分配一个伪输入终端，通常与 <span class=\"token parameter variable\">-i</span> 同时使用\n\t-d:表示容器放置后台运行\n\t-p: 指定端口映射，格式为：主机<span class=\"token punctuation\">(</span>宿主<span class=\"token punctuation\">)</span>端口:容器端口\n\t<span class=\"token parameter variable\">-m</span> :设置容器使用内存最大值；\n\t<span class=\"token parameter variable\">-h</span> <span class=\"token string\">\"mars\"</span><span class=\"token builtin class-name\">:</span> 指定容器的hostname\n\t<span class=\"token parameter variable\">-v</span> 容器外部目录:容器内部目录 -<span class=\"token operator\">></span>绑定一个卷<span class=\"token punctuation\">(</span>将容器外部目录映射到容器外部目录<span class=\"token punctuation\">)</span>\n\t如果不写容器外部目录,则是匿名挂载\n\t--volumes-from container1 :将容器名为container1的数据卷共享给当前run指令创建的容器\n\t--rm:表示退出后即删除容器\n\t--name:表示定义容器的唯一名称,不指定docker默认分配\n\t<span class=\"token parameter variable\">--expose</span><span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>: 开放一个端口或一组端口\n\t<span class=\"token parameter variable\">--cpuset</span><span class=\"token operator\">=</span><span class=\"token string\">\"0-2\"</span> or <span class=\"token parameter variable\">--cpuset</span><span class=\"token operator\">=</span><span class=\"token string\">\"0,1,2\"</span><span class=\"token builtin class-name\">:</span> 绑定容器到指定CPU运行\n\t<span class=\"token parameter variable\">--dns</span> <span class=\"token number\">8.8</span>.8.8: 指定容器使用的DNS服务器，默认和宿主一致；\n\t--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；\n\t<span class=\"token parameter variable\">--restart</span><span class=\"token operator\">=</span> 后接1个参数<span class=\"token punctuation\">(</span>always:容器退出时总是重启<span class=\"token punctuation\">;</span>\n\t\t\t\t\t\t   on-failure:number :若容器的退出状态非0，则docker自动重启容器，还可以指定重启次数，若超过指定次数未能启动容器则放弃<span class=\"token punctuation\">;</span>\n\t\t\t\t\t\t   no: 默认值，表示容器退出时，docker不自动重启容器<span class=\"token punctuation\">;</span>\n\t\t\t\t\t\t   <span class=\"token punctuation\">)</span>\n\timage:表示要运行的镜像\n\tcommand:表示启动容器时要运行的命令\n\t\n\t\n<span class=\"token comment\">#启动一个交互式容器</span>\n\t<span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> hello-world <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"geng-xin-rong-qi-can-shu\" id=\"更新容器参数\">更新容器参数</h5>\n<p>若在docker run 创建容器时未指定某些参数,可以通过docker update 命令进行更新一个或多个容器</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> update <span class=\"token punctuation\">[</span><span class=\"token punctuation\">..</span>.options<span class=\"token punctuation\">]</span> CONTAINER_ID/CONTAINER_NAME <span class=\"token punctuation\">[</span><span class=\"token punctuation\">..</span>.CONTAINER_ID/CONTAINER_NAME<span class=\"token punctuation\">]</span>\n\nOPTIONS:\n\t--cpu-shares :更新 cpu-shares。\n\t--kernel-memory :更新内核内存限制。\n\t<span class=\"token parameter variable\">--memory</span> :更新内存限制。\n\t<span class=\"token parameter variable\">--restart</span> :更新重启策略。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"tui-chu-rong-qi\" id=\"退出容器\">退出容器</h5>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">exit</span> :容器停止并退出\nctrl+p+q: 容器不停止退出<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h4 id=\"cha-kan-zheng-zai-yun-xing-de-rong-qi-lie-biao\" id=\"查看正在运行的容器列表\">查看正在运行的容器列表</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">ps</span> <span class=\"token punctuation\">[</span>options<span class=\"token punctuation\">]</span>\n\noptions:\n\t-a:查询所有容器,包括已经停止的或正在运行的<span class=\"token punctuation\">(</span>不加默认列出正在运行种的<span class=\"token punctuation\">)</span>\n\t<span class=\"token parameter variable\">-f:filter</span> filter根据所提供的条件过滤输出\n\t\t<span class=\"token function\">format</span> string使用Go模板漂亮打印容器\n\t<span class=\"token parameter variable\">-n:last</span> int显示n个最近创建的容器<span class=\"token punctuation\">(</span>包括所有状态<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>默认为-1<span class=\"token punctuation\">)</span>\n\t-l:latest显示最新创建的容器<span class=\"token punctuation\">(</span>包括所有状态<span class=\"token punctuation\">)</span>\n\t——no-trunc不要截断输出\n\t-q:quiet只显示容器id\n\t-s:size显示文件总大小\n\t\n\t\n<span class=\"token comment\">#列出已经关闭的容器列表</span>\n<span class=\"token function\">docker</span> <span class=\"token function\">ps</span> <span class=\"token parameter variable\">-f</span> <span class=\"token assign-left variable\">STATUS</span><span class=\"token operator\">=</span>exited<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"jin-ru-hou-tai-rong-qi\" id=\"进入后台容器\">进入后台容器</h4>\n<h5 id=\"exec-jin-ru\" id=\"exec进入\">exec进入</h5>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> <span class=\"token punctuation\">[</span>options<span class=\"token punctuation\">]</span> container<span class=\"token punctuation\">(</span>ID/Name<span class=\"token punctuation\">)</span> <span class=\"token builtin class-name\">command</span> <span class=\"token punctuation\">[</span>args<span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span>\n\noptions:\n\t<span class=\"token parameter variable\">-d</span> :分离模式: 在后台运行\n\t<span class=\"token parameter variable\">-i</span> :即使没有附加也保持STDIN<span class=\"token punctuation\">(</span>标准输入<span class=\"token punctuation\">)</span>打开\n\t<span class=\"token parameter variable\">-t</span> :分配一个伪终端\n\t\t\n\n每次连接到容器,相当于重新创建一个终端<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"attach-jin-ru\" id=\"attach进入\">attach进入</h5>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> attach container\n\n<span class=\"token comment\">#但在，使用该命令有一个问题。当多个窗口同时使用该命令进入该容器时，所有的窗口都会同步显示。如果有一个窗口阻塞了，那么其他窗口也无法再进行操作。</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>因为这个原因，所以docker attach命令不太适合于生产环境，平时自己开发应用时可以使用该命令。</p>\n<p>区别:</p>\n<p>docker exec: 进入容器就开启一个新的终端(常用),执行exit时不会停止容器</p>\n<p>docker attach:进入容器正在执行的终端 exit退出会停止容器</p>\n<h4 id=\"qi-dong-yi-jing-ting-zhi-de-rong-qi\" id=\"启动已经停止的容器\">启动已经停止的容器</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> start container<span class=\"token punctuation\">(</span>ID/name<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"ting-zhi-zheng-zai-yun-xing-de-rong-qi\" id=\"停止正在运行的容器\">停止正在运行的容器</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> stop container<span class=\"token punctuation\">(</span>ID/name<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"zhong-qi-rong-qi\" id=\"重启容器\">重启容器</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> restart container<span class=\"token punctuation\">(</span>ID/name<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"shan-chu-yi-jing-ting-zhi-de-rong-qi\" id=\"删除已经停止的容器\">删除已经停止的容器</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token punctuation\">[</span>OPTIONS<span class=\"token punctuation\">]</span> container<span class=\"token punctuation\">(</span>ID/name<span class=\"token punctuation\">)</span>\n\nOPTIONS:\n\t<span class=\"token parameter variable\">--force</span> , -f:强制删除正在运行的容器（使用 SIGKILL）\n\t<span class=\"token parameter variable\">--link</span> , -l:删除指定的链接\n\t<span class=\"token parameter variable\">--volumes</span> , -v:删除与容器关联的匿名卷\n\n<span class=\"token comment\">#删除所有已经停止的容器</span>\n<span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">docker</span> <span class=\"token function\">ps</span> <span class=\"token parameter variable\">-qf</span> <span class=\"token assign-left variable\">status</span><span class=\"token operator\">=</span>exited<span class=\"token variable\">)</span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"cha-kan-rong-qi-ri-zhi\" id=\"查看容器日志\">查看容器日志</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> logs <span class=\"token punctuation\">[</span>options<span class=\"token punctuation\">]</span> container<span class=\"token punctuation\">(</span>ID/name<span class=\"token punctuation\">)</span>\n\noptions:\n\t-f:跟踪日志输出\n\t--since:显示某个开始时间的所有日志\n\t-t:显示时间戳\n\t--tail:仅列出最新n条容器内容\n\n<span class=\"token comment\">#跟踪查看容器mynginx的日志输出。</span>\n <span class=\"token function\">docker</span> logs <span class=\"token parameter variable\">-f</span> mynginx\n\n<span class=\"token comment\">#查看容器mynginx从2016年7月1日后的最新10条日志。</span>\n<span class=\"token function\">docker</span> logs <span class=\"token parameter variable\">--since</span><span class=\"token operator\">=</span><span class=\"token string\">\"2016-07-01\"</span> <span class=\"token parameter variable\">--tail</span><span class=\"token operator\">=</span><span class=\"token number\">10</span> mynginx<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"jing-xiang-guan-li\" id=\"镜像管理\">镜像管理</h4>\n<h5 id=\"jiang-rong-qi-zhi-zuo-cheng-jing-xiang\" id=\"将容器制作成镜像\">将容器制作成镜像</h5>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> commit <span class=\"token punctuation\">[</span>options<span class=\"token punctuation\">]</span> container<span class=\"token punctuation\">(</span>ID/name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span>REPOSITORY<span class=\"token punctuation\">[</span>:TAG<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n\noptions:\n\t<span class=\"token parameter variable\">-a</span> :提交的镜像作者；\n\t<span class=\"token parameter variable\">-c</span> :使用Dockerfile指令来创建镜像；\n\t<span class=\"token parameter variable\">-m</span> :提交时的说明文字；\n\t<span class=\"token parameter variable\">-p</span> :在commit时，将容器暂停。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"jiang-zhi-ding-docker-dui-xiang-bao-cun-cheng-gui-dang-wen-jian\" id=\"将指定docker对象保存成归档文件\">将指定docker对象保存成归档文件</h5>\n<h6 id=\"ji-yu-save-bao-cun-jing-xiang-yu-ji-yu-load-jia-zai-jing-xiang\" id=\"基于save保存镜像与基于load加载镜像\">基于save保存镜像与基于load加载镜像</h6>\n<p><strong>将指定<code>镜像</code>保存为归档文件</strong></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> save <span class=\"token punctuation\">[</span>options<span class=\"token punctuation\">]</span> image <span class=\"token punctuation\">[</span>image<span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span>\n\noptions:\n\t-o:输出到的文件\n\t\n<span class=\"token comment\">#将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档</span>\n<span class=\"token number\">1</span>.\n<span class=\"token function\">docker</span> save <span class=\"token parameter variable\">-o</span> my_ubuntu_v3.tar runoob/ubuntu:v3\n\n<span class=\"token number\">2</span>.\n<span class=\"token function\">docker</span> save runoob/ubuntu:v3 <span class=\"token operator\">></span> my_ubuntu_v3.tar \n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>归档文件解压成镜像</strong></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> load <span class=\"token punctuation\">[</span>options<span class=\"token punctuation\">]</span>\n\noptions:\n\t<span class=\"token parameter variable\">-i</span> <span class=\"token builtin class-name\">:</span> 指定导入的文件，代替 STDIN。\n\t<span class=\"token parameter variable\">-q</span> <span class=\"token builtin class-name\">:</span> 精简输出信息。\n\t\n\n<span class=\"token function\">docker</span> load <span class=\"token operator\">&lt;</span> busybox.tar.gz\n\n\n<span class=\"token function\">docker</span> load <span class=\"token parameter variable\">-i</span> fedora.tar<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h6 id=\"dao-ru-dao-chu-rong-qi\" id=\"导入导出容器\">导入导出容器</h6>\n<p><strong>将指定容器导出为归档文件</strong></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token builtin class-name\">export</span> <span class=\"token punctuation\">[</span>OPTIONS<span class=\"token punctuation\">]</span> CONTAINER\n\nOPTIONS:\n\t<span class=\"token parameter variable\">--output</span> , -o: 输出到的文件\n\n\n<span class=\"token function\">docker</span> <span class=\"token builtin class-name\">export</span> <span class=\"token parameter variable\">-o</span> busybox.tar busyboxContainer \n\n<span class=\"token function\">docker</span> <span class=\"token builtin class-name\">export</span> busyboxContainer <span class=\"token operator\">></span> busybox.tar<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>将归档文件导入并命名为指定镜像</strong></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">import</span> fileUrl imageName\n\n<span class=\"token function\">docker</span> <span class=\"token function\">import</span> busybox.tar busyboxContainer:v1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"docker-export-he-docker-save-de-qu-bie\" id=\"docker-export和docker-save的区别\">docker export和docker save的区别</h5>\n<p>首先，两者的操作对象不同。<code>docker save</code>是将一个镜像保存为一个<code>tar</code>包，而<code>docker export</code>是将一个容器快照保存为一个<code>tar</code>包。</p>\n<p>然后，<code>docker export</code>导出的容器快照文件将丢弃所有的历史记录和元数据信息，即仅保存容器当时的快照状态；而<code>docker save</code>保存的镜像存储文件将保存完整记录，体积也要大。下图就能够很好的说明，<code>ubuntu:test</code>仅仅占<code>97.8MB</code>而<code>ubuntu:latest</code>却占了<code>120MB</code>。</p>\n<p><img src=\"docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20230606083054790.png\" alt=\"image-20230606083054790\"></p>\n<h5 id=\"dockerfile\" id=\"Dockerfile\">Dockerfile</h5>\n<p>使用<code>commit</code>构建一个镜像，由于<code>commit</code>在构建镜像时，很容易将无关内容添加到镜像且维护起来十分困难。所以不推荐使用<code>commit</code>来构建一个镜像。官方推荐使用<code>Dockerfile</code>来构建一个镜像</p>\n<h6 id=\"dockerfile-jian-jie\" id=\"Dockerfile简介\">Dockerfile简介</h6>\n<p>镜像的定制实际上就是定制每一层所添加的配置、文件。那么如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是<code>Dockerfile</code>。</p>\n<p><code>Dockerfile</code>描述了组装镜像的步骤，其中每一条命令都是单独执行的，除了<code>FROM</code>指令外，其他每一条指令都在上一条指定所生成的镜像基础上执行，执行完会生成一个新的镜像层，新的镜像层覆盖在原来的镜像层之上，从而形成了新的镜像。<code>Dockerfile</code>所生成的最终镜像就是在基础叠加镜像上一层层的镜像层组成的。</p>\n<p>在<code>Dockerfile</code>中，指令不区分大小写，但是为了与参数区分，推荐大写。<code>Docker</code>会顺序执行<code>Dockerfile</code>中的指令，第一条必须是<code>FROM</code>指令，它用于指定构建镜像的基础镜像。在<code>Dockerfile</code>中，以<code>#</code>开头的行是注释。</p>\n<h6 id=\"from-zhi-ling-he-run-zhi-ling\" id=\"FROM指令和RUN指令\">FROM指令和RUN指令</h6>\n<p>●<code>FROM</code>指定基础镜像； 格式：<code>FROM &lt;image&gt;</code>或 <code>FROM &lt;image&gt;:&lt;tag&gt;</code>。</p>\n<p><code>FROM</code>指令的功能是为后面的指令提供基础镜像，因此一个有效的<code>Dockerfile</code>必须以<code>FROM</code>指令作为第一条非注解指令。若<code>FROM</code>指令中<code>tag</code>参数为空，则<code>tag</code>默认为<code>latest</code>；若参数<code>image</code>或<code>tag</code>指定镜像不存在，则返回错误。</p>\n<p>●<code>RUN</code>执行命令； 格式：<code>RUN &lt;command&gt;</code>（<code>shell</code>格式）或<code>RUN [“executable”, “param1“, “param2”]</code>（<code>exec</code>格式，非常推荐）。</p>\n<p><code>RUN </code>指令是用来执行命令行命令的。<code>RUN</code>指令会在前一条命令创建出的镜像的基础上创建一个容器，并在容器中运行命令。在命令结束运行后提交新容器为新镜像，新镜像被<code>Dockerfile</code>的下一条指令使用。</p>\n<p>之前说过，<code>Dockerfile</code>中每一个指令都会建立一个镜像层，<code>RUN</code>也不例外。每一个<code>RUN</code> 的行为，就和之前学习的<code>docker commit</code>定制镜像的过程一样：在之前镜像的基础上创建一个容器，在其上执行这些命令，执行结束后，最后 <code>commit</code> 这一层的修改，构成新的镜像。</p>\n<p>下面举一个实例，使用<code>Dockerfile</code>构建一个名为<code>testimage</code>的镜像，该镜像具备<code>ubuntu:latest</code>的运行环境，而且在镜像的/目录下创建了一个<code>dir1</code>文件夹。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#先创建一个新的空文件夹</span>\n<span class=\"token function\">mkdir</span> newdir\n\n<span class=\"token comment\">#进入这个新文件夹中</span>\n<span class=\"token builtin class-name\">cd</span> newdir\n\n<span class=\"token comment\">#创建一个Dockerfile文件</span>\n<span class=\"token function\">touch</span> Dockerfile\n\n<span class=\"token comment\">#补全Dockerfile的内容（为了方便展示，这里用的是echo向Dockerfile中输入内容）</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"FROM ubuntu:latest\"</span> <span class=\"token operator\">></span> Dockerfile\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"RUN mkdir /dir1\"</span> <span class=\"token operator\">>></span> Dockerfile\n\n<span class=\"token comment\">#使用该Dockerfile构建一个名为testimage的镜像</span>\n<span class=\"token function\">docker</span> build <span class=\"token parameter variable\">-t</span> testimage <span class=\"token builtin class-name\">.</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>Dockerfile构建镜像的过程详解</strong></p>\n<p>上面的实例创建了一个<code>Dockerfile</code>文件，<code>Dockerfile</code>的内容如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">FROM ubuntu:latestRUN \n<span class=\"token function\">mkdir</span> /dir1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>执行<code>docker build</code>命令，指定使用<code>Dockerfile</code>构建一个镜像。执行结果如下所示：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>root@localhost newdir<span class=\"token punctuation\">]</span><span class=\"token comment\"># docker build -t testimage .</span>\nSending build context to Docker daemon <span class=\"token number\">2.048</span> kB\nStep <span class=\"token number\">1</span>/2 <span class=\"token builtin class-name\">:</span> FROM ubuntu \n ---<span class=\"token operator\">></span> 14f60031763d\nStep <span class=\"token number\">2</span>/2 <span class=\"token builtin class-name\">:</span> RUN <span class=\"token function\">mkdir</span> dir1 \n ---<span class=\"token operator\">></span> Running <span class=\"token keyword\">in</span> c5117d908931 \n ---<span class=\"token operator\">></span> cb0193727724\nRemoving intermediate container c5117d908931\nSuccessfully built cb0193727724<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><code>Docker</code>指令是从上到下一层一层执行的，所以在使用这个<code>Dockerfile</code>构建镜像时，首先执行<code>FROM ubuntu:latest</code>这条指令。</p>\n<p><code>FROM ubuntu:latest</code>指定<code>ubuntu:latest</code>作为基础镜像，也就是将<code>ubuntu:latest</code>镜像的所有镜像层放置在<code>testimage</code>镜像的最下面。</p>\n<p>然后执行<code>RUN mkdir dir1</code>指令，前面我们说过，执行<code>RUN</code>指令时，会在之前指令创建出的镜像的基础上创建一个临时容器，在这里的容器<code>Id</code>为<code>c5117d908931</code>，并在容器中运行命令。在命令结束运行后提交新容器为新镜像，并删除临时创建的容器<code>c5117d908931</code>。</p>\n<p>在<code>Dockerfile</code>的所有指令执行完后，新镜像就构建完成了</p>\n<p><em><strong>注意事项，谨慎使用RUN</strong></em></p>\n<p><strong>修改前的Dokcerfile文件</strong></p>\n<p>既然<code>RUN</code>就像 <code>Shell</code> 脚本一样可以执行命令，那么是否就可以像<code>Shell</code> 脚本一样把每个命令对应一个<code>RUN</code>呢？比如这样：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">FROM debian:jessie\nRUN <span class=\"token function\">apt-get</span> update\nRUN <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> <span class=\"token parameter variable\">-y</span> gcc libc6-dev <span class=\"token function\">make</span>\nRUN <span class=\"token function\">wget</span> <span class=\"token parameter variable\">-O</span> redis.tar.gz <span class=\"token string\">\"http://download.redis.io/releases/redis-3.2.5.tar.gz\"</span>\nRUN <span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> /usr/src/redis\nRUN <span class=\"token function\">tar</span> <span class=\"token parameter variable\">-xzf</span> redis.tar.gz <span class=\"token parameter variable\">-C</span> /usr/src/redis --strip-components<span class=\"token operator\">=</span><span class=\"token number\">1</span>\nRUN <span class=\"token function\">make</span> <span class=\"token parameter variable\">-C</span> /usr/src/redis\nRUN <span class=\"token function\">make</span> <span class=\"token parameter variable\">-C</span> /usr/src/redis <span class=\"token function\">install</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面这个<code>Dockerfile</code>是为了编译、安装 <code>redis</code>可执行文件。虽然它能够完成了所需的功能，但是正如之前说过，<code>Dockerfile</code>中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个<code>RUN</code>的行为，都会创建一个新的镜像层。</p>\n<p>而上面的这种写法，创建了<code>8</code>层镜像（<code>1</code>层基础镜像<code>+7</code>层由<code>RUN</code>执行创建的镜像）。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。</p>\n<p><strong>修改后的Dockerfile文件</strong></p>\n<p>因为之前所有的命令只有一个目的，就是编译、安装 <code>redis</code> 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，修改之后的<code>Dockerfile</code>文件并没有使用很多个<code>RUN</code>指令，而仅仅使用一个<code>RUN</code> 指令，并使用 <code>&amp;&amp;</code>将各个命令串联起来。除此以外，把redis的编译环境、更新的软件包也通通清除掉了，减少镜像占用的存储空间。如下所示，修改之后的<code>Dockerfile</code>构建完成后是就只会有<code>2</code>层镜像了（<code>1</code>层基础镜像<code>+1</code>层由<code>RUN</code>执行创建的镜像）。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">FROM debian:jessie\nRUN <span class=\"token assign-left variable\">buildDeps</span><span class=\"token operator\">=</span><span class=\"token string\">'gcc libc6-dev make'</span> <span class=\"token punctuation\">\\</span>\n<span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">apt-get</span> update <span class=\"token punctuation\">\\</span>\n<span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> <span class=\"token parameter variable\">-y</span> <span class=\"token variable\">$buildDeps</span> <span class=\"token punctuation\">\\</span>\n<span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">wget</span> <span class=\"token parameter variable\">-O</span> redis.tar.gz <span class=\"token string\">\"http://download.redis.io/releases/redis-3.2.5.tar.gz\"</span> <span class=\"token punctuation\">\\</span>\n<span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> /usr/src/redis <span class=\"token punctuation\">\\</span>\n<span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">tar</span> <span class=\"token parameter variable\">-xzf</span> redis.tar.gz <span class=\"token parameter variable\">-C</span> /usr/src/redis --strip-components<span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token punctuation\">\\</span>\n<span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">make</span> <span class=\"token parameter variable\">-C</span> /usr/src/redis <span class=\"token punctuation\">\\</span>\n<span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">make</span> <span class=\"token parameter variable\">-C</span> /usr/src/redis <span class=\"token function\">install</span> <span class=\"token punctuation\">\\</span>\n<span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-rf</span> /var/lib/apt/lists/* <span class=\"token punctuation\">\\</span>\n<span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">rm</span> redis.tar.gz <span class=\"token punctuation\">\\</span>\n<span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">rm</span> <span class=\"token parameter variable\">-r</span> /usr/src/redis <span class=\"token punctuation\">\\</span>\n<span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">apt-get</span> purge <span class=\"token parameter variable\">-y</span> --auto-remove <span class=\"token variable\">$buildDeps</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在<code>Dockerfile</code>的编写过程中一定要牢记一点：镜像的每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。</p>\n<h6 id=\"docker-build\" id=\"docker-build\">docker build</h6>\n<p><code>Dockerfile</code>创建完成后，可以使用<code>docker build</code>命令根据<code>Dockerfile</code>构建一个镜像。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> build <span class=\"token punctuation\">[</span>OPTIONS<span class=\"token punctuation\">]</span> 上下文路径<span class=\"token operator\">|</span>URL\n\nOPTIONS:\n\t-f:显示指定Dockerfile,如果不使用-f，则默认将上下文路径下的名为Dockerfile的文件认为是构建镜像的“Dockerfile”\n\t-t:指定镜像名称\n\t上下文路径<span class=\"token operator\">|</span>URL： 指定构建镜像的上下文的路径，构建镜像的过程中，可以且只可以引用上下文中的任何文件。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>现在让我们在看看<code>docker build -t myimage .</code>这条命令，在这条命令中，使用<code>-t</code>指定了镜像名为<code>myimage</code>，由于没有使用<code>-f</code>指令，所以默认使用上下文路径下名为<code>Dockerfile</code>的文件认为是构建镜像的“<code>Dockerfile</code>”。最后指定上下文路径，在这条命令中，上下文路径是<code>.</code>。</p>\n<p><code>.</code>代表着当前目录。所以<code>docker build -t myimage .</code>中小数点<code>.</code>其实就是将当前目录设置为上下文路径。</p>\n<p>执行<code>docker build</code>后，会首先将上下文目录的所有文件都打包，然后传给<code>Docker daemon</code>，这样<code>Docker daemon</code>收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>\n<p>如下图所示，在执行完<code>docker build</code>后，会首先<code>sending build context to Deckor daemon</code>，也就是将上下文目录下所有文件打包发给<code>Docker daemon</code>。所以在使用<code>Dockerfile</code>文件时构建镜像时，一般将它放在一个空文件夹下，就是为了防止将其他多余的文件传出去。然后依次执行<code>Dockerfile</code>的指令，如果指令正确执行，则继续执行下一条，直到所有指令执行正确完毕，镜像构建完成；如果指令执行出错，终止镜像构建。</p>\n<p><img src=\"docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20230606092243574.png\" alt=\"image-20230606092243574\"></p>\n<h3 id=\"zhu-ji-he-docker-de-jiao-hu\" id=\"主机和docker的交互\">主机和docker的交互</h3>\n<h4 id=\"zhu-ji-he-docker-wen-jian-zhong-de-xiang-hu-kao-bei\" id=\"主机和docker文件中的相互拷贝\">主机和docker文件中的相互拷贝</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#容器->主机</span>\n<span class=\"token function\">docker</span> <span class=\"token function\">cp</span> <span class=\"token punctuation\">[</span>options<span class=\"token punctuation\">]</span> container<span class=\"token punctuation\">(</span>ID<span class=\"token punctuation\">\\</span>name<span class=\"token punctuation\">)</span>:source_path 主机path\n\n<span class=\"token comment\">#主机->容器</span>\n<span class=\"token function\">docker</span> <span class=\"token function\">cp</span> <span class=\"token punctuation\">[</span>options<span class=\"token punctuation\">]</span> 主机path container<span class=\"token punctuation\">(</span>ID<span class=\"token punctuation\">\\</span>name<span class=\"token punctuation\">)</span>:source_path \n\noptions:\n\t-L:保持源目标中的链接\n\t\n<span class=\"token comment\">#将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。</span>\n<span class=\"token function\">docker</span> <span class=\"token function\">cp</span> /www/runoob 96f7f14e99ab:/www/\n\n<span class=\"token comment\">#将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。</span>\n<span class=\"token function\">docker</span> <span class=\"token function\">cp</span> /www/runoob 96f7f14e99ab:/www\n\n<span class=\"token comment\">#将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。</span>\n<span class=\"token function\">docker</span> <span class=\"token function\">cp</span>  96f7f14e99ab:/www /tmp/<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"jiang-zhu-ji-zhong-de-mu-lu-ying-she-dao-rong-qi-zhong\" id=\"将主机中的目录映射到容器中\">将主机中的目录映射到容器中</h4>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> volume COMMAND\n\nCommands:\n  create:挂载数据卷\n  \tOptions:\n  \t-d, <span class=\"token parameter variable\">--driver</span> string   Specify volume driver name <span class=\"token punctuation\">(</span>default <span class=\"token string\">\"local\"</span><span class=\"token punctuation\">)</span>\n      <span class=\"token parameter variable\">--label</span> list      Set metadata <span class=\"token keyword\">for</span> a volume\n  \t-o, <span class=\"token parameter variable\">--opt</span> map         Set driver specific options <span class=\"token punctuation\">(</span>default map<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  \n  inspect <span class=\"token punctuation\">[</span>options<span class=\"token punctuation\">]</span>: 查看volume数据卷的详细信息<span class=\"token punctuation\">(</span>挂载点等等<span class=\"token punctuation\">)</span>。\n  \tOptions:\n  \t\t-f, <span class=\"token parameter variable\">--format</span> string   Format the output using the given Go template\n  \n  \n  <span class=\"token function\">ls</span> <span class=\"token punctuation\">[</span>options<span class=\"token punctuation\">]</span>:查看本地所有数据卷<span class=\"token punctuation\">(</span>volume<span class=\"token punctuation\">)</span>\n  \tOptions:\n  \t\t-f, <span class=\"token parameter variable\">--filter</span> filter   Provide filter values <span class=\"token punctuation\">(</span>e.g. <span class=\"token string\">'dangling=true'</span><span class=\"token punctuation\">)</span>\n      \t<span class=\"token parameter variable\">--format</span> string   Pretty-print volumes using a Go template\n \t\t-q, --quiet:只需要展示数据卷的名称\n  \n  prune <span class=\"token punctuation\">[</span>options<span class=\"token punctuation\">]</span>:移除未使用的数据卷。\n  \t Options:\n  \t \t<span class=\"token parameter variable\">--filter</span> :filter   Provide filter values <span class=\"token punctuation\">(</span>e.g. <span class=\"token string\">'label=&lt;label>'</span><span class=\"token punctuation\">)</span>\n  \t\t-f, <span class=\"token parameter variable\">--force</span> :Do not prompt <span class=\"token keyword\">for</span> confirmation\n  \n  \n  \n  <span class=\"token function\">rm</span> <span class=\"token punctuation\">[</span>OPTIONS<span class=\"token punctuation\">]</span> VOLUME <span class=\"token punctuation\">[</span>VOLUME<span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span>:移除一个或多个数据卷，不能移除被容器使用的数据卷。\n  \tOptions:\n  \t\t -f, <span class=\"token parameter variable\">--force:Force</span> the removal of one or <span class=\"token function\">more</span> volumes\n  \t\t \n  \t\t \n  <span class=\"token comment\">#输出容器container1创建的数据卷的名字</span>\n  <span class=\"token function\">docker</span> inspect <span class=\"token parameter variable\">--type</span> container <span class=\"token parameter variable\">--format</span><span class=\"token operator\">=</span><span class=\"token string\">'&#123;&#123;range .Mounts&#125;&#125;&#123;&#123;.Name&#125;&#125;&#123;&#123;end&#125;&#125;'</span> container1\n  \n  <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","text":"Docker的基本使用 docker的意思是容器,是基于Go语言的轻量级的虚拟机 Ubuntu安装Docker sudo apt install docker.io #也可以使用wget使用官方脚本来进行安装 curl -fsSL https://get.docker.com |...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"运维","slug":"运维","count":2,"path":"api/categories/运维.json"},{"name":"Docker","slug":"运维/Docker","count":1,"path":"api/categories/运维/Docker.json"}],"tags":[{"name":"Docker","slug":"Docker","count":1,"path":"api/tags/Docker.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#docker-de-ji-ben-shi-yong\"><span class=\"toc-text\">Docker的基本使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ubuntu-an-zhuang-docker\"><span class=\"toc-text\">Ubuntu安装Docker</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jian-cha-docker-shi-fou-an-zhuang-cheng-gong\"><span class=\"toc-text\">检查docker是否安装成功</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#she-zhi-docker-kai-ji-zi-qi\"><span class=\"toc-text\">设置docker开机自启</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#docker-de-ji-ben-zhi-ling\"><span class=\"toc-text\">Docker的基本指令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cha-kan-ban-ben\"><span class=\"toc-text\">查看版本</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cha-kan-docker-xin-xi\"><span class=\"toc-text\">查看docker信息</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cha-xun-jing-xiang-xin-xi\"><span class=\"toc-text\">查询镜像信息</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cha-xun-jing-xiang-rong-qi-yuan-shu-ju\"><span class=\"toc-text\">查询镜像&#x2F;容器元数据</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#xia-zai-jing-xiang\"><span class=\"toc-text\">下载镜像</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cha-kan-ben-di-jing-xiang-lie-biao\"><span class=\"toc-text\">查看本地镜像列表</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#gei-jing-xiang-da-biao-qian\"><span class=\"toc-text\">给镜像打标签</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#deng-lu-docker\"><span class=\"toc-text\">登录docker</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jiang-jing-xiang-fa-bu-dao-yuan-cheng\"><span class=\"toc-text\">将镜像发布到远程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#shan-chu-jing-xiang\"><span class=\"toc-text\">删除镜像</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#yun-xing-jing-xiang-chuang-jian-rong-qi\"><span class=\"toc-text\">运行镜像(创建容器)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#geng-xin-rong-qi-can-shu\"><span class=\"toc-text\">更新容器参数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#tui-chu-rong-qi\"><span class=\"toc-text\">退出容器</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cha-kan-zheng-zai-yun-xing-de-rong-qi-lie-biao\"><span class=\"toc-text\">查看正在运行的容器列表</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jin-ru-hou-tai-rong-qi\"><span class=\"toc-text\">进入后台容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#exec-jin-ru\"><span class=\"toc-text\">exec进入</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#attach-jin-ru\"><span class=\"toc-text\">attach进入</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#qi-dong-yi-jing-ting-zhi-de-rong-qi\"><span class=\"toc-text\">启动已经停止的容器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ting-zhi-zheng-zai-yun-xing-de-rong-qi\"><span class=\"toc-text\">停止正在运行的容器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#zhong-qi-rong-qi\"><span class=\"toc-text\">重启容器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#shan-chu-yi-jing-ting-zhi-de-rong-qi\"><span class=\"toc-text\">删除已经停止的容器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cha-kan-rong-qi-ri-zhi\"><span class=\"toc-text\">查看容器日志</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jing-xiang-guan-li\"><span class=\"toc-text\">镜像管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#jiang-rong-qi-zhi-zuo-cheng-jing-xiang\"><span class=\"toc-text\">将容器制作成镜像</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#jiang-zhi-ding-docker-dui-xiang-bao-cun-cheng-gui-dang-wen-jian\"><span class=\"toc-text\">将指定docker对象保存成归档文件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#ji-yu-save-bao-cun-jing-xiang-yu-ji-yu-load-jia-zai-jing-xiang\"><span class=\"toc-text\">基于save保存镜像与基于load加载镜像</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#dao-ru-dao-chu-rong-qi\"><span class=\"toc-text\">导入导出容器</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#docker-export-he-docker-save-de-qu-bie\"><span class=\"toc-text\">docker export和docker save的区别</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#dockerfile\"><span class=\"toc-text\">Dockerfile</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#dockerfile-jian-jie\"><span class=\"toc-text\">Dockerfile简介</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#from-zhi-ling-he-run-zhi-ling\"><span class=\"toc-text\">FROM指令和RUN指令</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#docker-build\"><span class=\"toc-text\">docker build</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#zhu-ji-he-docker-de-jiao-hu\"><span class=\"toc-text\">主机和docker的交互</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#zhu-ji-he-docker-wen-jian-zhong-de-xiang-hu-kao-bei\"><span class=\"toc-text\">主机和docker文件中的相互拷贝</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jiang-zhu-ji-zhong-de-mu-lu-ying-she-dao-rong-qi-zhong\"><span class=\"toc-text\">将主机中的目录映射到容器中</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"ND_LJQ","slug":"blog-author","avatar":"/svg/head.jpg","link":"/","description":"一位正在摆烂的大四渣滓😋 <br /> @ <b>劉三刀的摆烂生活</b>","socials":{"github":"https://github.com/ND-LJQ","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_52475868?type=blog","juejin":"https://juejin.cn/user/2032336272362109","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/391491132?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/liu-jq"}}}},"mapped":true,"prev_post":{"title":"Linux基本操作","uid":"241e4fb174a989083556866451d735d1","slug":"Linux基本操作","date":"2023-07-18T06:03:34.000Z","updated":"2023-07-18T06:44:37.266Z","comments":true,"path":"api/articles/Linux基本操作.json","keywords":null,"cover":[],"text":"Linux 简介 Linux 系统的起源与发展 Linux 是一种免费使用和自由传播的类 UNIX 操作系统,是一个基于 POSIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。它能运行主要的 Unix 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。L...","link":"","photos":[],"count_time":{"symbolsCount":"68k","symbolsTime":"1:02"},"categories":[{"name":"运维","slug":"运维","count":2,"path":"api/categories/运维.json"},{"name":"Linux","slug":"运维/Linux","count":1,"path":"api/categories/运维/Linux.json"}],"tags":[{"name":"Linux","slug":"Linux","count":1,"path":"api/tags/Linux.json"}],"author":{"name":"ND_LJQ","slug":"blog-author","avatar":"/svg/head.jpg","link":"/","description":"一位正在摆烂的大四渣滓😋 <br /> @ <b>劉三刀的摆烂生活</b>","socials":{"github":"https://github.com/ND-LJQ","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_52475868?type=blog","juejin":"https://juejin.cn/user/2032336272362109","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/391491132?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/liu-jq"}}}}},"next_post":{"title":"软件工程基础","uid":"4f1b28a46122dcbfdd696db503d86e97","slug":"软件工程基础","date":"2023-07-18T03:21:00.000Z","updated":"2023-07-18T03:37:46.182Z","comments":true,"path":"api/articles/软件工程基础.json","keywords":null,"cover":[],"text":"软件工程 软件工程的概念和思想 何为软件工程 1968年,北大西洋公约组织(NATO)科学委员会在西德召开的研讨会上着重讨论如何应对软件危机,会上人们首次提出\"软件工程\"概念,进而开启了软件工程的研究与实践 根据IEEE给出的定义,软件工程是指: ①将系统的、规范的、可量化的方法...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"计算机基础","slug":"计算机基础","count":3,"path":"api/categories/计算机基础.json"},{"name":"软件工程","slug":"计算机基础/软件工程","count":1,"path":"api/categories/计算机基础/软件工程.json"}],"tags":[{"name":"软件工程","slug":"软件工程","count":1,"path":"api/tags/软件工程.json"}],"author":{"name":"ND_LJQ","slug":"blog-author","avatar":"/svg/head.jpg","link":"/","description":"一位正在摆烂的大四渣滓😋 <br /> @ <b>劉三刀的摆烂生活</b>","socials":{"github":"https://github.com/ND-LJQ","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_52475868?type=blog","juejin":"https://juejin.cn/user/2032336272362109","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/391491132?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/liu-jq"}}}}}}