{"title":"操作系统基础","uid":"09303d998ed7337d46bfa9387efc032e","slug":"操作系统基础","date":"2023-07-20T12:14:48.000Z","updated":"2023-07-21T01:41:26.404Z","comments":true,"path":"api/articles/操作系统基础.json","keywords":null,"cover":[],"content":"<h1 id=\"ji-suan-ji-xi-tong-gai-lun\">计算机系统概论</h1>\n<h2 id=\"cao-zuo-xi-tong-de-ji-ben-gai-nian\">操作系统的基本概念</h2>\n<h3 id=\"cao-zuo-xi-tong-de-gai-nian\">操作系统的概念</h3>\n<p>​\t在信息化时代，软件是计算机系统的灵魂，而作为软件核心的操作系统，已与现代计算机系统密不可分、融为一体。计算机系统自下而上可大致分为 4 部分:<code>硬件</code>、<code>操作系统</code>、<code>应用程序</code>和<code>用户</code>(这里的划分与计算机组成原理中的分层不同)。操作系统管理各种计算机硬件，为应用程序提供基础，并充当计算机硬件与用户之间的中介。</p>\n<p>硬件如中央处理器、内存、输入/输出设备等，提供基本的计算资源。应用程序如字处理程序、电子制表软件、编译器、网络浏览器等，规定按何种方式使用这些资源来解决用户的计算问题。操作系统控制和协调各用户的应用程序对硬件的分配与使用。</p>\n<p>在计算机系统的运行过程中，操作系统提供了正确使用这些资源的方法。</p>\n<p>综上所述，操作系统(Operating System，OS）是指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。<strong>操作系统是计算机系统中最基本的系统软件</strong>。</p>\n<h3 id=\"cao-zuo-xi-tong-de-te-zheng\">操作系统的特征</h3>\n<p>操作系统是一种系统软件，但与其他系统软件和应用软件有很大的不同，它有自己的特殊性即基本特征。操作系统的基本特征包括<code>并发</code>、<code>共享</code>、<code>虚拟</code>和<code>异步</code>。这些概念对理解和掌握操作系统的核心至关重要，将一直贯穿于各个章节中。</p>\n<h4 id=\"bing-fa-concurrence\">并发(Concurrence)</h4>\n<p><strong>并发是指两个或多个事件在同一时间间隔内发生</strong>。操作系统的并发性是指计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。在操作系统中，引入进程的目的是使程序能并发执行。</p>\n<p><strong>注意同一时间间隔（<code>并发</code>）和同一时刻（<code>并行</code>）的区别</strong>。在多道程序环境下，一段时间内，宏观上有多道程序在同时执行，而在每个时刻，单处理机环境下实际仅能有一道程序执行，因此微观上这些程序仍是分时交替执行的。操作系统的并发性是通过分时得以实现的。</p>\n<p><strong>注意，并行性是指系统具有同时进行运算或操作的特性，在同一时刻能完成两种或两种以上的工作</strong>。并行性需要有相关硬件的支持，如多流水线或多处理机硬件环境。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>我们以现实生活中的直观例子来认识并发和并行的区别。例如，如果你在 9:00 ～ 9:10 仅吃面包，在 9:10 ～ 9:20 仅写字，在 9:20 ～ 9:30 仅吃面包，在 9:30 ～ 10:00 仅写字，那么在 9:00 ～ 10:00 吃面包和写字这两种行为就是并发执行的;再如，如果你在 9:00 ～ 10:00 右手写字，左手同时拿着面包吃，那么这两个动作就是并行执行的。</p></blockquote>\n<h4 id=\"gong-xiang-sharing\">共享(Sharing)</h4>\n<p>资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。共享可分为以下两种资源共享方式。</p>\n<p>(1）互斥共享方式</p>\n<p>系统中的某些资源，如打印机、磁带机，虽然可供多个进程使用，但为使得所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程访问该资源。</p>\n<p>为此，当进程 A 访问某个资源时，必须先提出请求，若此时该资源空闲，则系统便将之分配给进程 A 使用，此后有其他进程也要访问该资源时（只要 A 未用完）就必须等待。仅当进程 A 访问完并释放该资源后，才允许另一个进程对该资源进行访问。我们把这种资源共享方式称为互斥式共享，而把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源。计算机系统中的大多数物理设备及某些软件中所用的栈、变量和表格，都属于临界资源，它们都要求被互斥地共享。</p>\n<p>(2）同时访问方式</p>\n<p>系统中还有另一类资源，这类资源允许在一段时间内由多个进程“同时”访问。这里所说的“同时”通常是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问即“分时共享”的。可供多个进程“同时”访问的典型资源是磁盘设备，一些用重入码编写的文件也可被“同时”共享，即允许若干个用户同时访问该文件。</p>\n<p>注意，互斥共享要求一种资源在一段时间内（哪怕是一段很小的时间）只能满足一个请求，否则就会出现严重的问题，(你能想象打印机第一行打印 A 文档的内容、第二行打印 B 文档的内容的效果吗?）而同时访问共享通常要求一个请求分几个时间片段间隔地完成，其效果与连续完成的效果相同。</p>\n<p><strong><code>并发</code>和<code>共享</code>是操作系统两个最基本的特征，两者之间互为存在的条件</strong>:① 资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题;② 若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。</p>\n<h4 id=\"xu-ni-virtual\">虚拟(Virtual)</h4>\n<p><strong>虚拟是指把一个物理上的<code>实体</code>变为若干<code>逻辑</code>上的对应物</strong>。物理实体（前者）是实的，即实际存在的;而后者是虚的，是用户感觉上的事物。用于实现虚拟的技术，称为虚拟技术。操作系统中利用了多种虚拟技术来实现虚拟处理器、虚拟内存和虚拟外部设备等。</p>\n<p>虚拟处理器技术是通过多道程序设计技术，采用让多道程序并发执行的方法，来分时使用一个处理器的。此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器(CPU)在专门为它服务。利用多道程序设计技术把一个物理上的 CPU 虚拟为多个逻辑上的 CPU，称为虚拟处理器。</p>\n<p>类似地，可以采用虚拟存储器技术将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。当然，这时用户所感觉到的内存容量是虚的。我们把用户感觉到（但实际不存在)的存储器称为虚拟存储器。</p>\n<p>还可采用虚拟设备技术将一台物理 IO 设备虚拟为多台逻辑上的 I/O 设备，并允许每个用户占用一台逻辑上的 IO 设备，使原来仅允许在一段时间内由一个用户访问的设备（即临界资源)变为在一段时间内允许多个用户同时访问的共享设备。</p>\n<p>因此，操作系统的虚拟技术可归纳为:时分复用技术，如处理器的分时共享;空分复用技术，如虚拟存储器。</p>\n<h4 id=\"yi-bu-asynchronism\">异步(Asynchronism)</h4>\n<p>多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进，这就是进程的异步性。</p>\n<p>异步性使得操作系统运行在一种随机的环境下，可能导致进程产生与时间有关的错误（就像对全局变量的访问顺序不当会导致程序出错一样)。然而，只要运行环境相同，操作系统就须保证多次运行进程后都能获得相同的结果。</p>\n<h3 id=\"cao-zuo-xi-tong-de-mu-biao-he-gong-neng\">操作系统的目标和功能</h3>\n<p>为了给多道程序提供良好的运行环境，操作系统应具有以下几方面的功能:处理机管理、存储器管理、设备管理和文件管理。为了方便用户使用操作系统，还必须向用户提供接口。同时，操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。</p>\n<p>我们用一个直观的例子来理解这种情况。例如，用户是雇主，操作系统是工人（用来操作机器)，计算机是机器（由处理机、存储器、设备、文件几个部件构成)，工人有熟练的技能，能够控制和协调各个部件的工作，这就是操作系统对资源的管理;同时，工人必须接收雇主的命令，这就是“接口”;有了工人，机器就能发挥更大的作用，因此工人就成了“扩充机器”。</p>\n<h4 id=\"cao-zuo-xi-tong-zuo-wei-ji-suan-ji-xi-tong-zi-yuan-de-guan-li-zhe\">操作系统作为计算机系统资源的管理者</h4>\n<h5 id=\"chu-li-ji-guan-li\">处理机管理</h5>\n<p>在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。并发是指在计算机内同时运行多个进程，因此进程何时创建、何时撤销、如何管理、如何避免冲突、合理共享就是进程管理的最主要的任务。进程管理的主要功能包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>\n<h5 id=\"cun-chu-qi-guan-li\">存储器管理</h5>\n<p>存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率，主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。</p>\n<h5 id=\"wen-jian-guan-li\">文件管理</h5>\n<p>计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。</p>\n<h5 id=\"she-bei-guan-li\">设备管理</h5>\n<p>设备管理的主要任务是完成用户的 IO 请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。</p>\n<p>这些工作都由“工人”负责，“雇主”无须关注。</p>\n<h4 id=\"cao-zuo-xi-tong-zuo-wei-yong-hu-yu-ji-suan-ji-ying-jian-xi-tong-zhi-jian-de-jie-kou\">操作系统作为用户与计算机硬件系统之间的接口</h4>\n<p>为了让用户方便、快捷、可靠地操纵计算机硬件并运行自己的程序，操作系统还提供了用户接口。操作系统提供的接口主要分为两类:一类是命令接口，用户利用这些操作命令来组织和控制作业的执行;另一类是程序接口，编程人员可以使用它们来请求操作系统服务。</p>\n<h5 id=\"ming-ling-jie-kou\">命令接口</h5>\n<p>使用命令接口进行作业控制的主要方式有两种，即联机控制方式和脱机控制方式。按作业控制方式的不同，可将命令接口分为联机命令接口和脱机命令接口。</p>\n<p><code>联机命令接口</code>又称<code>交互式命令接口</code>，适用于分时或实时系统的接口。它由一组键盘操作命令组成。用户通过控制台或终端输入操作命令，向系统提出各种服务要求。用户每输入一条命令，控制权就转给操作系统的命令解释程序，然后由命令解释程序解释并执行输入的命令，完成指定的功能。之后，控制权转回控制台或终端，此时用户又可输入下一条命令。联机命令接口可以这样理解:“雇主”说一句话，“工人”做一件事，并做出反馈，这就强调了交互性。</p>\n<p><code>脱机命令接口</code>又称<code>批处理命令接口</code>，适用于批处理系统，它由一组作业控制命令组成。脱机用户不能直接干预作业的运行，而应事先用相应的作业控制命令写成一份作业操作说明书，连同作业一起提交给系统。系统调度到该作业时，由系统中的命令解释程序逐条解释执行作业说明书上的命令，从而间接地控制作业的运行。脱机命令接口可以这样理解:“雇主”把要“工人”做的事写在清单上，“工人”按照清单命令逐条完成这些事，这就是批处理。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>联</code>机和脱机可以理解为「<code>联</code>接机器」的「<code>联</code>」不是「<code>联</code>网」的「<code>联</code>」;交互的状态不就是连接着机器的吗</p></blockquote>\n<h5 id=\"cheng-xu-jie-kou\">程序接口</h5>\n<p>程序接口由一组<code>系统调用</code>（也称<code>广义指令</code>）组成。用户通过在程序中使用这些系统调用来请求操作系统为其提供服务，如使用各种外部设备、申请分配和回收内存及其他各种要求。</p>\n<p>当前最为流行的是图形用户界面(GUI),即图形接口。GUI 最终是通过调用程序接口实现的，用户通过鼠标和键盘在图形界面上单击或使用快捷键，就能很方便地使用操作系统。严格来说，图形接口不是操作系统的一部分，但图形接口所调用的系统调用命令是操作系统的一部分。</p>\n<h4 id=\"cao-zuo-xi-tong-yong-zuo-kuo-chong-ji-qi\">操作系统用作扩充机器</h4>\n<p>没有任何软件支持的计算机称为裸机，它仅构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。裸机在最里层，其外面是操作系统。操作系统所提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器;因此，我们通常把覆盖了软件的机器称为扩充机器或虚拟机。</p>\n<p>“工人”操作机器，机器就有更大的作用，于是“工人”便成了“扩充机器”。</p>\n<p>注意，本课程所关注的内容是操作系统如何控制和协调处理机、存储器、设备和文件，而不关注接口和扩充机器，后两者读者只需要有个印象，能理解即可。</p>\n<h2 id=\"cao-zuo-xi-tong-de-fa-zhan-yu-fen-lei\">操作系统的发展与分类</h2>\n<h3 id=\"shou-gong-cao-zuo-jie-duan-ci-jie-duan-wu-cao-zuo-xi-tong\">手工操作阶段（此阶段无操作系统)</h3>\n<p>用户在计算机上算题的所有工作都要人工干预，如程序的装入、运行、结果的输出等。随着计算机硬件的发展，人机矛盾（速度和资源利用）越来越大，必须寻求新的解决办法。</p>\n<p>手工操作阶段有两个突出的缺点:① 用户独占全机，虽然不会出现因资源已被其他用户占用而等待的现象，但资源利用率低。②CPU 等待手工操作，CPU 的利用不充分。</p>\n<p>唯一的解决办法就是用高速的机器代替相对较慢的手工操作来对作业进行控制。</p>\n<h3 id=\"pi-chu-li-jie-duan-cao-zuo-xi-tong-kai-shi-chu-xian\">批处理阶段(操作系统开始出现）</h3>\n<p>为了解决人机矛盾及 CPU 和 IO 设备之间速度不匹配的矛盾，出现了批处理系统。按发展历程又分为单道批处理系统、多道批处理系统（多道程序设计技术出现以后)。·</p>\n<h4 id=\"dan-dao-pi-chu-li-xi-tong\">单道批处理系统</h4>\n<p>系统对作业的处理是成批进行的，但内存中始终保持一道作业。单道批处理系统是在解决人机矛盾及 CPU 和 IO 设备速率不匹配的矛盾中形成的。单道批处理系统的主要特征如下:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>自动性。在顺利的情况下，磁带上的一批作业能自动地逐个运行，而无须人工干预</p>\n</li>\n<li class=\"lvl-3\">\n<p>顺序性。磁带上的各道作业顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序在正常情况下应完全相同，亦即先调入内存的作业先完成。</p>\n</li>\n<li class=\"lvl-3\">\n<p>单道性。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。</p>\n</li>\n</ol>\n<p>此时面临的问题是:每次主机内存中仅存放一道作业，每当它在运行期间（注意这里是“运行时”而不是“完成后”)发出输入/输出请求后，高速的 CPU 便处于等待低速的 IO 完成的状态。为了进一步提高资源的利用率和系统的吞吐量，引入了多道程序技术。</p>\n<h4 id=\"duo-dao-pi-chu-li-xi-tong\">多道批处理系统</h4>\n<p>多道程序设计技术允许多个程序同时进入内存并允许它们在 CPU 中交替地运行，这些程序共享系统中的各种硬/软件资源。当一道程序因 I/O 请求而暂停运行时，CPU 便立即转去运行另一道程序。它不采用某些机制来提高某一技术方面的瓶颈问题，而让系统的各个组成部分都尽量去“忙”，因此切换任务所花费的时间很少，可实现系统各部件之间的并行工作，使其整体在单位时间内的效率翻倍。</p>\n<p>当然，多道批处理系统的设计和实现要比单道系统复杂很多，因为要充分利用各种资源，就要涉及各种资源的调度问题。</p>\n<p>多道程序设计的特点是多道、宏观上并行、微观上串行。</p>\n<ol>\n<li class=\"lvl-3\">\n<p>多道。计算机内存中同时存放多道相互独立的程序。</p>\n</li>\n<li class=\"lvl-3\">\n<p>宏观上并行。同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行，但都未运行完毕。</p>\n</li>\n<li class=\"lvl-3\">\n<p>微观上串行。内存中的多道程序轮流占有 CPU，交替执行。</p>\n</li>\n</ol>\n<p>多道程序设计技术的实现需要解决下列问题:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>如何分配处理器。</p>\n</li>\n<li class=\"lvl-3\">\n<p>多道程序的内存分配问题。</p>\n</li>\n<li class=\"lvl-3\">\n<p>IO 设备如何分配。</p>\n</li>\n<li class=\"lvl-3\">\n<p>如何组织和存放大量的程序和数据，以方便用户使用并保证其安全性与一致性。</p>\n</li>\n</ol>\n<p>​\t在批处理系统中采用多道程序设计技术就形成了多道批处理操作系统。该系统把用户提交的作业成批地送入计算机内存，然后由作业调度程序自动地选择作业运行。</p>\n<p>​\t优点:资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用;系统吞吐量大，CPU 和其他资源保持“忙碌”状态。缺点:用户响应的时间较长;不提供人机交互能力，用户既不能了解自己的程序的运行情况，又不能控制计算机。</p>\n<h3 id=\"fen-shi-cao-zuo-xi-tong\">分时操作系统</h3>\n<p>​\t所谓分时技术，是指把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得也很快，因此给每个用户的感觉就像是自己独占一台计算机。</p>\n<p>​\t分时操作系统是指多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰。因此，实现分时系统最关键的问题是如何使用户能与自己的作业进行交互，即当用户在自己的终端上键入命令时，系统应能及时接收并及时处理该命令，再将结果返回用户。分时系统也是支持多道程序设计的系统，但它不同于多道批处理系统多道批处理是实现作业自动控制而无须人工干预的系统，而分时系统是实现人机交互的系统，这使得分时系统具有与批处理系统不同的特征。分时系统的主要特征如下:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>同时性。同时性也称多路性，指允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。</p>\n</li>\n<li class=\"lvl-3\">\n<p>交互性。用户能够方便地与系统进行人机对话，即用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互。</p>\n</li>\n<li class=\"lvl-3\">\n<p>独立性。系统中多个用户可以彼此独立地进行操作，互不干扰，单个用户感觉不到别人也在使用这台计算机，好像只有自己单独使用这台计算机一样。</p>\n</li>\n<li class=\"lvl-3\">\n<p>及时性。用户请求能在很短时间内获得响应。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意。</p>\n</li>\n</ol>\n<p>虽然分时操作系统较好地解决了人机交互问题，但在一些应用场合，需要系统能对外部的信息在规定的时间（比时间片的时间还短）内做出处理（比如飞机订票系统或导弹制导系统)，因此，实时操作系统应运而生。</p>\n<h3 id=\"shi-shi-cao-zuo-xi-tong\">实时操作系统</h3>\n<p>​\t为了能在某个时间限制内完成某些紧急任务而不需要时间片排队，诞生了实时操作系统。这里的时间限制可以分为两种情况:若某个动作必须绝对地在规定的时刻（或规定的时间范围）发生，则称为硬实时系统，如飞行器的飞行自动控制系统，这类系统必须提供绝对保证，让某个特定的动作在规定的时间内完成。若能够接受偶尔违反时间规定且不会引起任何永久性的损害，则称为软实时系统，如飞机订票系统、银行管理系统。</p>\n<p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并在严格的时限内处理完接收的事件。实时操作系统的主要特点是 <code>及时性</code> 和 <code>可靠性 </code>。</p>\n<h3 id=\"wang-luo-cao-zuo-xi-tong-he-fen-bu-shi-ji-suan-ji-xi-tong\">网络操作系统和分布式计算机系统</h3>\n<p>​\t网络操作系统把计算机网络中的各台计算机有机地结合起来，提供一种统一、经济而有效的使用各台计算机的方法，实现各台计算机之间数据的互相传送。网络操作系统最主要的特点是网络中各种资源的共享及各台计算机之间的通信。</p>\n<p>​\t分布式计算机系统是由多台计算机组成并满足下列条件的系统:系统中任意两台计算机通过通信方式交换信息;系统中的每台计算机都具有同等的地位，即没有主机也没有从机;每台计算机上的资源为所有用户共享;系统中的任意台计算机都可以构成一个子系统，并且还能重构;任何工作都可以分布在几台计算机上，由它们并行工作、协同完成。用于管理分布式计算机系统的操作系统称为分布式计算机系统。该系统的主要特点是:分布性和并行性。分布式操作系统与网络操作系统的本质不同是，分布式操作系统中的若干计算机相互协同完成同一任务。</p>\n<h3 id=\"ge-ren-ji-suan-ji-cao-zuo-xi-tong\">个人计算机操作系统</h3>\n<p>个人计算机操作系统是目前使用最广泛的操作系统，它广泛应用于文字处理、电子表格、游戏中，常见的有 Windows、Linux 和 Macintosh 等。操作系统的发展历程如图 1.1 所示。\\</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210726161521.png\" alt></p>\n<p>此外，还有嵌入式操作系统、服务器操作系统、智能手机操作系统等。</p>\n<h2 id=\"cao-zuo-xi-tong-de-yun-xing-huan-jing\">操作系统的运行环境</h2>\n<h3 id=\"cao-zuo-xi-tong-de-yun-xing-ji-zhi\">操作系统的运行机制</h3>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>初学者需要弄清楚一个问题，即计算机“指令”和高级语言的“代码”是不同的。我们一般所说的“编写代码”指的是用高级语言〈如 C、Java 等）来编写程序。但 CPU 看不懂这些高级语言程序的含义，为了让这些程序能够顺利执行，就需要把它们“翻译”成 CPU 能懂的机器语言，即一条条“指令”(这个“翻译”的过程称为“编译”)。所谓执行程序，其实就是 CPU 根据一条条指令的指示来执行一个个具体的操作。</p></blockquote>\n<p>​\t计算机系统中，通常 CPU 执行两种不同性质的程序:一种是操作系统内核程序;另一种是用户自编程序（即系统外层的应用程序，或简称“应用程序”)。对操作系统而言，这两种程序的作用不同，前者是后者的管理者，因此“管理程序”(即内核程序）要执行一些特权指令，而“被管理程序”(即用户自编程序）出于安全考虑不能执行这些指令。所谓特权指令，是指计算机中不允许用户直接使用的指令，如 IO 指令、置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。在具体实现上，将 CPU 的状态划分为用户态(目态）和核心态（又称管态、内核态)。可以理解为 CPU 内部有一个小开关，当小开关为 1 时，CPU 处于核心态，此时 CPU 可以执行特权指令;当小开关为 0 时，CPU 处于用户态，此时 CPU 只能执行非特权指令。用户自编程序运行在用户态，操作系统内核程序运行在核心态。</p>\n<p>​\t在软件工程思想和结构化程序设计方法影响下诞生的现代操作系统，几乎都是层次式的结构。操作系统的各项功能分别被设置在不同的层次上。一些与硬件关联较紧密的模块，如时钟管理、中断处理、设备驱动等处于最低层。其次是运行频率较高的程序，如进程管理、存储器管理和设备管理等。这两部分内容构成了操作系统的内核。这部分内容的指令操作工作在核心态。</p>\n<p>内核是计算机上配置的底层软件，是计算机功能的延伸。不同系统对内核的定义稍有区别，大多数操作系统的内核包括 4 方面的内容。</p>\n<h4 id=\"shi-zhong-guan-li\">时钟管理</h4>\n<p>​\t在计算机的各种部件中，时钟是最关键的设备。时钟的第一功能是计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。另外，通过时钟中断的管理，可以实现进程的切换。例如，在分时操作系统中采用时间片轮转调度，在实时系统中按截止时间控制运行，在批处理系统中通过时钟管理来衡量一个作业的运行程度等。因此，系统管理的方方面面无不依赖于时钟。</p>\n<h4 id=\"zhong-duan-ji-zhi\">中断机制</h4>\n<p>​\t引入中断技术的初衷是提高多道程序运行环境中 CPU 的利用率，而且主要是针对外部设备的。后来逐步得到发展，形成了多种类型，成为操作系统各项操作的基础。例如，键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等，无不依赖于中断机制。<strong>可以说，现代操作系统是靠中断驱动的软件</strong>。</p>\n<p>中断机制中，只有一小部分功能属于内核，它们负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力。</p>\n<h4 id=\"yuan-yu\">原语</h4>\n<p>​\t按层次结构设计的操作系统，底层必然是一些可被调用的公用小程序，它们各自完成一个规定的操作。它们的特点如下:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>处于操作系统的最低层，是最接近硬件的部分。</p>\n</li>\n<li class=\"lvl-3\">\n<p>这些程序的运行具有原子性，其操作只能一气呵成(主要从系统安全性和便于管理考虑)。</p>\n</li>\n<li class=\"lvl-3\">\n<p>这些程序的运行时间都较短，而且调用频繁。</p>\n</li>\n</ol>\n<p>通常把具有这些特点的程序称为原语(Atomic Operation)。定义原语的直接方法是关闭中断，让其所有动作不可分割地完成后再打开中断。</p>\n<p>系统中的设备驱动、CPU 切换、进程通信等功能中的部分操作都可定义为原语，使它们成为内核的组成部分。</p>\n<h4 id=\"xi-tong-kong-zhi-de-shu-ju-jie-gou-ji-chu-li\">系统控制的数据结构及处理</h4>\n<p>​\t系统中用来登记状态信息的数据结构很多，如作业控制块、进程控制块(PCB)、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。为了实现有效的管理,系统需要一些基本的操作，常见的操作有以下 3 种:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>进程管理。进程状态管理、进程调度和分派、创建与撤销进程控制块等。</p>\n</li>\n<li class=\"lvl-3\">\n<p>存储器管理。存储器的空间分配和回收、内存信息保护程序、代码对换程序等。</p>\n</li>\n<li class=\"lvl-3\">\n<p>设备管理。缓冲区管理、设备分配和回收等。</p>\n</li>\n</ol>\n<p>从上述内容可以了解，核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令。</p>\n<h3 id=\"zhong-duan-he-yi-chang-de-gai-nian\">中断和异常的概念</h3>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>建议结合《计算机组成原理考研复习指导》第 7 章学习，那里的讲解更详细。</p></blockquote>\n<p>​\t在操作系统中引入核心态和用户态这两种工作状态后，就需要考虑这两种状态之间如何切换。操作系统内核工作在核心态，而用户程序工作在用户态。系统不允许用户程序实现核心态的功能，而它们又必须使用这些功能。因此，需要在核心态建立一些“门”，以便实现从用户态进入核心态。在实际操作系统中，CPU 运行上层程序时唯一能进入这些“门”的途径就是通过中断或异常。发生中断或异常时，运行用户态的 CPU 会立即进入核心态，这是通过硬件实现的(例如,用一个特殊寄存器的一位来表示 CPU 所处的工作状态，0 表示核心态，1 表示用户态。若要进入核心态，则只需将该位置 0 即可)。中断是操作系统中非常重要的一个概念，对一个运行在计算机上的实用操作系统而言，缺少了中断机制，将是不可想象的。原因是，操作系统的发展过程大体上就是一个想方设法不断提高资源利用率的过程，而提高资源利用率就需要在程序并未使用某种资源时，把它对那种资源的占有权释放，而这一行为就需要通过中断实现。</p>\n<h4 id=\"zhong-duan-he-yi-chang-de-ding-yi\">中断和异常的定义</h4>\n<p>​\t中断(Interruption)也称外中断，指来自 CPU 执行指令以外的事件的发生，如设备发出的 IO 结束中断，表示设备输入/输出处理已经完成，希望处理机能够向设备发下一个输入/输出请求，同时让完成输入/输出后的程序继续运行。时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等。这一类中断通常是与当前指令执行无关的事件，即它们与当前处理机运行的程序无关。</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210726162307.png\" alt></p>\n<p>异常（Exception）也称内中断、例外或陷入(trap)，指源自 CPU 执行指令内部的事件,如程序的非法操作码、地址越界、算术溢出、虚存系统的缺页及专门的陷入指令等引起的事件。对异常的处理一般要依赖于当前程序的运行现场，而且<strong>异常不能被屏蔽，一旦出现应立即处理</strong>。关于内中断和外中断的联系与区别如图 1.2 所示。</p>\n<h4 id=\"zhong-duan-chu-li-de-guo-cheng\">中断处理的过程</h4>\n<p>​\t不同计算机的中断(指外中断)处理过程各具特色，就其多数而论，中断处理流程如图 1.3 所示。各阶段处理流程的描述如下:</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210729154445.png\" alt></p>\n<ol>\n<li class=\"lvl-3\">\n<p>关中断。CPU 响应中断后，首先要保护程序的现场状态，在保护现场的过程中，CPU 不应响应更高级中断源的中断请求。否则，若现场保存不完整，在中断服务程序结束后，也就不能正确地恢复并继续执行现行程序。</p>\n</li>\n<li class=\"lvl-3\">\n<p>保存断点。为保证中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来的程序的断点（即程序计数器 PC）保存起来。</p>\n</li>\n<li class=\"lvl-3\">\n<p>中断服务程序寻址。其实质是取出中断服务程序的入口地址送入程序计数器 PC。</p>\n</li>\n<li class=\"lvl-3\">\n<p>保存现场和屏蔽字。进入中断服务程序后，首先要保存现场，现场信息一般是指程序状态字寄存器 PSWR 和某些通用寄存器的内容。</p>\n</li>\n<li class=\"lvl-3\">\n<p>开中断。允许更高级中断请求得到响应。</p>\n</li>\n<li class=\"lvl-3\">\n<p>执行中断服务程序。这是中断请求的目的。</p>\n</li>\n<li class=\"lvl-3\">\n<p>关中断。保证在恢复现场和屏蔽字时不被中断。</p>\n</li>\n<li class=\"lvl-3\">\n<p>恢复现场和屏蔽字。将现场和屏蔽字恢复到原来的状态。</p>\n</li>\n<li class=\"lvl-3\">\n<p>开中断、中断返回。中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序。</p>\n</li>\n</ol>\n<p>其中，1 ~ 3 步是在 CPU 进入中断周期后，由硬件自动（中断隐指令）完成的;4 ~ 9 步由中断服务程序完成。恢复现场是指在中断返回前，必须将寄存器的内容恢复到中断处理前的状态，这部分工作由中断服务程序完成。中断返回由中断服务程序的最后一条中断返回指令完成。</p>\n<h3 id=\"xi-tong-diao-yong\">系统调用</h3>\n<p>​\t所谓系统调用，是指用户在程序中调用操作系统所提供的一些子功能，系统调用可视为特殊的公共子程序。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、进行 IO 传输及管理文件等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。通常，一个操作系统提供的系统调用命令有几十条乃至上百条之多。这些系统调用按功能大致可分为如下几类。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>设备管理。完成设备的请求或释放，以及设备启动等功能。文件管理。完成文件的读、写、创建及删除等功能。</p>\n</li>\n<li class=\"lvl-2\">\n<p>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</p>\n</li>\n<li class=\"lvl-2\">\n<p>进程通信。完成进程之间的消息传递或信号传递等功能。</p>\n</li>\n<li class=\"lvl-2\">\n<p>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</p>\n</li>\n</ul>\n<p>显然，系统调用相关功能涉及系统资源管理、进程管理之类的操作，对整个系统的影响非常大，因此必定需要使用某些特权指令才能完成，所以系统调用的处理需要由操作系统内核程序负责完成，要运行在核心态。用户程序可以执行<code>陷入指令</code>(又称<code>访管指令</code>或<code> trap 指令</code>）来发起系统调用，请求操作系统提供服务。可以这么理解，用户程序执行“陷入指令”，相当于把 CPU 成低用权主动交给操作系统内核程序（CPU 状态会从用户态进入核心态)，之后操作系统内核程序再对系统调用请求做出相应处理。处理完成后，操作系统内核程序又会把 CPU 的使用权还给用户程序(即 CPU 状态会从核心态回到用户态)。这么设计的目的是:用户程序不能直接执行对系统影响非常大的操作，必须通过系统调用的方式请求操作系统代为执行，以便保证系统的稳定性和安全性，防止用户程序随意更改或访问重要的系统资源，影响其他进程的运行。</p>\n<p>​\t这样，操作系统的运行环境就可以理解为:用户通过操作系统运行上层程序（如系统提供的命令解释程序或用户自编程序)，而这个上层程序的运行依赖于操作系统的底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序;也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。管理程序运行结束时，用户程序需要继续运行，此时通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行，如图 1.4 所示。</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210726162621.png\" alt></p>\n<p>在操作系统这一层面上，我们关心的是系统核心态和用户态的软件实现与切换，对于硬件层面的具体理解，可以结合“计算机组成原理”课程中有关中断的内容进行学习。</p>\n<p>下面列举一些由用户态转向核心态的例子:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>用户程序要求操作系统的服务，即系统调用。</p>\n</li>\n<li class=\"lvl-3\">\n<p>发生一次中断。</p>\n</li>\n<li class=\"lvl-3\">\n<p>用户程序中产生了一个错误状态。</p>\n</li>\n<li class=\"lvl-3\">\n<p>用户程序中企图执行一条特权指令。</p>\n</li>\n<li class=\"lvl-3\">\n<p>从核心态转向用户态由一条指令实现，这条指令也是特权命令，一般是中断返回指令。</p>\n</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意:由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的。</p></blockquote>\n<p>若程序的运行由用户态转到核心态，则会用到访管指令，访管指令是在用户态使用的，所以它不可能是特权指令。</p>\n<h2 id=\"cao-zuo-xi-tong-de-ti-xi-jie-gou\">操作系统的体系结构</h2>\n<h3 id=\"da-nei-he-he-wei-nei-he\">大内核和微内核</h3>\n<p>​\t操作系统的体系结构是一个开放的问题。如上文所述，操作系统在核心态为应用程序提供公共的服务，那么操作系统在核心态应该提供什么服务、怎样提供服务﹖有关这一问题的回答形成了两种主要的体系结构:大内核和微内核。</p>\n<p>​\t大内核系统将操作系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为应用提供高性能的系统服务。因为各管理模块之间共享信息，能有效利用相互之间的有效特性.所以具有无可比拟的性能优势。</p>\n<p>​\t但随着体系结构和应用需求的不断发展，需要操作系统提供的服务越来越多，而且接口形式越来越复杂，操作系统的设计规模急剧增长，操作系统也面临着“软件危机”困境。为此，操作系统设计人员试图按照复杂性、时间常数、抽象级别等因素，将操作系统内核分成基本进程管理、虚存、IO 与设备管理、IPC、文件系统等几个层次，继而定义层次之间的服务结构，提高操作系统内核设计上的模块化。但是，由于层次之间的交互关系错综复杂，定义清晰的层次间接口非常困难，复杂的交互关系也使得层次之间的界限极其模糊。</p>\n<p>​\t为解决操作系统的内核代码难以维护的问题，提出了微内核的体系结构。它将内核中最基本的功能（如进程管理等）保留在内核，而将那些不需要在核心态执行的功能移到用户态执行,从而降低了内核的设计复杂性。那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。</p>\n<p>​\t微内核结构有效地分离了内核与服务、服务与服务，使得它们之间的接口更加清晰，维护的代价大大降低，各部分可以独立地优化和演进，从而保证了操作系统的可靠性。</p>\n<p>​\t微内核结构的最大问题是性能问题，因为需要频繁地在核心态和用户态之间进行切换，操作系统的执行开销偏大。因此有的操作系统将那些频繁使用的系统服务又移回内核，从而保证系统性能。但相当多的实验数据表明，体系结构不是引起性能下降的主要因素，体系结构带来的性能提升足以弥补切换开销带来的缺陷。为减少切换开销，也有人提出将系统服务作为运行库链接到用户程序的一种解决方案，这样的体系结构称为<code>库操作系统</code>。</p>\n<h2 id=\"ben-zhang-yi-nan-dian\">本章疑难点</h2>\n<h3 id=\"bing-xing-xing-yu-bing-fa-xing-de-qu-bie-he-lian-xi\">并行性与并发性的区别和联系</h3>\n<p>​\t\t并行性和并发性是既相似又有区别的两个概念。并行性是指两个或多个事件在同一时刻发生，并发性是指两个或多个事件在同一时间间隔内发生。</p>\n<p>​\t在多道程序环境下，并发性是指在一段时间内，宏观上有多个程序同时运行，但在单处理器系统中每个时刻却仅能有一道程序执行，因此微观上这些程序只能分时地交替执行。若在计算机系统中有多个处理器，则这些可以并发执行的程序便被分配到多个处理器上，实现并行执行，即利用每个处理器来处理一个可并发执行的程序。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>咬文嚼字一下，并行依靠多处理器支持，如果两个任务挂在到两个不同的处理器那么就能并行执行考虑 java 的线程机制，一个继承了 thread 的线程，在调用 start 的时候启动启动一个线程，那么就实现了并发发(发车，启动)java <a href=\"https://www.cnblogs.com/agilestyle/p/11421515.html\">run 和 start 的区别</a></p></blockquote>\n<h3 id=\"te-quan-zhi-ling-yu-fei-te-quan-zhi-ling\">特权指令与非特权指令</h3>\n<p>​\t所谓特权指令，是指有特殊权限的指令，由于这类指令的权限最大，使用不当将导致整个系统崩溃，如清内存、置时钟、分配系统资源、修改虚存的段表或页表、修改用户的访问权限等。若所有程序都能使用这些指令，则系统一天死机 n 次就不足为奇。为保证系统安全，这类指令只能用于操作系统或其他系统软件，不直接提供给用户使用。因此，特权指令必须在核心态执行。实际上，CPU 在核心态下可以执行指令系统的全集。形象地说，特权指令是那些儿童不宜的东西，而非特权指令是老少皆宜的东西。</p>\n<p>​\t为了防止用户程序中使用特权指令，用户态下只能使用非特权指令，核心态下可以使用全部指令。在用户态下使用特权指令时，将产生中断以阻止用户使用特权指令。所以把用户程序放在用户态下运行，而操作系统中必须使用特权指令的那部分程序在核心态下运行，保证了计算机系统的安全可靠。从用户态转换为核心态的唯一途径是中断或异常。</p>\n<h3 id=\"fang-guan-zhi-ling-yu-fang-guan-zhong-duan\">访管指令与访管中断</h3>\n<p>​\t访管指令是一条可以在用户态下执行的指令。在用户程序中，因要求操作系统提供服务而有意识地使用访管指令，从而产生一个中断事件（自愿中断)，将操作系统转换为核心态，称为访管中断。访管中断由访管指令产生，程序员使用访管指令向操作系统请求服务。</p>\n<p>​\t为什么要在程序中引入访管指令呢?这是因为用户程序只能在用户态下运行。若用户程序想要完成在用户态下无法完成的工作，该怎么办﹖解决这个问题要靠访管指令。访管指令本身不是特权指令，其基本功能是让程序拥有“自愿进管”的手段，从而引起访管中断。</p>\n<p>​\t处于用户态的用户程序使用访管指令时，系统根据访管指令的操作数执行访管中断处理程序，访管中断处理程序将按系统调用的操作数和参数转到相应的例行子程序。完成服务功能后，退出中断，返回到用户程序断点继续执行。</p>\n<h1 id=\"jin-cheng-guan-li\">进程管理</h1>\n<h2 id=\"jin-cheng-yu-xian-cheng\">进程与线程</h2>\n<h3 id=\"jin-cheng-de-gai-nian-he-te-zheng\">进程的概念和特征</h3>\n<h4 id=\"jin-cheng-de-gai-nian\">进程的概念</h4>\n<p>​\t在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性的特征。为此<strong>引入了进程（Process）的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性（最基本的两个特性)。</strong></p>\n<p>​\t为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为<code>进程控制块（Process Control Block，PCB)</code>。系统利用 PCB 来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由程序段、相关数据段和 PCB 三部分构成了进程映像（进程实体)。**所谓创建进程，实质上是创建进程映像中的 PCB;而撤销进程,实质上是撤销进程的 PCB。**值得注意的是，进程映像是静态的，进程则是动态的。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意:PCB 是进程存在的唯一标志!</p></blockquote>\n<p>从不同的角度，进程可以有不同的定义，比较典型的定义有:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>进程是程序的一次执行过程。</p>\n</li>\n<li class=\"lvl-3\">\n<p>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</p>\n</li>\n<li class=\"lvl-3\">\n<p>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</p>\n</li>\n</ol>\n<p>​\t引入进程实体的概念后，我们可以把传统操作系统中的进程定义为:“<strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</strong>。”</p>\n<p>​\t读者要准确理解这里说的系统资源。它指处理机、存储器和其他设备服务于某个进程的“时间”，例如把处理机资源理解为处理机的时间片才是准确的。因为进程是这些资源分配和调度的独立单位，即“时间片”分配的独立单位，这就决定了进程一定是一个动态的、过程性的概念。</p>\n<h4 id=\"jin-cheng-de-te-zheng\">进程的特征</h4>\n<p>进程是由多道程序的并发执行而引出的，它和程序是两个截然不同的概念。进程的基本特征是对比单个程序的顺序执行提出的，也是对进程管理提出的基本要求。</p>\n<ol>\n<li class=\"lvl-3\">\n<p>动态性。进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征。</p>\n</li>\n<li class=\"lvl-3\">\n<p>并发性。指多个进程实体同时存于内存中，能在一段时间内同时运行。并发性是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的就是使程序能与其他进程的程序并发执行，以提高资源利用率。</p>\n</li>\n<li class=\"lvl-3\">\n<p>独立性。指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立 PCB 的程序，都不能作为一个独立的单位参与运行。</p>\n</li>\n<li class=\"lvl-3\">\n<p>异步性。由于进程的相互制约，使得进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此在操作系统中必须配置相应的进程同步机制。</p>\n</li>\n<li class=\"lvl-3\">\n<p>结构性。每个进程都配置一个 PCB 对其进行描述。从结构上看，进程实体是由程序段、数据段和进程控制块三部分组成的。</p>\n</li>\n</ol>\n<p>通常不会直接考查进程有什么特性，所以读者对上面的 5 个特性不求记忆，只求理解。</p>\n<h3 id=\"jin-cheng-de-zhuang-tai-yu-zhuan-huan\">进程的状态与转换</h3>\n<p>​\t进程在其生命周期内，由于系统中各进程之间的相互制约关系及系统的运行环境的变化，使得进程的状态也在不断地发生变化(一个进程会经历若干不同状态)。通常进程有以下 5 种状态，前 3 种是进程的基本状态。</p>\n<ol>\n<li class=\"lvl-3\">\n<p>运行态。进程正在处理机上运行。在单处理机环境下，每个时刻最多只有一个进程处于运行态。</p>\n</li>\n<li class=\"lvl-3\">\n<p>就绪态。进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行。系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</p>\n</li>\n<li class=\"lvl-3\">\n<p>阻塞态，又称等待态。进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。</p>\n</li>\n<li class=\"lvl-3\">\n<p>创建态。进程正在被创建，尚未转到就绪态。创建进程通常需要多个步骤:首先申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息;然后由系统为该进程分配运行时所必需的资源;最后把该进程转入就绪态。</p>\n</li>\n<li class=\"lvl-3\">\n<p>结束态。进程正从系统中消失，可能是进程正常结束或其他原因中断退出运行。进程需要结束运行时，系统首先必须将该进程置为结束态，然后进一步处理资源释放和回收等工作。</p>\n</li>\n</ol>\n<p>​\t注意区别就绪态和等待态:<strong>就绪态是指进程仅缺少处理机，只要获得处理机资源就立即运行;而等待态是指进程需要其他资源（除了处理机）或等待某一事件</strong>。之所以把处理机和其他资源划分开，是因为在分时系统的时间片轮转机制中，每个进程分到的时间片是若干毫秒。也就是说，进程得到处理机的时间很短且非常频繁，进程在运行过程中实际上是频繁地转换到就绪态的;而其他资源（如外设）的使用和分配或某一事件的发生（如 IO 操作的完成）对应的时间相对来说很长，进程转换到等待态的次数也相对较少。这样来看，就绪态和等待态是进程生命周期中两个完全不同的状态，显然需要加以区分。</p>\n<p>图 2.1 说明了 5 种进程状态的转换，而 3 种基本状态之间的转换如下:</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>就绪态 → 运行态:处于就绪态的进程被调度后，获得处理机资源（分派处理机时间片)，于是进程由就绪态转换为运行态。</p>\n</li>\n<li class=\"lvl-2\">\n<p>运行态 → 就绪态:处于运行态的进程在时间片用完后，不得不让出处理机，从而进程由运行态转换为就绪态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程序将正在执行的进程转换为就绪态，让更高优先级的进程执行。</p>\n</li>\n<li class=\"lvl-2\">\n<p>运行态 → 阻塞态:进程请求某一资源（如外设）的使用和分配或等待某一事件的发生(如 I/O 操作的完成）时，它就从运行态转换为阻塞态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。</p>\n</li>\n<li class=\"lvl-2\">\n<p>阻塞态 → 就绪态:进程等待的事件到来时，如 IO 操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞态转换为就绪态。</p>\n</li>\n</ul>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210808131002.png\" alt></p>\n<p>需要注意的是，一个进程从运行态变成阻塞态是<code>主动</code>的行为，而从阻塞态变成就绪态是<code>被动</code>的行为，需要其他相关进程的协助。</p>\n<p><strong>拓展</strong>:<strong>引入挂起的五状态模型</strong></p>\n<p>​\t而在这些状态之外还存在着一个状态，我们称之为<code>挂起</code>状态，它既可以是我们客户主动使得进程挂起，也可以是操作系统因为某些原因使得进程挂起。总而言之引入挂起状态的原因有以下几种：</p>\n<p>用户的请求：可能是在程序运行期间发现了可疑的问题，需要暂停进程。</p>\n<ol>\n<li class=\"lvl-3\">\n<p><code>父进程的请求</code>：考察，协调，或修改子进程。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>操作系统的需要</code>：对运行中资源的使用情况进行检查和记账。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>负载调节的需要</code>：有一些实时的任务非常重要，需要得到充足的内存空间(将进程PCB等相关内容调入外存)，这个时候我们需要把非实时的任务进行挂起，优先使得实时任务执行。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>定时任务</code>：一个进程可能会周期性的执行某个任务，那么在一次执行完毕后挂起而不是阻塞，这样可以节省内存。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>安全</code>：系统有时可能会出现故障或者某些功能受到破坏，这是就需要将系统中正在进行的进程进行挂起，当系统故障消除以后，对进程的状态进行恢复。</p>\n</li>\n</ol>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20200516190118336.png\" alt></p>\n<p><strong>挂起状态和阻塞状态有什么区别?</strong><br>\n有以下几个方面的区别：</p>\n<ol>\n<li class=\"lvl-3\">\n<p><code>是否释放CPU</code>：<strong>阻塞（pend）就是任务释放CPU</strong>，其他任务可以运行，一般在等待某种资源或信号量的时候出现。<strong>挂起（suspend）不释放CPU</strong>，如果任务优先级高就永远轮不到其他任务运行。<strong>一般挂起用于程序调试中的条件中断，当出现某个条件的情况下挂起，然后进行单步调试</strong>。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>是否主动</code>：显然<strong>阻塞是一种被动行为</strong>，其发生在磁盘，网络IO，wait，lock等要等待某种事件的发生的操作之后。因为拿不到IO资源，所以阻塞时会放弃 CPU的占用。而<strong>挂起是主动的，因为挂起后还要受到CPU的监督（等待着激活）</strong>，所以挂起不释放CPU，比如sleep函数，占着CPU不使用。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>与调度器是否相关</code>：任务调度是操作系统来实现的，任务调度时，直接忽略挂起状态的任务，但是会顾及处于pend下的任务，当pend下的任务等待的资源就绪后，就可以转为ready了。ready只需要等待CPU时间，当然，任务调度也占用开销，但是不大，可以忽略。可以这样理解，只要是挂起状态，操作系统就不在管理这个任务了。</p>\n</li>\n</ol>\n<h3 id=\"jin-cheng-kong-zhi\">进程控制</h3>\n<p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序段称为原语，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。</p>\n<h4 id=\"jin-cheng-de-chuang-jian\">进程的创建</h4>\n<p>​\t允许一个进程创建另一个进程。此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给程。此外，在撤销父进程时，必须同时撤销其所有的子进程。</p>\n<p>在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。操作系统创建一个新进程的过程如下（创建原语):</p>\n<ol>\n<li class=\"lvl-3\">\n<p>为新进程分配一个唯一的进程标识号，并申请一个空白的 PCB (PCB 是有限的)。若申请失败，则创建失败。</p>\n</li>\n<li class=\"lvl-3\">\n<p>为进程分配资源，为新进程的程序和数据及用户栈分配必要的内存空间（在 PCB 中体现)。注意，若资源不足（如内存空间)，则并不是创建失败，而是处于阻塞态，等待内存资源。</p>\n</li>\n<li class=\"lvl-3\">\n<p>初始化 PCB，主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。</p>\n</li>\n<li class=\"lvl-3\">\n<p>若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。</p>\n</li>\n</ol>\n<h4 id=\"jin-cheng-de-zhong-zhi\">进程的终止</h4>\n<p>​\t引起进程终止的事件主要有:① 正常结束，表示进程的任务已完成并准备退出运行。② 异常结束，表示进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、I/O 故障等。③ 外界干预，指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。</p>\n<p>操作系统终止进程的过程如下（撤销原语):</p>\n<ol>\n<li class=\"lvl-3\">\n<p>根据被终止进程的标识符，检索 PCB，从中读出该进程的状态。</p>\n</li>\n<li class=\"lvl-3\">\n<p>若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。</p>\n</li>\n<li class=\"lvl-3\">\n<p>若该进程还有子孙进程，则应将其所有子孙进程终止。</p>\n</li>\n<li class=\"lvl-3\">\n<p>将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统。</p>\n</li>\n<li class=\"lvl-3\">\n<p>将该 PCB 从所在队列（链表）中删除。</p>\n</li>\n</ol>\n<h4 id=\"jin-cheng-de-zu-sai-he-huan-xing\">进程的阻塞和唤醒</h4>\n<p>​\t正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作可做等，由系统自动执行阻塞原语（Block)，使自己由运行态变为阻塞态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程(获得 CPU 才可能将其转为阻塞态。阻塞原语的执行过程如下:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>找到将要被阻塞进程的标识号对应的 PCB。</p>\n</li>\n<li class=\"lvl-3\">\n<p>若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。</p>\n</li>\n<li class=\"lvl-3\">\n<p>把该 PCB 插入相应事件的等待队列，将处理机资源调度给其他就绪进程。</p>\n</li>\n</ol>\n<p>当被阻塞进程所期待的事件出现时,如它所启动的 IO 操作已完成或其所期待的数据已到达，由有关进程（比如，释放该 IO 设备的进程，或提供数据的进程）调用唤醒原语（Wakeup)，将等待该事件的进程唤醒。唤醒原语的执行过程如下:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>在该事件的等待队列中找到相应进程的 PCB。</p>\n</li>\n<li class=\"lvl-3\">\n<p>将其从等待队列中移出，并置其状态为就绪态。</p>\n</li>\n<li class=\"lvl-3\">\n<p>把该 PCB 插入就绪队列，等待调度程序调度。</p>\n</li>\n</ol>\n<p>需要注意的是，Block 原语和 Wakeup 原语是一对作用刚好相反的原语，必须成对使用。Block 原语是由被阻塞进程自我调用实现的，而 Wakeup 原语则是由一个与被唤醒进程合作或被其他相关的进程调用实现的。</p>\n<h4 id=\"jin-cheng-qie-huan\">进程切换</h4>\n<p>​\t对于通常的进程而言，其创建、撤销及要求由系统设备完成的 I/O 操作，都是利用系统调用而进入内核，再由内核中的相应处理程序予以完成的。进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>\n<p>进程切换是指处理机从一个进程的运行转到另一个进程上运行，在这个过程中，进程的运行环境产生了实质性的变化。进程切换的过程如下:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>保存处理机上下文，包括程序计数器和其他寄存器。</p>\n</li>\n<li class=\"lvl-3\">\n<p>更新 PCB 信息。</p>\n</li>\n<li class=\"lvl-3\">\n<p>把进程的 PCB 移入相应的队列，如就绪、在某事件阻塞等队列。</p>\n</li>\n<li class=\"lvl-3\">\n<p>选择另一个进程执行，并更新其 PCB。</p>\n</li>\n<li class=\"lvl-3\">\n<p>更新内存管理的数据结构。</p>\n</li>\n<li class=\"lvl-3\">\n<p>恢复处理机上下文。</p>\n</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意，进程切换与处理机模式切换是不同的，模式切换时，处理机逻辑上可能还在同一进程中运行。若进程因中断或异常进入核心态运行，执行完后又回到用户态刚被中断的程序运行，则操作系统只需恢复进程进入内核时所保存的 CPU 现场，而无须改变当前进程的环境信息。但若要切换进程，当前运行进程改变了，则当前进程的环境信息也需要改变。</p></blockquote>\n<h3 id=\"jin-cheng-de-zu-zhi\">进程的组织</h3>\n<p>​\t进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位。它由以下三部分组成，其中最核心的是进程控制（PCB)。</p>\n<h4 id=\"jin-cheng-kong-zhi-kuai\">进程控制块</h4>\n<p>​\t进程创建时，操作系统为它新建一个 PCB，该结构之后常驻内存，任意时刻都可以存取，并在进程结束时删除。PCB 是进程实体的一部分，是进程存在的唯一标志。</p>\n<p>​\t进程执行时，系统通过其 PCB 了解进程的现行状态信息，以便对其进行控制和管理;进程结束时，系统收回其 PCB，该进程随之消亡。操作系统通过 PCB 表来管理和控制进程。</p>\n<p>​\t当操作系统欲调度某进程运行时，要从该进程的 PCB 中查出其现行状态及优先级;在调度到某进程后，要根据其 PCB 中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其 PCB 中的程序和数据的内存始址，找到其程序和数据;进程在运行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也需要访问 PCB;当进程由于某种原因而暂停运行时，又需将其断点的处理机环境保存在 PCB 中。可见，在进程的整个生命期中，系统总是通过 PCB 对进程进行控制的，亦即系统唯有通过进程的 PCB 才能感知到该进程的存在。</p>\n<p>表 2.1 是一个 PCB 的实例。PCB 主要包括进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息等。各部分的主要说明如下:</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210808131744.png\" alt></p>\n<ol>\n<li class=\"lvl-3\">\n<p>进程描述信息。进程标识符:标志各个进程，每个进程都有一个唯一的标识号。用户标识符:进程归属的用户，用户标识符主要为共享和保护服务。</p>\n</li>\n<li class=\"lvl-3\">\n<p>进程控制和管理信息。进程当前状态:描述进程的状态信息，作为处理机分配调度的依据。进程优先级:描述进程抢占处理机的优先级，优先级高的进程可优先获得处理机。</p>\n</li>\n<li class=\"lvl-3\">\n<p>资源分配清单，用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入/输出设备信息。</p>\n</li>\n<li class=\"lvl-3\">\n<p>处理机相关信息，主要指处理机中各寄存器的值，当进程被切换时，处理机状态信息都必须保存在相应的 PCB 中，以便在该进程重新执行时，能从断点继续执行。</p>\n</li>\n</ol>\n<p>在一个系统中，通常存在着许多进程的 PCB，有的处于就绪态，有的处于阻塞态，而且阻塞的原因各不相同。为了方便进程的调度和管理，需要将各进程的 PCB 用适当的方法组织起来。目前，常用的组织方式有链接方式和索引方式两种。链接方式将同一状态的 PCB 链接成一个队列,不同状态对应不同的队列，也可把处于阻塞态的进程的 PCB，根据其阻塞原因的不同，排成多个阻塞队列。索引方式将同一状态的进程组织在一个索引表中，索引表的表项指向相应的 PCB，不同状态对应不同的索引表，如就绪索引表和阻塞索引表等。</p>\n<h4 id=\"cheng-xu-duan\">程序段</h4>\n<p>程序段就是能被进程调度程序调度到 CPU 执行的程序代码段。注意，程序可被多个进程共享，即多个进程可以运行同一个程序。</p>\n<h4 id=\"shu-ju-duan\">数据段</h4>\n<p>一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</p>\n<h3 id=\"jin-cheng-de-tong-xin\">进程的通信</h3>\n<p>进程通信是指进程之间的信息交换。PV 操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三类。</p>\n<h4 id=\"gong-xiang-cun-chu\">共享存储</h4>\n<p>在通信的进程之间存在一块可直接访问的共享空间,通过对这片共享空间进行写/读操作实现进程之间的信息交换，如图 2.2 所示。在对共享空间进行写/读操作时，需要使用同步互斥工具(如 Р 操作、V 操作)，对共享空间的写/读进行控制。共享存储又分为两种:低级方式的共享是基于数据结构的共享;高级方式的共享则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。</p>\n<p>注意，用户进程空间一般都是独立的，进程运行期间一般不能访问其他进程的空间，要想让两个用户进程共享空间，必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。</p>\n<p>简单理解就是，甲和乙中间有一个大布袋，甲和乙交换物品是通过大布袋进行的，甲把物品放在大布袋里，乙拿走。但乙不能直接到甲的手中拿东西，甲也不能直接到乙的手中拿东西。</p>\n<h4 id=\"xiao-xi-chuan-di\">消息传递</h4>\n<p>在消息传递系统中，进程间的数据交换是以格式化的消息（Message）为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。</p>\n<ol>\n<li class=\"lvl-3\">\n<p>直接通信方式。发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息，如图 2.3 所示。</p>\n</li>\n</ol>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210808132052.png\" alt></p>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>间接通信方式。发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。</p>\n</li>\n</ol>\n<p>这种中间实体一般称为信箱，这种通信方式又称信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。简单理解就是，甲要告诉乙某些事情，就要写信，然后通过邮差送给乙。直接通信就是邮差把信直接送到乙的手上;间接通信就是乙家门口有一个邮箱，邮差把信放到邮箱里。</p>\n<h4 id=\"guan-dao-tong-xin\">管道通信</h4>\n<p>管道通信是消息传递的一种特殊方式（见图 2.4)。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间的通信的一个共享文件，又名 pipe 文件。向管道(共享文件)提供输入的发送进程（即写进程)，以字符流形式将大量的数据送入(写）管道;而接收管道输出的接收进程（即读进程）则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力:互斥、同步和确定对方的存在。</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210808132250.png\" alt=\"找不到图片(Image not found)\"></p>\n<p>下面以 Linux 中的管道为例进行说明。在 Linux 中，管道是一种使用非常频繁的通信机制。从本质上说，管道也是一种文件，但它又和一般的文件有所不同，管道可以克服使用文件进行通信的两个问题，具体表现如下:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>限制管道的大小。实际上，管道是一个固定大小的缓冲区。在 Linux 中，该缓冲区的大小为 4KB，这使得它的大小不像文件那样不加检验地增长。使用单个固定缓冲区也会带来问题，比如在写管道时可能变满，这种情况发生时，随后对管道的 write()调用将默认地被阻塞，等待某些数据被读取，以便腾出足够的空间供 write()调用写。</p>\n</li>\n<li class=\"lvl-3\">\n<p>读进程也可能工作得比写进程快。当所有当前进程数据已被读取时，管道变空。当这种情况发生时，一个随后的 read()调用将默认地被阻塞,等待某些数据被写入,这解决了 read()调用返回文件结束的问题。</p>\n</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意:从管道读数据是一次性操作，数据一旦被读取，它就从管道中被抛弃，释放空间以便写更多的数据。管道只能采用半双工通信，即某一时刻只能单向传输。要实现父子进程双方互动通信，需要定义两个管道。</p></blockquote>\n<p>管道可以理解为共享存储的优化和发展,因为在共享存储中，若某进程要访问共享存储空间则必须没有其他进程在该共享存储空间中进行写操作，否则访问行为就会被阻塞。而管道通信中存储空间进化成了缓冲区，缓冲区只允许一边写入、另一边读出，因此只要缓冲区中有数据，进程就能从缓冲区中读出，而不必担心会因为其他进程在其中进行写操作而遭到阻塞，因为写进程会先把缓冲区写满，然后才让读进程读，当缓冲区中还有数据时，写进程不会往缓冲区写数据。当然，这也决定了管道通信必然是半双工通信。</p>\n<h3 id=\"xian-cheng-gai-nian-he-duo-xian-cheng-mo-xing\">线程概念和多线程模型</h3>\n<h4 id=\"xian-cheng-de-ji-ben-gai-nian\">线程的基本概念</h4>\n<p>​\t引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量;而引入线程的目的则是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p>\n<p>​\t线程最直接的理解就是“轻量级进程”，它是一个基本的 CPU 执行单元，也是程序执行流的最小单元，由线程 ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。</p>\n<p>​\t引入线程后，进程的内涵发生了改变，进程只作为除 CPU 外的系统资源的分配单元，而线程则作为处理机的分配单元。由于一个进程内部有多个线程，若线程的切换发生在同一个进程内部，则只需要很少的时空开销。</p>\n<h4 id=\"xian-cheng-yu-jin-cheng-de-bi-jiao\">线程与进程的比较</h4>\n<ol>\n<li class=\"lvl-3\">\n<p>调度。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中,线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</p>\n</li>\n<li class=\"lvl-3\">\n<p>拥有资源。不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源（也有一点儿必不可少的资源)，但线程可以访问其隶属进程的系统资源。要知道，若线程也是拥有资源的单位，则切换线程就需要较大的时空开销，线程这个概念的提出就没有意义。</p>\n</li>\n<li class=\"lvl-3\">\n<p>并发性。在引入线程的操作系统中，不仅进程之间可以并发执行，而且多个线程之间也可以并发执行，从而使操作系统具有更好的并发性，提高了系统的吞吐量。</p>\n</li>\n<li class=\"lvl-3\">\n<p>系统开销。由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、IO 设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度到进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。此外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信非常容易实现，甚至无须操作系统的干预。</p>\n</li>\n<li class=\"lvl-3\">\n<p>地址空间和其他资源（如打开的文件)。进程的地址空间之间互相独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。</p>\n</li>\n<li class=\"lvl-3\">\n<p>通信方面。进程间通信（IPC）需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间可以直接读/写进程数据段（如全局变量）来进行通信。</p>\n</li>\n</ol>\n<h4 id=\"xian-cheng-de-shu-xing\">线程的属性</h4>\n<p>多线程操作系统把线程作为独立运行（或调度）的基本单位，此时的进程已不再是一个基本的可执行实体，但它仍具有与执行相关的状态。所谓进程处于“执行”状态，实际上是指该进程中的某线程正在执行。线程的主要属性如下:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块，线程控制块记录了线程执行的寄存器和栈等现场状态。</p>\n</li>\n<li class=\"lvl-3\">\n<p>不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统把它们创建成不同的线程。</p>\n</li>\n<li class=\"lvl-3\">\n<p>同一进程中的各个线程共享该进程所拥有的资源。</p>\n</li>\n<li class=\"lvl-3\">\n<p>线程是处理机的独立调度单位，多个线程是可以并发执行的。在单 CPU 的计算机系统中，各线程可交替地占用 CPU;在多 CPU 的计算机系统中，各线程可同时占用不同的 CPU,若各个 CPU 同时为一个进程内的各线程服务，则可缩短进程的处理时间。</p>\n</li>\n<li class=\"lvl-3\">\n<p>一个线程被创建后，便开始了它的生命周期，直至终止。线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。</p>\n</li>\n</ol>\n<p>为什么线程的提出有利于提高系统并发性?可以这样来理解:由于有了线程，线程切换时，有可能会发生进程切换，也有可能不发生进程切换，平均而言每次切换所需的开销就变小了，因此能够让更多的线程参与并发，而不会影响到响应时间等问题。</p>\n<h4 id=\"xian-cheng-de-shi-xian-fang-shi\">线程的实现方式</h4>\n<p>​\t线程的实现可以分为两类:用户级线程(User-Level Thread，ULT)和内核级线程(Kernel-LevelThread，KLT)。内核级线程又称内核支持的线程。</p>\n<p>在用户级线程中，有关线程管理（线程的创建、撤销和切换等）的所有工作都由应用程序完成，内核意识不到线程的存在。应用程序可以通过使用线程库设计成多线程程序。通常，应用程序从单线程开始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。图 2.5(a)说明了用户级线程的实现方式。</p>\n<p>在内核级线程中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。内核为进程及其内部的每个线程维护上下文信息，调度也在内核基于线程架构的基础上完成。图 2.5(b)说明了内核级线程的实现方式。</p>\n<p>有些系统中使用组合方式的多线程实现。线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。一个应用程序中的多个用户级线程被映射到一些(小于等于用户级线程的数目）内核级线程上。图 2.5©说明了用户级与内核级的组合实现方式。</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210808155557.png\" alt></p>\n<h4 id=\"duo-xian-cheng-mo-xing\">多线程模型</h4>\n<p>有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的连接方式。</p>\n<ol>\n<li class=\"lvl-3\">\n<p>多对一模型。将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户级线程对操作系统不可见（即透明)。</p>\n</li>\n</ol>\n<p>优点:线程管理是在用户空间进行的，因而效率比较高。</p>\n<p>缺点:一个线程在使用内核服务时被阻塞，整个进程都会被阻塞;多个线程不能并行地运行在多处理机上。</p>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>一对一模型。将每个用户级线程映射到一个内核级线程。</p>\n</li>\n</ol>\n<p>优点:当一个线程被阻塞后，允许另一个线程继续执行，所以并发能力较强。</p>\n<p>缺点:每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。</p>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>多对多模型。将 n 个用户级线程映射到 m 个内核级线程上，要求 m≤n。</p>\n</li>\n</ol>\n<p>特点:多对多模型是多对一模型和一对一模型的折中，既克服了多对一模型并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程而开销太大的缺点。</p>\n<p>此外，还拥有多对一模型和一对一模型各自的优点，可谓集两者之所长。</p>\n<h3 id=\"ben-jie-xiao-jie\">本节小结</h3>\n<h4 id=\"wei-shi-yao-yao-yin-ru-jin-cheng\">为什么要引入进程?</h4>\n<p>在多道程序同时运行的背景下，进程之间需要共享系统资源，因此会导致各程序在执行过程中出现相互制约的关系，程序的执行会表现出间断性的特征。这些特征都是在程序的执行过程中发生的，是动态的过程，而传统的程序本身是一组指令的集合，是一个静态的概念，无法描述程序在内存中的执行情况，即我们无法从程序的字面上看出它何时执行、何时停顿，也无法看出它与其他执行程序的关系，因此，程序这个静态概念已不能如实反映程序并发执行过程的特征。为了深刻描述程序动态执行过程的性质乃至更好地支持和管理多道程序的并发执行，人们引入了进程的概念。</p>\n<h4 id=\"shi-yao-shi-jin-cheng-jin-cheng-you-shi-yao-zu-cheng\">什么是进程?进程由什么组成?</h4>\n<p>进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码本身，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。</p>\n<p>一个进程实体由程序段、相关数据段和 PCB 三部分构成，其中 PCB 是标志一个进程存在的唯一标识，程序段是进程运行的程序的代码，数据段则存储程序运行过程中相关的一些数据。</p>\n<h2 id=\"chu-li-ji-diao-du\">处理机调度</h2>\n<h3 id=\"diao-du-de-gai-nian\">调度的概念</h3>\n<h4 id=\"diao-du-de-ji-ben-gai-nian\">调度的基本概念</h4>\n<p>​\t在多道程序系统中，进程的数量往往多于处理机的个数，因此进程争用处理机的情况在所难免。处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法（公平、高效）选择一个进程并将处理机分配给它运行，以实现进程并发地执行。</p>\n<p>处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题。</p>\n<h4 id=\"diao-du-de-ceng-ci\">调度的层次</h4>\n<p>一个作业从提交开始直到完成，往往要经历以下三级调度，如图 2.6 所示。</p>\n<ol>\n<li class=\"lvl-3\">\n<p><code>作业调度</code>。又称高级调度，其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个(或多个）作业，给它（们）分配内存、输入/输出设备等必要的资源，并建立相应的进程，以使它（们）获得竞争处理机的权利。简言之，作业调度就是内存与辅存之间的调度。对于每个作业只调入一次、调出一次。多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。作业调度的执行频率较低，通常为几分钟一次。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>中级调度</code> 。又称内存调度，其作用是提高内存利用率和系统吞吐量。为此，应将那些暂时不能运行的进程调至外存等待，把此时的进程状态称为挂起态。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪态，挂在就绪队列上等待。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>进程调度</code> 。又称低级调度，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p>\n</li>\n</ol>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210924232351.png\" alt></p>\n<h4 id=\"san-ji-diao-du-de-lian-xi\">三级调度的联系</h4>\n<p>作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，进程调度从就绪队列中选出一个进程，并把其状态改为运行态，把 CPU 分配给它。中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。当内存空间宽松时，通过中级调度选择具备运行条件的进程，将其唤醒。</p>\n<ol>\n<li class=\"lvl-3\">\n<p>作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。</p>\n</li>\n<li class=\"lvl-3\">\n<p>作业调度次数少，中级调度次数略多，进程调度频率最高。</p>\n</li>\n<li class=\"lvl-3\">\n<p>进程调度是最基本的，不可或缺。</p>\n</li>\n</ol>\n<h3 id=\"diao-du-de-shi-ji-qie-huan-yu-guo-cheng\">调度的时机、切换与过程</h3>\n<p>进程调度和切换程序是操作系统内核程序。请求调度的事件发生后，才可能运行进程调度程序，调度了新的就绪进程后，才会进行进程间的切换。理论上这三件事情应该顺序执行，但在实际设计中，操作系统内核程序运行时，若某时发生了引起进程调度的因素，则不一定能够马上进行调度与切换。</p>\n<p>现代操作系统中，不能进行进程的调度与切换的情况有以下几种:</p>\n<ol>\n<li class=\"lvl-3\">\n<p><code>处理中断</code>的过程中。中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源。</p>\n</li>\n<li class=\"lvl-3\">\n<p>进程在操作系统<code>内核程序临界区</code>中。进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放。</p>\n</li>\n<li class=\"lvl-3\">\n<p>其他需要完全屏蔽中断的<code>原子操作</code>过程中。如加锁、解锁、中断现场保护、恢复等原子操作。在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。</p>\n</li>\n</ol>\n<p>若在上述过程中发生了引起调度的条件，则不能马上进行调度和切换，应置系统的请求调度标志，直到上述过程结束后才进行相应的调度与切换。</p>\n<p>应该进行进程调度与切换的情况如下:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换。若操作系统只在这种情况下进行进程调度，则是 <code>非剥夺调度</code> 。</p>\n</li>\n<li class=\"lvl-3\">\n<p>中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。若操作系统支持这种情况下的运行调度程序，则实现了<code>剥夺方式</code>的调度。</p>\n</li>\n</ol>\n<p>进程切换往往在调度完成后立刻发生，它要求保存原进程当前切换点的现场信息，恢复被调度进程的现场信息。现场切换时，操作系统内核将原进程的现场信息推入当前进程的内核堆栈来保存它们，并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设 PC 寄存器等相关工作之后，开始运行新的进程。</p>\n<h3 id=\"jin-cheng-diao-du-fang-shi\">进程调度方式</h3>\n<p>所谓进程调度方式，是指当某个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更高的进程进入就绪队列，此时应如何分配处理机。</p>\n<p>通常有以下两种进程调度方式:</p>\n<ol>\n<li class=\"lvl-3\">\n<p><code>非剥夺调度方式</code>，又称非抢占方式。非剥夺调度方式是指当一个进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行直到该进程完成或发生某种事件而进入阻塞态时，才把处理机分配给更为重要或紧迫的进程。</p>\n</li>\n</ol>\n<p>在非剥夺调度方式下，一旦把 CPU 分配给一个进程，该进程就会保持 CPU 直到终止或转换到等待态。这种方式的优点是实现简单、系统开销小，适用于大多数的批处理系统但它不能用于分时系统和大多数的实时系统。</p>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p><code>剥夺调度方式</code>，又称抢占方式。剥夺调度方式是指当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。</p>\n</li>\n</ol>\n<p>采用剥夺式的调度，对提高系统吞吐率和响应效率都有明显的好处。但“剥夺”不是一种任意性行为，必须遵循一定的原则，主要有优先权、短进程优先和时间片原则等。</p>\n<h3 id=\"diao-du-de-ji-ben-zhun-ze\">调度的基本准则</h3>\n<p>不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法的特性。为了比较处理机调度算法的性能，人们提出了很多评价准则，下面介绍其中主要的几种:</p>\n<ol>\n<li class=\"lvl-3\">\n<p><code>CPU 利用率</code> 。CPU 是计算机系统中最重要和昂贵的资源之一，所以应尽可能使 CPU 保持“忙”状态，使这一资源利用率最高。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>系统吞吐量</code>。表示单位时间内 CPU 完成作业的数量。长作业需要消耗较长的处理机时间,因此会降低系统的吞吐量。而对于短作业，它们所需要消耗的处理机时间较短，因此能提高系统的吞吐量。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>周转时间 </code>。周转时间是指从作业提交到作业完成所经历的时间，是作业等待、在就绪队列中排队、在处理机上运行及进行输入/输出操作所花费时间的总和。</p>\n</li>\n</ol>\n<p>作业的周转时间可用公式表示如下:</p>\n<p>周转时间=作业完成时间-作业提交时间</p>\n<p>平均周转时间是指多个作业周转时间的平均值:</p>\n<p>平均周转时间=（作业 1 的周转时间+…+作业 n 的周转时间）/ n</p>\n<p><code>带权周转时间</code>是指<code>作业周转时间</code>与 <code>作业实际运行时间</code>的比值:</p>\n<p>带权周转时间=作业周转时间/作业实际运行时间</p>\n<p><code>平均带权周转时间</code>是指多个作业带权周转时间的平均值:</p>\n<p>平均带权周转时间=（作业 1 的带权周转时间+…+作业 n 的带权周转时间）/ n</p>\n<ol start=\"4\">\n<li class=\"lvl-3\">\n<p><code>等待时间</code>。等待时间指进程处于等处理机状态的时间之和，等待时间越长，用户满意度越低。处理机调度算法实际上并不影响作业执行或输入/输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，衡量一个调度算法的优劣，常常只需简单地考察等待时间。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>响应时间</code>。响应时间指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不可能是最好的评价准则，一般采用响应时间作为衡量调度算法的重要准则之一。从用户角度来看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内。</p>\n</li>\n</ol>\n<p>要想得到一个满足所有用户和系统要求的算法几乎是不可能的。设计调度程序，一方面要满足特定系统用户的要求（如某些实时和交互进程的快速响应要求)，另一方面要考虑系统整体效率（如减少整个系统的进程平均周转时间)，同时还要考虑调度算法的开销。</p>\n<h3 id=\"mark-dian-xing-de-diao-du-suan-fa-mark\"><mark>典型的调度算法</mark></h3>\n<h4 id=\"xian-lai-xian-fu-wu-fcfs-diao-du-suan-fa\">先来先服务(FCFS)调度算法</h4>\n<p>FCFS 调度算法是一种最简单的调度算法，它既可用于作业调度，又可用于进程调度。在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。</p>\n<p>在进程调度中，FCFS 调度算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到完成或因某种原因而阻塞时才释放处理机。</p>\n<p>下面通过一个实例来说明 FCFS 调度算法的性能。假设系统中有 4 个作业，它们的提交时间分别是 8,8.4,8.8,9，运行时间依次是 2,1,0.5,0.2，系统采用 FCFS 调度算法，这组作业的平均等待时间、平均周转时间和平均带权周转时间见表 2.2。</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210924234106.png\" alt></p>\n<p>FCFS 调度算法属于不可剥夺算法。从表面上看，它对所有作业都是公平的，但若一个长作业先到达系统，就会使后面的许多短作业等待很长时间，因此它不能作为分时系统和实时系统的主要调度策略。但它常被结合在其他调度策略中使用。例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程按 FCFS 原则处理。</p>\n<p>FCFS 调度算法的特点是算法简单，但效率低;对长作业比较有利，但对短作业不利（相对 SJF 和高响应比);有利于 CPU 繁忙型作业，而不利于 I/O 繁忙型作业。</p>\n<h4 id=\"duan-zuo-ye-you-xian-sjf-diao-du-suan-fa\">短作业优先(SJF)调度算法</h4>\n<p>​\t短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。短作业优先（SJF)调度算法从后备队列中选择一个或若干估计运行时间最短的作业，将它们调入内存运行;短进程优先(SPF）调度算法从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。</p>\n<p>例如，考虑表 2.2 中给出的一组作业，若系统采用短作业优先调度算法，其平均等待时间、平均周转时间和平均带权周转时间见表 2.3。</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210924234106-1689864784590-27.png\" alt></p>\n<p>SJF 调度算法也存在不容忽视的缺点:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>该算法对长作业不利，由表 2.2 和表 2.3 可知，SJF 调度算法中长作业的周转时间会增加更严重的是，若有一长作业进入系统的后备队列，由于调度程序总是优先调度那些（E 使是后进来的）短作业，将导致长作业长期不被调度（“饥饿”现象，注意区分“死锁”后者是系统环形等待，前者是调度策略问题)。</p>\n</li>\n<li class=\"lvl-3\">\n<p>该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理。</p>\n</li>\n<li class=\"lvl-3\">\n<p>由于作业的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。</p>\n</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意，SJF 调度算法的平均等待时间、平均周转时间最少。</p></blockquote>\n<h4 id=\"you-xian-ji-diao-du-suan-fa\">优先级调度算法</h4>\n<p>​\t优先级调度算法又称优先权调度算法，它既可用于作业调度，又可用于进程调度。该算法中的优先级用于描述作业运行的紧迫程度。</p>\n<p>在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最高的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。</p>\n<p>根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为如下两种:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>非剥夺式优先级调度算法非剥夺式优先级调度算法 。当一个进程正在处理机上运行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在运行的进程继续运行，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件)，才把处理机分配给更为重要或紧迫的进程。</p>\n</li>\n<li class=\"lvl-3\">\n<p>剥夺式优先级调度算法剥夺式优先级调度算法 。当一个进程正在处理机上运行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给更重要或紧迫的进程。</p>\n</li>\n</ol>\n<p>而根据进程创建后其优先级是否可以改变，可以将进程优先级分为以下两种:</p>\n<ol>\n<li class=\"lvl-3\">\n<p><code>静态优先级</code> 。优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>动态优先级</code> 。在进程运行过程中，根据进程情况的变化动态调整优先级。动态调整优先级的主要依据有进程占有 CPU 时间的长短、就绪进程等待 CPU 时间的长短。</p>\n</li>\n</ol>\n<p>一般来说，进程优先级的设置可以参照以下原则:</p>\n<ol>\n<li class=\"lvl-3\">\n<p><code>系统进程</code> &gt; <code>用户进程</code> 。系统进程作为系统的管理者，理应拥有更高的优先级。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>交互型进程</code> &gt; <code>非交互型进程</code> （或前台进程&gt;后台进程)。大家平时在使用手机时，在前台运行的正在和你交互的进程应该更快速地响应你，因此自然需要被优先处理，即要有更高的优先级。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>I/O 型进程</code> &gt; <code>计算型进程计算型进程</code> 。所谓 IO 型进程，是指那些会频繁使用 IO 设备的进程，而计算型进程是那些频繁使用 CPU 的进程（很少使用 I/O 设备)。我们知道，IO 设备（如打印机）的处理速度要比 CPU 慢得多，因此若将 IO 型进程的优先级设置得更高，就更有可能让 IO 设备尽早开始工作，进而提升系统的整体效率。</p>\n</li>\n</ol>\n<h4 id=\"gao-xiang-ying-bi-you-xian-diao-du-suan-fa\">高响应比优先调度算法</h4>\n<p>高响应比优先调度算法主要用于作业调度，是对 FCFS 调度算法和 SJF 调度算法的一种综合平衡，同时考虑了每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p>\n<p><code>响应比</code>的变化规律可描述为</p>\n<p>响应比R<sub>p</sub>=等待时间+要求服务时间/要求服务时间</p>\n<p>根据公式可知：</p>\n<ol>\n<li class=\"lvl-3\">\n<p>作业的等待时间相同时，要求服务时间越短，响应比越高，有利于 <code>短作业 </code>。</p>\n</li>\n<li class=\"lvl-3\">\n<p>要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高,因而它实现的是 <code>先来先服务</code> 。</p>\n</li>\n<li class=\"lvl-3\">\n<p>对于长作业，作业的响应比可以随等待时间的增加而提高，等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。因此，克服了<code>饥饿状态</code> ，兼顾了长作业。</p>\n</li>\n</ol>\n<h4 id=\"shi-jian-pian-lun-zhuan-diao-du-suan-fa\">时间片轮转调度算法</h4>\n<p>​\t时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中的第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如 100ms。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。</p>\n<p>​\t在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。若时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法。若时间片很小，则处理机将在进程间过于频繁地切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少。因此，时间片的大小应选择适当。</p>\n<p>​\t时间片的长短通常由以下因素确定:系统的响应时间、就绪队列中的进程数目和系统的处理能力。</p>\n<h4 id=\"duo-ji-fan-kui-dui-lie-diao-du-suan-fa-rong-he-liao-qian-ji-chong-suan-fa-de-you-dian\">多级反馈队列调度算法（融合了前几种算法的优点）</h4>\n<p>​\t多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合与发展，如图 2.7 所示。通过动态调整进程优先级和时间片大小,多级反馈队列调度算法可以兼顾多方面的系统目标。例如，为提高系统吞吐量和缩短平均周转时间而照顾短进程;为获得较好的 IO 设备利用率和缩短响应时间而照顾 IO 型进程;同时，也不必事先估计进程的执行时间。</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210924234833.png\" alt></p>\n<p>多级反馈队列调度算法的实现思想如下:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>设置多个就绪队列，并为各个队列赋予不同的优先级，第 1 级队列的优先级最高，第 2 级队列次之，其余队列的优先级逐次降低。</p>\n</li>\n<li class=\"lvl-3\">\n<p>赋予各个队列中进程执行时间片的大小各不相同。在优先级越高的队列中，每个进程的运行时间片越小。例如，第 2 级队列的时间片要比第 1 级队列的时间片长 1 倍……第 i +1 级队列的时间片要比第 i 级队列的时间片长 1 倍。</p>\n</li>\n<li class=\"lvl-3\">\n<p>一个新进程进入内存后，首先将它放入第 1 级队列的末尾，按 FCFS 原则排队等待调度当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统;若它在一个时间片结束时尚未完成，调度程序便将该进程转入第 2 级队列的末尾，再同样按 FCFS 原则等待调度执行;若它在第 2 级队列中运行一个时间片后仍未完成，再以同样的方法放入第 3 级队列……如此下去，当一个长进程从第 1 级队列依次降到第 n 级队列后，在第 n 级队列中便采用时间片轮转的方式运行。</p>\n</li>\n<li class=\"lvl-3\">\n<p>仅当第 1 级队列为空时，调度程序才调度 2 级队列中的进程运行;仅当第 1~( i -1)级队列均为空时，才会调度第 i 级队列中的进程运行。若处理机正在执行第 i 级队列中的某进程，这时又有新进程进入优先级较高的队列〔第 1 ～( i -1)中的任何一个队列]，则此时新进程将抢占正在运行进程的处理机,即由调度程序把正在运行的进程放回第 i 级队列的末尾，把处理机分配给新到的更高优先级的进程。</p>\n</li>\n</ol>\n<p>多级反馈队列的优势有以下几点:</p>\n<ol>\n<li class=\"lvl-3\">\n<p>终端型作业用户:短作业优先。</p>\n</li>\n<li class=\"lvl-3\">\n<p>短批处理作业用户:周转时间较短。</p>\n</li>\n<li class=\"lvl-3\">\n<p>长批处理作业用户:经过前面几个队列得到部分执行，不会长期得不到处理。</p>\n</li>\n</ol>\n<h3 id=\"ben-zhang-xiao-jie\">本章小结</h3>\n<p>本节开头提出的问题的参考答案如下。</p>\n<h4 id=\"wei-shi-yao-yao-jin-xing-chu-li-ji-diao-du\">为什么要进行处理机调度?</h4>\n<p>​\t若没有处理机调度，同意味着要等到当前运行的进程执行完毕后，下一个进程才能执行，而实际情况中，进程时常需要等待一些外部设备的输入，而外部设备的速度与处理机相比是非常缓慢的，若让处理机总是等待外部设备，则对处理机的资源是极大的浪费。而引进处理机调度后，可在运行进程等待外部设备时，把处理机调度给其他进程，从而提高处理机的利用率。用一句简单的话说，就是为了合理地处理计算机的软/硬件资源。</p>\n<h4 id=\"diao-du-suan-fa-you-na-ji-chong-jie-he-di-1-zhang-xue-xi-de-fen-shi-cao-zuo-xi-tong-he-shi-shi-cao-zuo-xi-tong-si-kao-you-mei-you-na-chong-diao-du-suan-fa-bi-jiao-gua-he-zhe-liang-chong-cao-zuo-xi-tong\">调度算法有哪几种?结合第 1 章学习的分时操作系统和实时操作系统，思考有没有哪种调度算法比较适合这两种操作系统。</h4>\n<p>​\t本节介绍的调度算法有先来先服务调度算法、短作业优先调度算法、优先级调度算法、高响应比优先调度算法、时间片轮转调度算法、多级反馈队列调度算法 6 种。</p>\n<p>​\t先来先服务算法和短作业优先算法无法保证及时地接收和处理问题，因此无法保证规定时时间间隔内响应每个用户的需求，也同样无法达到实时操作系统的实时性,对于更紧急的任务给予更高的优先级，适合实时操作系统。</p>\n<p>​\t高响应比优先调度算法、时间片轮转调度算法、多级反馈队列调度算法都能保证每个任务在一定时间内分配到时间片，并轮流占用 CPU，适合分时操作系统。</p>\n<p>本节主要介绍了处理机调度的概念。操作系统主要管理处理机、内存、文件、设备几种资源，只要对资源的请求大于资源本身的数量，就会涉及调度。例如，在单处理机系统中，处理机只有一个，而请求服务的进程却有多个，所以就有处理机调度的概念出现。而出现调度的概念后，又有了一个问题，即如何调度、应该满足谁、应该让谁等待，这是调度算法所回答的问题;而应该满足谁、应该让谁等待，要遵循一定的准则，即调度的准则。调度这一概念贯穿于操作系统的始终，读者在接下来的学习中，将接触到几种资源的调度问题和相应的调度算法。将它们与处理机调度的内容相对比，将会发现它们有异曲同工之妙。</p>\n<h2 id=\"jin-cheng-tong-bu\">进程同步</h2>\n<p>用 PV 操作解决进程之间的同步互斥问题是这一节的重点，考试已经多次考查过这一内容，读者务必多加练习，掌握好求解问题的方法。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>大题中遇到相关的题目，信号量的类型直接定义为 <code>semaphore</code></p>\n</li>\n</ul>\n<h3 id=\"jin-cheng-tong-bu-de-ji-ben-gai-nian\">进程同步的基本概念</h3>\n<p>​\t在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。下面举一个简单的例于米帮大豕理解赵个概念。例如，让系统计算 1+2x3，假设系统产生两个进程:一个是加法进程，一个是乘法进程。要让计算结果是正确的，一定要让加法进程发生在乘法进程之后，但实际上操作系统具有异步性，若不加以制约，加法进程发生在乘法进程之前是绝对有可能的，因此要制定一定的机制去约束加法进程，让它在乘法进程完成之后才发生，而这种机制就是本节要讨论的内容。</p>\n<h4 id=\"lin-jie-zi-yuan\">临界资源</h4>\n<p>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所用，我们将一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。</p>\n<p>对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。为了保证临界资源的正确使用，可把临界资源的访问过程分成 4 个部分:</p>\n<ol>\n<li class=\"lvl-3\">\n<p><code>进入区</code> 。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，若能进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>临界区</code> 。进程中访问临界资源的那段代码，又称临界段。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>退出区</code> 。将正在访问临界区的标志清除。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>剩余区</code> 。代码中的其余部分。</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">do</span><span class=\"token punctuation\">&#123;</span>\n  entry section<span class=\"token punctuation\">;</span> <span class=\"token comment\">//进入区</span>\n  critical section<span class=\"token punctuation\">;</span> <span class=\"token comment\">//临界区</span>\n  exit section<span class=\"token punctuation\">;</span><span class=\"token comment\">//退出区</span>\n  remainder section<span class=\"token punctuation\">;</span><span class=\"token comment\">//剩余区</span>\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"tong-bu\">同步</h4>\n<p>​\t同步亦称直接制约关系，是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系源于它们之间的相互合作。</p>\n<p>​\t例如，输入进程 A 通过单缓冲向进程 B 提供数据。当该缓冲区空时，进程 B 不能获得所需数据而阻塞，一旦进程 A 将数据送入缓冲区，进程 B 就被唤醒。反之，当缓冲区满时，进程 A 被阻塞，仅当进程 B 取走缓冲数据时，才唤醒进程 A。</p>\n<h4 id=\"hu-chi\">互斥</h4>\n<p>互斥也称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p>\n<p>例如，在仅有一台打印机的系统中，有两个进程 A 和进程 B，若进程 A 需要打印时，系统已将打印机分配给进程 B，则进程 A 必须阻塞。一旦进程 B 将打印机释放，系统便将进程唤醒，并将其由阻塞态变为就绪态。</p>\n<p>为禁止两个进程同时进入临界区，同步机制应遵循以下准则:</p>\n<ol>\n<li class=\"lvl-3\">\n<p><code>空闲让进</code>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>忙则等待 </code>。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>有限等待 </code>。对请求访问的进程，应保证能在有限时间内进入临界区。</p>\n</li>\n<li class=\"lvl-3\">\n<p><code>让权等待 </code>。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</p>\n</li>\n</ol>\n<h3 id=\"mark-shi-xian-lin-jie-qu-hu-chi-de-ji-ben-fang-fa-mark\"><mark>实现临界区互斥的基本方法</mark></h3>\n<h4 id=\"ruan-jian-shi-xian-fang-fa\">软件实现方法</h4>\n<p>在进入区设置并检查一些标志来标明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</p>\n<ol>\n<li class=\"lvl-3\">\n<p>算法一:<strong>单标志法</strong>。该算法设置一个公用整型变量 turn，用于指示被允许进入临界区的进程编号，即若 turn=0，则允许 P<sub>0</sub> 进程进入临界区。该算法可确保每次只允许一个进程进入临界区。但两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法进入临界区（违背“空闲让进”)。这样很容易造成资源利用不充分。若 P<sub>0</sub> 顺利进入临界区并从临界区离开，则此时临界区是空闲的，但 P<sub>1</sub> 并没有进入临界区的打算，turn=1 一直成立， P<sub>0</sub> 就无法再次进入临界区（一直被 while 死循环困住)。</p>\n</li>\n</ol>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210925000015.png\" alt></p>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>算法二:<strong>双标志法先检查</strong>。该算法的基本思想是在每个进程访问临界区资源之前，先查看临界资源是否正被访问，若正被访问，该进程需等待;否则，进程才进入自己的临界区。为此，设置一个数据 flag[i]，如第 i 个元素值为 FALSE，表示 P<sub>i</sub> 进程未进入临界区，值为 TRUE，表示 P 进程进入临界区。</p>\n</li>\n</ol>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210925000115.png\" alt></p>\n<p>优点:不用交替进入，可连续使用;缺点: P<sub>i</sub> 和 P<sub>j</sub> ,可能同时进入临界区。按序列 ①② ③③ ④④ 执行时，会同时进入临界区（违背“忙则等待”)。即在检查对方的 flag 后和切换自己的 flag 前有一段时间，结果都检查通过。这里的问题出在检查和修改操作不能一次进行。</p>\n<ol start=\"3\">\n<li class=\"lvl-3\">\n<p>算法三:<strong>双标志法后检查</strong>。算法二先检测对方的进程状态标志，再置自己的标志，由在检测和放置中可插入另一个进程到达时的检测操作，会造成两个进程在分别检测后同时进入临界区。为此，算法三先将自己的标志设置为 TRUE，再检测对方的状态标志，若对方标志为 TRUE，则进程等待;否则进入临界区。</p>\n</li>\n</ol>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210925000242.png\" alt></p>\n<p>两个进程几乎同时都想进入临界区时，它们分别将自己的标志值 flag 设置为 TRUE，并且同时检测对方的状态（执行 while 语句)，发现对方也要进入临界区时，双方互相谦让，结果谁也进不了临界区，从而导致“饥饿”现象。</p>\n<ol start=\"4\">\n<li class=\"lvl-3\">\n<p>算法四:<strong>Peterson’s Algorithm</strong>。为了防止两个进程为进入临界区而无限期等待，又设置变量 turn，每个进程在先设置自己的标志后再设置 turn 标志。这时，再同时检测另一个进程状态标志和不允许进入标志，以便保证两个进程同时要求进入临界区时，只允许个进程进入临界区。</p>\n</li>\n</ol>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210925000331.png\" alt></p>\n<p>具体如下:考虑进程 P<sub>I</sub> ，一旦设置 flag[ i ] = true，就表示它想要进入临界区，同时 turn =j,此时若进程 P<sub>j</sub> 已在临界区中，符合进程 P<sub>i</sub> 中的 while 循环条件，则 P<sub>i</sub> 不能进入临界区。若 P<sub>j</sub> 不想要进入临界区，即 flag[ j ] = false，循环条件不符合，则 P<sub>i</sub> 可以顺利进入，反之亦然。本算法的基本思想是算法一和算法三的结合。利用 flag 解决临界资源的互斥访问，而利用 turn 解决“饥饿”现象。</p>\n<p>理解 Peterson’s Algorithm 的最好方法就是手动模拟。</p>\n<h4 id=\"ying-jian-shi-xian-fang-fa\">硬件实现方法</h4>\n<p>理解本节介绍的硬件实现，对学习后面的信号量很有帮助。计算机提供了特殊的硬件指令，允许对一个字中的内容进行检测和修正，或对两个字的内容进行交换等。通过硬件支持实现临界段问题的方法称为低级方法，或称元方法。</p>\n<p><strong>中断屏蔽方法</strong></p>\n<p>当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入其临界区进行访问的最简方法是，禁止一切中断发生，或称之为屏蔽中断、关中断。因为 CPU 只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程让临界区代码顺利地执行完，进而保证互斥的正确实现，然后执行开中断。其典型模式为</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210925000605.png\" alt></p>\n<p>这种方法限制了处理机交替执行程序的能力，因此执行的效率会明显降低。对内核来说，在它执行更新变量或列表的几条指令期间，关中断是很方便的，但将关中断的权力交给用户则很不明智，若一个进程关中断后不再开中断，则系统可能会因此终止。</p>\n<p><strong>硬件指令方法</strong></p>\n<p>TestAndSet 指令:这条指令是原子操作，即执行该代码时不允许被中断。其功能是读出指定标志后把该标志设置为真。指令的功能描述如下:</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210925000736.png\" alt></p>\n<p>可以为每个临界资源设置一个共享布尔变量 lock，表示资源的两种状态: true 表示正被占用，初值为 false。在进程访问临界资源之前，利用 TestAndSet 检查和修改标志 lock;若有进程在临界区，则重复检查，直到进程退出。利用该指令实现进程互斥的算法描述如下:</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210925000758.png\" alt=\"找不到图片(Image not found)\"></p>\n<p>Swap 指令:该指令的功能是交换两个字（字节）的内容。其功能描述如下:</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210925000817.png\" alt></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意:以上对 TestAndSet 和 Swap 指令的描述仅是功能实现，而并非软件实现的定义。事实上，它们是由硬件逻辑直接实现的，不会被中断。</p></blockquote>\n<p>应为每个临界资源设置一个共享布尔变量 lock，初值为 false;在每个进程中再设置一个局部布尔变量 key，用于与 lock 交换信息。在进入临界区前，先利用 Swap 指令交换 lock 与 key 的内容，然后检查 key 的状态;有进程在临界区时，重复交换和检查过程，直到进程退出。利用 Swap 指令实现进程互斥的算法描述如下:</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210925001048.png\" alt></p>\n<p>硬件方法的优点:适用于任意数目的进程，而不管是单处理机还是多处理机;简单、容易验证其正确性。可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。</p>\n<p>硬件方法的缺点:进程等待进入临界区时要耗费处理机时间，不能实现让权等待。从等待进程中随机选择一个进入临界区，有的进程可能一直选不上，从而导致“饥饿”现象。</p>\n<p>无论是软件实现方法还是硬件实现方法，读者只需理解它的执行过程即可，关键是软件实现方法。实际练习和考试中很少让读者写出某种软件和硬件实现方法，因此读者并不需要默写或记忆。以上的代码实现与我们平时在编译器上写的代码意义不同，以上的代码实现是为了表述进程实现同步和互斥的过程，并不是说计算机内部实现同步互斥的就是这些代码。</p>\n<h3 id=\"mark-xin-hao-liang-mark\"><mark>信号量</mark></h3>\n<p>​\t信号量机制是一种功能较强的机制，可用来解决互斥与同步问题，它只能被两个标准的 原语原语 wait(S)和 signal(S)访问，也可记为“P 操作”和“V 操作”。</p>\n<p>​\t原语是指完成某种功能且不被分割、不被中断执行的操作序列，通常可由硬件来实现。例如,前述的 Test-and-Set 和 Swap 指令就是由硬件实现的原子操作。原语功能的不被中断执行特性在单处理机上可由软件通过屏蔽中断方法实现。</p>\n<p>​\t原语之所以不能被中断执行，是因为原语对变量的操作过程若被打断，可能会去运行另一个对同一变量的操作过程，从而出现临界段问题。若能够找到一种解决临界段问题的元方法，就可以实现对共享变量操作的原子性。</p>\n<h4 id=\"zheng-xing-xin-hao-liang\">整型信号量</h4>\n<p>整型信号量被定义为一个用于表示资源数目的整型量 S，wait 和 signal 操作可描述为</p>\n<p><img src=\"/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80.htm/20210925001244.png\" alt></p>\n<p>wait 操作中，只要信号量 S≤0，就会不断地测试。因此，该机制并未遵循“让权等待”的准则，而是使进程处于“忙等”的状态。</p>\n<h4 id=\"ji-lu-xing-xin-hao-liang\">记录型信号量</h4>\n<p>记录型信号量是不存在“忙等”现象的进程同步机制。除需要一个用于代表资源数目的整型变量 value 外，再增加一个进程链表 L，用于链接所有等待该资源的进程。记录型信号量得名于采用了记录型的数据结构。记录型信号量可描述为</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925001447.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925001447.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>相应的 wait(S)和 signal(S)的操作如下:</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925001545.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925001545.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>wait 操作，S.value–表示进程请求一个该类资源，当 S.value &lt;0 时，表示该类资源已分配完毕，因此进程应调用 block 原语，进行自我阻塞，放弃处理机，并插入该类资源的等待队列 S.L，可见该机制遵循了“让权等待”的准则。</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925095037.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925095037.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>signal 操作,表示进程释放一个资源,使系统中可供分配的该类资源数增 1,因此有 S.value ++。若加 1 后仍是 S.value≤0，则表示在 S.L 中仍有等待该资源的进程被阻塞，因此还应调用 wakeup 原语，将 S.L 中的第一个等待进程唤醒。</p>\n<h4 id=\"li-yong-xin-hao-liang-shi-xian-tong-bu\">利用信号量实现同步</h4>\n<p>信号量机制能用于解决进程间的各种同步问题。设 S 为实现进程 �1 , �2 同步的公共信号量，初值为 0。进程 �2 中的语句 y 要使用进程 �1 中语句 x 的运行结果，所以只有当语句 x 执行完成之后语句 y 才可以执行。其实现进程同步的算法如下:</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925095158.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925095158.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>若 �2 先执行到 P(S)时，S 为 0，执行 Р 操作会把进程 �2 阻塞，并放入阻塞队列;当进程 �1 中的 x 执行完后，执行 V 操作，把 �2 从阻塞队列中放回就绪队列，当 �2 得到处理机时，就得以继续执行。</p>\n<h4 id=\"li-yong-xin-hao-liang-shi-xian-jin-cheng-hu-chi\">利用信号量实现进程互斥</h4>\n<p>信号量机制也能很方便地解决进程互斥问题。设 S 为实现进程 �1 , �2 互斥的信号量，由于每次只允许一个进程进入临界区﹐所以 S 的初值应为 1(即可用资源数为 1)。只需把临界区置于 P(S)和 V(S)之间，即可实现两个进程对临界资源的互斥访问。其算法如下:</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925095407.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925095407.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>当没有进程在临界区时，任意一个进程要进入临界区，就要执行 Р 操作，把 S 的值减为 0，然后进入临界区;当有进程存在于临界区时，S 的值为 0，再有进程要进入临界区，执行 Р 操作时将会被阻塞，直至在临界区中的进程退出，这样便实现了临界区的互斥。</p>\n<p>互斥是不同进程对同一信号量进行 P,V 操作实现的，一个进程成功对信号量执行了 Р 操作后进入临界区，并在退出临界区后，由该进程本身对该信号量执行 V 操作，表示当前没有进程进入临界区，可以让其他进程进入。</p>\n<p>下面简单总结一下 PV 操作在同步互斥中的应用:在同步问题中，若某个行为要用到某种资源，则在这个行为前面 Р 这种资源一下;若某个行为会提供某种资源，则在这个行为后面 V 这种资源一下。在互斥问题中，P, V 操作要紧夹使用互斥资源的那个行为，中间不能有其他冗余代码。</p>\n<h4 id=\"li-yong-xin-hao-liang-shi-xian-qian-qu-guan-xi\">利用信号量实现前驱关系</h4>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925100154.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925100154.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>信号量也可用来描述程序之间或语句之间的前驱关系。图 2.8 给出了一个前驱图，其中 �1 , �2 , �3 ,… , �6 是最简单的程序段(只有一条语句)。为使各程序段能正确执行，应设置若干初始值为“0”的信号量。例如，为保证 �1 → �2 , �1 → �3 的前驱关系，应分别设置信号量 al, a2。同样，为保证 �2 → �4 , �2 → �5 , �5 → �6 , �4 → �6 , �5 → �6 ，应设置信号量 b1, b2,c, d,e。</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925100516.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925100516.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<h4 id=\"fen-xi-jin-cheng-tong-bu-he-hu-chi-wen-ti-de-fang-fa-bu-zou\">分析进程同步和互斥问题的方法步骤</h4>\n<p>1）关系分析。找出问题中的进程数，并分析它们之间的同步和互斥关系。同步、互斥、前驱关系直接按照上面例子中的经典范式改写。</p>\n<p>2）整理思路。找出解决问题的关键点，并根据做过的题目找出求解的思路。根据进程的操作流程确定 Р 操作、V 操作的大致顺序。</p>\n<p>3）设置信号量。根据上面的两步，设置需要的信号量，确定初值，完善整理。</p>\n<p>这是一个比较直观的同步问题，以 �2 为例，它是 �1 的后继，所以要用到 �1 的资源，在前面的简单总结中我们说过，在同步问题中，要用到某种资源，就要在行为（题中统一抽象成 L)前面 Р 这种资源一下。 �2 是 �4 ， �5 的前驱，给 �4 ， �5 ,提供资源，所以要在 L 行为后面 V 由 �4 和 �5 代表的资源一下。</p>\n<h3 id=\"guan-cheng\">管程</h3>\n<p>在信号量机制中，每个要访问临界资源的进程都必须自备同步的 PV 操作，大量分散的同步操作给系统管理带来了麻烦，且容易因同步操作不当而导致系统死锁。于是，便产生了一种新的进程同步工具-管程。管程的特性保证了进程互斥，无须程序员自己实现互斥，从而降低了死锁发生的可能性。同时管程提供了条件变量，可以让程序员灵活地实现进程同步。</p>\n<h4 id=\"guan-cheng-de-ding-yi\">管程的定义</h4>\n<p>系统中的各种硬件资源和软件资源，均可用数据结构抽象地描述其资源特性，即用少量信息和对资源所执行的操作来表征该资源，而忽略它们的内部结构和实现细节。</p>\n<p>利用共享数据结构抽象地表示系统中的共享资源，而把对该数据结构实施的操作定义为一组过程。进程对共享资源的申请、释放等操作，都通过这组过程来实现，这组过程还可以根据资源情况，或接受或阻塞进程的访问，确保每次仅有一个进程使用共享资源，这样就可以统一管理对共享资源的所有访问，实现进程互斥。这个代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，称为管程( monitor )。管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程中的数据。</p>\n<p>由上述定义可知，管程由 4 部分组成:</p>\n<p>① 管程的名称;<br>\n②② 局部于管程内部的共享结构数据说明;</p>\n<p>③③ 对该数据结构进行操作的一组过程(或函数);</p>\n<p>④④ 对局部于管程内部的共享数据设置初始值的语句。</p>\n<p>管程的定义描述举例如下:</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925101003.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925101003.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>熟悉面向对象程序设计的读者看到管程的组成后，会立即联想到管程很像一个类(class)。</p>\n<p>1）管程把对共享资源的操作封装起来，管程内的共享数据结构只能被管程内的过程所访问。一个进程只有通过调用管程内的过程才能进入管程访问共享资源。对于上例，外部进程只能通过调用 take_away()过程来申请一个资源;归还资源也一样。</p>\n<p>2）每次仅允许一个进程进入管程，从而实现进程互斥。若多个进程同时调用 take_away(),give_back()，则只有某个进程运行完它调用的过程后，下个进程才能开始运行它调用的过程。也就是说，各个进程只能串行执行管程内的过程，这一特性保证了进程“互斥”访问共享数据结构 S。</p>\n<h4 id=\"tiao-jian-bian-liang\">条件变量</h4>\n<p>当一个进程进入管程后被阻塞，直到阻塞的原因解除时，在此期间，如果该进程不释放管程，那么其他进程无法进入管程。为此，将阻塞原因定义为条件变量 condition。通常，一个进程被阻塞的原因可以有多个，因此在管程中设置了多个条件变量。每个条件变量保存了一个等待队列，用于记录因该条件变量而阻塞的所有进程，对条件变量只能进行两种操作，即 wait 和 signal。</p>\n<p>x.wait:当 x 对应的条件不满足时，正在调用管程的进程调用 x.wait 将自己插入 x 条件的等待队列，并释放管程。此时其他进程可以使用该管程。</p>\n<p>x.signal: x 对应的条件发生了变化，则调用 x.signal，唤醒一个因 x 条件而阻塞的进程。下面给出条件变量的定义和使用:</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925101118.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925101118.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>条件变量和信号量的比较:</p>\n<p>相似点:条件变量的 wait/signal 操作类似于信号量的 P/V 操作，可以实现进程的阻塞/唤醒。</p>\n<p>不同点:条件变量是“没有值”的，仅实现了“排队等待”功能;而信号量是“有值”的，信号量的值反映了剩余资源数，而在管程中，剩余资源数用共享数据结构记录。</p>\n<h3 id=\"jing-dian-tong-bu-wen-ti\">经典同步问题</h3>\n<h4 id=\"sheng-chan-zhe-xiao-fei-zhe-wen-ti\">生产者-消费者问题</h4>\n<p><strong>问题描述</strong>:一组生产者进程和一组消费者进程共享一个初始为空、大小为 n 的缓冲区，只有缓冲区没满时，生产者才能把消息放入缓冲区，否则必须等待;只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者从中取出消息。</p>\n<p><strong>问题分析</strong>:</p>\n<p>1）关系分析。生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是个相互协作的关系，只有生产者生产之后，消费者才能消费，它们也是同步关系。</p>\n<p>2）整理思路。这里比较简单，只有生产者和消费者两个进程，正好是这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步 PV 操作的位置。</p>\n<p>3）信号量设置。信号量 mutex 作为互斥信号量，用于控制互斥访问缓冲池，互斥信号量初值为 1;信号量 full 用于记录当前缓冲池中的“满”缓冲区数，初值为 0。信号量 empty 用于记录当前缓冲池中的“空”缓冲区数，初值为 � 。</p>\n<p>我们对同步互斥问题的介绍是一个循序渐进的过程。上面介绍了一个同步问题的例子和一个互斥问题的例子，下面来看生产者-消费者问题的例子是什么样的。</p>\n<p>生产者-消费者进程的描述如下:</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925101330.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925101330.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>该类问题要注意对缓冲区大小为 n 的处理，当缓冲区中有空时，便可对 empty 变量执行 Р 操作，一旦取走一个产品便要执行 V 操作以释放空闲区。对 empty 和 full 变量的 Р 操作必须放在对 mutex 的 P 操作之前。若生产者进程先执行 P(mutex)，然后执行 P(empty)，消费者执行 P(mutex),然后执行 P(full)，这样可不可以﹖答案是否定的。设想生产者进程已将缓冲区放满，消费者进程并没有取产品，即 empty =0，当下次仍然是生产者进程运行时，它先执行 P(mutex)封锁信号量,再执行 P(empty)时将被阻塞，希望消费者取出产品后将其唤醒。轮到消费者进程运行时，它先执行 P(mutex)，然而由于生产者进程已经封锁 mutex 信号量，消费者进程也会被阻塞，这样一来生产者、消费者进程都将阻塞，都指望对方唤醒自己，因此陷入了无休止的等待。同理，若消费者进程已将缓冲区取空，即 full = 0，下次若还是消费者先运行，也会出现类似的死锁。不过生产者释放信号量时，mutex, full 先释放哪一个无所谓，消费者先释放 mutex 或 empty 都可以。</p>\n<p>根据对同步互斥问题的简单总结，我们发现，其实生产者-消费者问题只是一个同步互斥问题的综合而已。</p>\n<p>下面再看一个较为复杂的生产者-消费者问题。</p>\n<p><strong>问题描述</strong>:桌子上有一个盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等吃盘子中的橘子，女儿专等吃盘子中的苹果。只有盘子为空时，爸爸或妈妈才可向盘子中放一个水果;仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出。</p>\n<p><strong>问题分析</strong>:</p>\n<p>1）关系分析。这里的关系要稍复杂一些。由每次只能向其中放入一只水果可知，爸爸和妈妈是互斥关系。爸爸和女儿、妈妈和儿子是同步关系，而且这两对进程必须连起来，儿子和女儿之间没有互斥和同步关系，因为他们是选择条件执行，不可能并发，如图 2.9 所示。</p>\n<p>2）整理思路。这里有 4 个进程，实际上可抽象为两个生产者和两个消费者被连接到大小为 1 的缓冲区上。</p>\n<p>3）信号量设置。首先将信号量 plate 设置互斥信号量，表示是否允许向盘子放入水果，初值为 1 表示允许放入，且只允许放入一个。信号量 apple 表示盘子中是否有苹果，初值为 0 表示盘子为空，不许取，apple = 1 表示可以取。信号量 orange 表示盘子中是否有橘子，初值为 0 表示盘子为空，不许取，orange =1 表示可以取。</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图2.9进程之间的关系</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925101528.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925101528.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>解决该问题的代码如下:</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925101624.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925101624.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>进程间的关系如图 2.9 所示。dad()和 daughter()、mom()和 son()必须连续执行，正因为如此，也只能在女儿拿走苹果后或儿子拿走橘子后才能释放盘子，即 V(plate)操作。</p>\n<h4 id=\"du-zhe-xie-zhe-wen-ti\">读者-写者问题</h4>\n<p><strong>问题描述</strong>:有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求:① 允许多个读者可以同时对文件执行读操作;② 只允许一个写者往文件中写信息;③ 任一写者在完成写操作之前不允许其他读者或写者工作;④ 写者执行写操作前，应让已有的读者和写者全部退出。</p>\n<p><strong>问题分析</strong>:</p>\n<p>1）关系分析。由题目分析读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。</p>\n<p>2）整理思路。两个进程，即读者和写者。写者是比较简单的，它和任何进程互斥，用互斥信号量的 Р 操作、V 操作即可解决。读者的问题比较复杂，它必须在实现与写者互斥的同时，实现与其他读者的同步，因此简单的一对 Р 操作、V 操作是无法解决问题的。这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者时，写者是无法写文件的，此时读者会一直占用文件，当没有读者时，写者才可以写文件。同时，这里不同读者对计数器的访问也应该是互斥的。</p>\n<p>3）信号量设置。首先设置信号量 count 为计数器，用于记录当前读者的数量，初值为 0;设置 mutex 为互斥信号量，用于保护更新 count 变量时的互斥;设置互斥信号量 rw，用于保证读者和写者的互斥访问。</p>\n<p>代码如下:</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925101839.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925101839.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>在上面的算法中，读进程是优先的，即当存在读进程时，写操作将被延迟，且只要有一个读进程活跃，随后而来的读进程都将被允许访问文件。这样的方式会导致写进程可能长时间等待，且存在写进程“饿死”的情况。</p>\n<p>若希望写进程优先，即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等到已在共享文件的读进程执行完毕，立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行。为此，增加一个信号量并在上面程序的 writer()和 reader()函数中各增加一对 PV 操作，就可以得到写进程优先的解决程序。</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925101951.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925101951.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>这里的写进程优先是相对而言的，有些书上把这个算法称为读写公平法，即读写进程具有-一样的优先级。当一个写进程访问文件时，若先有一些读进程要求访问文件，后有另一个写进程要求访问文件，则当前访问文件的进程结束对文件的写操作时，会是一个读进程而不是一个写进程占用文件(在信号量 w 的阻塞队列上，因为读进程先来，因此排在阻塞队列队首，而 V 操作唤醒进程时唤醒的是队首进程)，所以说这里的写优先是相对的，想要了解如何做到真正写者优先，</p>\n<p>可参考其他相关资料。</p>\n<p>读者-写者问题有一个关键的特征，即有一个互斥访问的计数器 count，因此遇到一个不太好解决的同步互斥问题时，要想一想用互斥访问的计数器 count 能否解决问题。</p>\n<h4 id=\"zhe-xue-jia-jin-can-wen-ti\">哲学家进餐问题</h4>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925102039.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925102039.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p><strong>问题描述</strong>:一张圆桌边上坐着 5 名哲学家，每两名哲学家之间的桌上摆一根筷子，两根筷子中间是一碗米饭，如图 2.10 所示。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子(一根一根地拿起)。若筷子已在他人手上，则需要等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，进餐完毕后，放下筷子继续思考。</p>\n<p><strong>问题分析</strong>:</p>\n<p>1）关系分析。5 名哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>\n<p>2）整理思路。显然，这里有 5 个进程。本题的关键是如何让一名哲学家拿到左右两根筷子而不造成死锁或饥饿现象。解决方法有两个:一是让他们同时拿两根筷子;二是对每名哲学家的动作制定规则，避免饥饿或死锁现象的发生。</p>\n<p>3）信号量设置。定义互斥信号量数组 chopstick[ 5 ]={1,1,1,1,1}，用于对 5 个筷子的互斥访问。哲学家按顺序编号为 0 ～ 4，哲学家 i 左边筷子的编号为 i，哲学家右边筷子的编号为(i +1)%5。</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925102239.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925102239.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>该算法存在以下问题:当 5 名哲学家都想要进餐并分别拿起左边的筷子时（都恰好执行完 wait(chopstick[ i]);）筷子已被拿光,等到他们再想拿右边的筷子时（执行 wait(chopstick[(i + 1)%5]);）就全被阻塞，因此出现了死锁。为防止死锁发生，可对哲学家进程施加一些限制条件，比如至多允许 4 名哲学家同时进餐;仅当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子;对哲学家顺序编号，要求奇数号哲学家先拿左边的筷子，然后拿右边的筷子，而偶数号哲学家刚好相反。</p>\n<p>制定的正确规则如下:假设采用第二种方法，当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子。</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925102409.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925102409.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>此外，还可采用 AND 型信号量机制来解决哲学家进餐问题，有兴趣的读者可以查阅相关资料，自行思考。</p>\n<p>熟悉 ACM 或有过相关训练的读者都应知道贪心算法，哲学家进餐问题的思想其实与贪心算法的思想截然相反，贪心算法强调争取眼前认为最好的，而不考虑后续会有什么后果。若哲学家进餐问题用贪心算法来解决，即只要眼前有筷子能拿起就拿起的话，就会出现死锁。然而,若不仅考虑眼前的一步，而且考虑下一步，即不因为有筷子能拿起就拿起，而考虑能不能一次拿起两根筷子才做决定的话，就会避免死锁问题，这就是哲学家进餐问题的思维精髓。</p>\n<p>大部分练习题和真题用消费者-生产者模型或读者-写者问题就能解决，但对于哲学家进餐问题和吸烟者问题仍然要熟悉。考研复习的关键在于反复多次和全面，“偷工减料”是要吃亏的。</p>\n<h4 id=\"xi-yan-zhe-wen-ti\">吸烟者问题</h4>\n<p><strong>问题描述</strong>:假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但要卷起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中,第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者一个信号告诉已完成，此时供应者就会将另外两种材料放到桌上，如此重复（让三个抽烟者轮流地抽烟）。</p>\n<p><strong>问题分析</strong>:<br>\n1）关系分析。供应者与三个抽烟者分别是同步关系。由于供应者无法同时满足两个或以上的抽烟者，三个抽烟者对抽烟这个动作互斥（或由三个抽烟者轮流抽烟得知)。</p>\n<p>2）整理思路。显然这里有 4 个进程。供应者作为生产者向三个抽烟者提供材料。</p>\n<p>3）信号量设置。信号量 offer1, offer2, offer3 分别表示烟草和纸组合的资源、烟草和胶水组合的资源、纸和胶水组合的资源。信号量 finish 用于互斥进行抽烟动作。</p>\n<p>代码如下:</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925102637.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925102637.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<h3 id=\"ben-jie-xiao-jie-1\">本节小结</h3>\n<p>本节开头提出的问题的参考答案如下。</p>\n<h4 id=\"wei-shi-yao-yao-yin-ru-jin-cheng-tong-bu-de-gai-nian\">为什么要引入进程同步的概念?</h4>\n<p>在多道程序共同执行的条件下，进程与进程是并发执行的，不同进程之间存在不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。</p>\n<h4 id=\"bu-tong-de-jin-cheng-zhi-jian-hui-cun-zai-shi-yao-guan-xi\">不同的进程之间会存在什么关系?</h4>\n<p>进程之间存在同步与互斥的制约关系。</p>\n<p>同步是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。</p>\n<p>互斥是指当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p>\n<h4 id=\"dang-dan-chun-yong-ben-jie-jie-shao-de-fang-fa-jie-jue-zhe-xie-wen-ti-shi-hui-yu-dao-shi-yao-xin-de-wen-ti-ma\">当单纯用本节介绍的方法解决这些问题时会遇到什么新的问题吗?</h4>\n<p>当两个或两个以上的进程在执行过程中，因占有一些资源而又需要对方的资源时，会因为争夺资源而造成一种互相等待的现象，若无外力作用，它们都将无法推进下去。这种现象称为死锁，具体介绍和解决方案请参考下一节。</p>\n<h2 id=\"si-suo\">死锁</h2>\n<p>在学习本节时，请读者思考以下问题:</p>\n<p>1）为什么会产生死锁?产生死锁有什么条件?</p>\n<p>2）有什么办法可以解决死锁问题?</p>\n<p>学完本节，读者应了解死锁的由来、产生条件及基本解决方法，区分死锁的避免和死锁的预防。</p>\n<h3 id=\"si-suo-de-gai-nian\">死锁的概念</h3>\n<h4 id=\"si-suo-de-ding-yi\">死锁的定义</h4>\n<p>在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处理能力。然而，多个进程的并发执行也带来了新的问题–死锁。所谓死锁，是指多个进程因竞争资源而造成的一种僵局（互相等待)，若无外力作用，这些进程都将无法向前推进。</p>\n<p>下面通过一些实例来说明死锁现象。</p>\n<p>先看生活中的一个实例。在一条河上有一座桥，桥面很窄，只能容纳一辆汽车通行。若有两辆汽车分别从桥的左右两端驶上该桥，则会出现下述冲突情况:此时，左边的汽车占有桥面左边的一段，要想过桥还需等待右边的汽车让出桥面右边的一段;右边的汽车占有桥面右边的一段，要想过桥还需等待左边的汽车让出桥面左边的一段。此时，若左右两边的汽车都只能向前行驶，则两辆汽车都无法过桥。</p>\n<p>在计算机系统中也存在类似的情况。例如，某计算机系统中只有一台打印机和一台输入设备，进程 �1 正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程 �2 所占用，而 �2 在未释放打印机之前，又提出请求使用正被 �1 占用的输入设备。这样，两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。</p>\n<h4 id=\"si-suo-chan-sheng-de-yuan-yin\">死锁产生的原因</h4>\n<h5 id=\"xi-tong-zi-yuan-de-jing-zheng\">系统资源的竞争</h5>\n<p>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。</p>\n<h5 id=\"jin-cheng-tui-jin-shun-xu-fei-fa\">进程推进顺序非法</h5>\n<p>进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发进程 �1 , �2 分别保持了资源 �1 , �2 ，而进程 �1 申请资源 �2 、进程 �2 申请资源 �1 时，两者都会因为所需资源被占用而阻塞。</p>\n<p>信号量使用不当也会造成死锁。进程间彼此相互等待对方发来的消息，也会使得这些进程间无法继续向前推进。例如，进程 A 等待进程 B 发的消息，进程 B 又在等待进程 A 发的消息，可以看出进程 A 和 B 不是因为竞争同一资源，而是在等待对方的资源导致死锁。</p>\n<h5 id=\"si-suo-chan-sheng-de-bi-yao-tiao-jian\">死锁产生的必要条件</h5>\n<p>产生死锁必须同时满足以下 4 个条件，只要其中任意一个条件不成立，死锁就不会发生。</p>\n<p><strong>互斥条件</strong>:进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p>\n<p><strong>不剥夺条件</strong>:进程所获得的资源在未使用完之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</p>\n<p><strong>请求并保持条件</strong>:进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p>\n<p><strong>循环等待条件</strong>:存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待态的进程集合{ �1 , �2 ,…, �� }，其中 �� 等待的资源被 ��+1 ( � =0,1,… , � -1）占有， �� 等待的资源被 �0 占有，如图 2.11 所示。</p>\n<p>直观上看，循环等待条件似乎和死锁的定义一样，其实不然。按死锁定义构成等待环所要求的条件更严，它要求 �� 等待的资源必须由 ��+1 来满足，而循环等待条件则无此限制。例如，系统中有两台输出设备， �0 占有一台， �� 占有另一台，且 K 不属于集合{0,1，…, n}。 �� 等待一台输出设备，它可从 �0 获得，也可能从 �� 获得。因此，虽然 �� , �0 和其他一些进程形成了循环等待圈,但 �� 不在圈内，若 �� 释放了输出设备，则可打破循环等待，如图 2.12 所示。因此循环等待只是死锁的必要条件。</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图2.11和图2.12</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925224155.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925224155.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>资源分配图含圈而系统又不一定有死锁的原因是，同类资源数大于 1。但若系统中每类资源都只有一个资源，则资源分配图含圈就变成了系统出现死锁的充分必要条件。</p>\n<p>要注意区分不剥夺条件与请求并保持条件。下面用一个简单的例子进行说明:若你手上拿着一个苹果（即便你不打算吃)，别人不能把你手上的苹果拿走，则这就是不剥夺条件;若你左手拿着一个苹果，允许你右手再去拿一个苹果，则这就是请求并保持条件。</p>\n<h3 id=\"si-suo-de-chu-li-ce-lue\">死锁的处理策略</h3>\n<p>为使系统不发生死锁，必须设法破坏产生死锁的 4 个必要条件之一，或允许死锁产生，但当死锁发生时能检测出死锁，并有能力实现恢复。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>预防和避免的区别：<a href=\"https://blog.csdn.net/Aloneingchild/article/details/111339390\">参考文献</a></p>\n</li>\n</ul>\n<h4 id=\"si-suo-yu-fang\">死锁预防</h4>\n<p>设置某些限制条件，破坏产生死锁的 4 个必要条件中的一个或几个，以防止发生死锁。</p>\n<h4 id=\"bi-mian-si-suo\">避免死锁</h4>\n<p>在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。</p>\n<h4 id=\"si-suo-de-jian-ce-ji-jie-chu\">死锁的检测及解除</h4>\n<p>无须采取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后采取某种措施解除死锁。</p>\n<p>预防死锁和避免死锁都属于事先预防策略，预防死锁的限制条件比较严格，实现起来较为简单，但往往导致系统的效率低，资源利用率低;避免死锁的限制条件相对宽松，资源分配后需要通过算法来判断是否进入不安全状态，实现起来较为复杂。</p>\n<p>死锁的几种处理策略的比较见表 2.4。</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">表2.4 死锁处理策略的比较</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925225720.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925225720.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<h3 id=\"si-suo-yu-fang-1\">死锁预防</h3>\n<p>防止死锁的发生只需破坏死锁产生的 4 个必要条件之一即可。</p>\n<h4 id=\"po-pi-hu-chi-tiao-jian\">破坏互斥条件</h4>\n<p>若允许系统资源都能共享使用，则系统不会进入死锁状态。但有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有的场合应该保护这种互斥性。</p>\n<h4 id=\"po-pi-bu-bo-duo-tiao-jian\">破坏不剥夺条件</h4>\n<p>当一个已保持了某些不可剥夺资源的进程请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺，或从而破坏了不剥夺条件。</p>\n<p>该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销,降低系统吞吐量。这种方法常用于状态易于保存和恢复的资源,如 CPU 的寄存器及内存资源，一般不能用于打印机之类的资源。</p>\n<h4 id=\"po-pi-qing-qiu-bing-bao-chi-tiao-jian\">破坏请求并保持条件</h4>\n<p>采用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行，这些资源就一直归它所有，不再提出其他资源请求，这样就可以保证系统不会发生死锁。</p>\n<p>这种方式实现简单，但缺点也显而易见，系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。</p>\n<h4 id=\"po-pi-xun-huan-deng-dai-tiao-jian\">破坏循环等待条件</h4>\n<p>为了破坏循环等待条件，可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源 �� ，则该进程在以后的资源申请中就只能申请编号大于 �� 的资源。</p>\n<p>这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加;尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费;此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦。</p>\n<h3 id=\"si-suo-bi-mian\">死锁避免</h3>\n<p>避免死锁同样属于事先预防策略，但并不是事先采取某种限制措施破坏死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。这种方法所施加的限制条件较弱，可以获得较好的系统性能。</p>\n<h4 id=\"xi-tong-an-quan-zhuang-tai\">系统安全状态</h4>\n<p>避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配的安全性。若此次分配不会导致系统进入不安全状态，则允许分配;否则让进程等待。</p>\n<p>所谓安全状态，是指系统能按某种进程推进顺序( �1 , �2 ,…, �� )为每个进程 �� 分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。此时称 �� ， �2 .…， �� 为安全序列。若系统无法找到一个安全序列，则称系统处于不安全状态。</p>\n<p>假设系统中有三个进程 �1 , �2 ,和 �3 ，共有 12 台磁带机。进程 �1 共需要 10 台磁带机， �2 和 �3 分别需要 4 台和 9 台。假设在 �0 时刻，进程 �1 ， �2 和 �3 已分别获得 5 台、2 台和 2 台，尚有 3 台未分配，见表 2.5。</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">表2.5 资源分配</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925232929.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925232929.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>在 �0 时刻是安全的，因为存在一个安全序列 �2 , �1 , �3 ，只要系统按此进程序列分配资源，那么每个进程都能顺利完成。也就是说，当前可用磁带机为 3 台，先把 3 台磁带机分配给 РР2 以满足其最大需求， �2 结束并归还资源后，系统有 5 台磁带机可用;接下来给 �1 分配 5 台磁带机以满足其最大需求， �1 结束并归还资源后，剩余 10 台磁带机可用;最后分配 7 台磁带机给 �3 ，这样 �3 也能顺利完成。</p>\n<p>若在 �0 时刻后，系统分配 1 台磁带机给 �3 ，系统剩余可用资源数为 2，此时系统进入不安全状态，因为此时已无法再找到一个安全序列。当系统进入不安全状态后，便可能导致死锁。例如，把剩下的 2 台磁带机分配给 �2 这样， �2 完成后只能释放 4 台磁带机，既不能满足 �1 又不能满足 �3 ，致使它们都无法推进到完成，彼此都在等待对方释放资源，陷入僵局，即导致死锁。</p>\n<p>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态;反之，只要系统处于安全状态，系统便可避免进入死锁状态。</p>\n<h4 id=\"yin-xing-jia-suan-fa\">银行家算法</h4>\n<p>银行家算法是最著名的死锁避免算法，其思想是:把操作系统视为银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源。进程运行之前先声明对各种资源的最大需求量，当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过该进程声明的最大需求量。若超过则拒绝分配资源，若未超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。</p>\n<h5 id=\"shu-ju-jie-gou-miao-shu\">数据结构描述</h5>\n<p>可利用资源向量 Available:含有 m 个元素的数组，其中每个元素代表一类可用的资源数目。Available[ j ]=K 表示系统中现有 �� 类资源 K 个。</p>\n<p>最大需求矩阵 Max: n×m 矩阵，定义系统中 � 个进程中的每个进程对 � 类资源的最大需求。简单来说，一行代表一个进程，一列代表一类资源。Max[ i,j ]=K 表示进程 i 需要 �� 类资源的最大数目为 K。</p>\n<p>分配矩阵 Allocation: �×� 矩阵，定义系统中每类资源当前已分配给每个进程的资源数。Allocation[ i,j ]=K 表示进程 � 当前已分得 �� 类资源的数目为 K。初学者容易混淆 Available 向量和 Allocation 矩阵，在此特别提醒。</p>\n<p>需求矩阵 Need: �×� 矩阵，表示每个进程接下来最多还需要多少资源。Need[ i,j ]=K 表示进程 i 还需要 �� 类资源的数目为 K。</p>\n<p>上述三个矩阵间存在下述关系:</p>\n<p>Need= Max- Allocation</p>\n<p>一般情况下，在银行家算法的题目中，Max 矩阵和 Allocation 矩阵是已知条件，而求出 Need 矩阵是解题的第一步。</p>\n<h5 id=\"yin-xing-jia-suan-fa-miao-shu\">银行家算法描述</h5>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">银行家算法描述</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925233723.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925233723.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<h4 id=\"an-quan-xing-suan-fa-ju-li\">安全性算法举例</h4>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925235124.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925235124.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<h4 id=\"yin-xing-jia-suan-fa-ju-li\">银行家算法举例</h4>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925235226.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925235226.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<h3 id=\"si-suo-jian-ce-he-jie-chu\">死锁检测和解除</h3>\n<p>前面介绍的死锁预防和避免算法，都是在为进程分配资源时施加限制条件或进行检测，若系统为进程分配资源时不采取任何措施，则应该提供死锁检测和解除的手段。</p>\n<h4 id=\"zi-yuan-fen-pei-tu\">资源分配图</h4>\n<p>系统死锁可利用资源分配图来描述。如图 2.13 所示，用圆圈代表一个进程，用框代表一类资源。由于一种类型的资源可能有多个，因此用框中的一个圆代表一类资源中的一个资源。从进程到资源的有向边称为 请求边请求边 ，表示该进程申请一个单位的该类资源;从资源到进程的边称为 分配边分配边 ，表示该类资源已有一个资源分配给了该进程。</p>\n<p>在图 2.13 所示的资源分配图中，进程 �1 已经分得了两个 �1 资源，并又请求一个 �2 资源;进程 �2 ,分得了一个 �1 资源和一个 �2 资源，并又请求一个 �1 资源。</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图2.13 资源分配示例</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925235430.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925235430.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<h4 id=\"si-suo-ding-li\">死锁定理</h4>\n<p>简化资源分配图可检测系统状态 S 是否为死锁状态。简化方法如下:</p>\n<p>1）在资源分配图中，找出既不阻塞又不孤点的进程 �� (即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中己有的空闲资源数量，如在图 2.13 中， �1 没有空闲资源， �2 有一个空闲资源。若所有连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源)。消去它所有的请求边和分配边，使之成为孤立的结点。在图 2.14(a)中， �1 是满足这一条件的进程结点，将 P 的所有边消去，便得到图 2.14(b)所示的情况。</p>\n<p>这里要注意一个问题，判断某种资源是否有空间，应用它的资源数量减去它在资源分配图中的出度，例如在图 2.13 中， �1 的资源数为 3，而出度也为 3，所以 �1 没有空闲资源, �2 的资源数为 2，出度为 1，所以 �2 有一个空闲资源。</p>\n<p>2）进程 �� 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在图 2.13 中，进程 �2 就满足这样的条件。根据 1)中的方法进行一系列简化后，若能消去图中所有的边，则称该图是可完全简化的，如图 2.14©所示。</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图2.14 资源分配图的化简</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210925235734.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210925235734.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>S 为死锁的条件是当且仅当 S 状态的资源分配图是不可完全简化的，该条件为 死锁定理死锁定理 。</p>\n<h4 id=\"si-suo-jie-chu\">死锁解除</h4>\n<p>一旦检测出死锁，就应立即采取相应的措施来解除死锁。死锁解除的主要方法有:</p>\n<p>1） 资源剥夺法资源剥夺法 。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源而处于资源匮乏的状态。</p>\n<p>2） 撤销进程法撤销进程法 。强制撤销部分甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</p>\n<p>3） 进程回退法进程回退法 。让一（或多〉个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而非被剥夺。要求系统保持进程的历史信息，设置还原点。</p>\n<h3 id=\"ben-jie-xiao-jie-2\">本节小结</h3>\n<p>本节开头提出的问题的参考答案如下。</p>\n<p>1）为什么会产生死锁?产生死锁有什么条件?</p>\n<p>由于系统中存在一些不可剥夺资源，当两个或两个以上的进程占有自身的资源并请求对方的资源时，会导致每个进程都无法向前推进，这就是死锁。死锁产生的必要条件有 4 个，分别是互斥条件、不剥夺条件、请求并保持条件和循环等待条件。</p>\n<p>互斥条件是指进程要求分配的资源是排他性的，即最多只能同时供一个进程使用。</p>\n<p>不剥夺条件是指进程在使用完资源之前，资源不能被强制夺走。</p>\n<p>请求并保持条件是指进程占有自身本来拥有的资源并要求其他资源。</p>\n<p>循环等待条件是指存在一种进程资源的循环等待链。</p>\n<p>2）有什么办法可以解决死锁问题?</p>\n<p>死锁的处理策略可以分为预防死锁、避免死锁及死锁的检测与解除。</p>\n<p>死锁的预防是指通过设立一些限制条件，破坏死锁的一些必要条件，让死锁无法发生。</p>\n<p>死锁的避免是指在动态分配资源的过程中，用一些算法防止系统进入不安全状态，从而避免死锁。</p>\n<p>死锁的检测和解除是指在死锁产生前不采取任何措施，只检测当前系统有没有发生死锁，若有，则采取一些措施解除死锁。</p>\n<h2 id=\"ben-zhang-yi-nan-dian-1\">本章疑难点</h2>\n<h3 id></h3>\n<h4 id=\"jin-cheng-yu-cheng-xu-de-qu-bie-yu-lian-xi\">进程与程序的区别与联系</h4>\n<p>1）进程是程序及其数据在计算机上的一次运行活动，是一个动态的概念。进程的运行实体是程序，离开程序的进程没有存在的意义。从静态角度看，进程是由程序、数据和进程控制块（PCB）三部分组成的。而程序是一组有序的指令集合，是一种静态的概念。</p>\n<p>2）进程是程序的一次执行过程，它是动态地创建和消亡的，具有一定的生命周期，是暂时存在的;而程序则是一组代码的集合，是永久存在的，可长期保存。</p>\n<p>3）一个进程可以执行一个或几个程序，一个程序也可构成多个进程。进程可创建进程，而程序不可能形成新的程序。</p>\n<p>4）进程与程序的组成不同。进程的组成包括程序、数据和 PCB。</p>\n<h4 id=\"si-suo-yu-ji-e\">死锁与饥饿</h4>\n<p>具有等待队列的信号量的实现可能导致这样的情况:两个或多个进程无限地等待一个事件，而该事件只能由这些等待进程之一来产生。这里的事件是 V 操作的执行（即释放资源)。出现这样的状态时，这些进程称为死锁(Deadlocked)。</p>\n<p>为加以说明，考虑一个由两个进程 �0 和 �1 组成的系统，每个进程都访问两个信号量 S 和 Q,这两个信号量的初值均为 1。</p>\n<details style=\"display: block; color: rgb(85, 85, 85); font-family: Lato, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 15.3px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: justify; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"><summary style=\"display: list-item;\">图片详情</summary><img src=\"https://raw.githubusercontent.com/ednow/cloudimg/main/githubio/20210926000155.png\" alt=\"找不到图片(Image not found)\" onerror=\"this.onerror=null;this.src='https://gitee.com/ednow/cloudimg/raw/main/githubio/20210926000155.png';\" style=\"border-style: none; display: block; margin-left: auto; margin-right: auto; max-width: 900px; width: 800px; height: auto; margin-bottom: 20px;\"></details>\n<p>假设进程 �0 执行 P(S)，接着进程 �1 执行 P(Q)。当进程 �0 执行 P(Q)时，它必须等待，直到进程 �1 执行 V(Q)。类似地，当进程 �1 执行 P(S)时，它必须等待，直到进程 �0 执行 V(S)。由于这两个 V 操作都不能执行，因此进程 �0 和进程 �1 就死锁了。</p>\n<p>一组进程处于死锁状态是指组内的每个进程都在等待一个事件，而该事件只可能由组内的另一个进程产生。这里所关心的主要是事件是资源的获取和释放。</p>\n<p>与死锁相关的另一个问题是无限期阻塞（Indefinite Blocking）或饥饿(Starvation)，即进程在信号量内无穷等待的情况。</p>\n<p>产生饥饿的主要原因是:在一个动态系统中，对于每类系统资源，操作系统需要确定一个分配策略，当多个进程同时申请某类资源时，由分配策略确定资源分配给进程的次序。有时资源分配策略可能是不公平的，即不能保证等待时间上界的存在。在这种情况下，即使系统没有发生死锁，某些进程也可能会长时间等待。当等待时间给进程推进和响应带来明显影响时，称发生了进程“饥饿”，当“饥饿”到一定程度的进程所赋予的任务即使完成也不再具有实际意义时，称该进程被“饿死”。</p>\n<p>例如，当有多个进程需要打印文件时，若系统分配打印机的策略是最短文件优先，则长文件的打印任务将由于短文件的源源不断到来而被无限期推迟，导致最终“饥饿”甚至“饿死”。</p>\n<p>“饥饿”并不表示系统一定会死锁，但至少有一个进程的执行被无限期推迟。“饥饿”与死锁的主要差别如下:</p>\n<p>1）进入“饥饿”状态的进程可以只有一个，而因循环等待条件而进入死锁状态的进程却必须大于等于两个。</p>\n<p>2）处于“饥饿”状态的进程可以是一个就绪进程，如静态优先权调度算法时的低优先权进程，而处于死锁状态的进程则必定是阻塞进程。</p>\n<h4 id=\"yin-xing-jia-suan-fa-de-gong-zuo-yuan-li\">银行家算法的工作原理</h4>\n<p>银行家算法的主要思想是避免系统进入不安全状态。在每次进行资源分配时，它首先检查系统是否有足够的资源满足要求，若有则先进行分配，并对分配后的新状态进行安全性检查。若新状态安全，则正式分配上述资源，否则拒绝分配上述资源。这样，它保证系统始终处于安全状态，从而避免了死锁现象的发生。</p>\n<h4 id=\"jin-cheng-tong-bu-hu-chi-de-qu-bie-he-lian-xi\">进程同步、互斥的区别和联系</h4>\n<p>并发进程的执行会产生相互制约的关系:一种是进程之间竞争使用临界资源，只能让它们逐个使用，这种现象称为互斥，是一种竞争关系;另一种是进程之间协同完成任务，在关键点上等待另一个进程发来的消息，以便协同一致，是一种协作关系。</p>\n<h4 id=\"zuo-ye-he-jin-cheng-de-guan-xi\">作业和进程的关系</h4>\n<p>进程是系统资源的使用者，系统的资源大部分都是以进程为单位分配的。而用户使用计算机是为了实现一串相关的任务，通常把用户要求计算机完成的这一串任务称为作业。</p>\n<h5 id=\"pi-chu-li-xi-tong-zhong-zuo-ye-yu-jin-cheng-de-guan-xi-jin-cheng-zu-zhi\">批处理系统中作业与进程的关系（进程组织)</h5>\n<p>批处理系统可以通过磁记录设备或卡片机向系统提交批作业，由系统的 SPOOLing 输入进程将作业放入磁盘的输入井，作为后备作业。作业调度程序（一般也作为独立的进程运行）每当选择一道后备作业运行时，首先为该作业创建一个进程（称为该作业的根进程)。该进程将执行作业控制语言解释程序，解释该作业的作业说明书。父进程在运行过程中可以动态地创建一个或多个子进程，执行说明书中的语句。例如，对一条编译的语句，该进程可以创建一个子进程执行编译程序对用户源程序进行编译。类似地，子进程也可继续创建子进程去完成指定的功能。因此,一个作业就动态地转换成了一组运行实体—进程族。当父进程遇到作业说明书中的“撤出作业”语句时，将该作业从运行态改变为完成态，将作业及相关结果送入磁盘上的输出井。作业终止进程负责将输出井中的作业利用打印机输出，回收作业所占用的资源，删除作业有关的数据结构,删除作业在磁盘输出井中的信息等。作业终止进程撤除一道作业后，可向作业调度进程请求进行新的作业调度。至此，一道进入系统运行的作业全部结束。</p>\n<h5 id=\"fen-shi-xi-tong-zhong-zuo-ye-yu-jin-cheng-de-guan-xi\">分时系统中作业与进程的关系</h5>\n<p>在分时系统中，作业的提交方法、组织形式均与批处理作业有很大差异。分时系统的用户通过命令语言逐条与系统应合八把武大系体自动时，系统为每个终端设备建立一个进程（称为终端统内部对应一个(以右 T 经程序，命令解释程序从终端设备读入俞令，解藉疯令是一茶后台命进程)，该进程执仃类令 n 可以创建一个子进程去具体执行。若当 HPN 根据需要创建子孙进程。条命令。对于每条终端命令，可以创建一个子进程去具体执行。若当前的终端命令是一条后台命令，则可以和下一条终端命令并行处理。各子进程在运行过程中完全可以根据需要创建子孙进程。终端命令所对应的进程结束后，命令的功能也相应处理完毕。用户本次上机完毕，用户通过一条登出命令即结束上机过程。</p>\n<p>分时系统的作业就是用户的一次上机交互过程，可以认为终端进程的创建是一个交互作业的开始，登出命令运行结束代表用户交互作业的终止。</p>\n<p>命令解释程序流程扮演着批处理系统中作业控制语言解释程序的角色，只不过命令解释程序是从用户终端接收命令。</p>\n<h5 id=\"jiao-hu-di-ti-jiao-pi-zuo-ye\">交互地提交批作业</h5>\n<p>在同时支持交互和批处理的操作系统中，人们可以用交互的方式准备好批作业的有关程序、数据及作业控制说明书。比如，可用交互式系统提供的全屏幕编辑命令编辑好自编的一个天气预报程序，用编译及装配命令将程序变成可执行文件，用调试命令进行程序调试。调试成功后，用户每天都要做如下工作:准备原始天气数据，运行天气预报执行文件处理原始数据，把结果打印出来等。这时，用交互系统提供的全屏幕编辑命令编辑好将要提交的作业控制说明书文件，如 Windows 系统的 bat 文件和 Linux 系统的 sh 文件。然后用一条作业提交命令将作业提交到系统作业队列中。系统有专门的作业调度进程负责从作业队列中选择作业，为被选取的作业创建一个父进程运行命令解释程序，解释执行作业控制说明书文件中的命令。</p>\n","feature":true,"text":"计算机系统概论 操作系统的基本概念 操作系统的概念 ​ 在信息化时代，软件是计算机系统的灵魂，而作为软件核心的操作系统，已与现代计算机系统密不可分、融为一体。计算机系统自下而上可大致分为 4 部分:硬件、操作系统、应用程序和用户(这里的划分与计算机组成原理中的分层不同)。操作系统...","link":"","photos":[],"count_time":{"symbolsCount":"55k","symbolsTime":"50 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ji-suan-ji-xi-tong-gai-lun\"><span class=\"toc-text\">计算机系统概论</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#cao-zuo-xi-tong-de-ji-ben-gai-nian\"><span class=\"toc-text\">操作系统的基本概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#cao-zuo-xi-tong-de-gai-nian\"><span class=\"toc-text\">操作系统的概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#cao-zuo-xi-tong-de-te-zheng\"><span class=\"toc-text\">操作系统的特征</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#bing-fa-concurrence\"><span class=\"toc-text\">并发(Concurrence)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#gong-xiang-sharing\"><span class=\"toc-text\">共享(Sharing)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#xu-ni-virtual\"><span class=\"toc-text\">虚拟(Virtual)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#yi-bu-asynchronism\"><span class=\"toc-text\">异步(Asynchronism)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#cao-zuo-xi-tong-de-mu-biao-he-gong-neng\"><span class=\"toc-text\">操作系统的目标和功能</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cao-zuo-xi-tong-zuo-wei-ji-suan-ji-xi-tong-zi-yuan-de-guan-li-zhe\"><span class=\"toc-text\">操作系统作为计算机系统资源的管理者</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#chu-li-ji-guan-li\"><span class=\"toc-text\">处理机管理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#cun-chu-qi-guan-li\"><span class=\"toc-text\">存储器管理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#wen-jian-guan-li\"><span class=\"toc-text\">文件管理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#she-bei-guan-li\"><span class=\"toc-text\">设备管理</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cao-zuo-xi-tong-zuo-wei-yong-hu-yu-ji-suan-ji-ying-jian-xi-tong-zhi-jian-de-jie-kou\"><span class=\"toc-text\">操作系统作为用户与计算机硬件系统之间的接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#ming-ling-jie-kou\"><span class=\"toc-text\">命令接口</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#cheng-xu-jie-kou\"><span class=\"toc-text\">程序接口</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cao-zuo-xi-tong-yong-zuo-kuo-chong-ji-qi\"><span class=\"toc-text\">操作系统用作扩充机器</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#cao-zuo-xi-tong-de-fa-zhan-yu-fen-lei\"><span class=\"toc-text\">操作系统的发展与分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#shou-gong-cao-zuo-jie-duan-ci-jie-duan-wu-cao-zuo-xi-tong\"><span class=\"toc-text\">手工操作阶段（此阶段无操作系统)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#pi-chu-li-jie-duan-cao-zuo-xi-tong-kai-shi-chu-xian\"><span class=\"toc-text\">批处理阶段(操作系统开始出现）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#dan-dao-pi-chu-li-xi-tong\"><span class=\"toc-text\">单道批处理系统</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#duo-dao-pi-chu-li-xi-tong\"><span class=\"toc-text\">多道批处理系统</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#fen-shi-cao-zuo-xi-tong\"><span class=\"toc-text\">分时操作系统</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#shi-shi-cao-zuo-xi-tong\"><span class=\"toc-text\">实时操作系统</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#wang-luo-cao-zuo-xi-tong-he-fen-bu-shi-ji-suan-ji-xi-tong\"><span class=\"toc-text\">网络操作系统和分布式计算机系统</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ge-ren-ji-suan-ji-cao-zuo-xi-tong\"><span class=\"toc-text\">个人计算机操作系统</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#cao-zuo-xi-tong-de-yun-xing-huan-jing\"><span class=\"toc-text\">操作系统的运行环境</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#cao-zuo-xi-tong-de-yun-xing-ji-zhi\"><span class=\"toc-text\">操作系统的运行机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#shi-zhong-guan-li\"><span class=\"toc-text\">时钟管理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#zhong-duan-ji-zhi\"><span class=\"toc-text\">中断机制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#yuan-yu\"><span class=\"toc-text\">原语</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#xi-tong-kong-zhi-de-shu-ju-jie-gou-ji-chu-li\"><span class=\"toc-text\">系统控制的数据结构及处理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#zhong-duan-he-yi-chang-de-gai-nian\"><span class=\"toc-text\">中断和异常的概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#zhong-duan-he-yi-chang-de-ding-yi\"><span class=\"toc-text\">中断和异常的定义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#zhong-duan-chu-li-de-guo-cheng\"><span class=\"toc-text\">中断处理的过程</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xi-tong-diao-yong\"><span class=\"toc-text\">系统调用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#cao-zuo-xi-tong-de-ti-xi-jie-gou\"><span class=\"toc-text\">操作系统的体系结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#da-nei-he-he-wei-nei-he\"><span class=\"toc-text\">大内核和微内核</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ben-zhang-yi-nan-dian\"><span class=\"toc-text\">本章疑难点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bing-xing-xing-yu-bing-fa-xing-de-qu-bie-he-lian-xi\"><span class=\"toc-text\">并行性与并发性的区别和联系</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#te-quan-zhi-ling-yu-fei-te-quan-zhi-ling\"><span class=\"toc-text\">特权指令与非特权指令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#fang-guan-zhi-ling-yu-fang-guan-zhong-duan\"><span class=\"toc-text\">访管指令与访管中断</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#jin-cheng-guan-li\"><span class=\"toc-text\">进程管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#jin-cheng-yu-xian-cheng\"><span class=\"toc-text\">进程与线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#jin-cheng-de-gai-nian-he-te-zheng\"><span class=\"toc-text\">进程的概念和特征</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jin-cheng-de-gai-nian\"><span class=\"toc-text\">进程的概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jin-cheng-de-te-zheng\"><span class=\"toc-text\">进程的特征</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#jin-cheng-de-zhuang-tai-yu-zhuan-huan\"><span class=\"toc-text\">进程的状态与转换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#jin-cheng-kong-zhi\"><span class=\"toc-text\">进程控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jin-cheng-de-chuang-jian\"><span class=\"toc-text\">进程的创建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jin-cheng-de-zhong-zhi\"><span class=\"toc-text\">进程的终止</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jin-cheng-de-zu-sai-he-huan-xing\"><span class=\"toc-text\">进程的阻塞和唤醒</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jin-cheng-qie-huan\"><span class=\"toc-text\">进程切换</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#jin-cheng-de-zu-zhi\"><span class=\"toc-text\">进程的组织</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jin-cheng-kong-zhi-kuai\"><span class=\"toc-text\">进程控制块</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cheng-xu-duan\"><span class=\"toc-text\">程序段</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#shu-ju-duan\"><span class=\"toc-text\">数据段</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#jin-cheng-de-tong-xin\"><span class=\"toc-text\">进程的通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#gong-xiang-cun-chu\"><span class=\"toc-text\">共享存储</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#xiao-xi-chuan-di\"><span class=\"toc-text\">消息传递</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#guan-dao-tong-xin\"><span class=\"toc-text\">管道通信</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xian-cheng-gai-nian-he-duo-xian-cheng-mo-xing\"><span class=\"toc-text\">线程概念和多线程模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#xian-cheng-de-ji-ben-gai-nian\"><span class=\"toc-text\">线程的基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#xian-cheng-yu-jin-cheng-de-bi-jiao\"><span class=\"toc-text\">线程与进程的比较</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#xian-cheng-de-shu-xing\"><span class=\"toc-text\">线程的属性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#xian-cheng-de-shi-xian-fang-shi\"><span class=\"toc-text\">线程的实现方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#duo-xian-cheng-mo-xing\"><span class=\"toc-text\">多线程模型</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ben-jie-xiao-jie\"><span class=\"toc-text\">本节小结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#wei-shi-yao-yao-yin-ru-jin-cheng\"><span class=\"toc-text\">为什么要引入进程?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#shi-yao-shi-jin-cheng-jin-cheng-you-shi-yao-zu-cheng\"><span class=\"toc-text\">什么是进程?进程由什么组成?</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#chu-li-ji-diao-du\"><span class=\"toc-text\">处理机调度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#diao-du-de-gai-nian\"><span class=\"toc-text\">调度的概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#diao-du-de-ji-ben-gai-nian\"><span class=\"toc-text\">调度的基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#diao-du-de-ceng-ci\"><span class=\"toc-text\">调度的层次</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#san-ji-diao-du-de-lian-xi\"><span class=\"toc-text\">三级调度的联系</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#diao-du-de-shi-ji-qie-huan-yu-guo-cheng\"><span class=\"toc-text\">调度的时机、切换与过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#jin-cheng-diao-du-fang-shi\"><span class=\"toc-text\">进程调度方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#diao-du-de-ji-ben-zhun-ze\"><span class=\"toc-text\">调度的基本准则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mark-dian-xing-de-diao-du-suan-fa-mark\"><span class=\"toc-text\">典型的调度算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#xian-lai-xian-fu-wu-fcfs-diao-du-suan-fa\"><span class=\"toc-text\">先来先服务(FCFS)调度算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#duan-zuo-ye-you-xian-sjf-diao-du-suan-fa\"><span class=\"toc-text\">短作业优先(SJF)调度算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#you-xian-ji-diao-du-suan-fa\"><span class=\"toc-text\">优先级调度算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#gao-xiang-ying-bi-you-xian-diao-du-suan-fa\"><span class=\"toc-text\">高响应比优先调度算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#shi-jian-pian-lun-zhuan-diao-du-suan-fa\"><span class=\"toc-text\">时间片轮转调度算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#duo-ji-fan-kui-dui-lie-diao-du-suan-fa-rong-he-liao-qian-ji-chong-suan-fa-de-you-dian\"><span class=\"toc-text\">多级反馈队列调度算法（融合了前几种算法的优点）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ben-zhang-xiao-jie\"><span class=\"toc-text\">本章小结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#wei-shi-yao-yao-jin-xing-chu-li-ji-diao-du\"><span class=\"toc-text\">为什么要进行处理机调度?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#diao-du-suan-fa-you-na-ji-chong-jie-he-di-1-zhang-xue-xi-de-fen-shi-cao-zuo-xi-tong-he-shi-shi-cao-zuo-xi-tong-si-kao-you-mei-you-na-chong-diao-du-suan-fa-bi-jiao-gua-he-zhe-liang-chong-cao-zuo-xi-tong\"><span class=\"toc-text\">调度算法有哪几种?结合第 1 章学习的分时操作系统和实时操作系统，思考有没有哪种调度算法比较适合这两种操作系统。</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#jin-cheng-tong-bu\"><span class=\"toc-text\">进程同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#jin-cheng-tong-bu-de-ji-ben-gai-nian\"><span class=\"toc-text\">进程同步的基本概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#lin-jie-zi-yuan\"><span class=\"toc-text\">临界资源</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#tong-bu\"><span class=\"toc-text\">同步</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#hu-chi\"><span class=\"toc-text\">互斥</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mark-shi-xian-lin-jie-qu-hu-chi-de-ji-ben-fang-fa-mark\"><span class=\"toc-text\">实现临界区互斥的基本方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ruan-jian-shi-xian-fang-fa\"><span class=\"toc-text\">软件实现方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ying-jian-shi-xian-fang-fa\"><span class=\"toc-text\">硬件实现方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#mark-xin-hao-liang-mark\"><span class=\"toc-text\">信号量</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#zheng-xing-xin-hao-liang\"><span class=\"toc-text\">整型信号量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ji-lu-xing-xin-hao-liang\"><span class=\"toc-text\">记录型信号量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#li-yong-xin-hao-liang-shi-xian-tong-bu\"><span class=\"toc-text\">利用信号量实现同步</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#li-yong-xin-hao-liang-shi-xian-jin-cheng-hu-chi\"><span class=\"toc-text\">利用信号量实现进程互斥</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#li-yong-xin-hao-liang-shi-xian-qian-qu-guan-xi\"><span class=\"toc-text\">利用信号量实现前驱关系</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#fen-xi-jin-cheng-tong-bu-he-hu-chi-wen-ti-de-fang-fa-bu-zou\"><span class=\"toc-text\">分析进程同步和互斥问题的方法步骤</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#guan-cheng\"><span class=\"toc-text\">管程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#guan-cheng-de-ding-yi\"><span class=\"toc-text\">管程的定义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#tiao-jian-bian-liang\"><span class=\"toc-text\">条件变量</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#jing-dian-tong-bu-wen-ti\"><span class=\"toc-text\">经典同步问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#sheng-chan-zhe-xiao-fei-zhe-wen-ti\"><span class=\"toc-text\">生产者-消费者问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#du-zhe-xie-zhe-wen-ti\"><span class=\"toc-text\">读者-写者问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#zhe-xue-jia-jin-can-wen-ti\"><span class=\"toc-text\">哲学家进餐问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#xi-yan-zhe-wen-ti\"><span class=\"toc-text\">吸烟者问题</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ben-jie-xiao-jie-1\"><span class=\"toc-text\">本节小结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#wei-shi-yao-yao-yin-ru-jin-cheng-tong-bu-de-gai-nian\"><span class=\"toc-text\">为什么要引入进程同步的概念?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#bu-tong-de-jin-cheng-zhi-jian-hui-cun-zai-shi-yao-guan-xi\"><span class=\"toc-text\">不同的进程之间会存在什么关系?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#dang-dan-chun-yong-ben-jie-jie-shao-de-fang-fa-jie-jue-zhe-xie-wen-ti-shi-hui-yu-dao-shi-yao-xin-de-wen-ti-ma\"><span class=\"toc-text\">当单纯用本节介绍的方法解决这些问题时会遇到什么新的问题吗?</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#si-suo\"><span class=\"toc-text\">死锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#si-suo-de-gai-nian\"><span class=\"toc-text\">死锁的概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#si-suo-de-ding-yi\"><span class=\"toc-text\">死锁的定义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#si-suo-chan-sheng-de-yuan-yin\"><span class=\"toc-text\">死锁产生的原因</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#xi-tong-zi-yuan-de-jing-zheng\"><span class=\"toc-text\">系统资源的竞争</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#jin-cheng-tui-jin-shun-xu-fei-fa\"><span class=\"toc-text\">进程推进顺序非法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#si-suo-chan-sheng-de-bi-yao-tiao-jian\"><span class=\"toc-text\">死锁产生的必要条件</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#si-suo-de-chu-li-ce-lue\"><span class=\"toc-text\">死锁的处理策略</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#si-suo-yu-fang\"><span class=\"toc-text\">死锁预防</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#bi-mian-si-suo\"><span class=\"toc-text\">避免死锁</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#si-suo-de-jian-ce-ji-jie-chu\"><span class=\"toc-text\">死锁的检测及解除</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#si-suo-yu-fang-1\"><span class=\"toc-text\">死锁预防</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#po-pi-hu-chi-tiao-jian\"><span class=\"toc-text\">破坏互斥条件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#po-pi-bu-bo-duo-tiao-jian\"><span class=\"toc-text\">破坏不剥夺条件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#po-pi-qing-qiu-bing-bao-chi-tiao-jian\"><span class=\"toc-text\">破坏请求并保持条件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#po-pi-xun-huan-deng-dai-tiao-jian\"><span class=\"toc-text\">破坏循环等待条件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#si-suo-bi-mian\"><span class=\"toc-text\">死锁避免</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#xi-tong-an-quan-zhuang-tai\"><span class=\"toc-text\">系统安全状态</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#yin-xing-jia-suan-fa\"><span class=\"toc-text\">银行家算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#shu-ju-jie-gou-miao-shu\"><span class=\"toc-text\">数据结构描述</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#yin-xing-jia-suan-fa-miao-shu\"><span class=\"toc-text\">银行家算法描述</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#an-quan-xing-suan-fa-ju-li\"><span class=\"toc-text\">安全性算法举例</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#yin-xing-jia-suan-fa-ju-li\"><span class=\"toc-text\">银行家算法举例</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#si-suo-jian-ce-he-jie-chu\"><span class=\"toc-text\">死锁检测和解除</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#zi-yuan-fen-pei-tu\"><span class=\"toc-text\">资源分配图</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#si-suo-ding-li\"><span class=\"toc-text\">死锁定理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#si-suo-jie-chu\"><span class=\"toc-text\">死锁解除</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ben-jie-xiao-jie-2\"><span class=\"toc-text\">本节小结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ben-zhang-yi-nan-dian-1\"><span class=\"toc-text\">本章疑难点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jin-cheng-yu-cheng-xu-de-qu-bie-yu-lian-xi\"><span class=\"toc-text\">进程与程序的区别与联系</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#si-suo-yu-ji-e\"><span class=\"toc-text\">死锁与饥饿</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#yin-xing-jia-suan-fa-de-gong-zuo-yuan-li\"><span class=\"toc-text\">银行家算法的工作原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jin-cheng-tong-bu-hu-chi-de-qu-bie-he-lian-xi\"><span class=\"toc-text\">进程同步、互斥的区别和联系</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#zuo-ye-he-jin-cheng-de-guan-xi\"><span class=\"toc-text\">作业和进程的关系</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#pi-chu-li-xi-tong-zhong-zuo-ye-yu-jin-cheng-de-guan-xi-jin-cheng-zu-zhi\"><span class=\"toc-text\">批处理系统中作业与进程的关系（进程组织)</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#fen-shi-xi-tong-zhong-zuo-ye-yu-jin-cheng-de-guan-xi\"><span class=\"toc-text\">分时系统中作业与进程的关系</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#jiao-hu-di-ti-jiao-pi-zuo-ye\"><span class=\"toc-text\">交互地提交批作业</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"ND_LJQ","slug":"blog-author","avatar":"static/img/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"File&Blob","uid":"497c273b21b6384f2b97078d8e2b85c3","slug":"File&Blob","date":"2023-07-19T14:19:55.000Z","updated":"2023-07-19T14:23:18.596Z","comments":true,"path":"api/articles/File&Blob.json","keywords":null,"cover":[],"text":"什么是文件 这是一张纯色图片 文件的内容 这是他的二进制代码格式: 以下是一些常见的文件的二进制代码前缀 .exe的： MZ? + This program cannot be run in DOS mode. .jpg的： JFIF Or Exif .png： NG .zip：...","link":"","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"前端","slug":"前端","count":12,"path":"api/categories/前端.json"},{"name":"基本概念","slug":"前端/基本概念","count":1,"path":"api/categories/前端/基本概念.json"}],"tags":[{"name":"基本概念(前端)","slug":"基本概念-前端","count":1,"path":"api/tags/基本概念-前端.json"}],"author":{"name":"ND_LJQ","slug":"blog-author","avatar":"static/img/head.jpg","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}