{"title":"数据结构基础","uid":"a4ba43b16c40c17ef43c675dbe1ccabe","slug":"数据结构基础","date":"2023-09-06T12:31:31.000Z","updated":"2023-11-22T11:21:53.020Z","comments":true,"path":"api/articles/数据结构基础.json","keywords":null,"cover":[],"content":"<h1 id=\"pai-xu-suan-fa\">排序算法</h1>\n<h2 id=\"nei-bu-pai-xu-suan-fa\" id=\"内部排序算法\">内部排序算法</h2>\n<h3 id=\"cha-ru-pai-xu\" id=\"插入排序\">插入排序</h3>\n<p><strong>将一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部记录插入完成。</strong></p>\n<h4 id=\"zhi-jie-cha-ru-pai-xu\" id=\"直接插入排序\">直接插入排序</h4>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/2116d673-c717-4809-a653-933a1ca5b54c.png\" alt=\"img\"></p>\n<p>插入排序通常采用就地排序，在从后向前的比较过程中，需要反复把已排序元素逐步向后挪位，为新元素腾出插入空间。</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/080106e44a05bb46a38ffa99a1f03c38.gif\" alt=\"insertionSort\"></p>\n<p><strong>空间效率</strong><br>\n仅使用了常数个辅助单元，空间复杂度为O ( 1 )</p>\n<p><strong>时间效率</strong><br>\n排序过程中，向有序子表中逐个插入元素的操作进行了n-1趟；每趟操作都分为比较关键字和移动元素，次数取决于待排序表的初始状态。</p>\n<p>在最好情况下，表中元素已经有序，此时每插入一个元素，都只需一次比较而不需要移动元素。时间复杂度为O ( n ) ；在最坏情况下。表中元素的顺序刚好与排序结果相反（逆序），总的比较次数达到最大为O（n²）；在平均情况下，考虑待排序表中的元素是随机的，此时取最好与最坏情况的平均值作为平均情况的时间复杂度。</p>\n<p><strong>稳定性</strong><br>\n在每次查找插入位置的时候，是temp的值比前面的值小，才会移动，所以如果是相同的两个数值，查找的指针是不会移动的，所以算法是<strong>稳定的</strong>。</p>\n<p><strong>适用性</strong><br>\n直接插入排序算法适用于<strong>顺序储存（大部分排序算法仅适用于顺序储存的线性表）和链式储存</strong>。<strong>当采用链表的时候，查找的次数和顺序表相同，但是移动的次数减少了，因为只需要修改几个指针就可以。</strong></p>\n<p>其更适用于基本有序、数据量不大的排序表。但是，它有缺点，也就是每次查找的次数会多很多。下面的算法是对直接插入排序进行的优化。</p>\n<h4 id=\"zhe-ban-cha-ru-pai-xu\" id=\"折半插入排序\">折半插入排序</h4>\n<p>上个直接插入排序当中，因为子表已经排好序了，所以没有必要从头到尾比较来查找，在查找插入点的时候可以采用折半插入，可以减少查找的次数</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/9f79750c-3dd3-4843-b916-f1d81a0d46f8.png\" alt=\"img\"></p>\n<p><strong>空间效率</strong></p>\n<p>和直接插入排序一样，仅使用了常数个辅助单元，空间复杂度为O ( 1 ) 。</p>\n<p><strong>时间效率</strong><br>\n相对于直接插入排序，折半插入排序仅仅减少了比较元素的次数，没有减少移动的次数，所以时间复杂度仍为O(n²)。</p>\n<p>但对于数据量不是很大的排序表，折半插入排序往往表现出很好的性能。</p>\n<p><strong>稳定性</strong><br>\n和折半插入一样，在移动的过程中， 只有前面一个数大于temp，才会移动，所以如果遇到相等的情况，就不会移动。所以折半插入排序也是一种稳定的排序方法。</p>\n<p><strong>适用性</strong></p>\n<p>和直接插入排序不一样，折半插入只适用于顺序表，不能用于链表！因为链表不支持随机查找，它不能随意定位到low mid high这些点处的数值。</p>\n<h4 id=\"xi-er-pai-xu\" id=\"希尔排序\">希尔排序</h4>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/5bde7cbe-f9a7-4289-a570-a8d2b6122aba.png\" alt=\"img\"></p>\n<p>基本思想：<strong>先设值一个增量</strong>——一般最开始是等于总数量的一半。根据增量将待排序表<strong>划分成若干特殊子表</strong>，然后对<strong>各个子表进行直接插入排序</strong>；再缩小增量，重复上述过程，直到增量=1为止。当整个表中的元素已呈“基本有序”时,再对全体记录进行一次直接插入排序。</p>\n<p>希尔排序和直接插入排序有很大的关系，希尔排序可以看作是为了让直接插入排序能更好的发挥作用而做的优化。总结来说，<strong>希尔排序是先追求表中元素部分有序，再逐渐逼近全局有序。</strong></p>\n<p>希尔排序的过程如下：</p>\n<p>第一步：取d=n/2；</p>\n<p>第二步：待排序表分割成若干形如[ i , i + d , i + 2 d , ⋯   , i + k d ] ；</p>\n<p>第三步：在各个组内进行直接插入排序；</p>\n<p>第四步：缩小d，即让d=d-1；重复二、三的步骤；</p>\n<p>第五步：不断缩小d，直到d= 1 ，即所有记录已放在同一组中，再进行一次直接插入排序。</p>\n<p><strong>空间效率</strong><br>\n仅使用了常数个辅助单元，空间复杂度为O ( 1 ) 。</p>\n<p><strong>时间效率</strong><br>\n目前无法用数学手段证明它的时间复杂度，但是当n在某个特定范围时，希尔排序的平均时间复杂度约为O(n^{1.3})。在最坏情况下，希尔排序的时间复杂度为O(n²)。不过总体而言，这个算法还是比较优化的。</p>\n<p><strong>稳定性</strong><br>\n当相同关键字的记录被划分到不同子表时，可能会改变它们之间的相对次序，因此希尔排序是一种不稳定的排序方法。</p>\n<p><strong>适用性</strong><br>\n希尔排序对较大规模的排序都可以达到很高的效率。</p>\n<p>仅适用于顺序存储的线性表。因为我们需要用增量d快速找到与之相邻的、从属于同一个子表的各元素，所以必须要有随机访问的个性。</p>\n<h3 id=\"jiao-huan-pai-xu\" id=\"交换排序\">交换排序</h3>\n<p>所谓交换，是指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。</p>\n<h4 id=\"mou-pao-pai-xu\" id=\"冒泡排序\">冒泡排序</h4>\n<p><strong>冒泡排序的基本思想：从后往前（或从前往后）两两比较相邻元素的值，若为逆序则交换，直到序列比较完，这称为一趟冒泡。</strong></p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/245eb94c-8e0f-48c6-a377-0f7a30a26532.png\" alt=\"img\"></p>\n<p>冒泡排序中所产生的有序子序列一定是全局有序的，<strong>每趟排序都会将一个元素放在其最终位置。</strong></p>\n<p>举例子，目标是进行从小到大排序，从后往前冒泡，那么一趟冒泡的结果是将最小的元素放到最前面，第二趟冒泡把第二大的元素放到第二个位置，从第二趟开始，已确定位置的元素不再参与比较，所以第二趟最多做n-1次移动。总体冒泡的趟数最多是n-1。</p>\n<p>结束冒泡的时机：某一趟冒泡结束后，元素的相对位置都不变。</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/1391679-20180618163321525-1936669878.gif\" alt=\"img\"></p>\n<p><strong>代码和示例</strong></p>\n<p>需要写一个交换的函数swap。冒泡排序算法代码如下</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">MaopaoSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> A<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">int</span> i <span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;=</span>len<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//i每增加一次，说明一趟冒泡结束</span>\n\t\tbool flag<span class=\"token operator\">=</span>false<span class=\"token punctuation\">;</span>   <span class=\"token comment\">//用来标记算法是否要结束</span>\n\t\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>j<span class=\"token operator\">=</span>len<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">></span>i<span class=\"token punctuation\">;</span>j<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//j是要处理的数。在这一趟冒泡里，是从后面往前冒泡，所以是j=len-1。</span>\n\t\t\t<span class=\"token comment\">//如果两个数，如果前面一个比后面一个大，就对调</span>\n\t\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span>A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>   \n\t\t\t\t<span class=\"token comment\">//对调</span>\n\t\t\t\t<span class=\"token keyword\">int</span> temp<span class=\"token operator\">=</span>A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t\tA<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>A<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t\tA<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>temp<span class=\"token punctuation\">;</span>\n\t\t\t\tflag<span class=\"token operator\">=</span>true<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//只要有交换就改成true。说明算法还没有结束。</span>\n\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>flag<span class=\"token operator\">==</span>false<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//算法结束的标志是false。意思是一趟结束后，flag都没有变成true。说明</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>空间效率</strong><br>\n仅使用了常数个辅助单元，空间复杂度为<strong>O ( 1 )</strong>。</p>\n<p><strong>时间效率</strong></p>\n<p>时间复杂度为<strong>O（n²）</strong>。</p>\n<p><strong>稳定性</strong></p>\n<p>冒泡排序时一种<strong>稳定的</strong>排序方法。如果把代码中判断是否逆序的条件由“＞”改为“≥”，则算法变得不稳定。</p>\n<h4 id=\"mark-kuai-su-pai-xu-mark\" id=\"快速排序\"><mark>快速排序</mark></h4>\n<p>快速排序的基本思想是基于分治法的：在待排序表中选取一个元素，称为枢轴（或称基准，常取首元素）。通过一趟排序，将待排序表分成两部分，一部分中所有元素均小于枢轴，另一部分元素均大于枢轴，两部分分别位于枢轴元素的两侧，这个过程称为一趟快速排序（或一次划分）。然后递归地分别对两个子表重复上述过程，直到每部分只有一个元素或空为止，此时所有元素都放在了最终位置。</p>\n<p>单轮动图演示:</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/dbabc9d57fd6498890b441cc6a188a15tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.gif\" alt=\"快排霍尔版本动图.gif\"></p>\n<p>完整演示:</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/quick_sort.gif\" alt=\"Sorting_quicksort_anim.gif\"></p>\n<p>快速排序并不产生有序子序列，但每趟排序后会将枢轴元素放在最终位置上。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> array<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> low<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> high<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>low <span class=\"token operator\">>=</span> high<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\ti <span class=\"token operator\">=</span> low<span class=\"token punctuation\">;</span>\n\tj <span class=\"token operator\">=</span> high<span class=\"token punctuation\">;</span>\n\tkey <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 以最左边的元素作为关键元素</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">&#123;</span>\n\t\t<span class=\"token comment\">// 始终保持 i &lt; j</span>\n\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> j <span class=\"token operator\">&amp;&amp;</span> array<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> key<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 右指针向左移动</span>\n\t\t\tj<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">)</span>\n\t\t\tarray<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将较小的元素放在左边</span>\n\n\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> j <span class=\"token operator\">&amp;&amp;</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> key<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 左指针向右移动</span>\n\t\t\ti<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">)</span>\n\t\t\tarray<span class=\"token punctuation\">[</span>j<span class=\"token operator\">--</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将较大的元素放在右边</span>\n\t<span class=\"token punctuation\">&#125;</span>\n\tarray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> key<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 最终将关键元素放入位置 i == j</span>\n\n\t<span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> low<span class=\"token punctuation\">,</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 递归排序左边</span>\n\t<span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 递归排序右边</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> array<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 待排序数组</span>\n\t<span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\">// 数组长度</span>\n\n\t<span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> len <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 排序数组</span>\n\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 打印排序后的数组</span>\n\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>空间效率</strong><br>\n快排是递归地，需要借助一个递归工作栈来保持每层递归调用的必要信息（变量、地址），容量与递归调用的最大深度一致。空间复杂度=O（递归层数）。递归层数最大是n，最小是log2n。</p>\n<p>所以：最好的空间复杂度是O（log2n），最坏的情况是O(n）。</p>\n<p><strong>时间效率</strong><br>\n时间复杂度=O（n*递归层数）。递归层数最大是n，最小是log2n</p>\n<p>所以：最好的时间复杂度是O(nlog2n)，最坏的情况是O(n²）。</p>\n<p>在实际中，它的时间复杂度是接近最好的情况，也就是O(nlog2n)。</p>\n<p><strong>快速排序是所有内部排序中平均性能最优的排序算法。</strong></p>\n<p><strong>稳定性</strong><br>\n某一趟中，两个关键字相同的元素，从一个区间被交换到另一个区间的过程中，相对位置会发生变化。<strong>快速排序是一种不稳定的排序方法</strong>。</p>\n<p><strong>优化</strong></p>\n<p>根据二叉树的特性，如果数值刚好顺序或者逆序，那么时间复杂度就是O（n²）。为了提高性能，在选取枢轴的时候，最好能将序列划分成为均匀的两部分。所以，在选取枢轴的时候，可以选头、尾、中间值，再比较一下，然后采用数值大小居中的元素作为枢轴；也可以采用随机选择的办法，这样就可以避免刚好顺序或者逆序。</p>\n<h3 id=\"xuan-ze-pai-xu\" id=\"选择排序\">选择排序</h3>\n<h4 id=\"jian-dan-xuan-ze-pai-xu\" id=\"简单选择排序\">简单选择排序</h4>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/9c231e67-a67d-43c9-ae4f-6da52bb8cb39.png\" alt=\"img\"></p>\n<p>选择排序的基本思想：<strong>每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序序列</strong></p>\n<p>简单选择排序的过程：</p>\n<p>第一趟：把整个无序的序列扫描，找出最小的元素和第一个位置元素互换，待排序的元素减小一个。</p>\n<p>第二趟：在待排序的序列中扫描最小的，和当前待排序序列的第一个元素互换，待排序的序列再减少；</p>\n<p>重复上述操作，直到待排序的序列元素个数为0。</p>\n<p><strong>空间效率</strong><br>\n仅使用常数个辅助单元，空间效率为<strong>O(1)</strong>。</p>\n<p><strong>时间效率</strong><br>\n这个算法，因为是全盘扫描找最小值，所以不管初始状态是什么（不管你是顺序还是逆序），它的时间复杂度始终是 <strong>O(n<sup>2</sup>)</strong>。</p>\n<p>其他算法，初始状态不同，时间复杂度可能就不一样（比如快速排序）。</p>\n<p><strong>稳定性</strong><br>\n在第 i 趟把最小元素和第 i 个元素进行交换时，可能导致第 i 个元素与其后含有相同关键字元素的相对位置发生变化。简单选择排序是不稳定的。</p>\n<p><strong>适用性</strong></p>\n<p>简单选择排序的思想是全部扫描，没有用到随机查找，所以顺序表和链表都适用。</p>\n<h4 id=\"dui-pai-xu\" id=\"堆排序\">堆排序</h4>\n<p>举一个建立大根堆的例子</p>\n<p>设初始序列为[53,17,78,9,45,65,87,32]</p>\n<p>1.建立初始堆</p>\n<p>先用层序遍历建立一个初始堆</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/A7ACFB27EAF20120A14B6E4F21B7760B-1700639901152-40.jpg\" alt=\"img\"></p>\n<p>2.从最后一个叶子结点的父节点开始调整并依次向前移动指针进行调整</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/9FA78B7EF7089F60D140CC215A34A756.jpg\" alt=\"img\"></p>\n<p>这是完整的过程演示:</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/1700644794641.gif\" alt=\"1700644794641\"></p>\n<p>排序是将最后一个叶元素与根元素进行交换后弹出叶元素</p>\n<p>以下是代码:</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//建立大根堆</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">buildMaxHeap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> A<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> len<span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// i指向要调整的非叶节点。从最小非叶结点开始，反复调整堆</span>\n        <span class=\"token function\">headAdjust</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//调用函数，调整为大根堆</span>\n<span class=\"token punctuation\">&#125;</span>\n \n<span class=\"token comment\">//将以k为根的子树调整为大根堆</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">headAdjust</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> A<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> k<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>  <span class=\"token comment\">//k是要调整的非叶节点。len是参与调整的界限</span>\n    A<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 暂存子树根节点</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token operator\">*</span>k<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> len<span class=\"token punctuation\">;</span> i <span class=\"token operator\">*=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// i指向左孩子。i *=2的意思是沿key值较大的结点往下，即小元素下坠。 i &lt;= len是向下调整的终止条件</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">&lt;</span>len <span class=\"token operator\">&amp;&amp;</span> A<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span>A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// i&lt;len的作用是保证k有右孩子</span>\n            i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 这时i 指向左右孩子中较大的节点。</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 再拿较大的孩子和根节点对比，如果根节点更大，就结束这次循环</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        A<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 否则就交换结点，把较大的孩子节点和根节点互换</span>\n        k <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// k指向了没有交换前i的位置，然后让i *=2，也就是进入第二次循环，以此来向下检查，让小元素不断下坠。</span>\n    <span class=\"token punctuation\">&#125;</span>\n    A<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//小元素下坠到最后，k指向了小元素最终下坠的位置，这步也是将被筛选的节点的值放入最终位置</span>\n<span class=\"token punctuation\">&#125;</span>\n \n<span class=\"token comment\">//堆排序的完整逻辑</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">HeapSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> A<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token function\">buildMaxHeap</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">,</span>len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//初始建堆(建堆函数中就有调整为大根堆）</span>\n\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span>len<span class=\"token punctuation\">;</span>i<span class=\"token operator\">></span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//n-1趟将堆顶和堆底互换</span>\n\t\t<span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>A<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token function\">headAdjust</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>；<span class=\"token comment\">//互换结束后，要调整。为什么是i-1，因为i不参与调整了。</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>空间复杂度=O(1)。</p>\n<p>时间复杂度（1）在建堆时，需要调用”调整函数”关键字的比较总次数不超过4n，<strong>建堆的时间复杂度为O(n)</strong>。</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/1e39a0f9-562e-4c1c-a880-108f7b43e233.png\" alt=\"img\"></p>\n<p>（2）在排序时，每下坠一层，最多只需要<strong>对比关键字2次（一次是左右孩子对比找出最大值，第二次是最大值和根对比）</strong>，所以是常数级别的对比，所以一趟下坠调整和高度相关。根节点最多下坠h-1层，根据二叉树的性质，下坠的高度h=log2n，所以每趟下坠的时间复杂度是O(log2n)。而总共需要n-1躺排序，两者相乘，即log2n*(n-1)，堆排序的时间复杂度是是nlog2n。</p>\n<p>（3）建堆的时间复杂度是n，排序是nlog2n，取最大值，所以堆排序的时间复杂度是nlog2n。</p>\n<p><strong>堆排序是不稳定的。</strong></p>\n<h3 id=\"gui-bing-pai-xu\" id=\"归并排序\">归并排序</h3>\n<p>归并：把两个或者多个<strong>有序的序列</strong>合并称为一个有序序列。“二路归并”就是把2个有序合并成一个有序；“多路归并”就是把4个有序序列合并成一个有序序列。</p>\n<h4 id=\"er-lu-gui-bing\" id=\"二路归并\">二路归并</h4>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/e9affbfa-239a-496e-a687-7d76fa1a14f9.png\" alt=\"img\"></p>\n<p>二路归并的思想：假定待排序表含有n 个记录，则可将其视为n个有序的子表，每个子表长度为1。然后两两归并，得到长度为2的有序序列。再将得到的长度为2的有序表两两归并，如此重复，直到合并成一个长度为n的有序表为止。</p>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>代码和示例</p>\n</li>\n</ol>\n<p>（1）口述代码：</p>\n<p>主体函数使用了归并的方式：对一个无序的序列，从中间拆分成左右两个部分，对左右两个部分分别进行递归的归并排序，当左右两个部分都有序之后，就可以对左右两个有序的子序列进行归并。</p>\n<p>归并函数Merge的代码逻辑：</p>\n<p>（注意，归并函数的作用是把A数组中两个已经排好序的部分进行排序。这两个部分是low~mid和mid+1到high)。</p>\n<p>第一步：A是要归并的数组，我们使用malloc函数做一个辅助数组B，用for循环把A复制到B。</p>\n<p>第二步：用i，j指针指向B数组中low和mid+1的位置，用k指针指向A的开头。</p>\n<p>第三步：i,j依次向后扫描，比较i和j的key值，把较小的值放到k，然后k指针向后移动，i和j中较小的指针也向后移动，直到i或者j扫描完自己的部分；</p>\n<p>第四步：把i或j没有扫描完的部分用while循环复制到k中，边复制，边移动指针。</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/webp.webp\" alt=\"img\"></p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/849589-20171015230557043-37375010.gif\" alt=\"img\"></p>\n<p><strong>空间效率</strong><br>\n（1）递归工作站需要辅助空间，递归调用的深度不会超过递归的趟数=log2n向上取整。所以递归带来的空间复杂度是O（log2n）；</p>\n<p>（2）空间的开销来自构建的辅助数组B，B和A元素个数相同，都是n，所以是O(n).</p>\n<p>（3）前两个比较，取最大值，所以<strong>归并排序的空间复杂度为O(n)。</strong></p>\n<p><strong>时间效率</strong><br>\n（1）归并的趟数是h-1趟；二叉树中，第h层最多有2的（h-1）次方个节点，换句话说，如果有n个节点，那么要满足不等式：n&lt;=2的(h-1)，解不等式等到h-1=log2n向上取整。所以结论：二路归并的趟数=log2n向上取整。</p>\n<p>（2）每趟归并的时间复杂度为O ( n ) ：因为是用i j 扫描，一共要进行n-1次关键字对比。</p>\n<p>（3）所以归并排序算法的<strong>时间复杂度为O(n*log2n)。</strong></p>\n<p><strong>稳定性</strong><br>\nmerge()操作的时候，如果i j 的key值相等，优先让靠左边的元素放入A，所以并不会改变相同关键字记录的相对次序，所以<strong>归并排序的算法是稳定的</strong>。</p>\n<p>从单个记录起进行两两归并并不值得提倡，通常将它和直接插入排序结合。改进后的归并排序仍是稳定的。</p>\n<h3 id=\"ji-shu-pai-xu\" id=\"基数排序\">基数排序</h3>\n<p>首先十位,然后百位然后千位…</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/196755.gif\" alt=\"img\"></p>\n<p>考试的时候最好这样来在草稿纸上写,我觉得容易理解些</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/4DC573A40401679E9C823922798EB67E.jpg\" alt=\"img\"></p>\n<p><strong>空间效率</strong><br>\n一趟排序需要辅助空间为 r（r个队列，r个队头指针和队尾指针）。空间复杂度为O ( r ) 。</p>\n<p><strong>时间效率</strong><br>\n基数排序需要进行 d 趟分配和收集，一趟分配需要O ( n ) ，一趟收集需要O ( r )。所以基数排序的时间复杂度为O ( d *( n + r ) ) 。每个元素拆成d部分，n是元素个数，r是基数（每个部分可能取得r个值）。其与序列的初始状态无关。</p>\n<p><strong>稳定性</strong><br>\n基数排序是稳定的。口诀：<strong>基你太稳</strong></p>\n<p>注意：基数排序不是基于比较的算法。之前学习的算法都是基于“比较”的算法</p>\n<p><strong>适用性</strong></p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/05a245c6-62b8-40e0-afe6-66f2e0165bb2.png\" alt=\"img\"></p>\n<h2 id=\"wai-bu-pai-xu-suan-fa\" id=\"外部排序算法\">外部排序算法</h2>\n<h3 id=\"duo-lu-gui-bing\" id=\"多路归并\">多路归并</h3>\n<h2 id=\"pai-xu-zong-jie\" id=\"排序总结\">排序总结</h2>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/f7b8687c-6c8d-4aaf-9a11-f5e0f9586917.png\" alt=\"img\"></p>\n<p><strong>稳定性</strong></p>\n<p>不稳定的算法口诀：<mark>“快些选堆”</mark>。快速排序、希尔排序、简单选择排序、堆排序</p>\n<p><strong>时间复杂度</strong></p>\n<p>时间较快的算法的口诀：<mark>“快些归队”</mark>。快速排序、希尔排序、归并排序、堆排序</p>\n<p>在实际应用中，快速排序往往可以优于其他算法，被认为是目前基于比较的内部排序中最好的方法。</p>\n<p><strong>空间复杂度</strong><br>\n大部分的算法的空间复杂度都是常量。空间复杂度的定义是用到的额外的辅助空间，不包含自己的空间的。</p>\n<p><strong>适用性</strong></p>\n<p>若 n 较小，可以采用直接插入排序或简单选择排序；若 n 较大，则应采用时间复杂度为n*(log n)的排序方法：<mark>“快些归队”</mark>。快速排序、希尔排序、归并排序、堆排序；</p>\n<p><strong>常考知识点</strong><br>\n（1）<strong>当关键字随机分布时，快速排序平均时间最短</strong>；（2）<strong>堆排序所需的辅助空间少于快速排序，且不会出现快速排序可能出现的最坏情况</strong>；（3）<strong>冒泡排序和堆排序每趟处理后都能产生当前的最大值或最小值</strong>。（4）<strong>快速排序一趟处理就能确定一个元素的最终位置</strong>。（5）当记录本身信息量较大时，为避免耗费大量时间移动记录，可以采用链表作为存储结构</p>\n<p>（6）<strong>每一趟都至少能确定一个元素的最终的位置的算法有：<mark>“快选一堆帽子”</mark>。快速排序、简单选择排序、堆排序、冒泡排序</strong>。</p>\n","feature":true,"text":"排序算法 内部排序算法 插入排序 将一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部记录插入完成。 直接插入排序 插入排序通常采用就地排序，在从后向前的比较过程中，需要反复把已排序元素逐步向后挪位，为新元素腾出插入空间。 空间效率 仅使用了常数个辅助单元，空间复杂...","link":"","photos":[],"count_time":{"symbolsCount":"7.9k","symbolsTime":"7 mins."},"categories":[{"name":"计算机基础","slug":"计算机基础","count":5,"path":"api/categories/计算机基础.json"},{"name":"数据结构基础","slug":"计算机基础/数据结构基础","count":1,"path":"api/categories/计算机基础/数据结构基础.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pai-xu-suan-fa\"><span class=\"toc-text\">排序算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nei-bu-pai-xu-suan-fa\"><span class=\"toc-text\">内部排序算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#cha-ru-pai-xu\"><span class=\"toc-text\">插入排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#zhi-jie-cha-ru-pai-xu\"><span class=\"toc-text\">直接插入排序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#zhe-ban-cha-ru-pai-xu\"><span class=\"toc-text\">折半插入排序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#xi-er-pai-xu\"><span class=\"toc-text\">希尔排序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#jiao-huan-pai-xu\"><span class=\"toc-text\">交换排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#mou-pao-pai-xu\"><span class=\"toc-text\">冒泡排序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#mark-kuai-su-pai-xu-mark\"><span class=\"toc-text\">快速排序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xuan-ze-pai-xu\"><span class=\"toc-text\">选择排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jian-dan-xuan-ze-pai-xu\"><span class=\"toc-text\">简单选择排序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#dui-pai-xu\"><span class=\"toc-text\">堆排序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gui-bing-pai-xu\"><span class=\"toc-text\">归并排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#er-lu-gui-bing\"><span class=\"toc-text\">二路归并</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ji-shu-pai-xu\"><span class=\"toc-text\">基数排序</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#wai-bu-pai-xu-suan-fa\"><span class=\"toc-text\">外部排序算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#duo-lu-gui-bing\"><span class=\"toc-text\">多路归并</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pai-xu-zong-jie\"><span class=\"toc-text\">排序总结</span></a></li></ol></li></ol>","author":{"name":"ND_LJQ","slug":"blog-author","avatar":"/svg/head.jpg","link":"/","description":"一位正在摆烂的大四渣滓😋 <br /> @ <b>劉三刀的摆烂生活</b>","socials":{"github":"https://github.com/ND-LJQ","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_52475868?type=blog","juejin":"https://juejin.cn/user/2032336272362109","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/391491132?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/liu-jq"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"操作系统基础","uid":"09303d998ed7337d46bfa9387efc032e","slug":"操作系统基础","date":"2023-07-20T12:14:48.000Z","updated":"2023-10-12T07:00:58.875Z","comments":true,"path":"api/articles/操作系统基础.json","keywords":null,"cover":"/svg/welcome-cover.jpg","text":"计算机系统概论 操作系统的基本概念 【考纲内容】 (一）操作系统的概念、特征、功能和提供的服务 (二）操作系统的发展与分类 (三）操作系统的运行环境 内核态与用户态;中断、异常;系统调用 (四）操作系统体系结构 【知识框架】 概论 特征 并发(最基本) 共享(最基本) 虚拟 同步...","link":"","photos":[],"count_time":{"symbolsCount":"130k","symbolsTime":"1:58"},"categories":[{"name":"计算机基础","slug":"计算机基础","count":5,"path":"api/categories/计算机基础.json"},{"name":"操作系统","slug":"计算机基础/操作系统","count":1,"path":"api/categories/计算机基础/操作系统.json"}],"tags":[{"name":"操作系统","slug":"操作系统","count":1,"path":"api/tags/操作系统.json"}],"author":{"name":"ND_LJQ","slug":"blog-author","avatar":"/svg/head.jpg","link":"/","description":"一位正在摆烂的大四渣滓😋 <br /> @ <b>劉三刀的摆烂生活</b>","socials":{"github":"https://github.com/ND-LJQ","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_52475868?type=blog","juejin":"https://juejin.cn/user/2032336272362109","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/391491132?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/liu-jq"}}}},"feature":true}}