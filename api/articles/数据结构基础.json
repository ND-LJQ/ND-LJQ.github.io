{"title":"数据结构基础","uid":"a4ba43b16c40c17ef43c675dbe1ccabe","slug":"数据结构基础","date":"2023-09-06T12:31:31.000Z","updated":"2023-11-22T11:53:41.576Z","comments":true,"path":"api/articles/数据结构基础.json","keywords":null,"cover":[],"content":"<h1 id=\"pai-xu-suan-fa\">排序算法</h1>\n<h2 id=\"nei-bu-pai-xu-suan-fa\" id=\"内部排序算法\">内部排序算法</h2>\n<h3 id=\"cha-ru-pai-xu\" id=\"插入排序\">插入排序</h3>\n<p><strong>将一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部记录插入完成。</strong></p>\n<h4 id=\"zhi-jie-cha-ru-pai-xu\" id=\"直接插入排序\">直接插入排序</h4>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/2116d673-c717-4809-a653-933a1ca5b54c.png\" alt=\"img\"></p>\n<p>插入排序通常采用就地排序，在从后向前的比较过程中，需要反复把已排序元素逐步向后挪位，为新元素腾出插入空间。</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/080106e44a05bb46a38ffa99a1f03c38.gif\" alt=\"insertionSort\"></p>\n<p><strong>空间效率</strong><br>\n仅使用了常数个辅助单元，空间复杂度为O ( 1 )</p>\n<p><strong>时间效率</strong><br>\n排序过程中，向有序子表中逐个插入元素的操作进行了n-1趟；每趟操作都分为比较关键字和移动元素，次数取决于待排序表的初始状态。</p>\n<p>在最好情况下，表中元素已经有序，此时每插入一个元素，都只需一次比较而不需要移动元素。时间复杂度为O ( n ) ；在最坏情况下。表中元素的顺序刚好与排序结果相反（逆序），总的比较次数达到最大为O（n²）；在平均情况下，考虑待排序表中的元素是随机的，此时取最好与最坏情况的平均值作为平均情况的时间复杂度。</p>\n<p><strong>稳定性</strong><br>\n在每次查找插入位置的时候，是temp的值比前面的值小，才会移动，所以如果是相同的两个数值，查找的指针是不会移动的，所以算法是<strong>稳定的</strong>。</p>\n<p><strong>适用性</strong><br>\n直接插入排序算法适用于<strong>顺序储存（大部分排序算法仅适用于顺序储存的线性表）和链式储存</strong>。<strong>当采用链表的时候，查找的次数和顺序表相同，但是移动的次数减少了，因为只需要修改几个指针就可以。</strong></p>\n<p>其更适用于基本有序、数据量不大的排序表。但是，它有缺点，也就是每次查找的次数会多很多。下面的算法是对直接插入排序进行的优化。</p>\n<h4 id=\"zhe-ban-cha-ru-pai-xu\" id=\"折半插入排序\">折半插入排序</h4>\n<p>上个直接插入排序当中，因为子表已经排好序了，所以没有必要从头到尾比较来查找，在查找插入点的时候可以采用折半插入，可以减少查找的次数</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/9f79750c-3dd3-4843-b916-f1d81a0d46f8.png\" alt=\"img\"></p>\n<p><strong>空间效率</strong></p>\n<p>和直接插入排序一样，仅使用了常数个辅助单元，空间复杂度为O ( 1 ) 。</p>\n<p><strong>时间效率</strong><br>\n相对于直接插入排序，折半插入排序仅仅减少了比较元素的次数，没有减少移动的次数，所以时间复杂度仍为O(n²)。</p>\n<p>但对于数据量不是很大的排序表，折半插入排序往往表现出很好的性能。</p>\n<p><strong>稳定性</strong><br>\n和折半插入一样，在移动的过程中， 只有前面一个数大于temp，才会移动，所以如果遇到相等的情况，就不会移动。所以折半插入排序也是一种稳定的排序方法。</p>\n<p><strong>适用性</strong></p>\n<p>和直接插入排序不一样，折半插入只适用于顺序表，不能用于链表！因为链表不支持随机查找，它不能随意定位到low mid high这些点处的数值。</p>\n<h4 id=\"xi-er-pai-xu\" id=\"希尔排序\">希尔排序</h4>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/5bde7cbe-f9a7-4289-a570-a8d2b6122aba.png\" alt=\"img\"></p>\n<p>基本思想：<strong>先设值一个增量</strong>——一般最开始是等于总数量的一半。根据增量将待排序表<strong>划分成若干特殊子表</strong>，然后对<strong>各个子表进行直接插入排序</strong>；再缩小增量，重复上述过程，直到增量=1为止。当整个表中的元素已呈“基本有序”时,再对全体记录进行一次直接插入排序。</p>\n<p>希尔排序和直接插入排序有很大的关系，希尔排序可以看作是为了让直接插入排序能更好的发挥作用而做的优化。总结来说，<strong>希尔排序是先追求表中元素部分有序，再逐渐逼近全局有序。</strong></p>\n<p>希尔排序的过程如下：</p>\n<p>第一步：取d=n/2；</p>\n<p>第二步：待排序表分割成若干形如[ i , i + d , i + 2 d , ⋯   , i + k d ] ；</p>\n<p>第三步：在各个组内进行直接插入排序；</p>\n<p>第四步：缩小d，即让d=d-1；重复二、三的步骤；</p>\n<p>第五步：不断缩小d，直到d= 1 ，即所有记录已放在同一组中，再进行一次直接插入排序。</p>\n<p><strong>空间效率</strong><br>\n仅使用了常数个辅助单元，空间复杂度为O ( 1 ) 。</p>\n<p><strong>时间效率</strong><br>\n目前无法用数学手段证明它的时间复杂度，但是当n在某个特定范围时，希尔排序的平均时间复杂度约为O(n^{1.3})。在最坏情况下，希尔排序的时间复杂度为O(n²)。不过总体而言，这个算法还是比较优化的。</p>\n<p><strong>稳定性</strong><br>\n当相同关键字的记录被划分到不同子表时，可能会改变它们之间的相对次序，因此希尔排序是一种不稳定的排序方法。</p>\n<p><strong>适用性</strong><br>\n希尔排序对较大规模的排序都可以达到很高的效率。</p>\n<p>仅适用于顺序存储的线性表。因为我们需要用增量d快速找到与之相邻的、从属于同一个子表的各元素，所以必须要有随机访问的个性。</p>\n<h3 id=\"jiao-huan-pai-xu\" id=\"交换排序\">交换排序</h3>\n<p>所谓交换，是指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。</p>\n<h4 id=\"mou-pao-pai-xu\" id=\"冒泡排序\">冒泡排序</h4>\n<p><strong>冒泡排序的基本思想：从后往前（或从前往后）两两比较相邻元素的值，若为逆序则交换，直到序列比较完，这称为一趟冒泡。</strong></p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/245eb94c-8e0f-48c6-a377-0f7a30a26532.png\" alt=\"img\"></p>\n<p>冒泡排序中所产生的有序子序列一定是全局有序的，<strong>每趟排序都会将一个元素放在其最终位置。</strong></p>\n<p>举例子，目标是进行从小到大排序，从后往前冒泡，那么一趟冒泡的结果是将最小的元素放到最前面，第二趟冒泡把第二大的元素放到第二个位置，从第二趟开始，已确定位置的元素不再参与比较，所以第二趟最多做n-1次移动。总体冒泡的趟数最多是n-1。</p>\n<p>结束冒泡的时机：某一趟冒泡结束后，元素的相对位置都不变。</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/1391679-20180618163321525-1936669878.gif\" alt=\"img\"></p>\n<p><strong>代码和示例</strong></p>\n<p>需要写一个交换的函数swap。冒泡排序算法代码如下</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">MaopaoSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> A<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">int</span> i <span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;=</span>len<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//i每增加一次，说明一趟冒泡结束</span>\n\t\tbool flag<span class=\"token operator\">=</span>false<span class=\"token punctuation\">;</span>   <span class=\"token comment\">//用来标记算法是否要结束</span>\n\t\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>j<span class=\"token operator\">=</span>len<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">></span>i<span class=\"token punctuation\">;</span>j<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//j是要处理的数。在这一趟冒泡里，是从后面往前冒泡，所以是j=len-1。</span>\n\t\t\t<span class=\"token comment\">//如果两个数，如果前面一个比后面一个大，就对调</span>\n\t\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span>A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>   \n\t\t\t\t<span class=\"token comment\">//对调</span>\n\t\t\t\t<span class=\"token keyword\">int</span> temp<span class=\"token operator\">=</span>A<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t\tA<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>A<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t\tA<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>temp<span class=\"token punctuation\">;</span>\n\t\t\t\tflag<span class=\"token operator\">=</span>true<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//只要有交换就改成true。说明算法还没有结束。</span>\n\t\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>flag<span class=\"token operator\">==</span>false<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//算法结束的标志是false。意思是一趟结束后，flag都没有变成true。说明</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>空间效率</strong><br>\n仅使用了常数个辅助单元，空间复杂度为<strong>O ( 1 )</strong>。</p>\n<p><strong>时间效率</strong></p>\n<p>时间复杂度为<strong>O（n²）</strong>。</p>\n<p><strong>稳定性</strong></p>\n<p>冒泡排序时一种<strong>稳定的</strong>排序方法。如果把代码中判断是否逆序的条件由“＞”改为“≥”，则算法变得不稳定。</p>\n<h4 id=\"mark-kuai-su-pai-xu-mark\" id=\"快速排序\"><mark>快速排序</mark></h4>\n<p>快速排序的基本思想是基于分治法的：在待排序表中选取一个元素，称为枢轴（或称基准，常取首元素）。通过一趟排序，将待排序表分成两部分，一部分中所有元素均小于枢轴，另一部分元素均大于枢轴，两部分分别位于枢轴元素的两侧，这个过程称为一趟快速排序（或一次划分）。然后递归地分别对两个子表重复上述过程，直到每部分只有一个元素或空为止，此时所有元素都放在了最终位置。</p>\n<p>单轮动图演示:</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/dbabc9d57fd6498890b441cc6a188a15tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.gif\" alt=\"快排霍尔版本动图.gif\"></p>\n<p>完整演示:</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/quick_sort.gif\" alt=\"Sorting_quicksort_anim.gif\"></p>\n<p>快速排序并不产生有序子序列，但每趟排序后会将枢轴元素放在最终位置上。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> array<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> low<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> high<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>low <span class=\"token operator\">>=</span> high<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\ti <span class=\"token operator\">=</span> low<span class=\"token punctuation\">;</span>\n\tj <span class=\"token operator\">=</span> high<span class=\"token punctuation\">;</span>\n\tkey <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 以最左边的元素作为关键元素</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">&#123;</span>\n\t\t<span class=\"token comment\">// 始终保持 i &lt; j</span>\n\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> j <span class=\"token operator\">&amp;&amp;</span> array<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> key<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 右指针向左移动</span>\n\t\t\tj<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">)</span>\n\t\t\tarray<span class=\"token punctuation\">[</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将较小的元素放在左边</span>\n\n\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> j <span class=\"token operator\">&amp;&amp;</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> key<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 左指针向右移动</span>\n\t\t\ti<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">)</span>\n\t\t\tarray<span class=\"token punctuation\">[</span>j<span class=\"token operator\">--</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 将较大的元素放在右边</span>\n\t<span class=\"token punctuation\">&#125;</span>\n\tarray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> key<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 最终将关键元素放入位置 i == j</span>\n\n\t<span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> low<span class=\"token punctuation\">,</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 递归排序左边</span>\n\t<span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 递归排序右边</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">int</span> i<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">int</span> array<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 待排序数组</span>\n\t<span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\">// 数组长度</span>\n\n\t<span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> len <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 排序数组</span>\n\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 打印排序后的数组</span>\n\t\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>空间效率</strong><br>\n快排是递归地，需要借助一个递归工作栈来保持每层递归调用的必要信息（变量、地址），容量与递归调用的最大深度一致。空间复杂度=O（递归层数）。递归层数最大是n，最小是log2n。</p>\n<p>所以：最好的空间复杂度是O（log2n），最坏的情况是O(n）。</p>\n<p><strong>时间效率</strong><br>\n时间复杂度=O（n*递归层数）。递归层数最大是n，最小是log2n</p>\n<p>所以：最好的时间复杂度是O(nlog2n)，最坏的情况是O(n²）。</p>\n<p>在实际中，它的时间复杂度是接近最好的情况，也就是O(nlog2n)。</p>\n<p><strong>快速排序是所有内部排序中平均性能最优的排序算法。</strong></p>\n<p><strong>稳定性</strong><br>\n某一趟中，两个关键字相同的元素，从一个区间被交换到另一个区间的过程中，相对位置会发生变化。<strong>快速排序是一种不稳定的排序方法</strong>。</p>\n<p><strong>优化</strong></p>\n<p>根据二叉树的特性，如果数值刚好顺序或者逆序，那么时间复杂度就是O（n²）。为了提高性能，在选取枢轴的时候，最好能将序列划分成为均匀的两部分。所以，在选取枢轴的时候，可以选头、尾、中间值，再比较一下，然后采用数值大小居中的元素作为枢轴；也可以采用随机选择的办法，这样就可以避免刚好顺序或者逆序。</p>\n<h3 id=\"xuan-ze-pai-xu\" id=\"选择排序\">选择排序</h3>\n<h4 id=\"jian-dan-xuan-ze-pai-xu\" id=\"简单选择排序\">简单选择排序</h4>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/9c231e67-a67d-43c9-ae4f-6da52bb8cb39.png\" alt=\"img\"></p>\n<p>选择排序的基本思想：<strong>每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序序列</strong></p>\n<p>简单选择排序的过程：</p>\n<p>第一趟：把整个无序的序列扫描，找出最小的元素和第一个位置元素互换，待排序的元素减小一个。</p>\n<p>第二趟：在待排序的序列中扫描最小的，和当前待排序序列的第一个元素互换，待排序的序列再减少；</p>\n<p>重复上述操作，直到待排序的序列元素个数为0。</p>\n<p><strong>空间效率</strong><br>\n仅使用常数个辅助单元，空间效率为<strong>O(1)</strong>。</p>\n<p><strong>时间效率</strong><br>\n这个算法，因为是全盘扫描找最小值，所以不管初始状态是什么（不管你是顺序还是逆序），它的时间复杂度始终是 <strong>O(n<sup>2</sup>)</strong>。</p>\n<p>其他算法，初始状态不同，时间复杂度可能就不一样（比如快速排序）。</p>\n<p><strong>稳定性</strong><br>\n在第 i 趟把最小元素和第 i 个元素进行交换时，可能导致第 i 个元素与其后含有相同关键字元素的相对位置发生变化。简单选择排序是不稳定的。</p>\n<p><strong>适用性</strong></p>\n<p>简单选择排序的思想是全部扫描，没有用到随机查找，所以顺序表和链表都适用。</p>\n<h4 id=\"dui-pai-xu\" id=\"堆排序\">堆排序</h4>\n<p>举一个建立大根堆的例子</p>\n<p>设初始序列为[53,17,78,9,45,65,87,32]</p>\n<p>1.建立初始堆</p>\n<p>先用层序遍历建立一个初始堆</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/A7ACFB27EAF20120A14B6E4F21B7760B-1700639901152-40.jpg\" alt=\"img\"></p>\n<p>2.从最后一个叶子结点的父节点开始调整并依次向前移动指针进行调整</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/9FA78B7EF7089F60D140CC215A34A756.jpg\" alt=\"img\"></p>\n<p>这是完整的过程演示:</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/1700644794641.gif\" alt=\"1700644794641\"></p>\n<p>排序是将最后一个叶元素与根元素进行交换后弹出叶元素</p>\n<p>以下是代码:</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//建立大根堆</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">buildMaxHeap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> A<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> len<span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// i指向要调整的非叶节点。从最小非叶结点开始，反复调整堆</span>\n        <span class=\"token function\">headAdjust</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//调用函数，调整为大根堆</span>\n<span class=\"token punctuation\">&#125;</span>\n \n<span class=\"token comment\">//将以k为根的子树调整为大根堆</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">headAdjust</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> A<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> k<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>  <span class=\"token comment\">//k是要调整的非叶节点。len是参与调整的界限</span>\n    A<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 暂存子树根节点</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token operator\">*</span>k<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> len<span class=\"token punctuation\">;</span> i <span class=\"token operator\">*=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">// i指向左孩子。i *=2的意思是沿key值较大的结点往下，即小元素下坠。 i &lt;= len是向下调整的终止条件</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">&lt;</span>len <span class=\"token operator\">&amp;&amp;</span> A<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span>A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// i&lt;len的作用是保证k有右孩子</span>\n            i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 这时i 指向左右孩子中较大的节点。</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 再拿较大的孩子和根节点对比，如果根节点更大，就结束这次循环</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        A<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 否则就交换结点，把较大的孩子节点和根节点互换</span>\n        k <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// k指向了没有交换前i的位置，然后让i *=2，也就是进入第二次循环，以此来向下检查，让小元素不断下坠。</span>\n    <span class=\"token punctuation\">&#125;</span>\n    A<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> A<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//小元素下坠到最后，k指向了小元素最终下坠的位置，这步也是将被筛选的节点的值放入最终位置</span>\n<span class=\"token punctuation\">&#125;</span>\n \n<span class=\"token comment\">//堆排序的完整逻辑</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">HeapSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> A<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token function\">buildMaxHeap</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">,</span>len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//初始建堆(建堆函数中就有调整为大根堆）</span>\n\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span>len<span class=\"token punctuation\">;</span>i<span class=\"token operator\">></span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//n-1趟将堆顶和堆底互换</span>\n\t\t<span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>A<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token function\">headAdjust</span><span class=\"token punctuation\">(</span>A<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>；<span class=\"token comment\">//互换结束后，要调整。为什么是i-1，因为i不参与调整了。</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>空间复杂度=O(1)。</p>\n<p>时间复杂度（1）在建堆时，需要调用”调整函数”关键字的比较总次数不超过4n，<strong>建堆的时间复杂度为O(n)</strong>。</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/1e39a0f9-562e-4c1c-a880-108f7b43e233.png\" alt=\"img\"></p>\n<p>（2）在排序时，每下坠一层，最多只需要<strong>对比关键字2次（一次是左右孩子对比找出最大值，第二次是最大值和根对比）</strong>，所以是常数级别的对比，所以一趟下坠调整和高度相关。根节点最多下坠h-1层，根据二叉树的性质，下坠的高度h=log2n，所以每趟下坠的时间复杂度是O(log2n)。而总共需要n-1躺排序，两者相乘，即log2n*(n-1)，堆排序的时间复杂度是是nlog2n。</p>\n<p>（3）建堆的时间复杂度是n，排序是nlog2n，取最大值，所以堆排序的时间复杂度是nlog2n。</p>\n<p><strong>堆排序是不稳定的。</strong></p>\n<h3 id=\"gui-bing-pai-xu\" id=\"归并排序\">归并排序</h3>\n<p>归并：把两个或者多个<strong>有序的序列</strong>合并称为一个有序序列。“二路归并”就是把2个有序合并成一个有序；“多路归并”就是把4个有序序列合并成一个有序序列。</p>\n<h4 id=\"er-lu-gui-bing\" id=\"二路归并\">二路归并</h4>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/e9affbfa-239a-496e-a687-7d76fa1a14f9.png\" alt=\"img\"></p>\n<p>二路归并的思想：假定待排序表含有n 个记录，则可将其视为n个有序的子表，每个子表长度为1。然后两两归并，得到长度为2的有序序列。再将得到的长度为2的有序表两两归并，如此重复，直到合并成一个长度为n的有序表为止。</p>\n<ol start=\"2\">\n<li class=\"lvl-3\">\n<p>代码和示例</p>\n</li>\n</ol>\n<p>（1）口述代码：</p>\n<p>主体函数使用了归并的方式：对一个无序的序列，从中间拆分成左右两个部分，对左右两个部分分别进行递归的归并排序，当左右两个部分都有序之后，就可以对左右两个有序的子序列进行归并。</p>\n<p>归并函数Merge的代码逻辑：</p>\n<p>（注意，归并函数的作用是把A数组中两个已经排好序的部分进行排序。这两个部分是low~mid和mid+1到high)。</p>\n<p>第一步：A是要归并的数组，我们使用malloc函数做一个辅助数组B，用for循环把A复制到B。</p>\n<p>第二步：用i，j指针指向B数组中low和mid+1的位置，用k指针指向A的开头。</p>\n<p>第三步：i,j依次向后扫描，比较i和j的key值，把较小的值放到k，然后k指针向后移动，i和j中较小的指针也向后移动，直到i或者j扫描完自己的部分；</p>\n<p>第四步：把i或j没有扫描完的部分用while循环复制到k中，边复制，边移动指针。</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/webp.webp\" alt=\"img\"></p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/849589-20171015230557043-37375010.gif\" alt=\"img\"></p>\n<p><strong>空间效率</strong><br>\n（1）递归工作站需要辅助空间，递归调用的深度不会超过递归的趟数=log2n向上取整。所以递归带来的空间复杂度是O（log2n）；</p>\n<p>（2）空间的开销来自构建的辅助数组B，B和A元素个数相同，都是n，所以是O(n).</p>\n<p>（3）前两个比较，取最大值，所以<strong>归并排序的空间复杂度为O(n)。</strong></p>\n<p><strong>时间效率</strong><br>\n（1）归并的趟数是h-1趟；二叉树中，第h层最多有2的（h-1）次方个节点，换句话说，如果有n个节点，那么要满足不等式：n&lt;=2的(h-1)，解不等式等到h-1=log2n向上取整。所以结论：二路归并的趟数=log2n向上取整。</p>\n<p>（2）每趟归并的时间复杂度为O ( n ) ：因为是用i j 扫描，一共要进行n-1次关键字对比。</p>\n<p>（3）所以归并排序算法的<strong>时间复杂度为O(n*log2n)。</strong></p>\n<p><strong>稳定性</strong><br>\nmerge()操作的时候，如果i j 的key值相等，优先让靠左边的元素放入A，所以并不会改变相同关键字记录的相对次序，所以<strong>归并排序的算法是稳定的</strong>。</p>\n<p>从单个记录起进行两两归并并不值得提倡，通常将它和直接插入排序结合。改进后的归并排序仍是稳定的。</p>\n<h3 id=\"ji-shu-pai-xu\" id=\"基数排序\">基数排序</h3>\n<p>首先十位,然后百位然后千位…</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/196755.gif\" alt=\"img\"></p>\n<p>考试的时候最好这样来在草稿纸上写,我觉得容易理解些</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/4DC573A40401679E9C823922798EB67E.jpg\" alt=\"img\"></p>\n<p><strong>空间效率</strong><br>\n一趟排序需要辅助空间为 r（r个队列，r个队头指针和队尾指针）。空间复杂度为O ( r ) 。</p>\n<p><strong>时间效率</strong><br>\n基数排序需要进行 d 趟分配和收集，一趟分配需要O ( n ) ，一趟收集需要O ( r )。所以基数排序的时间复杂度为O ( d *( n + r ) ) 。每个元素拆成d部分，n是元素个数，r是基数（每个部分可能取得r个值）。其与序列的初始状态无关。</p>\n<p><strong>稳定性</strong><br>\n基数排序是稳定的。口诀：<strong>基你太稳</strong></p>\n<p>注意：基数排序不是基于比较的算法。之前学习的算法都是基于“比较”的算法</p>\n<p><strong>适用性</strong></p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/05a245c6-62b8-40e0-afe6-66f2e0165bb2.png\" alt=\"img\"></p>\n<h2 id=\"wai-bu-pai-xu-suan-fa\" id=\"外部排序算法\">外部排序算法</h2>\n<h3 id=\"duo-lu-gui-bing\" id=\"多路归并\">多路归并</h3>\n<h2 id=\"pai-xu-zong-jie\" id=\"排序总结\">排序总结</h2>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/f7b8687c-6c8d-4aaf-9a11-f5e0f9586917.png\" alt=\"img\"></p>\n<p><strong>稳定性</strong></p>\n<p>不稳定的算法口诀：<mark>“快些选堆”</mark>。快速排序、希尔排序、简单选择排序、堆排序</p>\n<p><strong>时间复杂度</strong></p>\n<p>时间较快的算法的口诀：<mark>“快些归队”</mark>。快速排序、希尔排序、归并排序、堆排序</p>\n<p>在实际应用中，快速排序往往可以优于其他算法，被认为是目前基于比较的内部排序中最好的方法。</p>\n<p><strong>空间复杂度</strong><br>\n大部分的算法的空间复杂度都是常量。空间复杂度的定义是用到的额外的辅助空间，不包含自己的空间的。</p>\n<p><strong>适用性</strong></p>\n<p>若 n 较小，可以采用直接插入排序或简单选择排序；若 n 较大，则应采用时间复杂度为n*(log n)的排序方法：<mark>“快些归队”</mark>。快速排序、希尔排序、归并排序、堆排序；</p>\n<p><strong>常考知识点</strong><br>\n（1）<strong>当关键字随机分布时，快速排序平均时间最短</strong>；（2）<strong>堆排序所需的辅助空间少于快速排序，且不会出现快速排序可能出现的最坏情况</strong>；（3）<strong>冒泡排序和堆排序每趟处理后都能产生当前的最大值或最小值</strong>。（4）<strong>快速排序一趟处理就能确定一个元素的最终位置</strong>。（5）当记录本身信息量较大时，为避免耗费大量时间移动记录，可以采用链表作为存储结构</p>\n<p>（6）<strong>每一趟都至少能确定一个元素的最终的位置的算法有</strong>：<mark>“快选一堆帽子”</mark>。<strong>快速排序、简单选择排序、堆排序、冒泡排序</strong>。</p>\n<h1 id=\"tu\">图</h1>\n<p><strong>图的定义</strong></p>\n<ol>\n<li class=\"lvl-3\">\n<p>线性表可以是空表，树可以是空树，但图不可以是空图（边集可以为空 顶点集非空）</p>\n</li>\n<li class=\"lvl-3\">\n<p>简单图 VS 多重图 <strong>不存在重复边</strong>，<strong>不存在顶点到自身的边</strong>，那么称此图为简单图</p>\n</li>\n</ol>\n<p>多重图和简单图定义是相对的，数据结构只讨论简单图</p>\n<ol>\n<li class=\"lvl-3\">\n<p>完全图：任意两个顶点之间都存在边</p>\n</li>\n<li class=\"lvl-3\">\n<p>并非V和E的任何子集都能构成G的子图</p>\n</li>\n<li class=\"lvl-3\">\n<p><strong>无向图讨论连通性，有向图讨论强连通性</strong></p>\n</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>无向图任意两个顶点都是连通的，为连通图</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>无向图的极大连通子图称为连通分量 同理定义强连通图和强连通分量</p></blockquote>\n<ol>\n<li class=\"lvl-3\">\n<p>连通图的生成树是包含图中全部顶点的一个极小连通子图</p>\n</li>\n<li class=\"lvl-3\">\n<p>非连通图中，连通分量的生成树构成非连通图的生成森林</p>\n</li>\n</ol>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/e265d7cdf80b495faa11a3a8d9eabe6etplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp\" alt=\"IMG_0086.jpeg\"></p>\n<h1 id=\"shu\">树</h1>\n<h2 id=\"shu-de-xing-zhi\" id=\"树的性质\">树的性质</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>树的结点数等于所有结点的度数加1.</p>\n</li>\n<li class=\"lvl-3\">\n<p>度为m的树中第i层上至多有$$m^{i-1}$$个结点（i&gt;=1)</p>\n</li>\n<li class=\"lvl-3\">\n<p>高度为h，度为m的树【<strong>度为m的树指的是结点最多有m个孩子结点</strong>】至多有$$\\frac{m^{h}-1}{m-1}$$个结点. （推导利用等比数列的求和公式）</p>\n</li>\n<li class=\"lvl-3\">\n<p>具有sum个结点，度为m的树的最小高度为$$⌈logm(sum(m−1)+1)⌉$$ (利用第三个公式逆推得到h，注意是向上取整)</p>\n</li>\n</ol>\n<h2 id=\"er-cha-shu-de-xing-zhi\" id=\"二叉树的性质\">二叉树的性质</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>二叉树的第i层上至多有$$2^{i-1}$$个结点</p>\n</li>\n<li class=\"lvl-3\">\n<p>深度为k的二叉树至多有$$2^k-1$$个结点.</p>\n</li>\n<li class=\"lvl-3\">\n<p><strong>对于一棵非空二叉树，如果叶子节点数为$$m_0$$,度为2的结点数$$m_2$$,则有$$m_0=m_2+1$$</strong> （重点经常在选择题遇到！！！）</p>\n</li>\n<li class=\"lvl-3\">\n<p>具有n个结点的完全二叉树的深度为$$\\lfloor log_2 n \\rfloor+1$$</p>\n</li>\n<li class=\"lvl-3\">\n<p>任何一棵完全二叉树中度为1的结点数要么有1个，要么就没有.</p>\n</li>\n</ol>\n<h2 id=\"er-cha-shu-de-bian-li\" id=\"二叉树的遍历\">二叉树的遍历</h2>\n<p>下面是三种遍历的递归代码，后续很多题型以此拓展得来。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">c复制代码<span class=\"token comment\">//二叉树的存储结构</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">BTNode</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">char</span> data<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">BTNode</span> <span class=\"token operator\">*</span>lchild<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">BTNode</span> <span class=\"token operator\">*</span>rchild<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//先序遍历 根左右</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">preorder</span><span class=\"token punctuation\">(</span>BTNode <span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">!=</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">Visit</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//对p进行访问。比如打印p对应的数值</span>\n        \n        <span class=\"token function\">preorder</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">-></span>lchild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">preorder</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">-></span>rchild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//中序遍历 左根右</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">inorder</span><span class=\"token punctuation\">(</span>BTNode <span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">!=</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">inorder</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">-></span>lchild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">Visit</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">inorder</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">-></span>rchild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">//后序遍历 左右根</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">postorder</span><span class=\"token punctuation\">(</span>BTNode <span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">!=</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">postorder</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">-></span>lchild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">postorder</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">-></span>rchild<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">Visit</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"xiang-guan-ti-xing\" id=\"相关题型\">相关题型</h3>\n<ol>\n<li class=\"lvl-3\">\n<p>表达式(a-(b+c))*(d/e)存储在一棵以二叉链表为存储结构的二叉树中，编写程序求表达式的值。（提示，左右子树不为空则为表达式，用后序遍历求值，左右子树都为空，则为数值）</p>\n</li>\n<li class=\"lvl-3\">\n<p>求一棵二叉树的深度。（提示左右子树深度最大值＋1）</p>\n</li>\n<li class=\"lvl-3\">\n<p>查找二叉树中等于key的结点是否存在。</p>\n</li>\n<li class=\"lvl-3\">\n<p><strong>根据前和后遍历序列不能确定二叉树</strong></p>\n</li>\n<li class=\"lvl-3\">\n<p>输出先序（中/后）遍历序列中第k个结点的值</p>\n</li>\n<li class=\"lvl-3\">\n<p><strong>使用非递归算法描述先序后序中序代码(利用栈)</strong></p>\n</li>\n</ol>\n<p>下面是层次遍历的代码</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//层次遍历</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">level</span><span class=\"token punctuation\">(</span>BTNode <span class=\"token operator\">*</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> front<span class=\"token punctuation\">,</span>rear<span class=\"token punctuation\">;</span>\n    BTNode <span class=\"token operator\">*</span>que<span class=\"token punctuation\">[</span>maxSize<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//定义一个循环队列</span>\n    front<span class=\"token operator\">=</span>rear<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    BTNode <span class=\"token operator\">*</span>q<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">!=</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        rear<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>rear<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>maxSize<span class=\"token punctuation\">;</span>\n        que<span class=\"token punctuation\">[</span>rear<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>p<span class=\"token punctuation\">;</span>                    <span class=\"token comment\">//根结点入队</span>\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>front<span class=\"token operator\">!=</span>rear<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            front<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>front<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>maxSize<span class=\"token punctuation\">;</span>\n            q<span class=\"token operator\">=</span>que<span class=\"token punctuation\">[</span>front<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>               <span class=\"token comment\">//队头结点出队</span>\n            <span class=\"token function\">Visit</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>q<span class=\"token operator\">-></span>lchild<span class=\"token operator\">!=</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>        <span class=\"token comment\">//左子树不空，左子树的根结点入队</span>\n                rear<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>rear<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>maxSize<span class=\"token punctuation\">;</span>\n                que<span class=\"token punctuation\">[</span>rear<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>q<span class=\"token operator\">-></span>lchild<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>q<span class=\"token operator\">-></span>rchild<span class=\"token operator\">!=</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>        <span class=\"token comment\">//右子树不空，右子树的根结点入队</span>\n                rear<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>rear<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>maxSize<span class=\"token punctuation\">;</span>\n                que<span class=\"token punctuation\">[</span>rear<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>q<span class=\"token operator\">-></span>rchild<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"xian-suo-er-cha-shu\" id=\"线索二叉树\">线索二叉树</h2>\n<p>有一棵结点数目为n的二叉树，采用二叉链表的形式存储。二叉链表中存在n+1个空指针域。</p>\n<p>可以利用这些空指针进行线索化。</p>\n<p><strong>若结点的左子树为空，则该结点的左孩子指针指向其前驱结点。</strong></p>\n<p><strong>若结点的右子树为空，则该结点的右孩子指针指向其后继结点。</strong></p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/fedb2ecd7b8446d7b11862946d577dc9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp\" alt=\"image.png\"></p>\n<h2 id=\"shu-he-sen-lin\" id=\"树和森林\">树和森林</h2>\n<p>要熟悉二叉树、树和森林之间的相互转换过程</p>\n<p>（1）树转为二叉树</p>\n<p>加线–去线–调整</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/6ad5b094e48547ad9384e43476496f46tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp\" alt=\"image.png\"></p>\n<p>（2）森林转换为二叉树</p>\n<p>每个树转为二叉树–再连接起来</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/9aa8b021c8b14ac2830bc03dc3723f43tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp\" alt=\"image.png\"></p>\n<p>（3）二叉树转换为树</p>\n<p>加线–去线–调整</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/89c86090e3324654bc6d84bb8cbe7f05tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp\" alt=\"image.png\"></p>\n<p>（4）二叉树转换为森林</p>\n<p>如果二叉树的根节点有右孩子，那么这棵二叉树能够转换为森林，否则将转换为一棵树。</p>\n<p>从根结点开始，与右孩子连接的线去掉–再将分离的二叉树分别转为树 <img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/2e724716ed6845ceae828cc7fcaf0251tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp\" alt=\"image.png\"></p>\n<p><strong>习题</strong></p>\n<p>【2014年408】</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/23f2a1d38922435592683f181b430ec2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp\" alt=\"image.png\"></p>\n<details>\n<summary><mark>点击查看答案</mark></summary>\n可以通过上述森林转二叉树的例子看到叶节点个数等于没有左孩子的结点个数。选C\n</details>\n<p>除了以上三者转换的内容，还需要注意的是树和森林的遍历。</p>\n<ol>\n<li class=\"lvl-3\">\n<p>先根遍历。 若树不为空，先访问根结点，再依次遍历根结点的每棵子树。</p>\n</li>\n</ol>\n<p><strong>其遍历序列与这棵树相应的二叉树的先序序列相同。</strong></p>\n<ol>\n<li class=\"lvl-3\">\n<p>后根遍历</p>\n</li>\n</ol>\n<p>若树不为空，先依次遍历根结点的每棵子树，再访问根结点。</p>\n<p><strong>其遍历序列和这棵树相应的二叉树的中序序列相同。</strong></p>\n<ol>\n<li class=\"lvl-3\">\n<p>树也有层次遍历，与二叉树的层次遍历思想基本相同。</p>\n</li>\n</ol>\n<p>森林也有两种遍历方式，森林的先序和中序遍历即对应二叉树的先序遍历和中序遍历。</p>\n<p>部分教材会把森林的中序遍历称为后根遍历。</p>\n<table>\n<thead>\n<tr>\n<th>树</th>\n<th>森林</th>\n<th>二叉树</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>先根遍历</td>\n<td>先序遍历</td>\n<td>先序遍历</td>\n</tr>\n<tr>\n<td>后根遍历</td>\n<td>中序遍历</td>\n<td>中序遍历</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"ying-yong\" id=\"应用\">应用</h2>\n<h3 id=\"bing-cha-ji\" id=\"并查集\">并查集</h3>\n<h4 id=\"luo-ji-jie-gou\" id=\"逻辑结构\">逻辑结构</h4>\n<p>元素之间为集合关系，主要有查操作和并操作，存储结构可以采用双亲表示法。 [图片来源网络]</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/750ba5cb4413489ea9a8e8b396df8404tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp\" alt=\"image.png\"></p>\n<h4 id=\"dai-ma-shi-xian\" id=\"代码实现\">代码实现</h4>\n<p>初始化</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">c复制代码#define SIZE <span class=\"token number\">13</span>\n<span class=\"token keyword\">int</span> UFSets<span class=\"token punctuation\">[</span>SIZE<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//集合元素数组</span>\n\n<span class=\"token comment\">//初始化并查集</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">Initial</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> S<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span>SIZE<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        S<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>”查“操作，返回x所属的根结点。</p>\n<p>最坏时间复杂度为O（n）</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">c复制代码<span class=\"token keyword\">int</span> <span class=\"token function\">Find</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> S<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//找x所属的集合</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        x<span class=\"token operator\">=</span>S<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\">//循环寻址x的根</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>           <span class=\"token comment\">//根的s[]小于0,返回根结点的编号</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>”并“操作</p>\n<p>时间复杂度为O（1）</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">c复制代码<span class=\"token keyword\">void</span> <span class=\"token function\">Union</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> S<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> Root1<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> Root2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>Root1 <span class=\"token operator\">!=</span> Root2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//要求Root1和Root2是不同的集合</span>\n        S<span class=\"token punctuation\">[</span>Root2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Root1<span class=\"token punctuation\">;</span>  <span class=\"token comment\">//将根Root2连接到另一根Root1的下面</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>优化思路：每次合并的操作让树尽量不长太高。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>用根结点的绝对值表示树的结点总数</p>\n</li>\n<li class=\"lvl-2\">\n<p>让小树合并到大树</p>\n</li>\n</ul>\n<p>优化后的”并“操作</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">c复制代码<span class=\"token keyword\">void</span> <span class=\"token function\">Union</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> S<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> Root1<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> Root2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>Root1 <span class=\"token operator\">==</span> Root2<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">[</span>Root2<span class=\"token punctuation\">]</span><span class=\"token operator\">></span>S<span class=\"token punctuation\">[</span>Root1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>   <span class=\"token comment\">//Root2的结点数更少</span>\n        S<span class=\"token punctuation\">[</span>Root1<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> S<span class=\"token punctuation\">[</span>Root2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//累加结点个数</span>\n        S<span class=\"token punctuation\">[</span>Root2<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Root1<span class=\"token punctuation\">;</span>      <span class=\"token comment\">//小树合并到大树</span>\n    <span class=\"token punctuation\">&#125;</span>esle<span class=\"token punctuation\">&#123;</span>\n        S<span class=\"token punctuation\">[</span>Root2<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> S<span class=\"token punctuation\">[</span>Root1<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//累加结点个数</span>\n        S<span class=\"token punctuation\">[</span>Root1<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Root2<span class=\"token punctuation\">;</span>      <span class=\"token comment\">//小树合并到大树</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>该方法构造的树高不超过log2n向下取整+1</p>\n<p>所以优化后，Find操作最坏时间复杂度：O（log2n）</p>\n<h4 id=\"ying-yong-1\" id=\"应用-2\">应用</h4>\n<h5 id=\"pan-duan-tu-de-lian-tong-fen-liang-shu\" id=\"判断图的连通分量数\">判断图的连通分量数</h5>\n<p><strong>遍历无向图的邻接矩阵的上三角区域，利用并查集进行合并</strong>，连通分量会被化为一个集合。</p>\n<p>最后遍历并查集，<strong>有多少个小于0的值即为连通分量的个数</strong>。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">ComponentCount</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> g<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//g[5][5]二维数组表示的邻接矩阵</span>\n    <span class=\"token keyword\">int</span> S<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> S<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//初始化并查集</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//遍历各条边，无向图遍历上三角型。</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//结点i、j有边</span>\n                <span class=\"token keyword\">int</span> iRoot <span class=\"token operator\">=</span> <span class=\"token function\">Find</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">,</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">int</span> jRoot <span class=\"token operator\">=</span> <span class=\"token function\">Find</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">,</span>j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>iRoot <span class=\"token operator\">!=</span> jRoot<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//i，j并入同一集合</span>\n                    <span class=\"token function\">Union</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">,</span>iRoot<span class=\"token punctuation\">,</span>jRoot<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token comment\">//统计有几个连通分量</span>\n    <span class=\"token keyword\">int</span> count<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n            count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> count<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"pan-duan-tu-shi-fou-you-huan\" id=\"判断图是否有环\">判断图是否有环</h5>\n<p>已经连通的子图中，但凡再多出来一条边，这个子图就一定有环。</p>\n<p>代码在上面的基础上加一条判断即可。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>iRoot <span class=\"token operator\">!=</span> jRoot<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span> <span class=\"token comment\">//i，j并入同一集合</span>\n     <span class=\"token function\">Union</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">,</span>iRoot<span class=\"token punctuation\">,</span>jRoot<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">&#123;</span><span class=\"token comment\">//!!!i，j原本在同一个集合</span>\n     <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//在一个连通子图中，再多一条边，必有环。</span>\n<span class=\"token punctuation\">&#125;</span>\n                <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"shi-xian-kruskal-suan-fa\" id=\"实现Kruskal算法\">实现Kruskal算法</h5>\n<p>各条边按权值递增排序，依次处理各条边。</p>\n<p>通过Find操作确定一条边所连接的两个顶点是否属于同一个集合，如果不属于同一个集合，则将这条边加入生成树，并将两个点所属集合Union。</p>\n<h5 id=\"bu-chong-bing-cha-ji-you-hua-ya-suo-lu-jing\" id=\"补充并查集优化–压缩路径\">补充并查集优化–压缩路径</h5>\n<p>Find操作:先找到根结点，再将查找路径上所有结点都挂载到根结点上，下一次再查该节点只需要O（1），可以使树高不超过a(n)增长很慢的函数。</p>\n<p>比如下图（来源网络）就是一种压缩路径的表现</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/cb7befdd067d46cea8bda36ae46566cdtplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp\" alt=\"image.png\"></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> <span class=\"token function\">Find</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> S<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> root <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">[</span>root<span class=\"token punctuation\">]</span><span class=\"token operator\">>=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>  root<span class=\"token operator\">=</span>S<span class=\"token punctuation\">[</span>root<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//循环找到根</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">!=</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>  <span class=\"token comment\">//压缩路径</span>\n        <span class=\"token keyword\">int</span> t<span class=\"token operator\">=</span>S<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//t指向x的父节点</span>\n        S<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> root<span class=\"token punctuation\">;</span> <span class=\"token comment\">//x直接挂载到根结点</span>\n        x<span class=\"token operator\">=</span>t<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">return</span> root<span class=\"token punctuation\">;</span>       <span class=\"token comment\">//返回根结点的编号</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>最后总结如下：</p>\n<p><img src=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/fb9327ddcde1417495a4adbf31455719tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp\" alt=\"image.png\"></p>\n<h3 id=\"er-cha-pai-xu-shu-bst\" id=\"二叉排序树（BST）\">二叉排序树（BST）</h3>\n<p>查找和插入的操作比较简单</p>\n<p>沿着根结点，左小右大的策略进行查找或者插入操作。</p>\n<p>需要注意的是删除操作</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>如果被删的是叶节点，直接删除，不会破坏二叉树的性质。</p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>如果被删结点z只有一棵左子树或右子树，则让z的子树成为z父节点的子树。</strong></p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>如果被删结点z有左右两棵子树，用z的直接后继（直接前驱）代替z。</strong></p>\n</li>\n</ul>\n<p>二叉树的查找效率取决于树高。</p>\n<p>二分查找的判定树唯一，而二叉排序树的查找不唯一。</p>\n<h3 id=\"ping-heng-er-cha-shu\" id=\"平衡二叉树\">平衡二叉树</h3>\n<p>需要熟悉四种调整操作：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>LL（右单旋转）</p>\n</li>\n<li class=\"lvl-2\">\n<p>RR（左单旋转）</p>\n</li>\n<li class=\"lvl-2\">\n<p>LR（先左旋后右旋）</p>\n</li>\n<li class=\"lvl-2\">\n<p>RL（先右旋再左旋）</p>\n</li>\n</ul>\n<p>其他注意的tip： 含有n个结点的平衡二叉树的最大深度为log<sub>2</sub>（n），因此平均查找长度为log<sub>2</sub>（n）。</p>\n<h3 id=\"ha-fu-man-shu\" id=\"哈夫曼树\">哈夫曼树</h3>\n<p>会计算WPL，构造哈夫曼编码。</p>\n<p>构造核心是<strong>每次选取两个权植最小的树作为新结点的左右子树</strong>。</p>\n","feature":true,"text":"排序算法 内部排序算法 插入排序 将一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部记录插入完成。 直接插入排序 插入排序通常采用就地排序，在从后向前的比较过程中，需要反复把已排序元素逐步向后挪位，为新元素腾出插入空间。 空间效率 仅使用了常数个辅助单元，空间复杂...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[{"name":"计算机基础","slug":"计算机基础","count":5,"path":"api/categories/计算机基础.json"},{"name":"数据结构基础","slug":"计算机基础/数据结构基础","count":1,"path":"api/categories/计算机基础/数据结构基础.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#pai-xu-suan-fa\"><span class=\"toc-text\">排序算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nei-bu-pai-xu-suan-fa\"><span class=\"toc-text\">内部排序算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#cha-ru-pai-xu\"><span class=\"toc-text\">插入排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#zhi-jie-cha-ru-pai-xu\"><span class=\"toc-text\">直接插入排序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#zhe-ban-cha-ru-pai-xu\"><span class=\"toc-text\">折半插入排序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#xi-er-pai-xu\"><span class=\"toc-text\">希尔排序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#jiao-huan-pai-xu\"><span class=\"toc-text\">交换排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#mou-pao-pai-xu\"><span class=\"toc-text\">冒泡排序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#mark-kuai-su-pai-xu-mark\"><span class=\"toc-text\">快速排序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xuan-ze-pai-xu\"><span class=\"toc-text\">选择排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#jian-dan-xuan-ze-pai-xu\"><span class=\"toc-text\">简单选择排序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#dui-pai-xu\"><span class=\"toc-text\">堆排序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#gui-bing-pai-xu\"><span class=\"toc-text\">归并排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#er-lu-gui-bing\"><span class=\"toc-text\">二路归并</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ji-shu-pai-xu\"><span class=\"toc-text\">基数排序</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#wai-bu-pai-xu-suan-fa\"><span class=\"toc-text\">外部排序算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#duo-lu-gui-bing\"><span class=\"toc-text\">多路归并</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#pai-xu-zong-jie\"><span class=\"toc-text\">排序总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#tu\"><span class=\"toc-text\">图</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#shu\"><span class=\"toc-text\">树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#shu-de-xing-zhi\"><span class=\"toc-text\">树的性质</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#er-cha-shu-de-xing-zhi\"><span class=\"toc-text\">二叉树的性质</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#er-cha-shu-de-bian-li\"><span class=\"toc-text\">二叉树的遍历</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#xiang-guan-ti-xing\"><span class=\"toc-text\">相关题型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#xian-suo-er-cha-shu\"><span class=\"toc-text\">线索二叉树</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#shu-he-sen-lin\"><span class=\"toc-text\">树和森林</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ying-yong\"><span class=\"toc-text\">应用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bing-cha-ji\"><span class=\"toc-text\">并查集</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#luo-ji-jie-gou\"><span class=\"toc-text\">逻辑结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#dai-ma-shi-xian\"><span class=\"toc-text\">代码实现</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ying-yong-1\"><span class=\"toc-text\">应用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#pan-duan-tu-de-lian-tong-fen-liang-shu\"><span class=\"toc-text\">判断图的连通分量数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#pan-duan-tu-shi-fou-you-huan\"><span class=\"toc-text\">判断图是否有环</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#shi-xian-kruskal-suan-fa\"><span class=\"toc-text\">实现Kruskal算法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#bu-chong-bing-cha-ji-you-hua-ya-suo-lu-jing\"><span class=\"toc-text\">补充并查集优化–压缩路径</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#er-cha-pai-xu-shu-bst\"><span class=\"toc-text\">二叉排序树（BST）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ping-heng-er-cha-shu\"><span class=\"toc-text\">平衡二叉树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ha-fu-man-shu\"><span class=\"toc-text\">哈夫曼树</span></a></li></ol></li></ol></li></ol>","author":{"name":"ND_LJQ","slug":"blog-author","avatar":"/svg/head.jpg","link":"/","description":"一位正在摆烂的大四渣滓😋 <br /> @ <b>劉三刀的摆烂生活</b>","socials":{"github":"https://github.com/ND-LJQ","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_52475868?type=blog","juejin":"https://juejin.cn/user/2032336272362109","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/391491132?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/liu-jq"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"操作系统基础","uid":"09303d998ed7337d46bfa9387efc032e","slug":"操作系统基础","date":"2023-07-20T12:14:48.000Z","updated":"2023-10-12T07:00:58.875Z","comments":true,"path":"api/articles/操作系统基础.json","keywords":null,"cover":"/svg/welcome-cover.jpg","text":"计算机系统概论 操作系统的基本概念 【考纲内容】 (一）操作系统的概念、特征、功能和提供的服务 (二）操作系统的发展与分类 (三）操作系统的运行环境 内核态与用户态;中断、异常;系统调用 (四）操作系统体系结构 【知识框架】 概论 特征 并发(最基本) 共享(最基本) 虚拟 同步...","link":"","photos":[],"count_time":{"symbolsCount":"130k","symbolsTime":"1:58"},"categories":[{"name":"计算机基础","slug":"计算机基础","count":5,"path":"api/categories/计算机基础.json"},{"name":"操作系统","slug":"计算机基础/操作系统","count":1,"path":"api/categories/计算机基础/操作系统.json"}],"tags":[{"name":"操作系统","slug":"操作系统","count":1,"path":"api/tags/操作系统.json"}],"author":{"name":"ND_LJQ","slug":"blog-author","avatar":"/svg/head.jpg","link":"/","description":"一位正在摆烂的大四渣滓😋 <br /> @ <b>劉三刀的摆烂生活</b>","socials":{"github":"https://github.com/ND-LJQ","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/qq_52475868?type=blog","juejin":"https://juejin.cn/user/2032336272362109","customs":{"bilibili":{"icon":"/svg/bilibili-fill.svg","link":"https://space.bilibili.com/391491132?spm_id_from=333.1007.0.0"},"gitee":{"icon":"/svg/gitee-fill-round.svg","link":"https://gitee.com/liu-jq"}}}},"feature":true}}