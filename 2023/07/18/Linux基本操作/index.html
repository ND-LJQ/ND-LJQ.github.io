
<!DOCTYPE html>
<html lang="cn" class="loading">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
      name="viewport"
      content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Linux基本操作 - 刘三刀的blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="google" content="notranslate" />
    
    <meta name="keywords" content="刘三刀的blog," />
     
    <meta name="description" content="Linux 简介Linux 系统的起源与发展Linux 是一种免费使用和自由传播的类 UNIX 操作系统,是一个基于 POSIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。它能运行主要的," />
     
    <meta name="author" content="ND_LJQ" />
     
    <link
      rel="alternative"
      href="atom.xml"
      title="刘三刀的blog"
      type="application/atom+xml"
    />
     
    <link rel="icon" href="/img/favicon.png" />
     
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">
 
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">
 
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">
 
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">
 
<link rel="stylesheet" href="/css/obsidian.css">
 
<link rel="stylesheet" href="/css/ball-atom.min.css">
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
 
    <link
      href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css"
      rel="stylesheet"
    />
    <script>
      var musiclist = '';
    </script>
    
<script src="/js/loadaplayer.js"></script>

    <!-- 引用依赖 -->
    
<link rel="stylesheet" href="/aplayer/dist/APlayer.min.css">
 
<script src="/aplayer/dist/APlayer.min.js"></script>
<script src="/js/Meting.min.js"></script>
 
  <meta name="generator" content="Hexo 6.3.0"></head>
</html>


<body class="loading">
    <div class="loader">
        <div class="la-ball-atom la-2x">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
    <span id="config-title" style="display:none">刘三刀的blog</span>
    <div id="loader"></div>
    <div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="/img/favicon.png" alt="" data-url="https://nd-ljq.github.io">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">Linux基本操作</h3>
        <div class="social">
            <!--        <div class="like-icon">-->
            <!--            <a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
            <!--        </div>-->
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
            animation-delay: 600ms;
            animation-duration: 1.2s;
            background-image: 
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url('/img/cover.jpg') ">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                <a href="/categories/运维"><b>「
                    </b>运维<b> 」</b></a>
                
                July 18, 2023
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" title="Linux基本操作" class="">Linux基本操作</a>
            </h3>
            
            <p class="post-count animated fadeInDown">
                
                <span>
                    <b class="iconfont icon-text2"></b> <i>Words count</i>
                    116k
                </span>
                
                
                <span>
                    <b class="iconfont icon-timer__s"></b> <i>Reading time</i>
                    1:45
                </span>
                
                
                
                <span id="busuanzi_container_page_pv">
                    <b class="iconfont icon-read"></b> <i>Read count</i>
                    <span id="busuanzi_value_page_pv">0</span>
                </span>
                
            </p>
            
            
            <ul class="animated fadeInDown post-tags-list" itemprop="keywords"><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s"></span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <h1 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h1><h2 id="Linux-系统的起源与发展"><a href="#Linux-系统的起源与发展" class="headerlink" title="Linux 系统的起源与发展"></a>Linux 系统的起源与发展</h2><p><strong>Linux 是一种免费使用和自由传播的类 UNIX 操作系统</strong>,是一个基于 POSIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。它能运行主要的 Unix 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心 的设计思想，是一个性能稳定的多用户网络操作系统。并且 Linux 是一款自由软件，可以完全免费自由地提供给用户使用。</p>
<h2 id="Linux-系统的介绍"><a href="#Linux-系统的介绍" class="headerlink" title="Linux 系统的介绍"></a>Linux 系统的介绍</h2><h3 id="Linux-系统的特点"><a href="#Linux-系统的特点" class="headerlink" title="Linux 系统的特点"></a>Linux 系统的特点</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>① <strong>一切都是文件</strong> :系统中的所有都归结为一个文件，包括命令、硬件和软件设备、操作系统、进程 等等对于操作系统内核而言，都被视为拥有各自特性或类型的文件。</p>
<p>② <strong>每个文件都有确定的用途</strong></p>
<p><strong>==特点==</strong></p>
<p>① <strong>开放系统</strong> : Linux 系统遵循[[计算机网络基础#==OSI与TCP/IP模型==|开放式系统互联通信参考模型（Open System Interconnection Reference Model，缩写为 OSI）]]</p>
<p>② <strong>完全开源免费</strong></p>
<p>③ <strong>多用户、多用户</strong> : 多用户是指系统资源可以被不同用户同各自拥有，即每个用户对自己的资源（文件、设备） 有特定的权限，并且互不影响。</p>
<p>④ <strong>出色的稳定性和速度性能</strong> : Linux 可以连续运行很长时间而不需要重启（Linux 的主要使用场景是作为服务器，服务器是很 大重启或者关机的）</p>
<p>⑥ <strong>安全可靠的系统</strong> : Linux 采取了许多安全技术措施，可以在网络及多用户的情况下提供：包括对读/写文件系统进 行权限的限制、核心程序、关键操作的授权等。再有由于 Linux 是开源免费的（不像 Winidows），在敏感行业（政府、军工）可以避免后门漏洞造成的系统安全问题。</p>
<p>⑦ <strong>提供丰富的网络功能 </strong>: Linux 的设计初衷就是基于网络，所以 Linux 系统中有完善的内置网络服务，比如： DNS,DHCP,Samba 等，完善的网络服务也是 Linux 由于其它操作系统的一个原因</p>
<p>⑧ <strong>支持多种平台</strong> : Linux 可以运行在多种硬件平台上，如具有 x86、ARM、SPARC 等处理器的平台架构。此外 Linux 还是一种嵌入式操作系统，可以运行在掌上电脑、手机、机顶盒或游戏机上。</p>
<p>⑨ <strong>良好的界面</strong> : Linux 同时具有字符界面和图形界面。在字符界面用户可以通过键盘输入相应的指令来进行操 作。它同时也提供了类似 Windows 图形界面的 X-Window 系统</p>
<h3 id="Linux-系统的组成"><a href="#Linux-系统的组成" class="headerlink" title="Linux 系统的组成"></a>Linux 系统的组成</h3><p>Linux 系统一般有 4 个主要部分：<strong>内核</strong>、<strong>shell</strong>、<strong>文件系统</strong>和<strong>应用程序</strong>，如下图所示（最内层是各种硬件设备）。</p>
<p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/11.png" alt="image-20230623105133894"></p>
<h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>内核(Kernel)是操作系统的核心，具有很多最基本功能，它负责管理系统的进程、内存、设备 驱动程序、文件和网络系统，决定着系统的性能和稳定性。内核从应用层接受命令，根据调度算 法调度相关进程使用系统资源，使得程序能够顺利的运行。</p>
<p>Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。</p>
<h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p>shell 是一种<strong>命令解释器</strong>，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令 并把它送入内核去执行，并且将执行的结果返回个给用户。shell 还有自己的编程语言，运行用户 编写由 shell 命令组成的程序。</p>
<p>shell 有多个版本，目前主流的 shell 版本有四个：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>BASH</td>
<td>bash 是 BourneAgain Shell 的缩写，<em>bash 是 Linux 标准默认的 shell</em>。它基于 Bourne shell，吸收了 C shell 和 Korn shell 的一些特性。bash 完全兼容 Bourne shell。</td>
</tr>
<tr>
<td>Bourne Shell</td>
<td>一般缩写成 sh，由贝尔实验室开发，<em>是 Unix 标准默认的 shell</em>。</td>
</tr>
<tr>
<td>Korn Shell</td>
<td>Korn shell 缩写 ksh，其特点是兼容性好。</td>
</tr>
<tr>
<td>C Shell</td>
<td>Sun 公司 Shell 的 BSD 版本。</td>
</tr>
</tbody>
</table>
</div>
<p>shell 是用户与 Linux 操作系统之间的沟通的桥梁，在使用 shell 命令之前了解一下 Shell 命令的格式：</p>
<pre><code class="lang-shell"> 命令名称 [选项] [参数1] [参数2]...
</code></pre>
<p><strong>命令名</strong>：需要提交给系统执行的命令，这些命令是个可执行文件或 She 脚本文件。</p>
<p><strong>选项</strong>：是对命令的特别定义，以短线(-) 开始。在 Linux 中，如果一个命令有多个选项可以使用一 个短线 (-)将所有选项连接起来，也可分开输入。同一个命令可以通过不同的选项来实现不同的功 能。</p>
<p><strong>参数</strong>：是提供给命令运行的信息或命令执行过程中所使用的文件名。 一个简单的 Shell 命令可以只有命令名，复杂一些的可以通过不同的选项和参数来实现命令、选项以及参数之间通过空格键来分隔。如果有多条命令要执行，可将这些令输入在一行中， 各命令 之间用分号(;) 进行分隔。命令的执行顺序与输入的顺序相同。</p>
<p><strong>文件系统</strong>:文件系统是文件存放在磁盘等存储设备上的存储规则，系统只有规定了文件系统，也就是文件数据的存储组织方式，数据的读/写才能正常进行。目前 Linux 支持多种文件系统，如 EXT2、 EXT3、 XFS、FAT、 VFAT 和 MFS 等。</p>
<p><strong>应用程序</strong>:标准的 Linux 系统除了系统核心外，一般都有一套都有称为应用程序的程序集，以方便用户的 使用。它包括文本编辑器（vi）、编程语言、XWindow、办公套件、Internet 工具和数据库等。</p>
<h1 id="Linux-的基本操作"><a href="#Linux-的基本操作" class="headerlink" title="Linux 的基本操作"></a>Linux 的基本操作</h1><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><pre><code class="lang-shell">xfs #centOs7 默认的文件系统 高性能日志文件系统
ext2 #linux自带的文件系统类型
ext3 #是在ext2的基础之上发展演变而来的，二者区别在于ext3文件系统带有日志功能，它会跟踪对于磁盘的写入操作并记录于日志，这样可以在需要时回溯查找。
swap #文件系统在 Linux中作为交换分区的文件系统使用。交换分区是在硬盘上分配出来的一块存储空间，用来弥补物理内存空间的不足。交换空间由操作系统自动管理。因为Linux系统有提前读和延后写的操作机制，所以在安装Linux系统的过程中，交换分区是必须被分配的，其文件系统类型是swap。
</code></pre>
<h3 id="各个系统文件夹的意义"><a href="#各个系统文件夹的意义" class="headerlink" title="各个系统文件夹的意义"></a>各个系统文件夹的意义</h3><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/22.png" alt="image-20230623111250592"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">目录</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/</td>
<td>根目录</td>
</tr>
<tr>
<td style="text-align:center">/boot</td>
<td>引导程序，内核等存放的目录</td>
</tr>
<tr>
<td style="text-align:center"><strong>/sbin</strong></td>
<td>超级用户可以使用的命令的存放目录 —软链接(快捷方式) 真实路径是/usr/sbin</td>
</tr>
<tr>
<td style="text-align:center">/selinux</td>
<td>这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类 似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的。</td>
</tr>
<tr>
<td style="text-align:center">/srv</td>
<td>该目录存放一些服务启动之后需要提取的数据。</td>
</tr>
<tr>
<td style="text-align:center"><strong>/bin</strong></td>
<td>普通用户可以使用的命令的存放目录 —软链接(快捷方式) 真实路径是/usr/bin</td>
</tr>
<tr>
<td style="text-align:center"><strong>/lib</strong></td>
<td>根目录下的所程序的共享库目录</td>
</tr>
<tr>
<td style="text-align:center"><strong>/dev</strong></td>
<td>设备文件目录 在 linux 系统中设备是以文件的形式存在,通过访问设备文件(设备驱动)则可以访问到设备</td>
</tr>
<tr>
<td style="text-align:center">/home</td>
<td>普通用户的家目录</td>
</tr>
<tr>
<td style="text-align:center"><strong>/root</strong></td>
<td>用户 root 的$HOME 目录</td>
</tr>
<tr>
<td style="text-align:center">/etc</td>
<td>全局的配置文件存放目录。 —系统和程序一般都可以通过修改相应的配置文件，来进行配置</td>
</tr>
<tr>
<td style="text-align:center"><strong>/usr</strong></td>
<td>这个目录中包含了命令库文件和在通常操作中不会修改的文件。 —安装程序时默认安装到此目录下的某个子目录 (相当于 window 中软件默认安装到 Program Files 文件夹中)<br> <em>/usr/local</em> 程序默认安装位置<br> <em>/usr/sbin</em> 超级用户使用的比较高级的管理程序和系统守护程序。<br> <em>/usr/src</em> 内核源代码默认的放置目录。</td>
</tr>
<tr>
<td style="text-align:center"><strong>/opt</strong></td>
<td>可择的文件目录<br>这个目录表示的是可择的意思，些自定义软件包或者第三方工具，就可以安装在这里。(比如自己编的程序可以安装到这里)</td>
</tr>
<tr>
<td style="text-align:center"><strong>/mnt</strong></td>
<td>临时挂载目录<br>这个目录一般是用于存放挂载储存设备的挂载目录的，比如磁盘，光驱，网络文件系统等，当我们需要挂载某个磁盘设备的时候，可以把磁盘设备挂载到这个目录上去</td>
</tr>
<tr>
<td style="text-align:center"><strong>/media</strong></td>
<td>挂载的媒体设备目录<br>例如 u 盘</td>
</tr>
<tr>
<td style="text-align:center">/tmp</td>
<td>临时文件目录<br>该目录存放系统中的一些临时文件，文件可能会被系统自动清空。</td>
</tr>
<tr>
<td style="text-align:center">/proc</td>
<td>process(进程)的缩写</td>
</tr>
<tr>
<td style="text-align:center">/var</td>
<td>var 是 variable(变量) 的缩写，用于存放运行时需要改变数据的文件，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</td>
</tr>
<tr>
<td style="text-align:center">/run</td>
<td>是一个临时文件系统，存储系统启动以来的信息。当系统重启时,这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让 它指向 run。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>特殊目录</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td>当前目录</td>
</tr>
<tr>
<td style="text-align:center">..</td>
<td>上一级目录</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td>用户的主目录</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td>前一个工作目录</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="lang-shell"># 当前目录
cd .
# 上一级目录
cd ..
# 去用户的主目录
cd ~
# 去上一次目录
cd -
</code></pre>
<p><strong>文件的命名</strong></p>
<p>Linux 支持长文件名，最长可以达到<code>256字节</code>。Linux 的文件名中不能含有空格和以下特殊字符：</p>
<pre><code class="lang-shell">! @ # ￥ % ~ &amp; × () [] &#123;&#125; &#39; &quot; \ / | ; &lt; &gt; &lt;&lt; &gt;&gt;
</code></pre>
<p><a href="###文件">文件介绍之后进行,先进行系统基础命令的学习</a></p>
<h2 id="系统基础命令"><a href="#系统基础命令" class="headerlink" title="系统基础命令"></a>系统基础命令</h2><h3 id="查看-修改当前时间"><a href="#查看-修改当前时间" class="headerlink" title="查看/修改当前时间"></a>查看/修改当前时间</h3><pre><code class="lang-shell">date [-options] [mm/dd/yy] [hh:mm:ss]

options:
    d : 设置年月日
    s : 设置时分秒

    #设置月日年
    date -d 02/28/21

    #设置时分秒
    date -s 23:45:00
</code></pre>
<h3 id="查看命令类型"><a href="#查看命令类型" class="headerlink" title="查看命令类型"></a>查看命令类型</h3><pre><code class="lang-shell">type 命令名称

[nd_ljq@ROOT ~]$ type ifconfig
ifconfig is /usr/sbin/ifconfig
[nd_ljq@ROOT ~]$ type type
type is a shell builtin

ps:若响应为路径则代表这条命令是`外部命令`
   若响应为`xxx is a shell builtin`则代表这条命令是`内核命令`
</code></pre>
<h3 id="查看命令帮助文档"><a href="#查看命令帮助文档" class="headerlink" title="查看命令帮助文档"></a>查看命令帮助文档</h3><pre><code class="lang-shell">help [options] 命令名称

help type
help cd

ps:该命令只能用来查询linux`内部命令`的帮助文档
</code></pre>
<pre><code class="lang-shell">man [options] 命令名称

man ssh

ps: man（manual：手册），“Linux System Administrator&#39;s Manual”，命令可以快速查询Linux
命令（内核命令/外部命令）的详细描述和使用方法。
</code></pre>
<h3 id="查看系统基础信息"><a href="#查看系统基础信息" class="headerlink" title="查看系统基础信息"></a>查看系统基础信息</h3><pre><code class="lang-shell">uname [options] [--help][--version]

options:
    -a 或--all 　显示全部的信息，包括内核名称、主机名、操作系统版本、处理器类型和硬件架构等。
    -m 或--machine 　显示处理器类型。
    -n 或--nodename 　显示主机名。
    -r 或--release 　显示内核版本号。
    -s 或--sysname 　显示操作系统名称。
    -v 　显示操作系统的版本。
    --help 　显示帮助。
    --version 　显示版本信息。
    -p 显示处理器类型（与 -m 选项相同）。
</code></pre>
<h3 id="查看历史输入"><a href="#查看历史输入" class="headerlink" title="==查看历史输入=="></a>==查看历史输入==</h3><pre><code class="lang-shell">history num

ps: num为选取最近的n条指令打印
</code></pre>
<h3 id="注销用户"><a href="#注销用户" class="headerlink" title="注销用户"></a>注销用户</h3><pre><code class="lang-shell">logout
exit
</code></pre>
<h3 id="重启与关机"><a href="#重启与关机" class="headerlink" title="==重启与关机=="></a>==重启与关机==</h3><pre><code class="lang-shell">shutdown [-t seconds] [option] time [message]

-t seconds : 设定在几秒钟之后进行关机程序。
-k : 并不会真的关机，只是将警告讯息传送给所有使用者。
-r : (reboot)关机后重新开机。
-h : (halt)关机后停机。
-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。
-c : 取消目前已经进行中的关机动作。
time : 设定关机的时间。
message : 传送给所有使用者的警告讯息。

shutdown -k 5 &quot;system will be reboot! &quot;
!号后要有空格

poweroff 关机

reboot 重启
</code></pre>
<h3 id="组-用户的操作"><a href="#组-用户的操作" class="headerlink" title="==组/用户的操作=="></a>==组/用户的操作==</h3><blockquote>
<p>对用户组的操作,实质性是对/etc/group 文件和/etc/gshadow 文件的操作</p>
</blockquote>
<h4 id="创建组"><a href="#创建组" class="headerlink" title="创建组"></a>创建组</h4><pre><code class="lang-shell">groupadd [-g gid] groupName

ps: -g 为指定组的id
</code></pre>
<h4 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h4><pre><code class="lang-shell">groupdel goupName

ps:删除组的前提是这个组为空
</code></pre>
<blockquote>
<p>对用户的操作,实质上是对/etc/passwd 文件的操作</p>
<p>用户的密码是经过加密后存储在 /etc/shadow 文件中</p>
<p>查看所有用户可以查看/etc/passwd 文件中的记录数</p>
<p>查看组(组数)可以查看/etc/group 文件中的记录数</p>
</blockquote>
<p>/etc/passwd 中</p>
<p>每一行有七个字段组成，之间用”:”分隔，各个字段的顺序和含义如下：</p>
<pre><code class="lang-shell">LOGNAME:PASSWORD:UID:GID:USERINFO:HOME:SHELL
</code></pre>
<h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><pre><code class="lang-shell">useradd [options] userName

options:
    -e:有效期
    -f:缓冲天数
    -g:用户所属群
    -s:指定用户的shell 若未指定centos7会给其默认分配一个shell 为 /bin/bash
     /bin/sh
     /bin/ksshell
     /bin/bash ...

    -d:用户的工作目录(家目录)
    -u:指定用户id


例子:
    1.创建一个不能登录的的用户
        useradd -s /sbin/nologin(更优,后面会提及)

        useradd -s /bin/false
</code></pre>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LOGNAME</td>
<td>用户名：用于区分不同的用户。在同一系统中注册名是惟一的。注意！通常 在 Linux 系统中对字母大小写是敏感的。</td>
</tr>
<tr>
<td>PASSWORD</td>
<td>口令：用户的口令，注意用户的密码系统会加密存储在/etc/shadow 下，所以这里只显示一个 x 字符。</td>
</tr>
<tr>
<td>UID</td>
<td>UID：用户的 ID，是 Linux 系统中惟一的用户标识，用于区别不同的用户。 这个 ID 可以创建用户的时候指定，或者由系统自动分配。</td>
</tr>
<tr>
<td>GID</td>
<td>GID：用户所属的组 ID，用户的组存放在/etc/group 文件中。</td>
</tr>
<tr>
<td>USERINFO</td>
<td>用户信息：包含有关用户的一些信息。</td>
</tr>
<tr>
<td>HOME</td>
<td>用户主目录：该字段定义了用户的主目录，当用户登录后，他的 Shell 将把 该目录作为用户的工作目录。 在 Linux 系统中，root 的工作目录为/root； 而其它个人用户在的默认主目录在/home/用户名的目录，或者也可以创建 用户的时候指定。</td>
</tr>
<tr>
<td>SHELL</td>
<td>Shell：用户的 shell，比如：bash、sh、csh、ksh 等。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><pre><code class="lang-shell">userdel [option] userName

  option:
    -r: 删除用户登录目录以及目录中的所有文件
</code></pre>
<h4 id="查看当前用户-ID"><a href="#查看当前用户-ID" class="headerlink" title="查看当前用户 ID"></a>查看当前用户 ID</h4><pre><code class="lang-shell">id
</code></pre>
<h4 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h4><pre><code class="lang-shell">passwd [options] userName

options:
    -d 删除密码
    -w 口令要到期提前警告的天数
    -k 更新只能发送在过期之后
    -l (lock)停止账号使用
    -S 显示密码信息
    -u (unlock)启用已被停止的账户
    -x 指定口令最长存活期
    -g 修改群组密码
    -n 指定口令最短存活期
    -i 口令过期后多少天停用账户
</code></pre>
<h4 id="修改用户信息"><a href="#修改用户信息" class="headerlink" title="修改用户信息"></a>修改用户信息</h4><pre><code class="lang-shell">usermod [options] userName

options:
    -d &lt;登入目录&gt; 　修改用户登入时的目录。
    -e &lt;有效期限&gt; 　修改帐号的有效期限。
    -f &lt;缓冲天数&gt; 　修改在密码过期后多少天即关闭该帐号。
    -g &lt;群组&gt; 　修改用户所属的群组。
    -l &lt;帐号名称&gt; 　修改用户帐号名称。
    -L 锁定用户密码，使密码无效。
    -s 修改用户登入后所使用的shell。
    -u 修改用户ID。
    -U 解除密码锁定。

    查看用户信息:
    cat /etc/passwd | grep userName
</code></pre>
<h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4><p>su（英文全拼：switch user）命令用于变更为其他使用者的身份。同时使用 whoami 命令查看当前用户。</p>
<p>su 命令语法：</p>
<pre><code class="lang-shell">su [-] userName

#切换到root用户
su
su -
su root
</code></pre>
<blockquote>
<p>su 命令用户切换登录用户的命令。注意：普通用户切 root 是需要 root 密码的，但是 root 切普通 用户不要密码，并且英文安全考虑，输入的密码是不回显的。</p>
</blockquote>
<h2 id="系统高级应用与设置"><a href="#系统高级应用与设置" class="headerlink" title="系统高级应用与设置"></a>系统高级应用与设置</h2><h3 id="系统性能分析"><a href="#系统性能分析" class="headerlink" title="系统性能分析"></a>系统性能分析</h3><h4 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h4><pre><code class="lang-shell">uptime 命令可以用来查看服务器已经运行了多久，依次显示：现在时间，系统运行了多久，
当前登录的用户有多少，以及服务器在过去的1分钟、5分钟、15分钟的系统平均负载值。
</code></pre>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>free 命令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及 系统核心使用的缓冲区等。</p>
<pre><code class="lang-shell">free [-options] [-s &lt;间隔秒数&gt;]

 options:
    -b:以Byte为单位显示内存使用情况。
    -k:以KB为单位显示内存使用情况。
    -m:以MB为单位显示内存使用情况。
    -h:以人可视化的单位显示内存使用情况。

    -s &lt;间隔秒数&gt;:每隔n秒刷新一次
</code></pre>
<p>结果说明：</p>
<ul>
<li>total: 内存总数。</li>
<li>used: 已经使用内存数。</li>
<li>free: 完全空闲内存。</li>
<li>shared: 多个进程共享的内存。</li>
<li>buffers: 用于块设备数据缓冲，记录文件系统 metadata（目录，权限，属性等)。</li>
<li>cached: 用于文件内容的缓冲。</li>
<li>available：真正剩余的可被程序应用的内存数。</li>
</ul>
<h4 id="top-指令"><a href="#top-指令" class="headerlink" title="top 指令"></a>top 指令</h4><p>相当于 windows 中的任务管理器</p>
<p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/linux任务管理器.png" alt="linux任务管理器"></p>
<h5 id="第一行，任务队列信息，同-uptime-命令的执行结果"><a href="#第一行，任务队列信息，同-uptime-命令的执行结果" class="headerlink" title="第一行，任务队列信息，同 uptime 命令的执行结果"></a>第一行，任务队列信息，同 uptime 命令的执行结果</h5><pre><code class="lang-bash">第一行，任务队列信息，同 uptime 命令的执行结果
系统时间：11:08:47

运行时间：up 36 min,

当前登录用户：  1 user

负载均衡(uptime)  load average: 0.32, 0.26, 0.20

average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。

load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了
</code></pre>
<h5 id="第二行，Tasks-—-任务（进程）"><a href="#第二行，Tasks-—-任务（进程）" class="headerlink" title="第二行，Tasks — 任务（进程）"></a>第二行，Tasks — 任务（进程）</h5><pre><code class="lang-bash">总进程:150 total, 运行:1 running, 休眠:149 sleeping, 停止: 0 stopped, 僵尸进程: 0 zombie
</code></pre>
<h5 id="第三行，cpu-状态信息"><a href="#第三行，cpu-状态信息" class="headerlink" title="第三行，cpu 状态信息"></a>第三行，cpu 状态信息</h5><pre><code class="lang-shell">0.0%us【user space】— 用户空间占用CPU的百分比。

0.3%sy【sysctl】— 内核空间占用CPU的百分比。

0.0%ni【】— 改变过优先级的进程占用CPU的百分比

99.7%id【idolt】— 空闲CPU百分比

0.0%wa【wait】— IO等待占用CPU的百分比

0.0%hi【Hardware IRQ】— 硬中断占用CPU的百分比

0.0%si【Software Interrupts】— 软中断占用CPU的百分比
</code></pre>
<h5 id="第四行-内存状态"><a href="#第四行-内存状态" class="headerlink" title="第四行,内存状态"></a>第四行,内存状态</h5><pre><code class="lang-shell">1003020k total,   234464k used,   777824k free,    24084k buffers【缓存的内存量】
</code></pre>
<h5 id="第五行，swap-交换分区信息"><a href="#第五行，swap-交换分区信息" class="headerlink" title="第五行，swap 交换分区信息"></a>第五行，swap 交换分区信息</h5><pre><code class="lang-shell">2031612k total,      536k used,  2031076k free,   505864k cached【缓冲的交换区总量】

备注：

可用内存=free + buffer + cached

对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。

第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，

第四行中空闲内存总量（free）是内核还未纳入其管控范围的数量。

纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。
</code></pre>
<h5 id="第六行，空行"><a href="#第六行，空行" class="headerlink" title="第六行，空行"></a>第六行，空行</h5><h5 id="第七行以下：各进程（任务）的状态监控"><a href="#第七行以下：各进程（任务）的状态监控" class="headerlink" title="第七行以下：各进程（任务）的状态监控"></a>第七行以下：各进程（任务）的状态监控</h5><pre><code class="lang-bash">PID — 进程id
USER — 进程所有者
PR — 进程优先级
NI — nice值。负值表示高优先级，正值表示低优先级
VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
RES —  进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
SHR — 共享内存大小，单位kb
S —进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程
%CPU — 上次更新到现在的CPU时间占用百分比
%MEM — 进程使用的物理内存百分比
TIME+ — 进程使用的CPU时间总计，单位1/100秒
COMMAND — 进程名称（命令名/命令行）


说明:
VIRT：virtual memory usage 虚拟内存
1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等
2、假如进程申请100m的内存，但实际只使用了10m，那么它会增长100m，而不是实际的使用量

RES：resident memory usage 常驻内存
1、进程当前使用的内存大小，但不包括swap out
2、包含其他进程的共享
3、如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反
4、关于库占用内存的情况，它只统计加载的库文件所占内存大小

SHR：shared memory 共享内存
1、除了自身进程的共享内存，也包括其他进程的共享内存
2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小
3、计算某个进程所占的物理内存大小公式：RES – SHR
4、swap out后，它将会降下来

DATA
1、数据占用的内存。如果top没有显示，按f键可以显示出来。
2、真正的该程序要求的数据空间，是真正在运行中要使用的。
</code></pre>
<h5 id="top-指令的相关参数"><a href="#top-指令的相关参数" class="headerlink" title="top 指令的相关参数"></a>top 指令的相关参数</h5><pre><code class="lang-shell">在top运行中可以使用以下命令在top中进行操作
s – 改变画面更新频率
l – 关闭或开启第一部分第一行 top 信息的表示
t – 关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示
m – 关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示
N – 以 PID 的大小的顺序排列表示进程列表
P – 以 CPU 占用率大小的顺序排列进程列表
M – 以内存占用率大小的顺序排列进程列表
h – 显示帮助
n – 设置在进程列表所显示进程的数量
q – 退出 top
</code></pre>
<p>启动 top 时的参数列表</p>
<pre><code class="lang-bash">top [-] [options]

options:
d：指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。

p:通过指定监控进程ID来仅仅监控某个进程的状态。

q:该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。

S：指定累计模式。

s：使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。

i：使top不显示任何闲置或者僵死进程。

c:显示整个命令行而不只是显示命令名。
</code></pre>
<h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>df（英文全拼：disk free） 命令用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。</p>
<pre><code class="lang-shell">df [-options]

 options:
     -a, --all 包含所有的具有 0 Blocks 的文件系统
     -h, --human-readable 使用人类可读的格式(预设值是不加这个选项的...)
     -i, --inodes 列出 inode 资讯，不列出已使用 block
    -k, --kilobytes 就像是 --block-size=1024
    -l, --local 限制列出的文件结构
    -m, --megabytes 就像 --block-size=1048576
</code></pre>
<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="==防火墙=="></a>==防火墙==</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p><strong>基本操作包括</strong>：查看防火墙状况、开启防火墙、关闭防火墙、重启防火墙、设置防火墙随系统 启动而启动、关闭防火墙随着系统的启动而启动、查看防火墙随统启动而启动。</p>
<pre><code class="lang-shell"># 查看防火墙的状态
systemctl status firewalld

# 开启防火墙
systemctl start firewalld

# 关闭防火墙
systemctl stop firewalld

# 重启防火墙
systemctl restart firewalld

# 设置防火墙，并且随着系统的启动而启动
systemctl enable firewalld

# 关闭防火墙随着系统的启动而启动，重启以后生效
systemctl disable firewalld

# 检查防火墙服务是否开机启动
systemctl is-enabled firewalld
</code></pre>
<h5 id="开启端口"><a href="#开启端口" class="headerlink" title="开启端口"></a>开启端口</h5><pre><code class="lang-shell">firewall-cmd [选项...]

选项:
    --state: 显示firewalld的状态。
    --reload: 不中断服务的重新加载防火墙。
    --list-ports: 查看所有打开的端口。
    --zone: 作用域：block dmz drop external home internal public trusted work
    --add-port=80/tcp :添加端口，格式为：端口/通讯协议。
    --permanent: 永久生效，没有此参数重启后失效。
    --query-service: 查看对应的服务，比如：ftp、ssh服务。


#查看已经打开的端口
firewall-cmd --zone=public --list-ports

# 查看8080端口有没有打开
firewall-cmd --query-port=8080/tcp

# 如果不需要了，可以删除防火墙上面开辟的8080端口
firewall-cmd --zone=public --remove-port=8080/tcp --permanent
</code></pre>
<h3 id="系统的启动与配置"><a href="#系统的启动与配置" class="headerlink" title="系统的启动与配置"></a>系统的启动与配置</h3><ol>
<li><strong>硬件启动阶段</strong>：开机，然后初始化硬件设备，然后检查硬件设备，比如：CPU、内存、硬 盘、键盘等设备。</li>
<li><strong>GRUB 引导阶段</strong>：硬件启动后，通过执行固件里面的指令跳转到 BIOS，然后 BIOS 找到启动设 备并获取 MBR，MBR 又指向 GRUB。当 GRUB 获得引导控制权后，会现实 GRUB 的提示符，此时 如果用户不做任何操作，GRUB 将在等待指定时间后自动引导默认的操作系统，如果此时按 TAB 键，则可以看到一个可引导的操作系统的列表，用户可以选择相应的操作系统。如果用户选择了 某个 Linux 操作系统，GRUB 就会从/boot 分区里面读取并装载的压缩内核，然后压缩的内核解 压，加载内核镜像到内存，之后构建虚拟根文件系统，然后把控制权交给内核。</li>
<li><strong>内核引导阶段</strong>：通过内存中的虚拟根文件系统，加载驱动，然后切换到真正的根文件系统， 然后执行的初始化程序/sbin/init（其实指向的是/usr/lib/systemd/systemd）。</li>
<li><strong>systemed 初始化阶段</strong>：又叫系统初始化阶段，CentOS7 中我们的初始化进程为 systemd （天字号排行第一的进程，因为其 PID 为 1，可以通过 top 命令查看），然后系统执行默认 target 配置文件（/etc/systemd/system/default.target），然后根据这个默认的 target，引导系 统启动并进入<strong>指定的运行级别</strong>，并启动相应的服务程序。然后等待用户登录使用。</li>
</ol>
<h3 id="系统的运行级别"><a href="#系统的运行级别" class="headerlink" title="==系统的运行级别=="></a>==系统的运行级别==</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">级别</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">详解</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center"><strong>系统停机模式</strong></td>
<td style="text-align:center">系统关机状态，系统默认运行级别不能设置为 0，否则不能正常启动。</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">单用户模式</td>
<td style="text-align:center">root 权限，用于系统维护，禁止远程登陆，就像 Windows 下的安全 模式登录。</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">多用户模式</td>
<td style="text-align:center">多用户状态，但是没有 NFS 和网络支持。</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center"><strong>完全多用户模式</strong></td>
<td style="text-align:center">有 NFS 和网络，登陆后进入控制台命令行模式（如果默认是命令行则 它是默认的）。</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">系统未使用</td>
<td style="text-align:center">保留一般不用，在一些特殊情况下可以用它来做一些事情。</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center"><strong>图形化模式</strong></td>
<td style="text-align:center">登陆后进入图形用户模式，X Window 系统。</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center"><strong>重启模式</strong></td>
<td style="text-align:center">默认运行级别不能设为 6，否则不能正常启动。运行 init 6 机器就会 重启。</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="lang-shell">#使用启动级别来关机、重启、进入命令行模式、进入图形用户模式

# 关机
init 0
#复习 还有 halt\poweroff\shutdown -h now

# 重启
init 6
#复习 还有reboot\shutdown -r now

# 进入命令行模式
init 3
# 进入图形用户模式
init 5
</code></pre>
<p>每个运行级别都有属于自己的 target 文件，这些 target 文件都是以链接文 件的形式保存在<code>“/lib/systemd/system”</code>目录。运行级别的设置由<code>“/etc/systemd/system/default.target”</code>来控制，default.target 里面配置的是什么运行级别，系统启动的时候就运行哪个运行级别。</p>
<p><strong>“/lib/systemd/system”定义好的运行级别文件：</strong></p>
<p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-03-21_11-04-22.png" alt></p>
<p>default.target 指向的默认的一个运行级别。</p>
<p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-03-21_11-05-36.png" alt></p>
<p>由于不同的运行级别将要启动的服务不尽相同，所以，为了合理的管理各个运行级别的服务进 程，系统为每一个运行级别在目录下准备了一个目录用于存放各自的服务程序，命名规范是 “rcn.d”（n 代表 0~6 的七个运行级别），具体如下图所示。</p>
<p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-03-21_11-07-05.png" alt></p>
<p>在运行级别对应的目录中，<strong>所有文件的命名规则是“Snnxxxx” 和“Knnxxxx” 。其中，以 “S”开头的文件是系统启动时调用的服务程序，以“K”开头的文件是系统终止时调用的服务程序。 nn 是 00 ～ 99 之间的一个整数，数字 nn 的大小决定程序执行的先后顺序。xxx 是服务程序的名 称。</strong> 由于各个运行级别中的服务程序集合有可能存在交集，所以为了节省硬盘空间和便于更新服务 程序，在 rcn.d 目录中存放的只是各个服务程序的链接文件，我们装 CentOS7 的默认运行级别是 “完全多用户模式”，我们进入它对应的目录“/etc/rc.d/rc3.d”，如下图所示。</p>
<p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-03-21_11-09-02.png" alt></p>
<h4 id="查看系统默认运行级别"><a href="#查看系统默认运行级别" class="headerlink" title="查看系统默认运行级别"></a><strong>查看系统默认运行级别</strong></h4><pre><code class="lang-shell">runlevel
</code></pre>
<h4 id="设置系统运行级别"><a href="#设置系统运行级别" class="headerlink" title="设置系统运行级别"></a>设置系统运行级别</h4><h5 id="systemctl-设置"><a href="#systemctl-设置" class="headerlink" title="systemctl 设置"></a>systemctl 设置</h5><pre><code class="lang-shell"># 设置默认第三启动级别
systemctl set-default multi-user.target
# 设置默认第五启动级别
systemctl set-default graphical.target
# 查看当前默认的启动级别
systemctl get-default
</code></pre>
<h5 id="重置软链接文件"><a href="#重置软链接文件" class="headerlink" title="重置软链接文件"></a>重置软链接文件</h5><pre><code class="lang-shell">#设置完全多用户模式为默认的运行级别

# 先删除原有的软链接文件
rm -rf /etc/systemd/system/default.target
# 创建软连接文件
ln -s /usr/lib/systemd/system/multi-user.target
/etc/systemd/system/default.target
# 重启
reboot
</code></pre>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="网卡的配置"><a href="#网卡的配置" class="headerlink" title="网卡的配置"></a>网卡的配置</h4><h5 id="网卡配置文件"><a href="#网卡配置文件" class="headerlink" title="网卡配置文件"></a>网卡配置文件</h5><p>网卡的配置信息，通常包括 IP 地址、子网掩码、网关。这些网卡信息保存在配置文件中，这个 网卡的配置文件位于<strong>/etc/sysconfig/network-scripts</strong>，我们的 CentOS7 的网卡配置信息就在 <strong>ifcfg-ens33</strong>文件中。</p>
<p><strong>查看 ifcfg-ens33 的内容</strong></p>
<pre><code class="lang-shell">cat /etc/sysconfig/network-scripts/ifcfg-ens33
</code></pre>
<p><strong>显示内容</strong>:</p>
<pre><code class="lang-shell">TYPE=&quot;Ethernet&quot;
PROXY_METHOD=&quot;none&quot;
BROWSER_ONLY=&quot;no&quot;
BOOTPROTO=&quot;dhcp&quot;
DEFROUTE=&quot;yes&quot;
IPV4_FAILURE_FATAL=&quot;no&quot;
IPV6INIT=&quot;yes&quot;
IPV6_AUTOCONF=&quot;yes&quot;
IPV6_DEFROUTE=&quot;yes&quot;
IPV6_FAILURE_FATAL=&quot;no&quot;
IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;
NAME=&quot;ens33&quot;
UUID=&quot;1bedffd6-a745-41a6-b981-e3fff4e13b71&quot;
DEVICE=&quot;ens33&quot;
ONBOOT=&quot;yes&quot;
IPV6_PRIVACY=&quot;no&quot;
</code></pre>
<p><strong>配置信息</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>配置项</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEVICE</td>
<td>定义该网卡的识别名称。</td>
</tr>
<tr>
<td>TYPE</td>
<td>网卡类型。</td>
</tr>
<tr>
<td>BOOTPROTO</td>
<td>启动该网卡的方式。有 static/none 表示固定 IP 地址；bootp/dhcp 表示通 过 BOOTP 或者 DHCP 协议动态获取 IP 地址。 如果自己设置就用 static，如果想自动获取就用 dhcp。</td>
</tr>
<tr>
<td>ONBOOT</td>
<td>启动 NetworkManager 的时候，是否启动该网卡。有些情况下安装 CentOS 的时候网络老是不启动这个时候，就可以看这个配置项是否是 “yes”</td>
</tr>
<tr>
<td>IPADDR</td>
<td>静态方式设置指定的 IP 地址。</td>
</tr>
<tr>
<td>NETMASK</td>
<td>指定子网掩码。</td>
</tr>
<tr>
<td>GATEWAY</td>
<td>指定默认网关。</td>
</tr>
<tr>
<td>DNS1</td>
<td>配置 DNS 服务器</td>
</tr>
</tbody>
</table>
</div>
<p><strong>设置静态 IP</strong></p>
<p>安装的时候，我们设置的是网络采取的是“dhcp”网络配置方式，这种方式 IP 是动态设置的，这 个在我们以后的集群里面是不行的，所以我们设置成静态 ip，具体的步骤如下：</p>
<pre><code class="lang-shell"># 进入网络配置目录
cd /etc/sysconfig/network-scripts/

# 查看网络配置文件
ls -al

# 编辑网络配置文件
vi + /etc/sysconfig/network-scripts/ifcfg-ens33
</code></pre>
<pre><code class="lang-shell">TYPE=&quot;Ethernet&quot;
PROXY_METHOD=&quot;none&quot;
BROWSER_ONLY=&quot;no&quot;
# 注意这个要注释或者删除
#BOOTPROTO=&quot;dhcp&quot;
DEFROUTE=&quot;yes&quot;
IPV4_FAILURE_FATAL=&quot;no&quot;
IPV6INIT=&quot;yes&quot;
IPV6_AUTOCONF=&quot;yes&quot;
IPV6_DEFROUTE=&quot;yes&quot;
IPV6_FAILURE_FATAL=&quot;no&quot;
IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;
NAME=&quot;ens33&quot;
UUID=&quot;e9ce67e1-7d2a-41b4-9989-dfbc75278d80&quot;
DEVICE=&quot;ens33&quot;
ONBOOT=&quot;yes&quot;
IPV6_PRIVACY=&quot;no&quot;
# 配置静态的IP
BOOTPROTO=&quot;static&quot;
# IP地址
IPADDR=192.168.60.100
# 子网掩码
NETMASK=255.255.255.0
# 默认网关
GATEWAY=192.168.60.1
# 配置DNS
DNS1=8.8.8.8
</code></pre>
<p><strong>重启网络与重新登陆</strong></p>
<pre><code class="lang-shell"># 重启网络：
systemctl restart network
# 重新登录
ssh root@192.168.60.100
</code></pre>
<h5 id="ifconfig-命令"><a href="#ifconfig-命令" class="headerlink" title="ifconfig 命令"></a>ifconfig 命令</h5><p>ifconfig 命令（来源于 net-tools 软件包，默认的精简版的 CentOS7 里面是没遇的，得先安装） 功能比较的强大，用于显示或设置网络设备。</p>
<pre><code class="lang-shell">yum -y install net-tools
</code></pre>
<p><strong>查看网卡信息</strong></p>
<p><strong>命令格式</strong>：</p>
<pre><code class="lang-shell">ifconfig [选项]
</code></pre>
<p><strong>选项说明</strong>:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无选项</td>
<td>显示当前活动的网卡信息。</td>
</tr>
<tr>
<td style="text-align:center">-a</td>
<td>显示系统中所有的网卡配置信息。</td>
</tr>
<tr>
<td style="text-align:center">网卡设备名</td>
<td>显示指定网卡的配置信息。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>设置 IP 地址</strong></p>
<p><strong>命令格式</strong>：</p>
<pre><code class="lang-shell">ifconfig 网卡设备名 IP地址 netmask 子网掩码

#使用ifconfig将ens33网卡的ip改成192.168.60.133，子网掩码改成255.255.255.0
ifconfig ens33 192.168.60.133 netmask 255.255.255.0
</code></pre>
<blockquote>
<p>注意：这种方式设置 IP 只是临时性的，如果重启机器，IP 又会恢复到原来的 IP。</p>
</blockquote>
<h5 id="ifdown"><a href="#ifdown" class="headerlink" title="ifdown"></a><strong>ifdown</strong></h5><p>用于禁用网卡</p>
<p><strong>命令格式</strong>：</p>
<pre><code class="lang-shell">ifdown 网卡设备名

#禁用ens33
ifdown ens33
</code></pre>
<h5 id="ifup"><a href="#ifup" class="headerlink" title="ifup"></a>ifup</h5><p>重新启用网卡</p>
<pre><code class="lang-shell">ifup 网卡设备名

#重新启用ens33
ifup ens33
</code></pre>
<h5 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h5><p>ping 命令用于检测主机。执行 ping 指令会发出要求回应的信息，若远端主机的网络功能没有问 题，就会回应该信息，因而得知该主机运作正常。</p>
<p><strong>命令格式</strong>：</p>
<pre><code class="lang-shell">ping [选项] 主机ip地址、主机名、或者域名

选项说明：
-c：指定向目标主机发送的报文次数。
-s：指定发送报文的大小，单位字节。
-W：设置等待接收响应报文的时间间隔，单位秒。
</code></pre>
<blockquote>
<p>ping 命令默认情况下是一直往目标地址发生 ping 请求，然后数据包的大小是 64KB，直到按” Ctrl+c“才退出。</p>
</blockquote>
<h3 id="软件的安装"><a href="#软件的安装" class="headerlink" title="软件的安装"></a>软件的安装</h3><p>Linux 各个不同版本中内置了一些不同的工具用于下载和安装软件</p>
<h4 id="文件的下载"><a href="#文件的下载" class="headerlink" title="文件的下载"></a>文件的下载</h4><h5 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h5><p>wget 是 Linux 中的一个下载文件的工具，wget 是在 Linux 下开发的开放源代码的软件，作者是 Hrvoje Niksic，后来被移植到包括 Windows 在内的各个平台上。</p>
<p>wget 工具体积小但功能完善，它支持断点下载功能，同时支持 FTP 和 HTTP 下载方式</p>
<p><strong>安装 wget</strong></p>
<pre><code class="lang-shell">yum install -y wget
</code></pre>
<p><strong>命令格式</strong></p>
<pre><code class="lang-shell">wget [参数] [URL地址]
</code></pre>
<p><strong>使用实例</strong>:</p>
<p><strong>实例 1：使用 wget 下载单个文件</strong></p>
<p>以下的例子是从网络下载一个文件并保存在当前目录，在下载的过程中会显示进度条，包含下载完成百分比，已经下载的字节，当前下载速度和剩余下载时间：</p>
<pre><code class="lang-shell">wget http://www.minjieren.com/wordpress-3.1-zh_CN.zip
</code></pre>
<p><strong>实例 2：使用 wget -O 下载并以不同的文件名保存</strong></p>
<p>wget 默认会以最后一个符合”/”的后面的字符来命名，对于动态链接的下载通常文件名会不正确<br>下面的例子会下载一个文件并以名称 download.aspx?id=1080 保存，即使下载的文件是 zip 格式，它仍然以 download.php?id=1080 命令：</p>
<pre><code class="lang-shell">wget http://www.minjieren.com/download?id=1
</code></pre>
<p>为了解决这个问题，我们可以使用参数-O 来指定一个文件名：</p>
<pre><code class="lang-shell">wget -O wordpress.zip http://www.minjieren.com/download.aspx?id=1080
</code></pre>
<p><strong>实例 3：使用 wget –limit -rate 限速下载</strong></p>
<p>当你执行 wget 的时候，它默认会占用全部可能的宽带下载。但是当你准备下载一个大文件，而你还需要下载其它文件时就有必要限速了：</p>
<pre><code class="lang-shell">wget --limit-rate=300k http://www.minjieren.com/wordpress-3.1-zh_CN.zip
</code></pre>
<p><strong>实例 4：使用 wget -c 断点续传</strong></p>
<p>使用 wget -c 重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用-c 参数</p>
<pre><code class="lang-shell">wget -c http://www.minjieren.com/wordpress-3.1-zh_CN.zip
</code></pre>
<p><strong>实例 5：使用 wget -b 后台下载</strong></p>
<p>对于下载非常大的文件的时候，我们可以使用参数-b 进行后台下载</p>
<pre><code class="lang-shell">wget -b http://www.minjieren.com/wordpress-3.1-zh_CN.zip

wget -b http://www.minjieren.com/wordpress-3.1-zh_CN.zip
Continuing in background, pid 1840.
Output will be written to `wget-log&#39;.
</code></pre>
<p>你可以使用以下命令来察看下载进度：</p>
<pre><code class="lang-shell">tail -f wget-log
</code></pre>
<p><strong>实例 6：伪装代理名称下载</strong></p>
<p>有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过–user-agent 参数伪装。</p>
<pre><code class="lang-shell">wget --user-agent=&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot; http://www.minjieren.com/wordpress-3.1-zh_CN.zip
</code></pre>
<p><strong>实例 7：使用 wget –spider 测试下载链接</strong></p>
<p>当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加–spider 参数进行检查。</p>
<pre><code class="lang-shell">wget --spider URL
</code></pre>
<p>如果下载链接正确，将会显示：</p>
<pre><code class="lang-shell">wget --spider URL

Spider mode enabled. Check if remote file exists.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [text/html]
Remote file exists and could contain further links,
but recursion is disabled -- not retrieving.
</code></pre>
<p>这保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误：</p>
<pre><code class="lang-shell">wget --spider url

Spider mode enabled. Check if remote file exists.
HTTP request sent, awaiting response... 404 Not Found
Remote file does not exist -- broken link!!!
</code></pre>
<p>你可以在以下几种情况下使用 spider 参数：</p>
<ul>
<li>定时下载之前进行检查</li>
<li>间隔检测网站是否可用</li>
<li>检查网站页面的死链接</li>
</ul>
<p><strong>实例 8：使用 wget –tries 增加重试次数</strong></p>
<p>如果网络有问题或下载一个大文件也有可能失败。wget 默认重试 20 次连接下载文件。如果需要，你可以使用–tries 增加重试次数：</p>
<pre><code class="lang-shell">wget --tries=40 URL
</code></pre>
<p><strong>实例 9：使用 wget -i 下载多个文件</strong></p>
<p>首先，保存一份下载链接文件：</p>
<pre><code class="lang-shell">cat &gt; filelist.txt
url1
url2
url3
url4
12345
</code></pre>
<p>接着使用这个文件和参数-i 下载：</p>
<pre><code>wget -i filelist.txt
1
</code></pre><p><strong>实例 10：使用 wget –mirror 镜像网站</strong></p>
<p>下载整个网站到本地：</p>
<pre><code>wget --mirror -p --convert-links -P ./LOCAL URL
1
</code></pre><p>说明：</p>
<p>–miror:开户镜像下载</p>
<p>-p:下载所有为了 html 页面显示正常的文件</p>
<p>–convert-links:下载后，转换成本地的链接</p>
<p>-P ./LOCAL：保存所有文件和目录到本地指定目录</p>
<p><strong>实例 11：使用 wget –reject 过滤指定格式下载</strong></p>
<p>下载一个网站，但你不希望下载图片，可以使用以下命令：</p>
<pre><code class="lang-shell">wget --reject=gif url
</code></pre>
<p><strong>实例 12：使用 wget -o 把下载信息存入日志文件</strong></p>
<p>不希望下载信息直接显示在终端而是在一个日志文件，可以使用：</p>
<pre><code class="lang-shell">wget -o download.log URL
</code></pre>
<p><strong>实例 13：使用 wget -Q 限制总下载文件大小</strong></p>
<p>命令：</p>
<pre><code class="lang-shell">wget -Q5m -i filelist.txt
</code></pre>
<p>说明：</p>
<p>当你想要下载的文件超过 5M 而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。</p>
<p><strong>实例 14：使用 wget -r -A 下载指定格式文件</strong></p>
<p>Example：</p>
<pre><code class="lang-shell">wget -r -A.pdf url
</code></pre>
<p>可以在以下情况使用该功能：</p>
<ul>
<li>下载一个网站的所有图片</li>
<li>下载一个网站的所有视频</li>
<li>下载一个网站的所有 PDF 文件</li>
</ul>
<p><strong>实例 15：使用 wget FTP 下载</strong></p>
<p>使用 wget 匿名 ftp 下载：</p>
<pre><code class="lang-shell">wget ftp-url
</code></pre>
<p>使用 wget 用户名和密码认证的 ftp 下载</p>
<pre><code class="lang-shell">wget --ftp-user=USERNAME --ftp-password=PASSWORD url
</code></pre>
<h5 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h5><p><code>cURL</code>是用于数据传输的命令行工具，支持多种传输协议，包括 HTTP、HTTPS、SCP、FTP、SFTP、TELNET、FILE、SMTP、POP3 等等。可以使用<code>cURL</code>进行<code>HTTP/HTTPS</code>请求、上传/下载文件等，且支持<code>Cookie</code>、用户身份验证、代理支持、限速等。</p>
<p><strong>基本语法</strong>:</p>
<pre><code class="lang-shell">curl [options] [URL...]
</code></pre>
<p><strong>常见用法</strong>:</p>
<pre><code class="lang-shell">#1、下载(option:-o或者option:-O)

#1.1、下载页面：

curl -o dodo1.jpg http:www.linux.com/dodo1.JPG
#要注意-O这里后面的url要具体到某个文件，不然抓不下来
curl -O http://www.linux.com/dodo1.JPG

#1.2：循环下载
#有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样。这样就会把dodo1，dodo2，dodo3，dodo4，dodo5全部保存下来
curl -O http://www.linux.com/dodo[1-5].JPG


#1.3：下载重命名
#在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖
curl -o #1_#2.JPG http://www.linux.com/&#123;hello,bb&#125;/dodo[1-5].JPG

#由于下载的hello与bb中的文件名都是dodo1，dodo2，dodo3，dodo4，dodo5。因此第二次下载的会把第一次下载的覆盖，这样就需要对文件进行重命名。
curl -O http://www.linux.com/&#123;hello,bb&#125;/dodo[1-5].JPG


#1.4：分块下载(option：-r)
curl -r 0-100 -o dodo1_part1.JPG http://www.linux.com/dodo1.JPG
curl -r 100-200 -o dodo1_part2.JPG http://www.linux.com/dodo1.JPG
curl -r 200- -o dodo1_part3.JPG http://www.linux.com/dodo1.JPG
cat dodo1_part* &gt; dodo1.JPG  #这样就可以查看dodo1.JPG的内容了


#1.5：通过ftp下载文件(option：-u)
curl可以通过ftp下载文件，curl提供两种从ftp中下载的语法
curl -O -u 用户名:密码 ftp://www.linux.com/dodo1.JPG
curl -O ftp://用户名:密码@www.linux.com/dodo1.JPG


#1.6:下载，显示进度条(option：-#)或不显示进度条(option：-s)
curl -# -O http://www.linux.com/dodo1.JPG
curl -s -O http://www.linux.com/dodo1.JPG

#1.7、下载，断点续传(-C &lt;offset&gt;)
断点续转，从文件头的指定位置开始继续下载/上传；offset续传开始的位置，如果offset值为“-”，curl会自动从文件中识别起始位置开始传输；
curl -# -o centos6.8.iso -C - http://mirrors.aliyun.com/centos/6.8/isos/x86_64/CentOS-6.8-x86_64-minimal.iso
curl -C -O http://www.linux.com/dodo1.JPG



#2、上传文件(option:-T)

curl -T dodo1.JPG -u 用户名:密码 ftp://www.linux.com/img/



#3、伪造来源页面|伪造referer|盗链 (option：-e)

#很多服务器会检查http访问的referer从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了
#这样就会让服务器其以为你是从www.linux.com点击某个链接过来的
curl -e &quot;www.linux.com&quot; http://mail.linux.com
#告诉爱E族，我是从百度来的
curl -e http://baidu.com http://aiezu.com



#4、伪造代理设备(模仿浏览器)

#有些网站需要使用特定的浏览器去访问他们，有些还需要使用某些特定的版本。curl内置option:-A可以让我们指定浏览器去访问网站
curl -A &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)&quot; http://www.linux.com
#告诉爱E族，我是GOOGLE爬虫蜘蛛（其实我是curl命令）
curl -A &quot; Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)&quot; http://aiezu.com
#告诉爱E族，我用的是微信内置浏览器
curl -A &quot;Mozilla/5.0 AppleWebKit/600 Mobile MicroMessenger/6.0&quot; http://aiezu.com


#5、设置http请求

#5.1、设置http请求头(或option:-H或option:--head)
curl -H &quot;Cache-Control:no-cache&quot;  http://aiezu.com

#5.2、指定proxy服务器以及其端口(option::-x)
#很多时候上网需要用到代理服务器(比如是使用代理服务器上网或者因为使用curl别人网站而被别人屏蔽IP地址的时候)，幸运的是curl通过使用内置option：-x来支持设置代理
curl -x 192.168.100.100:1080 http://www.linux.com



#6、http响应头

#6.1、查看http响应头(option:-I)
# 看看本站的http头是怎么样的
curl -I  http://aiezu.com
输出：
HTTP/1.1 200 OK
Date: Fri, 25 Nov 2016 16:45:49 GMT
Server: Apache
Set-Cookie: rox__Session=abdrt8vesprhnpc3f63p1df7j4; path=/
Expires: Thu, 19 Nov 1981 08:52:00 GMT
Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0
Pragma: no-cache
Vary: Accept-Encoding
Content-Type: text/html; charset=utf-8

#6.2、保存http的response里面的header信息(option:-D)
curl -D cookied.txt http://www.linux.com
执行后cookie信息就被存到了cookied.txt里面了
注意：-c(小写)产生的cookie和-D里面的cookie是不一样的。



#7、发送表单数据

curl -F &quot;pic=@logo.png&quot; -F &quot;site=aiezu&quot;  http://aiezu.com/



#8、cookie

#8.1、发送cookie(option:-b）
#有些网站是使用cookie来记录session信息。对于chrome这样的浏览器，可以轻易处理cookie信息，但在curl中只要增加相关参数也是可以很容易的处理cookie
curl -b &quot;domain=aiezu.com&quot;  http://aiezu.com
#很多网站都是通过监视你的cookie信息来判断你是否按规矩访问他们的网站的，因此我们需要使用保存的cookie信息。内置option: -b
curl -b cookiec.txt http://www.linux.com


#8.2、保存http的response里面的cookie信息(option:-c）
#执行后http的response里面的cookie信息就被存到了cookiec.txt里面了
curl -c cookiec.txt  http://www.linux.com



#9、测试一个网址

#9.1、测试一个网址是否可达
curl -v http://www.linux.com

#9.2、测试网页返回值(option:-w [format])
curl -o /dev/null -s -w %&#123;http_code&#125; www.linux.com



#10、保存访问的网页(&gt;&gt;)

#2.1:使用linux的重定向功能保存
curl http://www.linux.com &gt;&gt; linux.html
</code></pre>
<h4 id="RedHat"><a href="#RedHat" class="headerlink" title="RedHat"></a>RedHat</h4><h5 id="rpm"><a href="#rpm" class="headerlink" title="==rpm=="></a>==rpm==</h5><p>rpm（英文全拼：redhat package manager） 原本是<code>Red Hat Linux</code>发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。包的格式为<code>*.rpm</code></p>
<p><strong>命令格式</strong>:</p>
<pre><code class="lang-SHELL">rpm [选项] [文件/软件包]
</code></pre>
<p><strong>常见选项</strong>:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>-a</strong></td>
<td>(all)显示所有软件包。</td>
</tr>
<tr>
<td><strong>-q</strong></td>
<td>(query)查询功能。</td>
</tr>
<tr>
<td><strong>-i</strong></td>
<td>安装指定的软件包。通常和-v，-h 选项结合使用。</td>
</tr>
<tr>
<td><strong>-e</strong></td>
<td>(erase)删除指定的软件包。</td>
</tr>
<tr>
<td><strong>-f</strong></td>
<td>查询拥有指定文件的软件包。</td>
</tr>
<tr>
<td><strong>-l</strong></td>
<td>(list)显示软件包的文件列表。</td>
</tr>
<tr>
<td>-p</td>
<td>查询待安装的软件包。</td>
</tr>
<tr>
<td>-s</td>
<td>显示文件状态，通常结合-l 选项使用。</td>
</tr>
<tr>
<td>-U</td>
<td>升级指定的软件包。</td>
</tr>
<tr>
<td><strong>-h</strong></td>
<td>在安装过程中将显示一系列的“#”来表示安装进度。</td>
</tr>
<tr>
<td><strong>-v</strong></td>
<td>显示指令执行过程。</td>
</tr>
<tr>
<td>-vv</td>
<td>详细显示指令执行过程，便于排错。</td>
</tr>
<tr>
<td><strong>—nodeps</strong></td>
<td>强制删除，不管它的依赖关系。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>常用命令</strong>:</p>
<pre><code class="lang-shell">#查询系统中已经安装的全部RPM包
rpm -qa

#结合管道符进行查询
rpm -qa | more
rpm -qa | less
rpm -qa | wc -l

#结合全局正则表达式进行查询
rpm -qa | grep python

#查询是否安装特定(多个)的软件包
rpm -q openssh-server [openssh-clients ...] #软件包间空格隔开

#查询软件包的描述信息
rpm -qi openssh-server

#查询已经安装的软件包的文件列表(即查询软件包的安装目录)
rpm -ql 软件包名称

#查询某个文件所属的软件包
rpm -qf 文件

#安装软件包
rpm -ivh 软件包名称
rpm -ivh jdk-8u221-linux-x64.rpm

#卸载软件包
rpm -e 软件包名称
</code></pre>
<blockquote>
<p>rpm 安装软件包过程总结(以安装 jdk8 为例)</p>
<p>1、把 jdk 解压到“/usr/java/jdk1.8.0_221-amd64”。</p>
<p>2、在“/etc/alternatives/”创建链接指向解压目录“/usr/java/jdk1.8.0_221-amd64”。</p>
<p>3、然后在“/usr/bin/”目录下创建链接指向“/etc/alternatives/”。</p>
<p>4、由于“/usr/bin/”已经被添加到环境变量里面去，我们可以直接使用。</p>
</blockquote>
<h5 id="yum"><a href="#yum" class="headerlink" title="==yum=="></a>==yum==</h5><p>yum（ Yellow dog Updater, Modified）是一个在 <code>Fedora</code> 和 <code>RedHat</code> 以及 <code>SUSE</code> 中的 Shell 前端软件包管理器。<code>基于 RPM 包管理</code>，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p>
<p>yum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
<pre><code class="lang-shell">yum [options] [command] [package ...]

    options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为 &quot;yes&quot;），-q（不显示安装的过程）等等。
    command：要进行的操作。
    package：安装的包名。

#yum常用命令
#1. 列出所有可更新的软件清单命令：
yum check-update

#2. 更新所有软件命令：
yum update

#3. 仅安装指定的软件命令：
yum install &lt;package_name&gt;

#4. 仅更新指定的软件命令：
yum update &lt;package_name&gt;

#5. 列出所有可安裝的软件清单命令：
yum list

#6. 删除软件包命令：
yum remove &lt;package_name&gt;

#7. 查找软件包命令：
yum search &lt;keyword&gt;

#8. 清除缓存命令:
yum clean packages: 清除缓存目录下的软件包
yum clean headers: 清除缓存目录下的 headers
yum clean oldheaders: 清除缓存目录下旧的 headers
yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers
</code></pre>
<h4 id="Debian、Ubuntu"><a href="#Debian、Ubuntu" class="headerlink" title="Debian、Ubuntu"></a>Debian、Ubuntu</h4><h5 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a>dpkg</h5><p>dpkg 命令的英文全称是“Debian package”，故名意思是 Debian Linux 系统用来安装、创建和管理软件包的实用工具。能直接本地安装<code>*.deb</code>的包文件</p>
<pre><code class="lang-shell">dpkg [参数] [包名]

常用参数：
    -i    安装软件包
    -r    删除软件包
    -l    显示已安装软件包列表
    -L    显示于软件包关联的文件
    -c    显示软件包内文件列表

#安装包
dpkg -i package.deb

#删除包
dpkg -r package.deb

#列出当前已安装的包
dpkg -l

#列出deb包的内容
dpkg -c package.deb

#配置
dpkg --configure package
</code></pre>
<h5 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h5><p>apt（Advanced Packaging Tool）是一个在 <code>Debian</code> 和<code>Ubuntu</code>中的 Shell 前端软件包管理器。</p>
<p>apt 命令提供了查找、安装、升级、删除某一个、一组甚至全部<code>软件包(*.deb)</code>的命令，而且命令简洁而又好记。</p>
<p>apt 命令执行需要超级管理员权限(root)。</p>
<p><code>apt</code> = <code>apt-get</code>+ <code>apt-cache</code> + <code>apt-config</code> 中最常用命令选项的集合</p>
<p><strong>基本格式</strong></p>
<pre><code class="lang-shell">apt [options] [command] [package ...]

    options：可选，选项包括 -h（帮助），-y（当安装过程提示选择全部为&quot;yes&quot;），-q（不显示安装的过程）等等。
    command：要进行的操作。
    package：安装的包名。
</code></pre>
<p><strong>常用命令</strong>:</p>
<pre><code class="lang-shell">#列出所有可更新的软件清单命令,刷新存储库索引
sudo apt update

#列出可更新的软件包及版本信息：
apt list --upgradeable

#升级所有可升级的软件包
sudo apt upgrade

#升级软件包，在升级软件包时自动处理依赖关系：
sudo apt full-upgrade

#安装指定的软件命令：
sudo apt install &lt;package_name&gt;

#安装多个软件包：
sudo apt install &lt;package_1&gt; &lt;package_2&gt; &lt;package_3&gt;

#更新指定的软件命令：
sudo apt update &lt;package_name&gt;

#显示软件包具体信息,例如：版本号，安装大小，依赖关系等等：
sudo apt show &lt;package_name&gt;

#删除软件包命令：
sudo apt remove &lt;package_name&gt;

#清理不再使用的依赖和库文件:
sudo apt autoremove

#移除软件包及配置文件:
sudo apt purge &lt;package_name&gt;

#自动删除不需要的包
sudo apt autoremove

#查找软件包命令：
sudo apt search &lt;keyword&gt;

#列出所有已安装的包：
apt list --installed

#列出所有已安装的包的版本信息：
apt list --all-versions
</code></pre>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="==挂载=="></a>==挂载==</h3><p>挂载在 Linux 系统中是一个比较重要的操作，我们 使用 CentOS 使需要插入 U 盘了，由于我们使用的是命令行不像 Windows 有图形用户界面，那 么直观的帮助用户使用。或者当我们的硬盘满了的时候，我们可能就需要加硬盘,这个需要使用挂载这个功能。</p>
<h4 id="挂载点"><a href="#挂载点" class="headerlink" title="挂载点"></a>挂载点</h4><p>由于 Linux 操作系统只有一个根目录(/)，所以当向系统中添加新的存储设备时，不会像 Windows 操作系统那样出现一个新的根目录或者盘符（比如：K 盘，L 盘等）。因此，在 Linux 下 访问新存储设备时需要首先创建挂载点。</p>
<p><strong>所谓的挂载点就是文件系统中存在的一个目录</strong>,通常情况下，创建在/mnt 目录下，挂载成功后,访问挂载点就是访问新的存储设备。挂载点应该是空目录,否则原来该挂载点中存在的文件将会被隐藏。而且,挂载点在实施挂载操作之前就应该存在。</p>
<h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>Linux fdisk 是一个创建和维护分区表的命令，它兼容 DOS 类型的分区表、BSD 或者 SUN 类型的 磁盘列表。fdisk 能划分的最大分区为<strong><code>2T</code></strong></p>
<pre><code class="lang-shell">fdisk [必要参数][选择参数]

必要参数：
    -l 列出所有分区表
    -u 与 -l 搭配使用，显示分区数目

选择参数：
    -s&lt;分区编号&gt; 指定分区
    -v 版本信息
</code></pre>
<p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-03-21_11-17-25.png" alt></p>
<p>我们可以发现系统中有两块硬盘分别是：/dev/sda1 与/dev/sda2，大小分别是 19.1G 与 2G 左 右，前面的是“根节点‘/’”，后面的分区是交换区。</p>
<pre><code class="lang-shell">#输入
fdisk /指定设备
#可进入该设备以执行分区的相关操作
</code></pre>
<h4 id="parted"><a href="#parted" class="headerlink" title="parted"></a>parted</h4><ul>
<li><p><code>parted</code> 命令可以创建全局惟一的标识符分区表 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/GUID_Partition_Table">GPT</a>，而 <code>fdisk</code> 和 <code>cfdisk</code> 则仅限于 DOS 分区表。</p>
</li>
<li><p><strong>更大的磁盘：</strong> DOS 分区表可以格式化最多 2TB 的磁盘空间，尽管在某些情况下最多可以达到 16TB。然而，一个 GPT 分区表可以处理最多 8ZB 的空间。</p>
</li>
<li><p><strong>更多的分区：</strong> 使用主分区和扩展分区，DOS 分区表只允许 16 个分区。在 GPT 中，默认情况下您可以得到 128 个分区，并且可以选择更多的分区。</p>
</li>
<li><p><strong>可靠性：</strong> 在 DOS 分区表中，只保存了一份分区表备份，在 GPT 中保留了两份分区表的备份（在磁盘的起始和结束部分），同时 GPT 还使用了 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a> 校验和来检查分区表的完整性，在 DOS 分区中并没有实现。</p>
<h6 id="1、列出分区"><a href="#1、列出分区" class="headerlink" title="1、列出分区"></a>1、列出分区</h6><p>使用 <code>parted -l</code> 来标识你要进行分区的设备。一般来说，第一个硬盘 （<code>/dev/sda</code> 或 <code>/dev/vda</code> ）保存着操作系统， 因此要寻找另一个磁盘，以找到你想要分区的磁盘 (例如，<code>/dev/sdb</code>、<code>/dev/sdc</code>、 <code>/dev/vdb</code>、<code>/dev/vdc</code> 等)。</p>
<pre><code class="lang-shell">$ sudo parted -l
[sudo] password for daniel:
Model: ATA RevuAhn_850X1TU5 (scsi)
Disk /dev/vdc: 512GB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags:
Number  Start   End    Size   Type     File system  Flags
 1      1049kB  525MB  524MB  primary  ext4         boot
 2      525MB   512GB  512GB  primary               lvm
</code></pre>
<h5 id="2、打开存储设备"><a href="#2、打开存储设备" class="headerlink" title="2、打开存储设备"></a>2、打开存储设备</h5><p>使用 <code>parted</code> 选中要分区的设备。在这里例子中，是虚拟系统上的第三个磁盘（<code>/dev/vdc</code>）。指明要使用哪一个设备非常重要。 如果你仅仅输入了 <code>parted</code> 命令而没有指定设备名字， 它会<strong>随机</strong>选择一个设备进行操作。</p>
<pre><code class="lang-shell">$ sudo parted /dev/vdc
GNU Parted 3.2
Using /dev/vdc
Welcome to GNU Parted! Type &#39;help&#39; to view a list of commands.
(parted)
</code></pre>
<h5 id="3、-设定分区表"><a href="#3、-设定分区表" class="headerlink" title="3、 设定分区表"></a>3、 设定分区表</h5><p>设置分区表为 GPT ，然后输入 <code>Yes</code> 开始执行。</p>
<pre><code class="lang-shell">(parted) mklabel gpt
Warning: the existing disk label on /dev/vdc will be destroyed
and all data on this disk will be lost. Do you want to continue?
Yes/No? Yes
</code></pre>
<p><code>mklabel</code> 和 <code>mktable</code> 命令用于相同的目的（在存储设备上创建分区表）。支持的分区表有：aix、amiga、bsd、dvh、gpt、mac、ms-dos、pc98、sun 和 loop。记住 <code>mklabel</code> 不会创建一个分区，而是创建一个分区表。</p>
<h5 id="4、-检查分区表"><a href="#4、-检查分区表" class="headerlink" title="4、 检查分区表"></a>4、 检查分区表</h5><p>查看存储设备信息:</p>
<pre><code class="lang-shell">(parted) print
Model: Virtio Block Device (virtblk)
Disk /dev/vdc: 1396MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags:
Number Start End Size File system Name Flags
</code></pre>
<h5 id="5、-获取帮助"><a href="#5、-获取帮助" class="headerlink" title="5、 获取帮助"></a>5、 获取帮助</h5><p>为了知道如何去创建一个新分区，输入： <code>(parted) help mkpart</code> 。</p>
<pre><code class="lang-shell">(parted) help mkpart
  mkpart PART-TYPE [FS-TYPE] START END     make a partition
        PART-TYPE is one of: primary, logical, extended
        FS-TYPE is one of: btrfs, nilfs2, ext4, ext3, ext2, fat32, fat16, hfsx, hfs+, hfs, jfs, swsusp,
        linux-swap(v1), linux-swap(v0), ntfs, reiserfs, hp-ufs, sun-ufs, xfs, apfs2, apfs1, asfs, amufs5,
        amufs4, amufs3, amufs2, amufs1, amufs0, amufs, affs7, affs6, affs5, affs4, affs3, affs2, affs1,
        affs0, linux-swap, linux-swap(new), linux-swap(old)
        START and END are disk locations, such as 4GB or 10%.  Negative values count from the end of the
        disk.  For example, -1s specifies exactly the last sector.
        &#39;mkpart&#39; makes a partition without creating a new file system on the partition.  FS-TYPE may be
        specified to set an appropriate partition ID.
</code></pre>
<h5 id="6、-创建分区"><a href="#6、-创建分区" class="headerlink" title="6、 创建分区"></a>6、 创建分区</h5><p>为了创建一个新分区（在这个例子中，分区 0 有 1396MB），输入下面的命令：</p>
<pre><code class="lang-shell">(parted) mkpart primary 0 1396MB
Warning: The resulting partition is not properly aligned for best performance
Ignore/Cancel? I
(parted) print
Model: Virtio Block Device (virtblk)
Disk /dev/vdc: 1396MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags:
Number Start   End     Size    File system Name Flags
1      17.4kB  1396MB  1396MB  primary
</code></pre>
<p>文件系统类型（<code>fstype</code>）并不是在 <code>/dev/vdc1</code>上创建 ext4 文件系统。 DOS 分区表的分区类型是主分区 primary、逻辑分区 logical 和扩展分区 extended。 在 GPT 分区表中，分区类型用作分区名称。 在 GPT 下必须提供分区名称；在上例中，<code>primary</code> 是分区名称，而不是分区类型。</p>
<h5 id="7、-保存退出"><a href="#7、-保存退出" class="headerlink" title="7、 保存退出"></a>7、 保存退出</h5><p>当你退出 <code>parted</code> 时，修改会自动保存。退出请输入如下命令：</p>
<pre><code class="lang-shell">(parted) quit
Information: You may need to update /etc/fstab.
$
</code></pre>
</li>
</ul>
<h4 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h4><p>在 Linux 中使用 mount 这个命令来挂载文件系统。</p>
<pre><code class="lang-shell">mount [选项] [设备名] [挂载点]

 选项：
    -r： 以只读方式挂载文件系统。
    -w：以读写方式挂载文件系统，默认选项。
    mount不加任何参数，会列出系统中所有已经挂载的文件系统。
</code></pre>
<p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-03-21_11-20-18.png" alt></p>
<p>比如：“/dev/mapper/centos-root on / type xfs (rw,relatime,seclabel,attr2,inode64,noquota)”，表示“/dev/mapper/centos-root”挂载到“/”下 面了，并且文件类型是“xfs”。</p>
<h5 id="挂载-u-盘"><a href="#挂载-u-盘" class="headerlink" title="挂载 u 盘"></a>挂载 u 盘</h5><p>使用 fdisk 命令查看 U 盘的分区：</p>
<p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-03-21_11-25-00.png" alt></p>
<pre><code class="lang-shell"># 创建一个目录用于挂载U盘（创建挂载点）。
mkdir /root/upan
# 将U盘所在分区挂载到我们刚刚创建的目录下面。
mount /dev/sdb /root/upan/
# 对U盘里面的文件进行查看或者操作
ls -hl /root/upan/
# 卸载U盘
umount /dev/sdb
</code></pre>
<p><strong>如果挂载的时候出现“mount: unknown filesystem type ‘(null)’</strong></p>
<pre><code class="lang-shell"># 格式化U盘所在的分区,window的文件系统类型linux无法识别
mkfs.ext4 /dev/sdb
</code></pre>
<h4 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h4><p>在 Linux 中使用 umount 这个命令来解挂文件系统。如果某个文件系统你不需要使用了，就可以 使用 umount 命令来进行卸载。这个命令可以把文件系统从 Linux 系统中分离。</p>
<pre><code class="lang-shell">umount [设备名]
</code></pre>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><h4 id="服务的概念"><a href="#服务的概念" class="headerlink" title="服务的概念"></a><strong>服务的概念</strong></h4><p>服务是指执行指定系统功能的程序、或者进程，以便于支持其它程序的运行，尤其是接近底层 （接近硬件）的程序，比如：FTP、HTTP、防火墙、网络等服务。服务的管理包括：<strong>开启</strong>、<strong>查 看</strong>、<strong>重启</strong>、<strong>停止</strong>等操作</p>
<h4 id="服务的分类"><a href="#服务的分类" class="headerlink" title="服务的分类"></a><strong>服务的分类</strong></h4><p>Linux 系统的服务分为<strong>独立运行的服务</strong>和<strong>受 xinetd 管理的服务</strong>两大类。独立运行的服务在系统 启动后可以独立运行并直接进行管理，这种服务与运行级别有关；而 xinetd，其本身是一个独立 运行的服务，它负责管理一些不常用的服务，当这些不常用的服务被请求时，由 xinetd 服务负责 启动运行，完成服务请求，再结束该服务的运行，以减少系统资源的占用，这些服务的启动和停 止都由 xinetd 控制。</p>
<p>xinetd 服务的配置文件是“/etc/xinetd.conf”，受 xinetd 服务管理的服务在“/etc/xinetd.d”目 录下有相应的配置脚本文件。例如，telnet 服务就是一个受 xinetd 管理的服务。</p>
<h4 id="服务的启动脚本"><a href="#服务的启动脚本" class="headerlink" title="服务的启动脚本"></a><strong>服务的启动脚本</strong></h4><p>在管理服务时，Linux 中的每个服务都有相应的启动脚本，可用于设置启动、停止、重启和查 询服务等功能。所有的服务脚本都保存在“/etc/rc.d/init.d”目录中，脚本名称和服务器名称相对 应。在服务的启动脚本中，一般还有对该脚本文件的有效期和使用方法的描述，可以使用查看命 令来查看。</p>
<h4 id="systemctl-命令"><a href="#systemctl-命令" class="headerlink" title="systemctl 命令"></a><strong>systemctl 命令</strong></h4><p>服务在使用过程中可以进行启动、状态查询、停止、重启，实现服务自启动状态设置，禁用服 务等操作。在 Linux 中对服务的管理可以通过 systemctl 命令来实现。之前版本的 CentOS7 使用 <strong>service</strong>命令和<strong>chkconfig</strong>命令实现对服务的状态设置和自启动设置，目前 CentOS Linux 7 使用 <strong>systemctl</strong>替换了原有命令。</p>
<pre><code class="lang-shell">systemctl [start|stop|status|restart|reload] 服务名

 参数说明:
     start：启动服务。
    stop：停止服务。
    status：查看服务运行情况。
    restart：重启服务。
    reload：重新加载服务，加载更新后的配置文件（并不是所有服务都支持这个选项)。用户可以使用该命令管理服务，systemctl命令会自动到/etc/rc.d/init.d/下查找并执行相应的服
务脚本。
</code></pre>
<p>服务名一般以<strong>“.service”</strong>结尾，这些服务是被 systemctl 监视的进程，如果要求启动或停止的某 个服务不存在，系统将会寻找同名的初始化脚本，即去掉.service 后缀的服务脚本。这主要用于 与传统的 Linux 系统兼容。</p>
<h4 id="设置服务自启动"><a href="#设置服务自启动" class="headerlink" title="设置服务自启动"></a>设置服务自启动</h4><h5 id="systemctl-设置自启动"><a href="#systemctl-设置自启动" class="headerlink" title="systemctl 设置自启动"></a>systemctl 设置自启动</h5><p><strong>查看服务是不是自启动</strong></p>
<pre><code class="lang-shell">systemctl is-enable 服务名称
</code></pre>
<p><strong>设置服务自启动/取消自启动</strong></p>
<pre><code class="lang-shell">systemctl enable/disable 服务名

#enable：表示设置服务随着系统启动而启动。
#disable：表示设置取消服务随系统启动而启动。
</code></pre>
<h3 id="进程"><a href="#进程" class="headerlink" title="==进程=="></a>==进程==</h3><h4 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a><strong>进程的概念</strong></h4><p><strong>进程(Process)：是指操作系统中一个独立运行的程序</strong>（这里强调的是运行中的程序，如果程 序不运行，仅仅保存在硬盘上就不能称为进程）。例如在 windows 中，同时运行着 Winxin、 Word、QQ，那么 Winxin 程序是一个进程，Word 程序也是一个进程。在 Windows 操作系统中的 任务管理器中，就可以清晰的看到当前操作系统中正在运行的进程信息。</p>
<p><strong>进程</strong>，也称<strong>任务</strong>，所有支持多个进程同时执行的操作系统就被称作<strong>多进程操作系统</strong>或<strong>多任务操作系统</strong>，现在主流的操作系统都属于这种类型。</p>
<h4 id="进程的分类"><a href="#进程的分类" class="headerlink" title="进程的分类"></a><strong>进程的分类</strong></h4><p>进程一般分为<strong>交互进程</strong>、批处理进程和<strong>守护进程</strong>三类。</p>
<ul>
<li>交互进程指 Shell 下通过执行程序产生的进程，可在前台运行，也可在后台运行。</li>
<li>批处理进程是进程的序列，在执行批处理进程时是不需要人机交互的。</li>
<li>守护进程总是活跃的，一般在后台运行（也叫后台进程）。守护进程一般是由系统在开机时 通过脚本自动启动或者由 root 用户启动的。由于守护进程是一直运行着的，所以它所处的 状态是等待请求处理任务。比如，httpd 服务一直在运行，等待着用户来访问，也就是等待 需要处理的任务。</li>
</ul>
<h4 id="进程的查看"><a href="#进程的查看" class="headerlink" title="进程的查看"></a>进程的查看</h4><h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><p>用于查看系统进程的信息的命令。</p>
<pre><code class="lang-shell">#查找指定进程的信息
ps [options] [| grep 进程名]
options:
    -A    显示所有的进程，跟-e的效果相同
    -a    显示现行终端机下的所有进程，包括其他用户的进程
    -u    显示当前用户的进程状态
    -x    通常与 a 这个参数一起使用，可列出较完整信息
    -l    较长、较详细的将该PID的信息列出
    -j    工作的格式(jobs format)
    -f    把进程的所有信息都显示出来
    -e    表示显示所有继承
    -p：显示由进程ID指定的进程的信息。

# 获得所有用户进程的信息
ps -aux

# 跟more/less一起使用
ps -aux | more

# 查看pid=1号进程的信息
ps -p 1

# 查看MySQL进程的运行情况
ps -ef | grep mysql
</code></pre>
<blockquote>
<p>ps 只能显示进程的瞬时状态,如果要动态监控进程状态则使用一个’top’指令<br>​ 进程名后的 d<br>​ mysqld<br>​ firewalld<br>​ 是后台进程(守护进程的意思) daemon</p>
</blockquote>
<p><strong>查看指定端口的进程</strong></p>
<pre><code class="lang-shell">ss [options] [| grep 端口号]

ss 是 Socket Statistics 的缩写
options:
 -h, –help 帮助
 -V, –version 显示版本号
 -t, –tcp 显示 TCP 协议的 sockets
 -u, –udp 显示 UDP 协议的 sockets
 -x, –unix 显示 unix domain sockets，与 -f 选项相同
 -n, –numeric 不解析服务的名称，如 “22” 端口不会显示成 “ssh”
 -l, –listening 只显示处于监听状态的端口
 -p, –processes 显示监听端口的进程(Ubuntu 上需要 sudo)
 -a, –all 对 TCP 协议来说，既包含监听的端口，也包含建立的连接
 -r, –resolve 把 IP 解释为域名，把端口号解释为协议名称

# 输出所有建立的连接不包含端口
ss | more

# 查看主机监听的端口。
ss -tnl

# 使用 -p查看监听端口的程序名称
ss -tlp

# 过滤SSH进程的信息。
ss -tlp | grep ssh
ss -tnlp | grep ssh
</code></pre>
<h5 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h5><p><strong>kill</strong></p>
<pre><code class="lang-shell">kill [信号代码] 进程编号
</code></pre>
<p>kill 命令可将指定的信息送至程序。预设的信息 SIGTERM(15)，可将指定进程终止。若仍无法 终止该进程，可使用 SIGKILL(9)，尝试强制删除进程。kill 命令的工作原理是：<strong>向 Linux 系统的内 核发送一个系统操作信号和某个进程的进程标志号，然后系统内核就可以对该进程进行操作。</strong>一 般情况下，kill 命令与 ps、grep 命令结合在一起使用（因为要查询进程的编号）。</p>
<p><strong>killall</strong></p>
<pre><code class="lang-shell">killall [信号代码] 进程名

#关闭sshd所有的进程
killall sshd
</code></pre>
<h4 id="查看被文件被哪个进程占用-拓展"><a href="#查看被文件被哪个进程占用-拓展" class="headerlink" title="查看被文件被哪个进程占用(拓展)"></a>查看被文件被哪个进程占用(拓展)</h4><h5 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h5><p>lsof 是 List Open File 的缩写, 它主要用来获取被进程打开文件的信息，我们都知道，在 Linux 中，一切皆文件，lsof 命令可以查看所有已经打开了的文件，比如: 普通文件，目录，特殊的块文件，管道，socket 套接字，设备，Unix 域套接字等等，同时，它还可以结合 grep 以及 ps 命令进行更多的高级搜索</p>
<p><strong>安装</strong></p>
<p>lsof 命令默认是没有安装的，而且它的使用需要有 root 权限或者赋予普通用于 sudo 权限, 使用以下命令安装</p>
<pre><code class="lang-mipsasm">yum install -y lsof
</code></pre>
<p><code>lsof</code> 命令有很多可选参数,以下是一些常用的场景</p>
<p><strong>列出所有打开的文件</strong></p>
<p>不带任何参数执行 <code>lsof</code> 命令会输出当前所有活跃进程打开的所有文件</p>
<pre><code class="lang-bash">[root@ecs-centos-7 ~]# lsof | more
COMMAND     PID   TID    USER   FD      TYPE             DEVICE  SIZE/OFF       NODE NAME
systemd       1          root  cwd       DIR              253,1      4096          2 /
systemd       1          root  rtd       DIR              253,1      4096          2 /
systemd       1          root  txt       REG              253,1   1624520     530313 /usr/lib/systemd/systemd
systemd       1          root  mem       REG              253,1     20064     528340 /usr/lib64/libuuid.so.1.3.0
systemd       1          root  mem       REG              253,1    265600     532853 /usr/lib64/libblkid.so.1.1.0
systemd       1          root  mem       REG              253,1     90248     525942 /usr/lib64/libz.so.1.2.7
systemd       1          root  mem       REG              253,1    157424     525955 /usr/lib64/liblzma.so.5.2.2
systemd       1          root  mem       REG              253,1     23968     526159 /usr/lib64/libcap-ng.so.0.0.0
systemd       1          root  mem       REG              253,1     19896     526135 /usr/lib64/libattr.so.1.1.0
systemd       1          root  mem       REG              253,1     19288     525996 /usr/lib64/libdl-2.17.so
systemd       1          root  mem       REG              253,1    402384     525931 /usr/lib64/libpcre.so.1.2.0
systemd       1          root  mem       REG              253,1   2156160
</code></pre>
<p>由于<code>lsof</code>命令会输出很多信息，所以上面例子中使用了 <code>lsof | more</code> 来分页显示命令输出结果</p>
<p>输出结果中，第一列中 <code>systemd</code> 的进程 ID 是 <code>1</code>,它是一个守护进程</p>
<p>其中列 <code>COMMAND</code> 、<code>PID</code>、<code>USER</code> 分别表示进程名、进程 ID、所属用户</p>
<p>列 <code>FD</code> 是文件描述符，下面是可能的类型以及说明</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">FD</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">cwd</td>
<td style="text-align:center">当前目录</td>
</tr>
<tr>
<td style="text-align:center">txt</td>
<td style="text-align:center">txt 文件</td>
</tr>
<tr>
<td style="text-align:center">rtd</td>
<td style="text-align:center">root 目录</td>
</tr>
<tr>
<td style="text-align:center">mem</td>
<td style="text-align:center">内存映射文件</td>
</tr>
</tbody>
</table>
</div>
<p>列 <code>TYPE</code> 是文件类型，下面是可能的值以及说明</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">TYPE</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DIR</td>
<td style="text-align:center">目录</td>
</tr>
<tr>
<td style="text-align:center">REG</td>
<td style="text-align:center">普通文件</td>
</tr>
<tr>
<td style="text-align:center">CHR</td>
<td style="text-align:center">字符</td>
</tr>
<tr>
<td style="text-align:center">a_inode</td>
<td style="text-align:center">Inode 文件</td>
</tr>
<tr>
<td style="text-align:center">FIFO</td>
<td style="text-align:center">管道或者 socket 文件</td>
</tr>
<tr>
<td style="text-align:center">netlink</td>
<td style="text-align:center">网络</td>
</tr>
<tr>
<td style="text-align:center">unknown</td>
<td style="text-align:center">未知</td>
</tr>
</tbody>
</table>
</div>
<p>列 <code>DEVICE</code> 表示设备 ID</p>
<p>列 <code>SIZE/OFF</code> 表示进程大小</p>
<p>列 <code>NODE</code> 表示文件的 Inode 号</p>
<p>列<code>NAME</code> 表示路径或者链接</p>
<p><strong>列出指定用户已打开的文件</strong></p>
<p>使用 <code>-u</code> 选项可以列出指定用户已经打开的文件，该选项后面可以接多个用户名，每个用户名之间用空格隔开，表示列出所有指定用户已打开的所有文件</p>
<pre><code class="lang-bash">[root@ecs-centos-7 ~]# lsof -u tt | more
COMMAND   PID USER   FD   TYPE DEVICE  SIZE/OFF   NODE NAME
bash    27789   tt  cwd    DIR  253,1      4096 131090 /home/tt
bash    27789   tt  rtd    DIR  253,1      4096      2 /
bash    27789   tt  txt    REG  253,1    964600 525779 /usr/bin/bash
vim     27813   tt  txt    REG  253,1   2337192 531847 /usr/bin/vim
vim     27813   tt    4u   REG  253,1     12288 131167 /home/tt/.p.txt.swp
</code></pre>
<p>上面的例子中，<code>lsof -u tt</code> 命令表示列出 <code>tt</code> 用户已经打开了的文件，从结果可以看出，用户打开了 <code>/home/tt</code>、<code>/</code>、<code>/usr/bin/bash</code>、<code>/usr/bin/vim</code>、<code>/home/tt/.p.txt.swp</code> 这几个文件</p>
<p>如果要排除指定用户已经打开的文件，可以在用户名前加 <code>^</code> 符号，下面的命令会列出除<code>tt</code>用户外其他所有用户已打开了的文件</p>
<pre><code class="lang-dos">lsof -u ^tt | more
</code></pre>
<p><strong>找出打开着但已被删除了的文件</strong></p>
<p>有这样一种场景，有一个服务正在往日志文件中写日志，这个时候，不小心把正在写入的日志文件删除了</p>
<p>上面的场景中，日志文件虽然被删除了，但是文件仍然是打开着的，它仍然占用文件系统的空间，我们可以结合 <code>grep</code> 命令找出这种打开着，但是已经被删除的文件</p>
<pre><code class="lang-bash">[root@ecs-centos-7 ~]# lsof -u tt | grep deleted
vim     27813   tt    4u   REG  253,1    12288 131167 /home/tt/.p.txt.swp(deleted)
</code></pre>
<p>上面例子中使用 <code>lsof -u tt | grep deleted</code> 命令查看用户 <code>tt</code>打开着的确被删除的文件</p>
<p>从结果可以看出，在往 <code>p.txt</code>写入内容的时候，文件被删除了</p>
<p><strong>列出所有打开了的网络文件</strong></p>
<pre><code class="lang-x86asm">[root@ecs-centos-7 ~]# lsof -i
COMMAND    PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
ntpd       567   ntp   18u  IPv4  12657      0t0  UDP localhost:ntp
ntpd       567   ntp   22u  IPv6  16095      0t0  UDP ecs-centos-7.4-64bit-20200212:ntp
dhclient   651  root    6u  IPv4  14594      0t0  UDP *:bootpc
master     960  root   13u  IPv4  15791      0t0  TCP localhost:smtp (LISTEN)
master     960  root   14u  IPv6  15792      0t0  TCP localhost:smtp (LISTEN)
mysqld    1053 mysql   13u  IPv6  15147      0t0  TCP *:mysql (LISTEN)
sshd      1348  root    3u  IPv4  16698      0t0  TCP *:ssh (LISTEN)
</code></pre>
<ul>
<li>列出所有 IPV4/6 网络文件</li>
</ul>
<p>列出所有已经打开了的 ipv4 网络文件</p>
<pre><code class="lang-ruby">[root@ecs-centos-7 ~]# lsof -i 4
COMMAND    PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
ntpd       567  ntp   16u  IPv4  12651      0t0  UDP *:ntp
ntpd       567  ntp   18u  IPv4  12657      0t0  UDP localhost:ntp
ntpd       567  ntp   21u  IPv4  16094      0t0  UDP ecs-centos-7.4-64bit-20200212:ntp
dhclient   651 root    6u  IPv4  14594      0t0  UDP *:bootpc
master     960 root   13u  IPv4  15791      0t0  TCP localhost:smtp (LISTEN)
sshd      1348 root    3u  IPv4  16698      0t0  TCP *:ssh (LISTEN)
</code></pre>
<p>所有已经打开了的 ipv6 网络文件</p>
<pre><code class="lang-ruby">[root@ecs-centos-7 ~]# lsof -i 6
COMMAND  PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
ntpd     567   ntp   17u  IPv6  12652      0t0  UDP *:ntp
ntpd     567   ntp   19u  IPv6  12658      0t0  UDP localhost:ntp
ntpd     567   ntp   22u  IPv6  16095      0t0  UDP ecs-centos-7.4-64bit-20200212:ntp
master   960  root   14u  IPv6  15792      0t0  TCP localhost:smtp (LISTEN)
mysqld  1053 mysql   13u  IPv6  15147      0t0  TCP *:mysql (LISTEN)
sshd    1348  root    4u  IPv6  16700      0t0  TCP *:ssh (LISTEN)
</code></pre>
<ul>
<li>列出在指定端口上打开的文件</li>
</ul>
<p>使用 <code>lsof -i:端口号</code> 可以获得所有在指定端口号上打开的文件</p>
<pre><code class="lang-ruby">[root@ecs-centos-7 ~]# lsof -i:22
COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd     1348 root    3u  IPv4  16698      0t0  TCP *:ssh (LISTEN)
sshd     1348 root    4u  IPv6  16700      0t0  TCP *:ssh (LISTEN)
sshd    27741 root    3u  IPv4 458958      0t0  TCP ecs-centos-7.4-64bit-20200212:ssh-&gt;113.118.121.220:42395 (ESTABLISHED)
sshd    27819 root    3u  IPv4 459250      0t0  TCP ecs-centos-7.4-64bit-20200212:ssh-&gt;113.118.121.220:19807 (ESTABLISHED)
sshd    27895 root    3u  IPv4 459828      0t0  TCP
</code></pre>
<p>上面例子列出了所有在 22 号端口上打开的文件</p>
<p>在服务器开发中，经常会部署一个网关或者代理程序，用来和客户端通讯，网关或者代理程序需要开放一个固定的端口供客户端连接用</p>
<p>如果客户端连接不上网关或者代理程序，我们可以用上述命令检查网关或代理程序的端口是否开启，来排除因为端口关闭了导致连接不上网关的情况</p>
<ul>
<li>列出使用了指定协议(TCP/UDP) 的文件</li>
</ul>
<p>使用 <code>lsof -i TCP/UDP</code> 列出使用了 TCP 或 UDP 协议的文件</p>
<pre><code class="lang-ruby">[root@cghost8 /home/cgyx]# lsof -i TCP | more
COMMAND      PID   USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
sshd        1704   root    3u  IPv4   13593      0t0  TCP *:ssh (LISTEN)
sshd        1704   root    4u  IPv6   13595      0t0  TCP *:ssh (LISTEN)
redis-serer   1725   root    4u  IPv4   19773      0t0  TCP localhost:6380 (LISTEN)
nc          2067   cgyx    4u  IPv4   39167      0t0  TCP *:60600 (LISTEN)
mysqld      3020  mysql    4u  IPv6 5514608      0t0  TCP 192.168.70.10:mysql-&gt;192.168.70.10:37084 (ESTABLISHED)
</code></pre>
<p>使用 <code>lsof -i TCP:3306</code> 列出使用了 TCP 协议并且端口为 3306 的文件</p>
<pre><code class="lang-ruby">[root@cghost8 /home/cgyx]# lsof -i TCP:3306
COMMAND      PID  USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
mysqld      3020 mysql    4u  IPv6 5514608      0t0  TCP 192.168.70.10:mysql-&gt;192.168.70.10:37084 (ESTABLISHED)
</code></pre>
<p>使用 <code>lsof -i TCP:1-1024</code> 列出使用了 TCP 协议并且端口范围为 1 到 1024 的文件</p>
<pre><code class="lang-ruby">[root@cghost8 /home/cgyx]# lsof -i TCP:1-1024
COMMAND   PID   USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
sshd     1704   root    3u  IPv4   13593      0t0  TCP *:ssh (LISTEN)
sshd     1704   root    4u  IPv6   13595      0t0  TCP *:ssh (LISTEN)
cupsd    1709   root   12u  IPv6   39148      0t0  TCP localhost:ipp (LISTEN)
cupsd    1709   root   13u  IPv4   39149      0t0  TCP localhost:ipp (LISTEN)
smbd     1824   root   35u  IPv6   17658      0t0  TCP *:microsoft-ds (LISTEN)
smbd     1824   root   36u  IPv6   17659      0t0  TCP *:netbios-ssn (LISTEN)
smbd     1824   root   37u  IPv4   17660      0t0  TCP *:microsoft-ds (LISTEN)
smbd     1824   root   38u  IPv4   17661      0t0  TCP *:netbios-ssn (LISTEN)
</code></pre>
<p><strong>列出目录中所有打开的文件</strong></p>
<p>可以使用<code>lsof</code>命令列出指定目录中的所有打开文件</p>
<p>现有一个<code>data</code>目录 ,结构如下：</p>
<pre><code class="lang-haskell">[root@ecs-centos-7 tt]# tree data/
data/
├── dira
│   └── a.txt
└── d.s

1 directory, 2 files
</code></pre>
<p>列出 <code>data</code> 目录中打开的文件</p>
<pre><code class="lang-powershell">[root@ecs-centos-7 tt]# lsof +D ./data/
COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME
bash    28473 root  cwd    DIR  253,1     4096 131146 ./data
bash    28502 root  cwd    DIR  253,1     4096 131172 ./data/dira
vim     28530 root  cwd    DIR  253,1     4096 131172 ./data/dira
vim     28530 root    4u   REG  253,1    12288 131174 ./data/dira/.a.txt.swp

[root@ecs-centos-7 tt]# lsof +d ./data/
COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME
bash    28473 root  cwd    DIR  253,1     4096 131146 ./data
bash    28502 root  cwd    DIR  253,1     4096 131172 ./data/dira
vim     28530 root  cwd    DIR  253,1     4096 131172 ./data/dira
</code></pre>
<p>上面例子中，<code>+D</code> 和 <code>+d</code> 选项都是列出目录中打开的文件</p>
<p><code>+D</code> 选项会列出一个目录和其子目录中打开的文件，而 <code>+d</code> 选项只会列出当前目录下已打开的文件</p>
<p><strong>列出指定进程 ID 打开的文件</strong></p>
<p>进程 ID 是操作系统进程的唯一标识，以下命令列出了进程 ID 为 <code>1053</code> 相关的文件, 从结果中可以知道这个进程 ID 对应的进程是 MySQL</p>
<pre><code class="lang-yaml">[root@ecs-centos-7 ~]# lsof -p 1053
COMMAND  PID  USER   FD   TYPE             DEVICE  SIZE/OFF    NODE NAME
mysqld  1053 mysql  cwd    DIR              253,1      4096 1055765 /var/lib/mysql
mysqld  1053 mysql  rtd    DIR              253,1      4096       2 /
mysqld  1053 mysql  txt    REG              253,1 251841448  534935 /usr/sbin/mysqld
mysqld  1053 mysql  mem    REG              253,1    209512  659436 /usr/lib64/mysql/plugin/validate_password.so
mysqld  1053 mysql    1w   REG              253,1    206658  924771 /var/log/mysqld.log
mysqld  1053 mysql    2w   REG              253,1    206658  924771 /var/log/mysqld.log
</code></pre>
<p>上述命令中，<code>-p</code> 选项后面可以指定多个进程 ID，每个进程 ID 之间用逗号分隔，如果想排除掉某个进程打开的文件，可以在该进程 ID 前面加上 <code>^</code>符号</p>
<pre><code class="lang-css">lsof -p 1,2,3,^4
</code></pre>
<p>上述命令会列出进程 1，进程 2，进程 3 打开的所有文件，同时忽略进程 4 打开的文件</p>
<h4 id="使用文件或文件结构识别进程"><a href="#使用文件或文件结构识别进程" class="headerlink" title="使用文件或文件结构识别进程"></a>使用文件或文件结构识别进程</h4><h5 id="fuser"><a href="#fuser" class="headerlink" title="fuser"></a>fuser</h5><p>用于报告进程使用的文件和网络套接字。fuser 命令列出了本地进程的进程号，那些本地进程使用 file，参数指定的本地或远程文件。每个进程号后面都跟随一个字母，该字母指示进程如何使用文件。</p>
<ul>
<li><code>c</code> ：指示进程的工作目录。</li>
<li><code>e</code> ：指示该文件为进程的可执行文件(即进程由该文件拉起)。</li>
<li><code>f</code> ：指示该文件被进程打开，默认情况下 f 字符不显示。</li>
<li><code>F</code> ：指示该文件被进程打开进行写入，默认情况下 F 字符不显示。</li>
<li><code>r</code> ：指示该目录为进程的根目录。</li>
<li><code>m</code> ：指示进程使用该文件进行内存映射，抑或该文件为共享库文件，被进程映射进内存。</li>
</ul>
<p><strong>语法</strong></p>
<pre><code class="lang-shell">fuser(选项)(参数)

选项:
    -a：显示命令行中指定的所有文件；
    -k：杀死访问指定文件的所有进程；
    -i：杀死进程前需要用户进行确认；
    -l：列出所有已知信号名；
    -m：指定一个被加载的文件系统或一个被加载的块设备；
    -n：选择不同的名称空间；
    -u：在每个进程后显示所属的用户名。

参数:
    文件：可以是文件名或者TCP、UDP端口号。
</code></pre>
<p><strong>实例</strong></p>
<p>要列出使用<code>/etc/passwd</code>文件的本地进程的进程号，请输入：</p>
<pre><code class="lang-shell">fuser /etc/passwd
</code></pre>
<p>要列出使用<code>/etc/filesystems</code>文件的进程的进程号和用户登录名，请输入：</p>
<pre><code class="lang-shell">fuser -u /etc/filesystems
</code></pre>
<p>要终止使用给定文件系统的所有进程，请输入：</p>
<pre><code class="lang-shell">fuser -k -x -u -c /dev/hd1  或者  fuser -kxuc /home
</code></pre>
<p>任一命令都列出了进程号和用户名，然后终止每个正在使用<code>/dev/hd1 (/home)</code>文件系统的进程。仅有 root 用户能终止属于另一用户的进程。如果您正在试图卸下<code>/dev/hd1</code>文件系统，而一个正在访问<code>/dev/hd1</code>文件系统的进程不允许这样，您可能希望使用此命令。</p>
<p>要列出正在使用已从给定文件系统删除的文件的全部进程，请输入：</p>
<pre><code class="lang-shell">fuser -d /usr文件
</code></pre>
<p><code>/dev/kmem</code> 用于系统映像。<br><code>/dev/mem</code> 也用于系统映像。</p>
<h4 id="杀死指定用户的所有进程"><a href="#杀死指定用户的所有进程" class="headerlink" title="杀死指定用户的所有进程"></a>杀死指定用户的所有进程</h4><p>前面介绍了列出指定用户所有打开的文件，我们可以组合 <code>kill</code> 命令一起使用，实现杀死指定用户的所有进程的功能，具体的命令如下</p>
<pre><code class="lang-perl">kill -9 `lsof -t -u tt`
</code></pre>
<p>上述命令中，<code>lsof -u tt</code> 是列出<code>tt</code>用户所有打开的文件，加上 <code>-t</code> 选项之后表示结果只列出 PID 列，也就是进程 ID 列，其他列都忽略，前面的 <code>kill -9</code> 表示强制结束指定的进程 ID</p>
<h3 id="shell-1"><a href="#shell-1" class="headerlink" title="shell"></a>shell</h3><h4 id="echo"><a href="#echo" class="headerlink" title="==echo=="></a>==echo==</h4><p>用于字符串的输出</p>
<pre><code class="lang-shell">echo string

#1.显示字符串
echo &quot;It is a test&quot;
#这里的双引号完全可以省略，以下命令与上面实例效果一致
echo It is a test

#2.显示转义字符
echo &quot;\&quot;It is a test\&quot;&quot;
#结果
&quot;It is a test&quot;

#3.显示变量
#read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量
#!/bin/sh
read name
echo &quot;$name It is a test&quot;
#以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:
[root@www ~]# sh test.sh
OK                     #标准输入
OK It is a test        #输出


#4.显示换行
echo -e &quot;OK! \n&quot; # -e 开启转义
echo &quot;It is a test&quot;
#输出结果：
OK!

It is a test


#6.显示结果定向至文件
echo &quot;It is a test&quot; &gt; myfile

#7.原样输出字符串，不进行转义或取变量(用单引号)
echo &#39;$name\&quot;&#39;
#输出结果:
$name\&quot;


#8.显示命令执行结果(使用反引号)
echo `date`
</code></pre>
<h3 id="后台运行任务"><a href="#后台运行任务" class="headerlink" title="==后台运行任务=="></a>==后台运行任务==</h3><h4 id="任务日志打印"><a href="#任务日志打印" class="headerlink" title="任务日志打印"></a>任务日志打印</h4><p>0:标准输入 操作重定向符为<code>&lt;</code></p>
<p>1:标准输出(不指定的话默认省略)</p>
<p>2:错误输出</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>重定向操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;</td>
<td>指定标准输出文件(即无报错输出)，若有则覆盖</td>
</tr>
<tr>
<td>>&gt;</td>
<td>指定标准输出文件，若有则追加</td>
</tr>
<tr>
<td>2&gt;</td>
<td>错误重定向，如果重定向文件存在，则覆盖</td>
</tr>
<tr>
<td>2&gt;&gt;</td>
<td>错误重定向，如果重定向文件存在，则追加</td>
</tr>
<tr>
<td>&amp;&gt;</td>
<td>错误重定向和标准输出重定向一起操作，如果重定向文件存在，则覆盖</td>
</tr>
<tr>
<td>&amp;&gt;&gt;</td>
<td>错误重定向和标准输出重定向一起操作，如果重定向文件存在，则追加</td>
</tr>
</tbody>
</table>
</div>
<p>这个命令可以实现两个文件的合并</p>
<pre><code class="lang-plain">cat helloWord1.txt &gt;&gt; helloWord2.txt
</code></pre>
<p>&amp;1 表示标准输出的引用，所以 2&gt;&amp;1 是指把标准错误输出重定向到标准输出的引用，即也重定向到 file</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>重定向操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmd &gt; filename 2&gt;&amp;1</td>
<td>把标准输出和标准错误一起重定向到一个文件中。</td>
</tr>
<tr>
<td>cmd &gt;&gt; filename 2&gt;&amp;1</td>
<td>把标准输出和标准错误一起重定向到一个文件中(追加)。</td>
</tr>
<tr>
<td>cmd &lt; filename</td>
<td>输入重定向，命令的输入不是通过键盘来完成，而是通过其它方式实 现。cmd 命令以 filename 文件作为标准输入。</td>
</tr>
<tr>
<td>cmd &lt; filename &gt; filename2</td>
<td>把 cmd 命令以 filename 文件作为标准输入，以 filename2 文件作为标准 输出。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h4><p>使进程后台不挂起运行（即用户退出登录后，进程仍然运行）</p>
<pre><code class="lang-plain">nohup command [Args...] [&amp;]

command ： 需要执行的命令
[Args...] : 些参数，可以指定输出文件
&amp; ：让命令在后台执行，终端正常退出后命令仍旧执行,即使用exit命令
</code></pre>
<h3 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="==创建定时任务=="></a>==创建定时任务==</h3><h4 id="cron-和-crontab"><a href="#cron-和-crontab" class="headerlink" title="cron 和 crontab"></a>cron 和 crontab</h4><p>cron 是系统主要的非常好用的调度进程，它可以在无需人工干预的情况下运行作业。我们可以 通过 crontab 的命令提交、编辑或删除相应的作业。每一个用户都可以有一个 crontab 文件来保存 调度信息。可以使用它运行任意一个 shell 脚本或某个命令，可以是每小时运行一次，每一天、或 一周一次，这完全取决于用户自己。每一个用户都可以有自己的 crontab 文件，但在一个较大的 系统中，系统管理员一般会禁止这些文件，而只在整个系统保留一个这样的文件。系统管理员是 通过<strong>/etc/cron.deny</strong>和<strong>/etc/cron.allow</strong>这两个文件来禁止或允许用户拥有自己的 crontab 文件。</p>
<p>如果我们把 test 用户加入到<strong>/etc/cron.deny</strong>文件中去：</p>
<p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-04-12_07-43-12.png" alt></p>
<p>如果我们以 test 用户登录，然后配置 crontab，会得到下面的提示：</p>
<p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-04-12_07-44-12.png" alt></p>
<h5 id="crontab-命令"><a href="#crontab-命令" class="headerlink" title="crontab 命令"></a>crontab 命令</h5><pre><code class="lang-shell">crontab [-u user] file
#或者
crontab [ -u user ] &#123; -l | -r | -e &#125;

Options:
    -u：用户名，一般不用，都是自己管理自己的crontab任务。
    -e：编辑(edit)crontab文件。
    -l：列出(list)crontab文件中的内容。
    -r：删除(remove)crontab文件。

#如果使用自己的名字登录，就不用使用-u选项，因为在执行crontab命令时，该命令能够知道当前的用户。
</code></pre>
<p><strong>crontab 的域</strong></p>
<p>为了能够在特定的时间运行作业，需要了解 crontab 文件每个条目的格式，以及其中各个域的 意义。下面就是这些域：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">列</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">第 1 列</td>
<td>分钟 1 ～ 59</td>
</tr>
<tr>
<td style="text-align:center">第 2 列</td>
<td>小时 0 ～ 23（0 表示子夜）</td>
</tr>
<tr>
<td style="text-align:center">第 3 列</td>
<td>日期 1 ～ 31</td>
</tr>
<tr>
<td style="text-align:center">第 4 列</td>
<td>月份 1 ～ 12</td>
</tr>
<tr>
<td style="text-align:center">第 5 列</td>
<td>星期 0 ～ 6（注意：0 表示星期天）</td>
</tr>
<tr>
<td style="text-align:center">第 6 列</td>
<td>要运行的命令或者脚本</td>
</tr>
</tbody>
</table>
</div>
<p>下面是 crontab 的格式：</p>
<pre><code class="lang-shell">分 时 日 月 星期几 要运行的命令或者要执行的脚本
</code></pre>
<p>在这些域中，可以用横杠<code>-</code>来表示一个时间范围，例如你希望星期一至星期五运行某个作业， 那么可以在星期域使用<code>1 - 5</code>来表示。还可以在这些域中使用逗号<code>,</code>，例如你希望星期一和星期四 运行某个作业，只需要使用<code>1, 4</code>来表示。如果你对某个表示时间域没有特别的限定，也应该在该 域填入*。该文件的每一个条目必须含有 5 个时间域，而且每个域之间要用空格分隔。该文件中所有的注释行要在行首用<code>#</code>来表示。</p>
<p><strong>案例</strong>:</p>
<pre><code class="lang-shell"># 表示每晚的21:30运行主目录目录下的cleanup.sh。
30 21 * * * ~/cleanup.sh
# 表示每月1、10、22日的4:45运行主目录目录下的backup.sh。
45 4 1,10,22 * * ~/backup.sh
# 表示每周六、周日的1:10运行一个find命令，查询日志文件然后删除
10 1 * * 6,0 /bin/find / -name &quot;*.log&quot; -exec rm &#123;&#125; \;
# 表示在每天18:00至23:00之间每隔30分钟运行主目录目录下的check.sh。
0,30 18-23 * * * ~/check.sh
# 表示每星期六的23:59进行系统的重启(执行命令得写命令的绝对路径)
59 23 * * 6 /sbin/reboot
# 表示每分钟执行一次时钟同步。
*/1 * * * * /usr/sbin/ntpdate ntp4.aliyun.com
</code></pre>
<p><strong>注意</strong>：如果是执行命令，请写命令的绝对路径，比如上面的 reboot、find 命令。 即<code>/sbin/reboot</code>,<code>/bin/find</code></p>
<p>其中当 第一列 为 <em>/n 时表示每 n 分钟个时间间隔执行一次，第二列为 </em>/n 表示每 n 小时个时间间隔执行一次，其余类推</p>
<h5 id="创建新的-crontab"><a href="#创建新的-crontab" class="headerlink" title="创建新的 crontab"></a>创建新的 crontab</h5><p>创建新的 crontab 可以直接编辑 crontab，也可以创建一个文件把 crontab 的内容写进入， 然后进行提交。</p>
<p>创建一个文件“mycron”，然后输入下面的内容：</p>
<pre><code class="lang-shell"># 每隔一分钟将当前时间写入主目录下面的system.log文件
*/1 * * * * /bin/echo `date` &gt;&gt; ~/system.log
</code></pre>
<p>向“crontab”提交 mycron 文件</p>
<pre><code class="lang-shell">crontab mycron
</code></pre>
<h4 id="at"><a href="#at" class="headerlink" title="at"></a>at</h4><p>at 命令允许用户向 cron 守护进程提交作业，使其在稍后的时间运行。这里稍后的时间可能是指 10min 以后，也可能是指几天以后。如果你希望在一个月或更长的时间以后运行，最好还是使用 crontab 文件。</p>
<p>一旦一个作业被提交， at 命令将会保留所有当前的环境变量，包括路径，不象 crontab，只提 供缺省的环境。该作业的所有输出都将以电子邮件的形式发送给用户，除非你对其输出进行了重 定向，绝大多数情况下是重定向到某个文件中。</p>
<p>at 在系统中可能是没有安装的,如果需要使用,则需要使用<code>yum</code>或者<code>apt</code>进行安装,然后使用<code>systemctl</code>开启<code>atd</code>服务,并最好设置其随着系统启动而启动</p>
<pre><code class="lang-shell"># 安装at。
yum -y install at
# 设置atd服务随机启动
systemctl enable atd
# 启动atd服务
systemctl start atd
</code></pre>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><pre><code class="lang-shell">at [options] [-f file] [time] [date]

    Options:
        -V：显示作业将被执行的时间。
        -q：选队列名称，队列名称可以是a-z和A-Z之间的任意字母。队列字母顺序越高，则队列优
先级别越低。
        -f：从文件中读取命令或Shell脚本。
        -l：(list)列出当前所有等待运行的作业。atq命令具有相同的作用。
        -r：(remove)清除作业。为了清除某个作业，还要提供相应的作业标识(id)。
        -m：执行完作业后发送电子邮件到用户。
      date：日期格式可以是月份数或日期数，而且at命令还能够识别诸如today、tomorrow这
样的词。
      time：设定作业执行的时间。time选项可以是下面格式中的任何一种。
        1、HH:MM格式，例如04:00，代表4:00AM。如果时间已过，就会在第二天的这一时间执
行。
        2、midnight代表12:00AM、teatime代表4:00PM。
        3、英文月名日期年份格式，例如 January 15 2022，代表2022年1月15
        4、MMDDYY、MM/DD/YY 或 MM.DD.YY格式，如051522，代表2022年5月15日。
        5、now +时间格式，时间以minutes、hours、day或 weeks为单位。如now +5 days，代
表命令应该在5天之后的此时此刻执行。此种格式可以写为“时间＋偏移量”的形式，偏移量
的单位是minutes、 hours和 days。
</code></pre>
<h5 id="at-提交命令或脚本"><a href="#at-提交命令或脚本" class="headerlink" title="at 提交命令或脚本"></a>at 提交命令或脚本</h5><p>使用 at 命令提交作业有几种不同的形式，可以通过<strong>命令行</strong>方式，也可以使用<strong>at 命令提示符</strong>。一 般来说在提交若干行的系统命令时，我使用 at 命令提示符方式，而在提交 shell 脚本时，使用命令 行方式。</p>
<p>如果你想提交若干行的命令，可以在 at 命令后面跟上日期/时间并回车。然后就进入了 at 命令提 示符，这时只需逐条输入相应的命令，然后按“<strong>CTRL - D</strong>”退出。</p>
<p>1.打印当前时间到主目录下面的 system.log 文件。</p>
<pre><code class="lang-shell"># 设要执行的时间
at -m 00:02
# 设置要执行的语句
echo `date` &gt;&gt; ~/system.log
</code></pre>
<p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-04-12_09-03-58.png" alt></p>
<p>其中， 就是。在 00:02 系统将执行我们指定的命令。你应当已经注意到，我所提交的作业被分 配了一个唯一标识 job4。并且提示我们了，这个 job 具体的执行时间。该命令在完成以后会将全 部结果以邮件的形式发送给我。</p>
<p>2.如果希望向 at 命令提交一个 shell 脚本，使用其命令行方式即可，在提交脚本时使用-f 选项。</p>
<pre><code class="lang-shell"># 将下面的内容写入~/my_at.sh文件
find / -name &quot;*.txt&quot; &gt; ~/result.log

# 今天晚上的23:59执行主目录下面的my_at.sh
at 23:59 -f ~/my_at.sh
</code></pre>
<p>3.可以使用管道符来提交 at 作业</p>
<pre><code class="lang-shell">find /root/ -name &quot;*.txt&quot; | at now +1 minute
</code></pre>
<p><strong>下面这些日期/时间格式都是 at 命令可以接受的：</strong></p>
<pre><code class="lang-shell"># 四月16号的早上6:45分触发
at 6:45am April 16
# 晚上的10:10触发
at 10:10pm
# 两分钟后触发
at now + 2 minutes
# 一个小时后触发
at now + 1 hour
# 明天上午九点触发
at 9:00am tomorrow

# yesterda是无效的。
at 9:00am yesterday
</code></pre>
<h5 id="列出所提交的作业"><a href="#列出所提交的作业" class="headerlink" title="列出所提交的作业"></a>列出所提交的作业</h5><pre><code class="lang-shell">at -l
#或
atq
</code></pre>
<p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-04-12_12-49-05.png" alt></p>
<p><strong>注意：</strong>其中，第一列是作业标识也就是 ID，后面是作业运行的日期/时间。第三列 a 代表 at，最后 一列代表谁提交的作业。如果作业已经运行完了，这里面是看不见的，也就是里面的 id 为什么不 连贯的原因。</p>
<p>当提交一个作业后，它就被拷贝到<strong>/var/spool/at</strong>目录中，准备在要求的时间运行。我们发现 里面正好有四个文件，就对应我们提交的四个作业。</p>
<pre><code class="lang-plain">echo &amp;变量名


# 定义变量
hello=&quot;world&quot;

# 打印变量
echo $hello
</code></pre>
<pre><code class="lang-plain">set
</code></pre>
<pre><code class="lang-plain">unset variable_name
</code></pre>
<h2 id="文件"><a href="#文件" class="headerlink" title="==文件=="></a>==文件==</h2><h3 id="文件的基本属性"><a href="#文件的基本属性" class="headerlink" title="==文件的基本属性=="></a>==文件的基本属性==</h3><pre><code class="lang-shell">d rw- rw- r--   1   nd_ljq   nd_ljq   110   Sep 12 18:20   javaTest
</code></pre>
<ul>
<li>第一个字符代表这个文件是目录,文件,链接文件等</li>
</ul>
<pre><code class="lang-shell">d 目录
- 文件
l 链接文件
b 可供存取的接口设备
c 表示串行的端口设备
</code></pre>
<ul>
<li>接下来的三组都是以 <code>rwx</code>的三个参数的组合(没有权限则是<code>-</code>号)</li>
</ul>
<pre><code class="lang-shell">r代表可读(readable) 4
w代表可写(writable) 2
x代表可执行(executable) 1
第一组rwx:所有者权限(owner)
第二组rwx:组权限(group)
第三组rwx:其他用户权限(other)
</code></pre>
<h3 id="为文件添加软-硬链接"><a href="#为文件添加软-硬链接" class="headerlink" title="==为文件添加软/硬链接=="></a>==为文件添加软/硬链接==</h3><pre><code class="lang-shell">#在linux中链接相当于windows中的快捷方式
#在linux中存在两种不同的链接:分别是`软链接`和`硬链接`
硬链接:是指同一个系统中的两个文件修改其中一个文件内容另一个文件也会改变 即两个文件指向一个node

软链接:又被称作符号链接,他是一个指向文件的指针,这个指针代表一个初始状态与指向文件一致的文件,修改软链接的内容,指向文件的内容不变

简而言之，硬链接是指两个文件指向同一个 inode，而软链接是指一个文件指向另一个文件的路径(更像快捷方式)

ln [-s] source_path target_path

 -s :soft 创建软链接


例:
ifcfg-ens33文件用于配置网络信，但是这个文件目录比较深，所以我们可以设置这个文件的链接文件。

ln -s /etc/sysconfig/network-scripts/ifcfg-ens33 my-ifcfg-ens33
</code></pre>
<h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="==修改文件权限=="></a>==修改文件权限==</h3><pre><code class="lang-shell">符号格式:
chmod [who]operator[permission] filename

who的选项是
    u:文件属主的权限
    g:同组用户权限
    o:其他用户权限
    a:所有用户权限

operator的选项是:
    + :增加权限
    - :取消权限
    = :设定权限

permission的选项是:
    r :读权限(4)
    w :写权限(2)
    x :执行权限(1)


绝对模式:
chmod 第一组权限数字(累加)第二组权限数字(累加)第三组权限数字(累加) fileName
</code></pre>
<h3 id="修改文件所属用户-组"><a href="#修改文件所属用户-组" class="headerlink" title="==修改文件所属用户/组=="></a>==修改文件所属用户/组==</h3><pre><code class="lang-shell">#更改所有者
chown [-options] userName fileName

#更改所属组
chgrp [-options] groupName fileName

options:
    R: 对所有子目录下的文件都进行同样操作
    h: 改变符号链接文件的属主不影响
</code></pre>
<h3 id="查看当前目录绝对路径"><a href="#查看当前目录绝对路径" class="headerlink" title="==查看当前目录绝对路径=="></a>==查看当前目录绝对路径==</h3><pre><code class="lang-js">pwd;
</code></pre>
<h3 id="拷贝文件-文件夹到指定目录"><a href="#拷贝文件-文件夹到指定目录" class="headerlink" title="拷贝文件/文件夹到指定目录"></a>拷贝文件/文件夹到指定目录</h3><pre><code>cp [options] source dest
cp [options] source dir

options:
    -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。
    -d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。
    -f：覆盖已经存在的目标文件而不给出提示。
    -i：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖。
    -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。
    -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。
    -l：不复制文件，只是生成链接文件。
</code></pre><h3 id="拷贝文件到远程服务器"><a href="#拷贝文件到远程服务器" class="headerlink" title="==拷贝文件到远程服务器=="></a>==拷贝文件到远程服务器==</h3><pre><code class="lang-shell">scp [options] fileName/dir targetPath

options:
    -C:使用压缩
    -P:指定远程主机号
    -p:保留文件最后修改时间,最后访问时间和权限模式
    -q:不显示复制进程
    -r:以递归的方式复制

# 普通文件
scp source user@hostname:filePath(fileName)
# 拷贝目录需要使用-r。
scp -r source user@hostname:filePath(fileName)
# 除了使用主机名也可以用IP地址
scp -r source user@ip:filePath(fileName)
</code></pre>
<h3 id="剪切文件-文件夹"><a href="#剪切文件-文件夹" class="headerlink" title="剪切文件/文件夹"></a>剪切文件/文件夹</h3><pre><code class="lang-shell">mv [options] source dest

options:
    -b: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。
    -i: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输
入 y 表示直接覆盖，输入 n 表示取消该操作。
    -f: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。
    -n: 不覆盖任何已存在的文件或目录。
    -u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作
</code></pre>
<h3 id="查看当前目录下的文件-文件夹信息"><a href="#查看当前目录下的文件-文件夹信息" class="headerlink" title="查看当前目录下的文件/文件夹信息"></a>查看当前目录下的文件/文件夹信息</h3><pre><code class="lang-shell">ls [options] fileName/condition

options:
    -l:除文件名其文件的所有信息全部列出(文件形态,权限,拥有者,文件大小等)  ==&gt; ll = ls -l
    -t:按照创建时间依次列出
    -a:列出目录下所有文件夹名(包括隐藏文件)
    -R:递归显示当前目录下的文件和子目录
      -h:以人类可读的方式显示当前目录中的文件和目录大小
</code></pre>
<h3 id="创建文件-文件夹"><a href="#创建文件-文件夹" class="headerlink" title="==创建文件/文件夹=="></a>==创建文件/文件夹==</h3><pre><code class="lang-shell">创建文件:
vim fileName
touch fileName1 [fileName2 ...]

创建目录(文件夹):
mkdir dirName
</code></pre>
<h3 id="删除文件夹-文件"><a href="#删除文件夹-文件" class="headerlink" title="==删除文件夹/文件=="></a>==删除文件夹/文件==</h3><pre><code class="lang-shell">rm [options] fileName/dirName

options:
    -i:删除前逐个询问
    -r:将目录以及以下的文件遍历删除
    -f:即使文件为只可读也直接删除,无需确认 (-force)
</code></pre>
<h3 id="统计目录-文件大小"><a href="#统计目录-文件大小" class="headerlink" title="统计目录/文件大小"></a>统计目录/文件大小</h3><pre><code class="lang-shell">du [-options] [fileName/dirName]

options:
    a或-all 显示目录中个别文件的大小。
    b或-bytes 显示目录或文件大小时，以byte为单位。
    h或--human-readable 以K，M，G为单位，提高信息的可读性。
    k或--kilobytes 以1024 bytes为单位。
    l或--count-links 重复计算硬件连接的文件。
    m或--megabytes 以1MB为单位。
    s或--summarize 仅显示总计。
    --exclude=&lt;目录或文件&gt; 略过指定的目录或文件。
    --max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。
    --help 显示帮助。
</code></pre>
<h3 id="查找文件"><a href="#查找文件" class="headerlink" title="==查找文件=="></a>==查找文件==</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p><code>find</code>命令与<code>locate</code>命令相比各有各的优缺点，<code>locate</code>命令的优点就是查找速度比<code>find</code>命令快的多，但是缺点也比较明显，<code>locate</code>命令无法查找最新添加的文件/目录以及会查找出来已经过期的文件/目录。</p>
<p>相反<code>find</code>命令的优点就是可以按照自定义的方法查找任何文件，缺点就是查询速度比较慢，因为是通过遍历硬盘来查找而不像<code>locate</code>命令事先建立好数据库来进行查找。</p>
<pre><code class="lang-shell">find path -options [-print] [-exec command /-ok command &#123;&#125; \ ]

    -exec: 将前面查询到的文件交给 exec后的命令完成
    -ok:将前面查询到的文件交给 ok 后的命令完成 (安全,执行一次,询问一次)
    但是性能较低,做一次操作创建一个进程,而且有参数长度限制(文件过多执行出错)
    推荐使用:
        find path -options | xargs command
        在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。



options:
    name/iname : 文件名符合name的文件,iname会忽略大小写
    path/ipath : 路径名符合p的文件,ipath会忽略大小写
    empty : 空的文件夹,或者是空目录
    size [+/-]n:文件大小是(大于/小于)n的文件
    type c:文件类型是c的文件,类型:f(文件),d(目录),l(链接)
    user : 按照文件属于的用户来查找文件
    nouser : 查找无效用户的文件(userdel删除用户时没有-r)
    group : 按照文件所属的组来查找文件
    mtime -/+ n :按照文件的更改时间来查找文件(-n表示距离现在n天以内 +n代表更改时间距现在n天以前)
    perm : 按照文件权限来查找文件


例:
    想要在/etc目录中查找文件名以host开头的文件
    find /etc -name &quot;host*&quot;
</code></pre>
<h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p><code>locate</code>命令要比其他查找文件命令（例如:<code>find</code>）快得多，原因在于它不搜索具体目录，而是搜索一个数据库<code>/var/lib/mlocate/mlocate.db</code>。</p>
<p><code>/var/lib/mlocate/mlocate.db</code>这个数据库中含有本地所有文件信息。Linux 系统自动创建这个数据库，并且每天自动更新一次，因此，我们在用<code>locate</code>查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。为了避免这种情况，可以在使用<code>locate</code>之前，先使用<strong><code>updatedb</code></strong>命令，手动更新数据库。</p>
<pre><code class="lang-shell">locate　命令参数　文件/目录

    参数列表:
        -c, --count            只输出找到的数量；
        -d, --database DBPATH  使用DBPATH指定的数据库，而不是默认数据库/var/lib/mlocate/mlocate.db；
        -i, --ignore-case      忽略大小写；
        -q, --quiet            安静模式，不会显示任何错误讯息；
        -e, --existing         只显示当前存在的文件条目；
</code></pre>
<p>案例演示<code>1</code>：</p>
<p>搜索<code>etc</code>目录下以<code>pass</code>开头的文件或目录，具体使用如下命令：</p>
<pre><code class="lang-shell">locate /etc/pass
</code></pre>
<p>案例演示<code>２</code>：</p>
<p>搜索包含<code>passwd</code>字母的文件或目录总个数，具体使用如下命令：</p>
<pre><code class="lang-shell">locate -c passwd
</code></pre>
<h3 id="管道符"><a href="#管道符" class="headerlink" title="==管道符=="></a>==管道符==</h3><pre><code class="lang-shell">somecommand |
</code></pre>
<h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><h4 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h4><pre><code class="lang-shell">file filePath

[nd_ljq@ROOT ~]$ file part-r-00000
part-r-00000: ASCII text
[nd_ljq@ROOT ~]$ type ifconfig
ifconfig is /usr/sbin/ifconfig
[nd_ljq@ROOT ~]$ file /usr/sbin/ifconfig
/usr/sbin/ifconfig: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=96ce19fd01f2ed4f0a677a4b412ba28142d7ac3b, stripped, too many notes (256)

ps: ELF全称为(Executable and Linkable Format)
    相当于window中的exe可执行文件
</code></pre>
<h4 id="查找文件位置"><a href="#查找文件位置" class="headerlink" title="==查找文件位置=="></a>==查找文件位置==</h4><h5 id="which"><a href="#which" class="headerlink" title="which"></a>which</h5><p><code>which</code>命令主要是用来查找系统<code>PATH</code>目录下的可执行文件，说白了就是查找那些我们已经安装好的可以直接执行的命令。</p>
<p><code>which</code>命令用于查找并显示给定命令的绝对路径，环境变量<code>PATH</code>中保存了查找命令时需要遍历的目录。<code>which</code>指令会在环境变量<code>$PATH</code>设置的目录里查找符合条件的文件。也就是说，使用<code>which</code>命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>
<p><code>which</code>是<code>shell</code>内建命令，内建命令要比系统论命令有比较高的执行效率。</p>
<pre><code class="lang-shell">which　需要查找的命令
</code></pre>
<h5 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h5><p><code>whereis</code>命令可以用来查找二进制（命令）、源文件、<code>man</code>文件。与<code>which</code>不同的是这条命令可以是通过文件索引数据库而非<code>PATH</code>来查找的，所以查找的面比<code>which</code>要广。</p>
<pre><code class="lang-shell">whereis [options] [-B &lt;目录&gt;...] [-M &lt;目录&gt;...] [-S &lt;目录&gt;...] [文件...]

options:
-b 　只查找二进制文件。
-f 　不显示文件名前的路径名称。
-m 　只查找说明文件。
-s 　只查找原始代码文件。
-u 　查找不包含指定类型的文件。

-B&lt;目录&gt; 　只在设置的目录下查找二进制文件。
-M&lt;目录&gt; 　只在设置的目录下查找说明文件。
-S&lt;目录&gt; 　只在设置的目录下查找原始代码文件。

ps:该指令只能用于查找二进制文件、源代码文件和man手册页
</code></pre>
<h4 id="查看-小-文件内容并打印到控制台"><a href="#查看-小-文件内容并打印到控制台" class="headerlink" title="==查看(小)文件内容并打印到控制台=="></a>==查看(小)文件内容并打印到控制台==</h4><pre><code class="lang-shell">cat [options] fileName

options:
    -n:显示行号
    -b:只显示有内容行的行号,忽略无内容行
</code></pre>
<h4 id="查看-大-文件内容并打印到控制台"><a href="#查看-大-文件内容并打印到控制台" class="headerlink" title="==查看(大)文件内容并打印到控制台=="></a>==查看(大)文件内容并打印到控制台==</h4><pre><code class="lang-shell">less [options] fileName

按Q键退出less命令
/字符串：向下搜索&quot;字符串&quot;的功能
?字符串：向上搜索&quot;字符串&quot;的功能
n：重复前一个搜索（与 / 或 ? 有关）
N：反向重复前一个搜索（与 / 或 ? 有关）
b 向上翻一页
d 向后翻半页
h 显示帮助界面
Q 退出less 命令
u 向前滚动半页
y 向前滚动一行
空格键 滚动一页
回车键 滚动一行
options:
    -i:忽略大小写
    -e:文件显示完自动退出
    -g:只显示搜索到的最后一个关键词
    -N:显示每行行号
</code></pre>
<h4 id="查看文件头-尾"><a href="#查看文件头-尾" class="headerlink" title="==查看文件头/尾=="></a>==查看文件头/尾==</h4><pre><code class="lang-shell">head/tail [options] fileName

options:
    -c number:只查看前/后number个字符
</code></pre>
<h4 id="查看文件尾"><a href="#查看文件尾" class="headerlink" title="==查看文件尾=="></a>==查看文件尾==</h4><p>在屏幕上显示指定文件的末尾若干行</p>
<p><strong>tail 命令</strong> 用于输入文件中的尾部内容。</p>
<ul>
<li><p>默认在屏幕上显示指定文件的末尾 10 行。</p>
</li>
<li><p>处理多个文件时会在各个文件之前附加含有文件名的行。</p>
</li>
<li><p>如果没有指定文件或者文件名为<code>-</code>，则读取标准输入。</p>
</li>
<li><p>如果表示字节或行数的<code>NUM</code>值之前有一个<code>+</code>号，则从文件开头的第<code>NUM</code>项开始显示，而不是显示文件的最后<code>NUM</code>项。</p>
</li>
<li><p><code>NUM</code>值后面可以有后缀：</p>
<ul>
<li><code>b</code> : 512</li>
<li><code>kB</code> : 1000</li>
<li><code>k</code>: 1024</li>
<li><code>MB</code> : 1000 * 1000</li>
<li><code>M</code>: 1024 * 1024</li>
<li><code>GB</code> : 1000 <em> 1000 </em> 1000</li>
<li><code>G</code>: 1024 <em> 1024 </em> 1024</li>
<li><code>T</code>、<code>P</code>、<code>E</code>、<code>Z</code>、<code>Y</code>等以此类推。</li>
</ul>
</li>
</ul>
<p><strong>语法</strong></p>
<pre><code class="lang-shell">tail (选项) fileName

选项:
    -c, --bytes=NUM                 输出文件尾部的NUM（NUM为整数）个字节内容。
    -f, --follow[=&#123;name|descript&#125;]  显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。
    -F                              与 “--follow=name --retry” 功能相同。
    -n, --line=NUM                  输出文件的尾部NUM（NUM位数字）行内容。
    --pid=&lt;进程号&gt;                  与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令。
    -q, --quiet, --silent           当有多个文件参数时，不输出各个文件名。
    --retry                         即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“--follow=name”连用。
    -s, --sleep-interal=&lt;秒数&gt;      与“-f”选项连用，指定监视文件变化时间隔的秒数。
    -v, --verbose                   当有多个文件参数时，总是输出各个文件名。
    --help                          显示指令的帮助信息。
    --version                       显示指令的版本信息。
</code></pre>
<p><strong>实例</strong></p>
<pre><code class="lang-shell">tail file #（显示文件file的最后10行）
tail -n +20 file #（显示文件file的内容，从第20行至文件末尾）
tail -c 10 file #（显示文件file的最后10个字节）

tail -25 mail.log # 显示 mail.log 最后的 25 行
tail -f mail.log # 等同于--follow=descriptor，根据文件描述符进行追踪，当文件改名或被删除，追踪停止
tail -F mail.log # 等同于--follow=name --retry，根据文件名进行追踪，并保持重试，即该文件被删除或改名后，如果再次创建相同的文件
</code></pre>
<p><strong>拓展</strong>:</p>
<p><strong>tailf</strong>命令</p>
<p>在屏幕上显示指定文件的末尾若干行内容，通常用于日志文件的跟踪输出</p>
<p><strong>补充说明</strong></p>
<p>tailf 命令几乎等同于<code>tail -f</code>，严格说来应该与<code>tail --follow=name</code>更相似些。当文件改名之后它也能继续跟踪，特别适合于日志文件的跟踪（follow the growth of a log file）。与<code>tail -f</code>不同的是，如果文件不增长，它不会去访问磁盘文件。tailf 特别适合那些便携机上跟踪日志文件，因为它能省电，因为减少了磁盘访问。tailf 命令不是个脚本，而是一个用 C 代码编译后的二进制执行文件，某些 Linux 安装之后没有这个命令。</p>
<p>tailf 和 tail -f 的区别</p>
<ol>
<li>tailf 总是从文件开头一点一点的读， 而 tail -f 则是从文件尾部开始读</li>
<li>tailf check 文件增长时，使用的是文件名， 用 stat 系统调用；而 tail -f 则使用的是已打开的文件描述符； 注：tail 也可以做到类似跟踪文件名的效果； 但是 tail 总是使用 fstat 系统调用，而不是 stat 系统调用；结果就是：默认情况下，当 tail 的文件被偷偷删除时，tail 是不知道的，而 tailf 是知道的。</li>
</ol>
<p><strong>语法</strong></p>
<pre><code class="lang-shell">tailf logfile # 动态跟踪日志文件logfile，最初的时候打印文件的最后10行内容。
</code></pre>
<p><strong>选项</strong></p>
<pre><code class="lang-shell">-n, --lines NUMBER  # 输出最后数行
-NUMBER             # 与NUMBER相同 `-n NUMBER&#39;
-V, --version       # 输出版本信息并退出
-h, --help          # 显示帮助并退出
</code></pre>
<p><strong>参数</strong></p>
<p>目标：指定目标日志。</p>
<p><strong>实例</strong></p>
<pre><code class="lang-shell">tailf log/WEB.LOG
tailf -n 5 log2014.log   # 显示文件最后5行内容
</code></pre>
<h3 id="统计文件行数-单词数-字节数"><a href="#统计文件行数-单词数-字节数" class="headerlink" title="统计文件行数/单词数/字节数"></a>统计文件行数/单词数/字节数</h3><pre><code class="lang-shell">wc [options] fileName

options:
    -l:仅查看行数
    -w:仅查看单词数
    -c:仅查看bytes数
</code></pre>
<h3 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h3><h4 id="创建文件-修改文件修改时间"><a href="#创建文件-修改文件修改时间" class="headerlink" title="创建文件/修改文件修改时间"></a>创建文件/修改文件修改时间</h4><pre><code class="lang-shell">touch fileName
</code></pre>
<pre><code class="lang-shell">vim [options] path fileName
有该文件则编辑,无该文件则创建

options:
    +:进入vim后直接定位到文件的最后一行
    &quot;+&quot;+number:定位到第number行

按I进入插入模式
按ESC退出插入模式,进入命令模式

:x 保存退出
:w 保存
:q 退出
dd 删除光标所在的一行
:number 定位到第number行
:set nu 显示行号
</code></pre>
<h3 id="文件的归档"><a href="#文件的归档" class="headerlink" title="文件的归档"></a>文件的归档</h3><h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><pre><code class="lang-shell">gzip [options] [&lt;压缩效率&gt;] [--best/fast] [文件/目录]

options:
    -d:(decompress/uncompress)解开压缩文件。
    -f:(force)强行压缩文件,不理会文件名称或硬链接是否存在,以及改文件是否为符号连接
    -l:(list)列出压缩文件的相关信息
    -n:(no-name)压缩文件时，不保存原来的文件名称及时间戳记。
    -N:(name)压缩文件时，保存原来的文件名称及时间戳记。
    -r:(recursive)递归处理，将指定目录下的所有文件及子目录一并处理。注意他的递归是把单个文件压缩,而不是一个整包
    -v:(verbose)显示指令执行过程

#压缩效率
    压缩效率是一个介于1~9的数值,预设值为`6`,指定越大的数,压缩程度越高,速度越慢
</code></pre>
<h4 id="tar"><a href="#tar" class="headerlink" title="==tar=="></a>==tar==</h4><pre><code class="lang-shell">tar [options] fileName
options:
    -z:使用gzip处理压缩文件
    -x:(extract)从压缩文件中还原文件
    -v:(verbose)显示指令执行过程
    -j: 支持bzip2解压文件
    -f:指定归档文件名称
    在参数 f 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加 z 参数，则以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar包； 如果加 j 参数，则以 .tar.bz2 来作为tar包名。
    -c:(create)建立新的归档文件。
    -t:显示tar包中的文件列表
</code></pre>
<h2 id="文本的操作"><a href="#文本的操作" class="headerlink" title="==文本的操作=="></a>==文本的操作==</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="元字符集"><a href="#元字符集" class="headerlink" title="元字符集"></a>元字符集</h4><div class="table-container">
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>只匹配行首</td>
</tr>
<tr>
<td>$</td>
<td>只匹配行尾</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意字符串</td>
</tr>
<tr>
<td>[]</td>
<td>匹配[]内字符.可以是一个单字符串符，也可以是字符序列。可以使用-表示[ ]内字符序 列范围，如用[1-5]代替[12345]。[A-Z]</td>
</tr>
<tr>
<td>\</td>
<td>转义字符，因为有时在 Linux 中一些元字符有特殊含义。”\“可以使其失去应有意 义。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="grep"><a href="#grep" class="headerlink" title="==grep=="></a>==grep==</h3><p>grep(全局正则表达式)</p>
<pre><code class="lang-shell">grep [OPTIONS] PATTERN [FILE...]

OPTIONS:
    -c：只输出匹配行的计数。
    -i：不区分大小写（只适用于单字符）。
    -h：查询多文件时不显示文件名。
    -l：查询多文件时只输出包含匹配字符的文件名。
    -n：显示匹配行及行号。
    -s：不显示不存在或无匹配文本的错误信息。
    -v：显示不包含匹配文本的所有行。
</code></pre>
<h4 id="pattern-正则表达式主要参数"><a href="#pattern-正则表达式主要参数" class="headerlink" title="pattern 正则表达式主要参数"></a>pattern 正则表达式主要参数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>pattern</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>忽略正则表达式中特殊字符的原有含义，用于转义</td>
</tr>
<tr>
<td>^</td>
<td>匹配正则表达式的开始行。</td>
</tr>
<tr>
<td>$</td>
<td>匹配正则表达式的结束行。</td>
</tr>
<tr>
<td>\&lt;</td>
<td>从匹配正则表达式的开始。</td>
</tr>
<tr>
<td>></td>
<td>到匹配正则表达式的结束。</td>
</tr>
<tr>
<td>[]</td>
<td>单个字符，如[A]即 A 符合要求 。</td>
</tr>
<tr>
<td>[-]</td>
<td>范围，如[A-Z]，即 A、B、C 一直到 Z 都符合要求 。</td>
</tr>
<tr>
<td>.</td>
<td>所有的单个字符。</td>
</tr>
<tr>
<td>*</td>
<td>有字符，长度可以为 0。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="双引号引用"><a href="#双引号引用" class="headerlink" title="双引号引用"></a>双引号引用</h4><p>在 grep 命令中输入字符串参数时，最好将其用双引号括起来。例如：“mystring”。这样做有两 个原因，一是以防被误解为 shell 命令，二是可以用来查找多个单词组成的字符串，例如：“my string”，如果不用双引号将其括起来，那么单词 string 将被误认为是一个文件，查询结果将返回 “文件不存在”的错误信息。</p>
<h4 id="查询多个文件"><a href="#查询多个文件" class="headerlink" title="查询多个文件"></a>查询多个文件</h4><p>如果要在当前目录下所有. txt 文件中查找字符串“test”，我们可以使用通配符，方法如下：</p>
<pre><code class="lang-shell">grep &quot;test&quot; *.txt
</code></pre>
<h4 id="行匹配数"><a href="#行匹配数" class="headerlink" title="行匹配数"></a>行匹配数</h4><p>我们可以使用”-c“来查询匹配到的行数据。</p>
<p>案例：查询 data.txt 文件中出现 48 的行数。</p>
<pre><code class="lang-shell">grep -c &quot;48&quot; data.txt
</code></pre>
<h4 id="显示行数据"><a href="#显示行数据" class="headerlink" title="显示行数据"></a>显示行数据</h4><p>显示满足匹配模式的所有行行数。</p>
<p>案例：查询 data.txt 文件中出现 48 的行的数据</p>
<pre><code class="lang-shell">grep -n &quot;48&quot; data.txt
</code></pre>
<h4 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h4><p>在上一例中，抽取字符串“48”，返回结果包含诸如 484 和 483 等包含“48”的 其他字符串，实际上应精确抽取只包含 48 的各行。注意在每个匹配模式中抽取字符串后有一个 Tab 键，所以应操作如下：</p>
<pre><code class="lang-shell"># 使用grep抽取精确匹配的方式是在抽取字符串后加”\&gt;”。
grep &quot;48\&gt;&quot; data.txt
</code></pre>
<h4 id="模式出现机率"><a href="#模式出现机率" class="headerlink" title="模式出现机率"></a>模式出现机率</h4><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/X[RQMCV9S8`UK%MU6I9N0LO.png" alt></p>
<p>抽取包含数字 4 至少重复出现两次的所有行</p>
<pre><code class="lang-shell"># 以前可以这么写
grep &#39;44&#39; data.txt
# 也可以这么写。
grep &#39;4\&#123;2,\&#125;&#39; data.txt
</code></pre>
<h4 id="与-或模式"><a href="#与-或模式" class="headerlink" title="与/或模式"></a>与/或模式</h4><p>grep 命令加-E 参数，这一扩展允许使用扩展模式匹配。</p>
<p>案例：要获取城市代码为 219 或 216。</p>
<pre><code class="lang-shell"># 这么写不行。
grep &quot;[219][216]&quot; data.txt
#
grep -E &#39;219|216&#39; data.txt
</code></pre>
<h4 id="查询文件名"><a href="#查询文件名" class="headerlink" title="查询文件名"></a>查询文件名</h4><p>有时候按照一定个格式去查找对应的文件，是一件很常用的使用场景，比如我们只是依稀记得 文件名，但是不知道它在哪里，这个时候就可以结合 grep 来进行查找。</p>
<p>案例 1：查找系统中所有的文件，并且这些文件的文件名要求：”以小写字母开头，然后接数字者 字母最多十位，然后一个点，文件的后缀是 2 到 4 位的小字母“，比如”test1.docx“</p>
<pre><code class="lang-shell"># 第一步：查询到文件
find / -type f
# 第二步：获取文件的文件名
find / -type f -exec basename &#123;&#125; \;
# 第三步：进行文件名的过滤。
find / -type f -exec basename &#123;&#125; \; | grep &#39;[a-z][a-zA-Z0-9]\&#123;1,9\&#125;\.
[a-z]\&#123;2,4\&#125;&#39;
# 第4步：进行前后的限定。
find / -type f -exec basename &#123;&#125; \; | grep &#39;^[a-z][a-zA-Z0-9]\&#123;1,9\&#125;\.
[a-z]\&#123;2,4\&#125;$&#39;
</code></pre>
<h4 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h4><p>我们上面查找文件的时候，文件名可以是数字或者大小写字母，我们写的正则表达式是”[a-zA-Z0-9]“，这种写法其实是比较麻烦的，grep 允许使用国际字符模式匹配或匹配模式的类名形式。</p>
<h5 id="类名及其等价的正则表达式"><a href="#类名及其等价的正则表达式" class="headerlink" title="类名及其等价的正则表达式"></a>类名及其等价的正则表达式</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类</th>
<th style="text-align:center">等价的正则表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[[:upper:]]</td>
<td style="text-align:center">[A-Z]</td>
</tr>
<tr>
<td style="text-align:center">[[:lower:]]</td>
<td style="text-align:center">[a-z]</td>
</tr>
<tr>
<td style="text-align:center">[[:digit:]]</td>
<td style="text-align:center">[0-9]</td>
</tr>
<tr>
<td style="text-align:center">[[:alnum:]]</td>
<td style="text-align:center">[0-9a-zA-Z</td>
</tr>
<tr>
<td style="text-align:center">[[:alpha:]]</td>
<td style="text-align:center">[a-zA-Z]</td>
</tr>
<tr>
<td style="text-align:center">[[:space:]]</td>
<td style="text-align:center">空格或 tab 键</td>
</tr>
</tbody>
</table>
</div>
<h4 id="grep-命令的应用"><a href="#grep-命令的应用" class="headerlink" title="grep 命令的应用"></a>grep 命令的应用</h4><p>要查询其他用户和其他用户组成员有可执行权限的文件集合。</p>
<pre><code class="lang-shell">ls -al | grep &#39;^\-.....x..x&#39;
</code></pre>
<h3 id="awk"><a href="#awk" class="headerlink" title="==awk=="></a>==awk==</h3><p>awk 是所有 shell 文本过滤工具</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre><code class="lang-shell">awk [OPTION] &#39;script&#39; var=value file(s) [&gt; filename]
或
awk [OPTION] -f scriptfile var=value file(s) [&gt; filename]

OPTION:
    -F fs:指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。
    -v var=value:赋值一个用户定义变量。
    -f scripfile:从脚本文件中读取awk命令。
    -W re-interval:允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]

    file(s):可以是一个文件,也可以是多个文件
    [&gt; filename]:将前面输出在控制台的内容存入指定文件中
</code></pre>
<p>如果设置了 <code>-F</code> 选项，则 awk 每次读一条记录或一行，并使用指定的 <code>分隔符</code> 分隔指定域，如果未设 置-F 选项，awk 假定 <code>空格</code> 为域分隔符，以这种格式读取数据，一直这么读取数据一直到文件末尾。</p>
<pre><code class="lang-shell">48 Dec 3BC1997 LPSX 68.00 LVX2A 138
483 Sept 5AP1996 USP 65.00 LVX2c 189
47 Oct 3ZL1998 LPSX 43.00 KVM9D 512
219 dec 2CC1999 CAD 23.00 PLV2C 68
484 nov 7PL1996 CAD 49.00 PLV2C 234
483 may 5PA1998 USP 37.00 KVM9D 644
216 sept 3ZL1998 USP 86.00 KVM9E 234
</code></pre>
<p>参照上表，awk 每次在文件中读一行，找到域分隔符（这里是符号 <code>&#39;\t&#39;</code> ），设置其为域 n，直至一 新行（这里是缺省记录分隔符），然后，划分这一行作为一条<code>记录</code>，接着 awk 再次启动下一行读进程。</p>
<h4 id="模式和动作"><a href="#模式和动作" class="headerlink" title="模式和动作"></a>模式和动作</h4><p>awk 语句都由<code>模式</code> 和<code>动作</code> 组成。在一个 awk 脚本中可能有许多语句，模式部分决定动作语句何时 触发，模式部分可以省略。处理即对数据进行的操作。</p>
<p>模式可以是任何条件语句或复合语句或正则表达式。模式包括两个特殊字段 <code>BEGIN</code>和 <code>END</code> 。使用 BEGIN 语句设置<code>计数</code> 和 <code>打印头</code> 。BEGIN 语句使用在任何文本浏览动作之前，之后文本浏览动作依据 输入文件开始执行。END 语句用来在 awk 完成文本浏览动作后 <code>输出文本总数</code> 和 <code>结尾状态标志</code> 。如果 不特别指明模式， awk 总是匹配或打印行数。</p>
<p>实际动作在大括号 <code>&#123;&#125;</code>内指明。动作大多数用来打印，但是还有些更长的代码诸如 if 和循环 （looping）语句及循环退出结构。如果不指明采取动作，awk 将打印出所有浏览出来的记录。</p>
<h4 id="域和记录"><a href="#域和记录" class="headerlink" title="域和记录"></a>域和记录</h4><p>awk 执行时，其浏览域标记为 $1，$2…$n。这种方法称为域标识。使用这些域标识将更容易对域 进行进一步处理。使用$1,$2 表示参照第 1 和第 2 域，注意这里用逗号做域分隔。如果希望打印一个有 7 个域的记录的所有域，不必指明$1, $2, $3, $4, $5, $6, $7，可使用$0 即所有域。</p>
<p>如果要打印一个域或所有域，使用 print 命令，其这是一个 awk 动作（动作语法用大括号‘{}’括起 来）。</p>
<pre><code class="lang-shell">#以tab来切割data.txt，然后获取第1个域的值
awk -F &#39;\t&#39; &#39;&#123;print $1&#125;&#39; data.txt

#由于tab其实也是空格，所以我们不指定-F也行，所以也可以这么写。
awk -F &#39;&#123;print $1&#125;&#39; data.txt

#在上面的例子为基础进行修改，我们取第一，第二，第三个域。
awk &#39;&#123;print $1,$2,$3&#125;&#39; data.txt



ps:$0表示所有域
</code></pre>
<h5 id="头部与尾部"><a href="#头部与尾部" class="headerlink" title="头部与尾部"></a>头部与尾部</h5><p>我们上面使用了 TAB 来进行域之间的分隔，也可以为输出文本加入信息头与尾信息，打印信息头放 置在 BEGIN 模式部分，因为打印信息头被界定为一个动作，必须用大括号括起来。如果要打印尾部信 息我们可以使用 END 语句。END 语句在所有文本处理动作执行完之后才被执行。</p>
<pre><code class="lang-shell">#打印月份与价格的域信息，并且添加头与尾部的信息
awk &#39;BEGIN &#123;print &quot;Month\tPrice&quot;&#125; &#123;print $2&quot;\t&quot;$5&#125;&#39; data.txt

#加入尾部信息：
awk &#39;BEGIN &#123;print &quot;Month\tPrice&quot;&#125; &#123;print $2&quot;\t&quot;$4&#125; END &#123;print &quot;end...&quot;&#125;&#39; data.txt
</code></pre>
<p>当第一次使用 awk 时，如果出现错误可能不知所措，但是使用久了就会发现，可总结出以下规则， 可以帮助我们减少错误的出现。</p>
<ol>
<li>确保整个 awk 命令用单引号括起来。</li>
<li>确保命令内所有引号成对出现。</li>
<li>确保用花括号括起动作语句，用圆括号括起条件语句。</li>
</ol>
<h4 id="AWK-中的正则表达式"><a href="#AWK-中的正则表达式" class="headerlink" title="AWK 中的正则表达式"></a>AWK 中的正则表达式</h4><h5 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h5><p>awk 中正则表达式匹配操作中经常用到的字符，这些字符是有特殊含义的，</p>
<pre><code class="lang-shell">\ ^ $ . [] | () * + ?
</code></pre>
<p>这里有两个字符前面的章节提到过讲到，注意它们只适用于 awk。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">使用+匹配一个或多个字符。</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">匹配模式出现频率。例如使用/XY?Z/匹配 XYZ 或 XZ。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">小于等于</td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">大于等于</td>
</tr>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">等于</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">不等于</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">匹配正则表达式</td>
</tr>
<tr>
<td style="text-align:center">!~</td>
<td style="text-align:center">不匹配正则表达式(与上面条件相反)</td>
</tr>
</tbody>
</table>
</div>
<p>为使域匹配正则表达式，使用符号‘～’后紧跟正则表达式，也可以用 i f 语句。awk 中 if 后面的条件用 ()括起来。</p>
<p>案例：查询月份为”sept“的行信息。</p>
<pre><code class="lang-shell">awk &#39;&#123; if($2~/sept/) print $0 &#125;&#39; data.txt
</code></pre>
<p>精确匹配 48，使用等号==，并用单引号括起条件。例如$3 == “48”，这样确保只有 48 号得以匹 配，其余则不行</p>
<pre><code class="lang-shell">awk &#39;&#123; if($1==&quot;48&quot;) print $0 &#125;&#39; data.txt
或
awk &#39;$1==&quot;48&quot; &#123; print $0 &#125;&#39; data.txt
</code></pre>
<p>上面我们通过/[Ss]ept/实现了 Sept 与 sept 的匹配，我们其实也可以使用 <code>或</code>关系匹配 ，使用竖线 符<code>|</code>，意为匹配<code>|</code> 两边模式之一。<strong><em>注意：使用竖线符时，语句必须用圆括号括起来。</em></strong></p>
<pre><code class="lang-shell">awk &#39;&#123; if($2~/(Sept|sept)/) print $0 &#125;&#39; data.txt
# 或者
awk &#39;$2~/(Sept|sept)/&#39; data.txt
# 或者
awk &#39;&#123; if($2 == &quot;Sept&quot; || $2 == &quot;sept&quot;) print $0 &#125;&#39; data.txt
# 或者
awk &#39;$2 == &quot;Sept&quot; || $2 == &quot;sept&quot;&#39; data.txt

//不加任何动作默认输出所有匹配
</code></pre>
<p>匹配价格大于 50 的，并且库存大于 200 的。</p>
<pre><code class="lang-shell">awk &#39;&#123; if($5 &gt; 50 &amp;&amp; $7 &gt; 200) print $0 &#125;&#39; data.txt
# 或者
awk &#39;$5 &gt; 50 &amp;&amp; $7 &gt; 200&#39; data.txt
</code></pre>
<h5 id="awk-内置变量"><a href="#awk-内置变量" class="headerlink" title="awk 内置变量"></a>awk 内置变量</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">变量名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ARGC</td>
<td style="text-align:center">命令行参数个数</td>
</tr>
<tr>
<td style="text-align:center">ARGV</td>
<td style="text-align:center">命令行参数排列</td>
</tr>
<tr>
<td style="text-align:center">ENVIRON</td>
<td style="text-align:center">支持队列中系统环境变量的使用</td>
</tr>
<tr>
<td style="text-align:center">FILENAME</td>
<td style="text-align:center">awk 浏览的文件名</td>
</tr>
<tr>
<td style="text-align:center">FNR</td>
<td style="text-align:center">浏览文件的记录数</td>
</tr>
<tr>
<td style="text-align:center">FS</td>
<td style="text-align:center">设置输入域分隔符，等价于命令行-F 选项</td>
</tr>
<tr>
<td style="text-align:center">NF</td>
<td style="text-align:center">浏览记录的域个数(总共多少列)</td>
</tr>
<tr>
<td style="text-align:center">NR</td>
<td style="text-align:center">已读的记录数(当前行号)</td>
</tr>
<tr>
<td style="text-align:center">OFS</td>
<td style="text-align:center">输出域分隔符</td>
</tr>
<tr>
<td style="text-align:center">ORS</td>
<td style="text-align:center">输出记录分隔符</td>
</tr>
<tr>
<td style="text-align:center">RS</td>
<td style="text-align:center">控制记录分隔符</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>ARGC 支持命令行中传入 awk 脚本的参数个数。ARGV 是 ARGC 的参数排列数组，其中每一元素表 示为 ARGV[n]，n 为期望访问的命令行参数。</li>
<li>ENVIRON 支持系统设置的环境变量，要访问单独变量，使用实际变量名，例如： ENVIRON[“EDITOR”] =“Vi”。</li>
<li>FILENAME 支持 awk 脚本实际操作的输入文件。因为 awk 可以同时处理许多文件，因此如果访问 了这个变量，将告之系统目前正在浏览的实际文件。</li>
<li>FNR 支持 awk 目前操作的记录数。其变量值小于等于 NR。如果脚本正在访问许多文件，每一新 输入文件都将重新设置此变量。</li>
<li>FS 用来在 awk 中设置域分隔符，与命令行中-F 选项功能相同。缺省情况下为空格。如果用逗号来 作域分隔符，设置 FS=”,”。</li>
<li>NF 支持记录域个数，在记录被读之后再设置。</li>
<li>OFS 允许指定输出域分隔符，缺省为空格。如果想设置为#，写入 OFS=”#”。</li>
<li>ORS 为输出记录分隔符，缺省为新行（\n）。</li>
<li>RS 是记录分隔符，缺省为新行(\n)。</li>
</ul>
<p>测试 NR, NF, FILENAME 这几个内置变量的使用。</p>
<pre><code class="lang-shell">awk &#39;&#123; print NR, NF, $0&#125; END&#123; print FILENAME &#125;&#39; data.txt
</code></pre>
<p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-03-16_18-00-06.png" alt></p>
<p>之前有个案例是匹配价格大于五十的数据，具体如下：</p>
<pre><code class="lang-shell">awk &#39;&#123; if($5 &gt; 50) print $0 &#125;&#39; data.txt
</code></pre>
<p>有的时候有这一种情况，那就是如果由于数据不完整，某一行没有五个域，这个时候就会有问题， 这个时候我们就可以先通过 NF 来进行判断，代码可以改成这样：</p>
<pre><code class="lang-shell">awk &#39;&#123; if(NF &gt; 5 &amp;&amp; $5 &gt; 50) print $0 &#125;&#39; data.txt
或
awk &#39;NF &gt; 5 &amp;&amp; $5 &gt; 50&#39; data.txt
</code></pre>
<h5 id="awk-操作符"><a href="#awk-操作符" class="headerlink" title="awk 操作符"></a>awk 操作符</h5><p>在 awk 中使用操作符，基本表达式可以划分为数字型、字符串型、变量型、域及数组元素</p>
<p><strong>数据准备</strong>：雇员(emp)信息，由于上面的案例数据有的力不从心，我们引入以前数据库里面的一份数据。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">NO</th>
<th style="text-align:center">列名</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">empno</td>
<td style="text-align:center">int</td>
<td style="text-align:center">雇员编号</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">ename</td>
<td style="text-align:center">varchar(10)</td>
<td style="text-align:center">雇员姓名</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">job</td>
<td style="text-align:center">varchar(9)</td>
<td style="text-align:center">职位</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">mgr</td>
<td style="text-align:center">int</td>
<td style="text-align:center">雇员直属上司</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">hiredate</td>
<td style="text-align:center">date</td>
<td style="text-align:center">雇员雇佣日期</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">sal</td>
<td style="text-align:center">decimal(7,2)</td>
<td style="text-align:center">雇员的薪水，有五位整数两位小数组成</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">comm</td>
<td style="text-align:center">decimal(7,2)</td>
<td style="text-align:center">雇员的佣金(提成)，有五位整数两位小数组成</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">deptno</td>
<td style="text-align:center">int</td>
<td style="text-align:center">雇员所属的部门号</td>
</tr>
</tbody>
</table>
</div>
<p><strong>数据:</strong></p>
<pre><code class="lang-shell">7369,SMITH,CLERK,7902,1980-12-17,800.00,0,20
7499,ALLEN,SALESMAN,7698,1981-02-20,1600.00,300.00,30
7521,WARD,SALESMAN,7698,1981-02-22,1250.00,500.00,30
7566,JONES,MANAGER,7839,1981-04-02,2975.00,0,20
7654,MARTIN,SALESMAN,7698,1981-09-28,1250.00,1400.00,30
7698,BLAKE,MANAGER,7839,1981-05-01,2850.00,0,30
7782,CLARK,MANAGER,7839,1981-06-09,2450.00,0,10
7788,SCOTT,ANALYST,7566,1987-04-19,3000.00,0,20
7839,KING,PRESIDENT,,1981-11-17,5000.00,0,10
7844,TURNER,SALESMAN,7698,1981-09-08,1500.00,0.00,30
7876,ADAMS,CLERK,7788,1987-05-23,1100.00,0,20
7900,JAMES,CLERK,7698,1981-12-03,950.00,0,30
7902,FORD,ANALYST,7566,1981-12-03,3000.00,0,20
7934,MILLER,CLERK,7782,1982-01-23,1300.00,0,10
</code></pre>
<p><strong>设置域到域变量名</strong></p>
<p>在 awk 中，设置有意义的域名是一种好习惯，在进行模式匹配或关系操作时更容易理解。一般的变 量名设置方式为 name=$n，这里 name 为引用的域变量名，n 为实际域号。例如设置学生域名为 name，年龄的域名为 age，操作为 name=$1; age=$2。注意分号的使用，它分隔 awk 命令。下面例 子中，重新赋值月份名域为 month，价格域为 price。查询价格大于 50 的记录，并最终打印月份和价格。</p>
<pre><code class="lang-shell">awk &#39;&#123;if($5&gt;50) print $2, $5 &#125;&#39; data.txt
#
awk &#39;&#123;month=$2; price=$5; if(price&gt;50) print month, price &#125;&#39; data.txt
</code></pre>
<p>也可以在 BEGIN 部分给变量赋值，然后再后面使用：</p>
<pre><code class="lang-shell">awk &#39;&#123; if($5 &gt; 50) print $0 &#125;&#39; data.txt

awk &#39;BEGIN &#123; PRICE = 50 &#125; &#123; if($5 &gt; PRICE) print $0 &#125;&#39; data.txt
</code></pre>
<p><strong>修改数值域取值</strong></p>
<p>当在 awk 中修改任何域时，重要的一点是要记住实际输入文件是不可修改的，修改的只是保存在缓 存里的 awk 复本。awk 会在变量 NR 或 NF 变量中反映出修改痕迹。为修改数值域，简单的给域标识重 赋新值，如：$1=$1+5，会将域$1 数值加 5</p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort 命令用于对文件内容进行排序，我们可以可以指定按指定的域来进行排序，也可以通过参 数来控制排序的规则。</p>
<pre><code class="lang-shell">sort [选项] 文件

参数：
-b：忽略每行前面开始出的空格字符。
-c：检查内容有没有排序，没有输出意味着已经排序了。
-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符。
-M：将前面3个字母依照月份（比如：JAN）的缩写进行排序。
-m：将几个排序好的文件进行合并。
-n：按照数值的大小进行排序
-o：&lt;输出文件&gt; 将排序后的结果存入指定的文件。
-r：以倒序的形式来进行排序。
-t：&lt;分隔字符&gt; 指定排序时所用的域的分隔符（默认是空格）。
-h：以人类可视化的单位来进行排序（针对于文件大小单位：kB, MB, GB等）
[-k field1[, field2]]：按指定的列进行排序。
</code></pre>
<h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h3 id="HDFS-的基本操作"><a href="#HDFS-的基本操作" class="headerlink" title="HDFS 的基本操作"></a>HDFS 的基本操作</h3><h4 id="开启-关闭分布式"><a href="#开启-关闭分布式" class="headerlink" title="开启/关闭分布式"></a>开启/关闭分布式</h4><pre><code class="lang-shell">start-dfs.sh
stop-dfs.sh
</code></pre>
<h4 id="在分布式文件系统中创建映射文件夹"><a href="#在分布式文件系统中创建映射文件夹" class="headerlink" title="在分布式文件系统中创建映射文件夹"></a>在分布式文件系统中创建映射文件夹</h4><pre><code class="lang-shell">hdfs dfs -mkdir Mapping_Folder_Path
</code></pre>
<h4 id="在分布式文件系统中创建文件"><a href="#在分布式文件系统中创建文件" class="headerlink" title="在分布式文件系统中创建文件"></a>在分布式文件系统中创建文件</h4><pre><code class="lang-shell">hdfs dfs -touchz Mapping_Folder_Path/file_Name
</code></pre>
<h4 id="查询文件列表"><a href="#查询文件列表" class="headerlink" title="查询文件列表"></a>查询文件列表</h4><pre><code class="lang-shell">hdfs dfs -ls Mapping_Folder_Path
</code></pre>
<h4 id="查找文件-1"><a href="#查找文件-1" class="headerlink" title="查找文件"></a>查找文件</h4><pre><code class="lang-shell">hdfs dfs -find Mapping_Folder_Path -name 表达式
例:
hdfs dfs -find /input -name wc*   -- input映射文件夹中名字中带有wc的文件
</code></pre>
<h4 id="打印文件"><a href="#打印文件" class="headerlink" title="打印文件"></a>打印文件</h4><pre><code class="lang-shell">hdfs dfs -cat Mapping_Folder_Path/file_name
</code></pre>
<h4 id="移动文件夹-文件"><a href="#移动文件夹-文件" class="headerlink" title="移动文件夹/文件"></a>移动文件夹/文件</h4><pre><code class="lang-shell">hdfs dfs -mv Source_Mapping_Folder_Path  target_Mapping_Folder_Path
</code></pre>
<h4 id="删除文件夹-文件-1"><a href="#删除文件夹-文件-1" class="headerlink" title="删除文件夹/文件"></a>删除文件夹/文件</h4><pre><code class="lang-shell">hdfs dfs -rm &lt;-r&gt; &lt;-skipTrash&gt; Mapping_Folder_Path/file_name
-r 递归删除
-skipTrash 彻底删除(不进垃圾桶)
</code></pre>
<h4 id="把本地文件追加到映射文件末尾"><a href="#把本地文件追加到映射文件末尾" class="headerlink" title="把本地文件追加到映射文件末尾"></a>把本地文件追加到映射文件末尾</h4><pre><code class="lang-shell">hdfs dfs -appendToFile localfile_Path/file_name Mapping_Folder_Path/file_name
</code></pre>
<h4 id="上传文件到分布式文件系统的映射文件夹"><a href="#上传文件到分布式文件系统的映射文件夹" class="headerlink" title="上传文件到分布式文件系统的映射文件夹"></a>上传文件到分布式文件系统的映射文件夹</h4><pre><code class="lang-shell">hdfs dfs -put file_Name/file_Path Mapping_Folder_Path --本地文件复制上传

hdfs dfs -movefromLocal file_Name/file_Path Mapping_Folder_Path  --本地文件删除上传

例: hdfs dfs -put hello.txt /input
</code></pre>
<h4 id="从分布式文件系统的映射文件夹下载文件到本地路径"><a href="#从分布式文件系统的映射文件夹下载文件到本地路径" class="headerlink" title="从分布式文件系统的映射文件夹下载文件到本地路径"></a>从分布式文件系统的映射文件夹下载文件到本地路径</h4><pre><code class="lang-shell">hdfs dfs -get Mapping_Folder_Path file_Name/file_Path --映射文件复制到本地路径
</code></pre>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
            <ul id="audio-list" style="display:none">
                
                
                <li title='0' data-url='/statics/chengdu.mp3'></li>
                
                    
            </ul>
            
                        
            
            
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci='7bbd114371cb2cd73dc2'
        data-cs='fd7cda0eb23cbb69b65e291c5b607b196613a6b1'
        data-r='nd-ljq.github.io'
        data-o='ND-LJQ'
        data-a='ND-LJQ'
        data-d=''
        data-p='https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    >Comments</div>


            
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="/img/head.jpg" height=300 width=300></img>
                    <p>ND_LJQ</p>
                    <span>Think like an artist, develop like an artisan</span>
                    <dl>
                        
                            
                                <dd><a href="https://github.com/ND-LJQ'" target="_blank"><span
                                    class=" iconfont icon-github"></span></a></dd>
                            
                            
                            
                        
                        
                    </dl>
                </div>
                <ul>
                    <li><a href="/">6 <p>Articles</p></a></li>
                    <li><a href="/categories">8 <p>Categories</p></a></li>
                    <li><a href="/tags">6 <p>Tags</p></a></li>
                </ul>
            </div>
            
            
            
            <div class="box sticky animated fadeInRight faster">
                <div id="toc" class="subbox">
                    <h4>Contents</h4>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">Linux 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B5%B7%E6%BA%90%E4%B8%8E%E5%8F%91%E5%B1%95"><span class="toc-number">1.1.</span> <span class="toc-text">Linux 系统的起源与发展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">Linux 系统的介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.1.</span> <span class="toc-text">Linux 系统的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.2.2.</span> <span class="toc-text">Linux 系统的组成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">Linux 的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.1.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">各个系统文件夹的意义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="toc-number">2.2.</span> <span class="toc-text">系统基础命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-%E4%BF%AE%E6%94%B9%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4"><span class="toc-number">2.2.1.</span> <span class="toc-text">查看&#x2F;修改当前时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">查看命令类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%91%BD%E4%BB%A4%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3"><span class="toc-number">2.2.3.</span> <span class="toc-text">查看命令帮助文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF"><span class="toc-number">2.2.4.</span> <span class="toc-text">查看系统基础信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%8E%86%E5%8F%B2%E8%BE%93%E5%85%A5"><span class="toc-number">2.2.5.</span> <span class="toc-text">&#x3D;&#x3D;查看历史输入&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%94%80%E7%94%A8%E6%88%B7"><span class="toc-number">2.2.6.</span> <span class="toc-text">注销用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%90%AF%E4%B8%8E%E5%85%B3%E6%9C%BA"><span class="toc-number">2.2.7.</span> <span class="toc-text">&#x3D;&#x3D;重启与关机&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84-%E7%94%A8%E6%88%B7%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.8.</span> <span class="toc-text">&#x3D;&#x3D;组&#x2F;用户的操作&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E4%B8%8E%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.3.</span> <span class="toc-text">系统高级应用与设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">2.3.1.</span> <span class="toc-text">系统性能分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E7%81%AB%E5%A2%99"><span class="toc-number">2.3.2.</span> <span class="toc-text">&#x3D;&#x3D;防火墙&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="toc-number">2.3.3.</span> <span class="toc-text">系统的启动与配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB"><span class="toc-number">2.3.4.</span> <span class="toc-text">&#x3D;&#x3D;系统的运行级别&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">2.3.5.</span> <span class="toc-text">网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">2.3.6.</span> <span class="toc-text">软件的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD"><span class="toc-number">2.3.7.</span> <span class="toc-text">&#x3D;&#x3D;挂载&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.3.8.</span> <span class="toc-text">服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.3.9.</span> <span class="toc-text">&#x3D;&#x3D;进程&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell-1"><span class="toc-number">2.3.10.</span> <span class="toc-text">shell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.3.11.</span> <span class="toc-text">&#x3D;&#x3D;后台运行任务&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.3.12.</span> <span class="toc-text">&#x3D;&#x3D;创建定时任务&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.</span> <span class="toc-text">&#x3D;&#x3D;文件&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="toc-number">2.4.1.</span> <span class="toc-text">&#x3D;&#x3D;文件的基本属性&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E8%BD%AF-%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-number">2.4.2.</span> <span class="toc-text">&#x3D;&#x3D;为文件添加软&#x2F;硬链接&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="toc-number">2.4.3.</span> <span class="toc-text">&#x3D;&#x3D;修改文件权限&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%89%80%E5%B1%9E%E7%94%A8%E6%88%B7-%E7%BB%84"><span class="toc-number">2.4.4.</span> <span class="toc-text">&#x3D;&#x3D;修改文件所属用户&#x2F;组&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">2.4.5.</span> <span class="toc-text">&#x3D;&#x3D;查看当前目录绝对路径&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95"><span class="toc-number">2.4.6.</span> <span class="toc-text">拷贝文件&#x2F;文件夹到指定目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.4.7.</span> <span class="toc-text">&#x3D;&#x3D;拷贝文件到远程服务器&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AA%E5%88%87%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">2.4.8.</span> <span class="toc-text">剪切文件&#x2F;文件夹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BF%A1%E6%81%AF"><span class="toc-number">2.4.9.</span> <span class="toc-text">查看当前目录下的文件&#x2F;文件夹信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">2.4.10.</span> <span class="toc-text">&#x3D;&#x3D;创建文件&#x2F;文件夹&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%A4%B9-%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.11.</span> <span class="toc-text">&#x3D;&#x3D;删除文件夹&#x2F;文件&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E7%9B%AE%E5%BD%95-%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.4.12.</span> <span class="toc-text">统计目录&#x2F;文件大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.13.</span> <span class="toc-text">&#x3D;&#x3D;查找文件&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%AC%A6"><span class="toc-number">2.4.14.</span> <span class="toc-text">&#x3D;&#x3D;管道符&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.15.</span> <span class="toc-text">查看文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0-%E5%8D%95%E8%AF%8D%E6%95%B0-%E5%AD%97%E8%8A%82%E6%95%B0"><span class="toc-number">2.4.16.</span> <span class="toc-text">统计文件行数&#x2F;单词数&#x2F;字节数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.17.</span> <span class="toc-text">编辑文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%BD%92%E6%A1%A3"><span class="toc-number">2.4.18.</span> <span class="toc-text">文件的归档</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.5.</span> <span class="toc-text">&#x3D;&#x3D;文本的操作&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.5.1.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#grep"><span class="toc-number">2.5.2.</span> <span class="toc-text">&#x3D;&#x3D;grep&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awk"><span class="toc-number">2.5.3.</span> <span class="toc-text">&#x3D;&#x3D;awk&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort"><span class="toc-number">2.5.4.</span> <span class="toc-text">sort</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE"><span class="toc-number">3.</span> <span class="toc-text">大数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HDFS-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.0.1.</span> <span class="toc-text">HDFS 的基本操作</span></a></li></ol></li></ol></li></ol>
                </div>
            </div>
            
            
        </div>
    </div>
</div>

    </div>
</div>
    <div id="back-to-top" class="animated fadeIn faster">
        <div class="flow"></div>
        <span class="percentage animated fadeIn faster">0%</span>
        <span class="iconfont icon-top02 animated fadeIn faster"></span>
    </div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2023
        <span class="gradient-text">
            ND_LJQ
        </span>.
        Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
        Theme
        <span class="gradient-text">
            <a href="https://github.com/TriDiamond/hexo-theme-obsidian" title="Obsidian" target="_blank" rel="noopener">Obsidian</a>
        </span>
        <small><a href="https://github.com/TriDiamond/hexo-theme-obsidian/blob/master/CHANGELOG.md" title="v1.4.9.3" target="_blank" rel="noopener">v1.4.9.3</a></small>
        
        
    </p>
</footer>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX", "TeX"],
      linebreaks: {
        automatic: true
      },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"]
      ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      noUndefined: {
        attributes: {
          mathcolor: "red",
          mathbackground: "#FFEEEE",
          mathsize: "90%"
        }
      },
      Macros: {
        href: "{}"
      }
    },
    messageStyle: "none"
  });
</script>
<script>
  function initialMathJax() {
    MathJax.Hub.Queue(function () {
      var all = MathJax.Hub.getAllJax(),
        i;
      // console.log(all);
      for (i = 0; i < all.length; i += 1) {
        console.log(all[i].SourceElement().parentNode)
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  }

  function reprocessMathJax() {
    if (typeof MathJax !== 'undefined') {
      MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }
</script>


 
<link rel="stylesheet" href="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.css">
 
<script src="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.js"></script>
  
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>
 
<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>
 
<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>
 
<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>
 
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/sql/sql.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/java/java.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/c/c.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/html/html.min.js"></script>
   
<script src="/js/busuanzi.min.js"></script>

<script>
  $(document).ready(function () {
    if ($('span[id^="busuanzi_"]').length) {
      initialBusuanzi();
    }
  });
</script>
 
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
  

<script>
  function initialTyped() {
    var typedTextEl = $('.typed-text');
    if (typedTextEl && typedTextEl.length > 0) {
      var typed = new Typed('.typed-text', {
        strings: ['Think like an artist, develop like an artisan', '艺术家思维去思考问题，工匠创造精神去开发'],
        typeSpeed: 90,
        loop: true,
        loopCount: Infinity,
        backSpeed: 20,
      });
    }
  }

  if ($('.article-header') && $('.article-header').length) {
    $(document).ready(function () {
      initialTyped();
    });
  }
</script>




<!-- 引用依赖 -->
<script>document.write(aplayerconf)</script>




</html>
