
<!DOCTYPE html>
<html lang="cn" class="loading">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
      name="viewport"
      content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>计算机网络基础 - 刘三刀的blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="google" content="notranslate" />
    
    <meta name="keywords" content="刘三刀的blog," />
     
    <meta name="description" content="计算机网络体系概述计算机网络是”以能够相互共享资源的方式互联起来的自治计算机系统的集合体”
计算机网络的组成
组成成分: 硬件、软件、协议
工作方式: 边缘部分和核心部分
功能组成:通信子网和资源子," />
     
    <meta name="author" content="ND_LJQ" />
     
    <link
      rel="alternative"
      href="atom.xml"
      title="刘三刀的blog"
      type="application/atom+xml"
    />
     
    <link rel="icon" href="/img/favicon.png" />
     
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">
 
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">
 
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">
 
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">
 
<link rel="stylesheet" href="/css/obsidian.css">
 
<link rel="stylesheet" href="/css/ball-atom.min.css">
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
 
    <link
      href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css"
      rel="stylesheet"
    />
    <script>
      var musiclist = '';
    </script>
    
<script src="/js/loadaplayer.js"></script>

    <!-- 引用依赖 -->
    
<link rel="stylesheet" href="/aplayer/dist/APlayer.min.css">
 
<script src="/aplayer/dist/APlayer.min.js"></script>
<script src="/js/Meting.min.js"></script>
 
  <meta name="generator" content="Hexo 6.3.0"></head>
</html>


<body class="loading">
    <div class="loader">
        <div class="la-ball-atom la-2x">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
    <span id="config-title" style="display:none">刘三刀的blog</span>
    <div id="loader"></div>
    <div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="/img/favicon.png" alt="" data-url="http://www.hunauforum.top">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">计算机网络基础</h3>
        <div class="social">
            <!--        <div class="like-icon">-->
            <!--            <a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
            <!--        </div>-->
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
            animation-delay: 600ms;
            animation-duration: 1.2s;
            background-image: 
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url('/img/cover.jpg') ">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                <a href="/categories/计算机基础"><b>「
                    </b>计算机基础<b> 」</b></a>
                
                July 18, 2023
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" title="计算机网络基础" class="">计算机网络基础</a>
            </h3>
            
            <p class="post-count animated fadeInDown">
                
                <span>
                    <b class="iconfont icon-text2"></b> <i>Words count</i>
                    108k
                </span>
                
                
                <span>
                    <b class="iconfont icon-timer__s"></b> <i>Reading time</i>
                    1:38
                </span>
                
                
                
                <span id="busuanzi_container_page_pv">
                    <b class="iconfont icon-read"></b> <i>Read count</i>
                    <span id="busuanzi_value_page_pv">0</span>
                </span>
                
            </p>
            
            
            <ul class="animated fadeInDown post-tags-list" itemprop="keywords"><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s"></span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <h1 id="计算机网络体系概述"><a href="#计算机网络体系概述" class="headerlink" title="计算机网络体系概述"></a>计算机网络体系概述</h1><p><strong>计算机网络是”以能够相互共享资源的方式互联起来的自治计算机系统的集合体”</strong></p>
<h2 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h2><ul>
<li>组成成分: 硬件、软件、协议</li>
<li>工作方式: 边缘部分和核心部分</li>
<li>功能组成:通信子网和资源子网</li>
</ul>
<h2 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h2><p>数据通信(最基本最重要的功能)</p>
<p>资源共享,分布式处理,提高可靠性,负载均衡</p>
<h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><h3 id="按分布范围分类"><a href="#按分布范围分类" class="headerlink" title="按分布范围分类"></a>按分布范围分类</h3><p> 广域网(WAN)、城域网(MAN) 5-50km</p>
<p> 局域网(LAN)、个人区域网(PAN) 10m</p>
<h3 id="按传输技术分类"><a href="#按传输技术分类" class="headerlink" title="按传输技术分类"></a>按传输技术分类</h3><p> 广播式网络(局域网、广域网中的无线,卫星通信)</p>
<p> 点对点网络:采用<code>存储转发</code>和<code>路由选择</code>机制(广域网基本属于点对点网络)</p>
<h3 id="按拓扑结构分类"><a href="#按拓扑结构分类" class="headerlink" title="按拓扑结构分类"></a>按拓扑结构分类</h3><h4 id="总线型"><a href="#总线型" class="headerlink" title="总线型"></a>总线型</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230608163723803.png" alt="image-20230608163723803"></p>
<h4 id="星型"><a href="#星型" class="headerlink" title="星型"></a>星型</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230608163750535.png" alt="image-20230608163750535"></p>
<h4 id="环形"><a href="#环形" class="headerlink" title="环形"></a>环形</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230608163909998.png" alt="image-20230608163909998"></p>
<h4 id="树型"><a href="#树型" class="headerlink" title="树型"></a>树型</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230608164005762.png" alt="image-20230608164005762"></p>
<h4 id="网状"><a href="#网状" class="headerlink" title="网状"></a>网状</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230608164038289.png" alt="image-20230608164038289"></p>
<h3 id="按使用者分类"><a href="#按使用者分类" class="headerlink" title="按使用者分类"></a>按使用者分类</h3><p> 电路交换网络</p>
<p> 报文交换网络</p>
<p> 分组交换网络</p>
<h3 id="按传输介质分类"><a href="#按传输介质分类" class="headerlink" title="按传输介质分类"></a>按传输介质分类</h3><p><strong>有线网络</strong></p>
<ul>
<li>双绞线网络</li>
<li>同轴电缆网络</li>
</ul>
<p><strong>无线网络</strong></p>
<ul>
<li>蓝牙</li>
<li>微波</li>
<li>无线电</li>
</ul>
<h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="==计算机网络的性能指标=="></a>==计算机网络的性能指标==</h2><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>(即数字信道所能传送的”最高数据率”的同义词)</p>
<p> 单位: 在通信领域为赫兹(Hz)</p>
<p> 在计算机网络中是(b/s)</p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p> 发送时延:分组长度/信道宽度</p>
<p> 传播时延:信道长度/电磁波在信道上的传播速率</p>
<p> 处理时延:提取数据报首数据部分,解析首部,查找合适路由所需时间</p>
<p> 排队时延:分组进入路由器输入队列等待处理,然后在路由器的输入队列中等待处理</p>
<h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p> 表示当第一个发送的比特到达终点后信道的比特量</p>
<p> 带宽 × 传输时延</p>
<h3 id="往返时延-RRT-Round-Trip-Time"><a href="#往返时延-RRT-Round-Trip-Time" class="headerlink" title="往返时延(RRT Round Trip Time)"></a>往返时延(RRT Round Trip Time)</h3><p> 发送端收到接受端的确认报文所需的时间</p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p> 单位时间内通过某个网络所需的时间</p>
<h3 id="速率-传输速率、数据率、比特率"><a href="#速率-传输速率、数据率、比特率" class="headerlink" title="速率(传输速率、数据率、比特率)"></a>速率(传输速率、数据率、比特率)</h3><p> 单位为 b/s 或 bit/s(bps bit per second)</p>
<p> k=10^3^ M=10^6^ G=10^9^ T=10^12^ P=10^15^ Z=10^18^ E=10^21^</p>
<p> 需要注意的是在计算机存储中 k=2^10^ M=2^20^ G=2^30^……</p>
<h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p> 某一时间段内有数据通过的时间占这一段时间的百分比</p>
<h2 id="协议、服务、接口"><a href="#协议、服务、接口" class="headerlink" title="协议、服务、接口"></a>协议、服务、接口</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li>语法:传输数据的格式</li>
<li>语义:所需要完成的功能(发出何种控制信息,完成何种动作,已经做出何种相应)</li>
<li>同步:事件实现顺序的说明</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p> 上层通过接口来访问下层提供的服务</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p> 下层为上层提供功能的调用,它是垂直的</p>
<p> 服务原语:</p>
<ul>
<li>请求(request):服务用户发往服务提供者,请求完成某项工作</li>
<li>指示(indication):服务提供者发往服务用户,指示服务用户做某件事</li>
<li>响应(response):服务用户发往服务提供者,作为对指示的响应</li>
<li>证实(confirmation):由服务提供者发往服务用户作为对请求的证实</li>
</ul>
<h4 id="服务的种类"><a href="#服务的种类" class="headerlink" title="服务的种类"></a>服务的种类</h4><ul>
<li><ul>
<li>面向连接的服务:通信前双方必须先建立连接,分配相应的资源(如缓冲区),以确保通信的正常进行</li>
<li>无连接的服务(尽最大努力交付):不需要建立连接,直接发送数据</li>
</ul>
</li>
<li><ul>
<li>可靠服务:网络具有纠错、检错、应答机制,能保证数据正确可靠的到达目的地</li>
<li>不可靠服务:尽量可靠、正确的传输,是一种尽力而为的服务</li>
</ul>
</li>
<li><ul>
<li>有应答服务:接受方收到数据后向发送方给出相应的应答(文件传输服务)</li>
<li>无应答服务:接受方收到数据后不给出相应应答,若需要应答也是由高层来实现(www 服务)</li>
</ul>
</li>
</ul>
<h2 id="OSI-与-TCP-IP-模型"><a href="#OSI-与-TCP-IP-模型" class="headerlink" title="==OSI 与 TCP/IP 模型=="></a>==OSI 与 TCP/IP 模型==</h2><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230606121610515.png" alt="image-20230606121610515"></p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p><strong>传输单位</strong>:==比特==</p>
<p><strong>任务</strong>:==透明传输比特流==</p>
<p><strong>功能</strong>:在物理媒体上为数据端设备透明传输比特流</p>
<p><strong>物理层协议(物理层接口标准,物理层规程):</strong><code>EIA-232C</code>、<code>EIA/TIA RS-449</code>、<code>CCITT的X.21</code></p>
<p>注意 传输信息所用的物理媒介(双绞线,光纤,无线信道)并不处于物理层协议之内而处于物理层协议之下</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p><strong>传输单位:</strong>==帧==</p>
<p><strong>任务</strong>: 将网络层传来的数据报封装成帧</p>
<p><strong>功能</strong>:封装成帧,差错控制,流量控制,传输管理</p>
<p><strong>典型协议:</strong><code>SDLC</code>、<code>HDLC</code>、<code>SLIP</code>→<code>PPP</code>、<code>STP</code></p>
<p>注意实际上数据链路层分为两个子层:MAC 子层和高级数据链路控制子层</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a><strong>网络层</strong></h3><p><strong>传输单位</strong>:==数据包==</p>
<p><strong>任务</strong>:把网络层的<code>协议数据单元(分组)</code>从源端到目的端,为分组交换网络上的==不同主机==提供通信服务</p>
<p><strong>功能</strong>:实现路由选择、流量控制、拥塞控制、差错控制、网际互连等功能</p>
<p><strong>典型协议:</strong><code>IP</code>、<code>ICMP</code>、<code>IPX</code>、<code>IGMP</code>、<code>ARP(Address Resolution Protocol)</code>、<code>RARP</code>、<code>OSPF</code></p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p><strong>传输单位:</strong>==报文段==或者==用户数据报==</p>
<p> TCP UDP</p>
<p><strong>任务</strong>:负责不同主机中的两个==进程==之间的通信,提供端到端的可靠的传输服务</p>
<p><strong>功能</strong>:为端到端的服务提供流量控制、差错控制、服务质量、数据传输管理</p>
<p><strong>典型协议:</strong><code>TCP</code>、<code>UDP</code></p>
<h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>允许不同主机上的各个进程进行会话,建立、管理以及终止进程间的会话</p>
<p>校验点技术使通信会话在通信失效时从校验点继续恢复通信,实现数据同步</p>
<h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>不同机器采用的编码和表示方法不同,表示层采用标准编码形式,功能为数据压缩,加密和解密</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>用户与网络的接口,最复杂的一层</p>
<p><strong>典型协议:</strong><code>FTP</code>、<code>SMTP</code>、<code>HTTP</code>、<code>DNS</code>、<code>RTP</code></p>
<p><strong><em>OSI 模型与 TCP/IP 模型的区别</em></strong></p>
<ul>
<li>OSI 模型网络层支持无连接和面向连接的服务,传输层只支持面向连接的服务(TCP,SPX)</li>
<li>TCP/IP 模型网络层仅支持无连接的服务(IP),传输层提供面向连接(TCP)和无连接的服务(UDP)</li>
</ul>
<h1 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h1><p><strong>模拟信号(数据):</strong>连续变换的数据</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/resize,m_lfit,w_536,limit_1.jpeg" alt="波形图"></p>
<p><strong>数字信号(数据)</strong>:取值仅有有限的几个离散数据: 01001101001</p>
<h2 id="信源、信宿、信道"><a href="#信源、信宿、信道" class="headerlink" title="信源、信宿、信道"></a>信源、信宿、信道</h2><p><strong>信源</strong>:产生和发送数据的源头</p>
<p><strong>信宿</strong>:接受数据的终点</p>
<p><strong>信道</strong>:数据的传输媒介</p>
<p>数字信号传输(基带传输)</p>
<p>模拟信号在模拟信道中传输(宽带传输)</p>
<h2 id="通信双方的交互方式"><a href="#通信双方的交互方式" class="headerlink" title="通信双方的交互方式"></a>通信双方的交互方式</h2><ul>
<li>单向通信</li>
<li>半双工通信(通信双方在同一时间)</li>
<li>全双工通信</li>
</ul>
<h2 id="速率、波特与带宽"><a href="#速率、波特与带宽" class="headerlink" title="==速率、波特与带宽=="></a>==速率、波特与带宽==</h2><p><strong>速率</strong>:数据传输速率</p>
<pre><code class="lang-css">    - 码元传输速率(波特率) Baud →代表每秒发生的信号变化次数
    - 信息传输速率 b/s
</code></pre>
<p><strong>带宽:</strong> 指信号所具有频带的宽 HZ 同时表示单位时间内的最高数据率</p>
<p>所以三者可以互相转换</p>
<h2 id="奈氏准则和香农定律"><a href="#奈氏准则和香农定律" class="headerlink" title="==奈氏准则和香农定律=="></a>==奈氏准则和香农定律==</h2><h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><p>在理想低通的信道(没有噪声,带宽有限)</p>
<p>理想低通信道下的极限数据传输速率:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/奈氏准则.svg" alt="奈氏准则"></p>
<p>极限码元速率:2W Baud</p>
<h3 id="香农定律"><a href="#香农定律" class="headerlink" title="香农定律"></a>香农定律</h3><p>在带宽受限且有高斯白噪音干扰的信道的极限传输速率,当用此速率进行传输时,可以做到不产生误差</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/香农定理.svg" alt="香农定理"></p>
<p>信噪比: S/N,10log~10~(S/N) (dB)</p>
<blockquote>
<p>🤔<strong>信噪比为 S/N,为什么还要取对数 10log~10~(S/N)</strong>❓</p>
<ul>
<li>以数字信号表示,即一般数值.如噪声功率为 1,信号功率为 100,信噪比为 100/1=100.</li>
<li><p>以分贝形式表示,同样还是上述数字,分贝形式表示的信噪比为 10log~10~(100/1) = 20dB</p>
<p>两者的区别在于,前者(数值)是没有单位的,后者必须加 dB,代表分贝.两者数值上等价</p>
<p>采用分贝表示的原因是,很多时候信号要比噪声强得多,比如信号比噪声强 10 亿倍,使</p>
<p>用分贝表示则不容易丢失 0</p>
</li>
</ul>
</blockquote>
<h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p><strong>编码</strong>:将数字数据编码为数字信号</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/编码.svg" alt="编码"></p>
<p><strong>调制</strong>:数字信号调制为模拟信号</p>
<p>正交振幅调制(QAM)</p>
<ul>
<li>调频:幅移键控(FSK)</li>
<li>调幅:频移键控(ASK)</li>
<li>调相:相移键控(PSK)</li>
</ul>
<p>采用 m 个相位,每个相位 n 种振幅</p>
<p>即 log~2~(mn)为每一波特(Baud)所携带的比特数</p>
<p><strong>模拟信号编码为数字信号</strong></p>
<p>采样、量化和编码</p>
<p><strong>采样定理</strong>:==奈奎斯特定理==</p>
<p>模拟信号转换为数字信号时**原始信号中的最大频率为 f,那么采样频率 f~采样~必须大于等于最大频率的两倍,才能保证采样后的数字信号完整保留原始模拟信号的信息</p>
<h2 id="电路交换-报文交换与分组交换"><a href="#电路交换-报文交换与分组交换" class="headerlink" title="电路交换,报文交换与分组交换"></a>电路交换,报文交换与分组交换</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p> 进行数据传输前,两结点之间必须建立一条专用的物理通信路径</p>
<p> 连接建立 → 数据传输 → 连接释放</p>
<h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p> 数据交换的单位是报文,报文携带有<code>目标地址</code>,<code>源地址</code></p>
<p> 报文交换节点采用的是存储转发的传输方式</p>
<p> (主要使用在早期的电报通信网中)</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>同样采用存储转发方式,但限制了每一次传输数据块大小,把大的数据块划分成合理的小数据块,然后添加一些必要的控制信息(源地址、目的地址、编号信息),构成一个个分组(Packet)</p>
<ul>
<li>数据报<ul>
<li>发送分组前不需要建立连接</li>
<li>最大努力交付</li>
</ul>
</li>
<li>虚电路<ul>
<li>虚电路的建立:建立一条逻辑通路</li>
<li>数据传输,进行双向的数据传输</li>
<li>虚电路的释放:发送释放请求,逐段断开整个连接</li>
</ul>
</li>
</ul>
<h4 id="分组交换和报文交付时间比较"><a href="#分组交换和报文交付时间比较" class="headerlink" title="==分组交换和报文交付时间比较=="></a>==分组交换和报文交付时间比较==</h4><p>所有链路的数据传输速率为 100Mbps,分组大小为 1000B,其中分组头大小为 20B,若主机 H1 向主机 H2 发送一个大小为 980000B 的文件,在不考虑分组拆装时间和传播时延的情况下,H1 发送开始到 H2 接受为止,需要的时间是多少?</p>
<p>网络拓扑图如下 👇</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/拓扑.svg" alt="未命名绘图-第 12 页.drawio"></p>
<p><strong>报文交换时间</strong></p>
<p>文件从 H1 发送到 R1 所用的时间为:</p>
<p>t~1~ = (980000×8)/(100×10^6^)</p>
<p>所以 H1 到 H2 中要经过 3 段路程</p>
<p>t~总~ = t~1~ × 3</p>
<p><strong>分组交换时间</strong></p>
<p>分析:</p>
<p>一个分组 1000B,分组头 20B =&gt; 一个分组中数据部分为 980B</p>
<p>分组数 =&gt; 980000B / 980B = 1000 组</p>
<p>分析前三个分组的传送时间</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/分组交换.svg" alt="分组交换"></p>
<p>可得时间示意图</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/时间图.svg" alt="时间图"></p>
<blockquote>
<p>可类比计算机组成原理中的流水线</p>
</blockquote>
<p>当分组 1 到 R1 时</p>
<p>t = (1000 × 8)/(100×10^6^)</p>
<p>则分组 1 到 H2 的时间为</p>
<p>t~1 总~ = t × 3</p>
<p>所以可得 T~总~为</p>
<p>T~总~ = 分组 1 到达时间 + (1000 - 1)×t =&gt; T~总~ = t~1 总~ + (1000 - 1)×t</p>
<h2 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h2><p><code>双绞线</code>、<code>同轴电缆</code>、<code>光纤</code>与<code>无线传输介质</code></p>
<h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3><h4 id="屏蔽双绞线-STP"><a href="#屏蔽双绞线-STP" class="headerlink" title="屏蔽双绞线(STP)"></a>屏蔽双绞线(STP)</h4><p>shielded twisted pair</p>
<p><code>F/UTP</code>(FTP,U/FTP) U 代表整条电缆不再加另外的屏蔽层</p>
<p> 铝箔屏蔽</p>
<h4 id="无屏蔽双绞线-UTP"><a href="#无屏蔽双绞线-UTP" class="headerlink" title="无屏蔽双绞线(UTP)"></a>无屏蔽双绞线(UTP)</h4><p>unshielded twisted pair</p>
<h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p> 50Ω 同轴电缆(基带同轴电缆):基带数字信号传送(局域网应用广泛)</p>
<p> 75Ω 同轴电缆(宽带同轴电缆):宽带信号(有线电视系统)</p>
<h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p>可见光的频率约为 10^8^MHZ 因此光纤通信带宽范围极大</p>
<p><strong>多模光纤</strong>:利用光的全反射,只适合近距离传输</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/多模光纤.svg" alt="多模光纤"></p>
<p><strong>单模光纤</strong>:适合远距离传输</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/单模光纤.svg" alt="单模光纤"></p>
<h3 id="无线传输介质"><a href="#无线传输介质" class="headerlink" title="无线传输介质"></a>无线传输介质</h3><h4 id="无线电波"><a href="#无线电波" class="headerlink" title="无线电波"></a>无线电波</h4><p>有较强的穿透能力可以传输很长的距离</p>
<p>应用场景:</p>
<p> 无线手机通信</p>
<p> 无线局域网(WLAN)</p>
<h4 id="微波、红外线和激光"><a href="#微波、红外线和激光" class="headerlink" title="微波、红外线和激光"></a>微波、红外线和激光</h4><p>高带宽,地面传输距离有限</p>
<p>卫星通信利用地球同步卫星作为中继器转发</p>
<p>三颗同步卫星(120^°^)能基本实现全球通信</p>
<p>(传播时延长、保密性差)</p>
<h2 id="物理接口层的特性"><a href="#物理接口层的特性" class="headerlink" title="物理接口层的特性"></a>物理接口层的特性</h2><ul>
<li><strong>机械特性</strong>:指明接口所用接线器形状、尺寸、引脚数目、排列、固定和锁定装置</li>
<li><strong>电气特性</strong>:接口电缆中各条线上的电压范围</li>
<li><strong>功能特性</strong>:某条件上出现的某一电平和电压的意义</li>
<li><strong>过程特性(规程特性)</strong>:对不同功能的各种可能事件的出现顺序</li>
</ul>
<p><a href="###物理层">接口标准</a></p>
<h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p>将信号整形后放大再转发出去</p>
<p>中继器两端都是网段而不是子网</p>
<p>中继器不能连接两个不同速率的局域网,且需要为同一协议</p>
<blockquote>
<p>如果某个网络设备具有”<code>存储转发</code>“的功能</p>
<p>那么可以认为它能连接两个不同的协议</p>
</blockquote>
<p>在采用粗同轴电缆的 10BASE5 的以太网规范中</p>
<p>规定:==5-4-3 规则==</p>
<p>互相串联的中继器个数不能超过<code>4个</code>,而且用<code>4个</code>中继器串联的<code>5段</code>通信介质中,只有<code>3段</code>可以挂接计算机</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/543.svg" alt="543"></p>
<blockquote>
<p><code>放大器</code>与<code>中继器</code>功能类似</p>
<p>但是放大器是放大的<code>模拟信号</code>,原理是将衰减的信号<code>放大</code></p>
<p> 中继器是放大的<code>数据信号</code>,原理是将衰减的信号<code>整形再生</code></p>
</blockquote>
<h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>实质是一个多端口的中继器</p>
<p>如果两个或以上的端口同时发送数据那么其所有数据都无效</p>
<p>即<strong>所有集线器的端口都属于一个冲突域</strong></p>
<p>即 1 个 10M 带宽的集线器连接 8 台计算机时每台计算机工作时的真正带宽为 10/8 = 1.25Mb/s</p>
<h3 id="Q-A"><a href="#Q-A" class="headerlink" title="Q.A"></a>Q.A</h3><blockquote>
<p>==传输媒介并不是物理层==</p>
<p>其在物理层下面</p>
<p>传输媒体传输的是信号,即传输不知道所传输的信号代表什么</p>
<p>但物理层规定了功能特性,所以能识别信号的意义</p>
</blockquote>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/传输媒介.svg" alt="传输媒介"></p>
<blockquote>
<p><strong>什么是基带传输,频带传输和宽带传输?三者的区别是什么?</strong></p>
<p> <strong>基带传输</strong>→ 在计算机内部或在相邻设备近距离传输时可以不经过调制直接传输数字信号</p>
<p> <strong>频带传输</strong>→ 用数字信号对特定频率的载波进行调制,将其变为适合传送的信号后再进行传输(远距离/无线传输)</p>
<p> <strong>宽带传输</strong>→ 借助频带传输,可将链路容量分解为多个信道,每个信道可以携带不同的信号(频分复用)</p>
</blockquote>
<h1 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="==数据链路层=="></a>==数据链路层==</h1><h2 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h2><p>将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路</p>
<p>使其对网络层表现为一条无差错的链路</p>
<h2 id="为网络层提供的服务"><a href="#为网络层提供的服务" class="headerlink" title="为网络层提供的服务"></a>为网络层提供的服务</h2><p>1)无确认的无连接的服务</p>
<p> 适用于实时通信,误码率较低的网络(以太网)</p>
<p>2)有确认无连接的服务</p>
<p> 适用于误码率较高的通信(无线通信)</p>
<p>3)有确认的面向连接的服务</p>
<p> 适用于通信要求较高的场合(可靠性,实时性)</p>
<blockquote>
<p><code>有连接就一定有确认</code></p>
</blockquote>
<h2 id="链路的管理"><a href="#链路的管理" class="headerlink" title="链路的管理"></a>链路的管理</h2><p> 数据链路层连接的建立、维持和释放的过程称为链路管理</p>
<p><code>帧定界</code>、<code>帧同步</code>、<code>透明传输</code></p>
<p>在 HDLC 协议中(高级数据链路控制协议)</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/HDLC.svg" alt="HDLC"></p>
<h2 id="流量控制-OSI-体系结构"><a href="#流量控制-OSI-体系结构" class="headerlink" title="流量控制(OSI 体系结构)"></a>流量控制(OSI 体系结构)</h2><p>限制发送方的数据流量,使其发送速率不超过接收方的接受能力</p>
<p>对数据链路层来说,控制的是<code>相邻两节点之间的数据链接的流量</code></p>
<h2 id="差错控制"><a href="#差错控制" class="headerlink" title="==差错控制=="></a>==差错控制==</h2><p>通过 CRC(循环冗余校验)方式发现位错,通过自动重传请求(Automatic Repeat Request,aARQ)</p>
<h3 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h3><h4 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a><strong>奇偶校验码</strong></h4><p>n-1 位的信息元后+1 位的校验元</p>
<p>如果是奇校验码,则代表码长为 n 种有”1”的个数为奇数</p>
<p> 偶 偶</p>
<p>不足:只能校验奇/偶位数的错误</p>
<h4 id="循环冗余码-CRC"><a href="#循环冗余码-CRC" class="headerlink" title="循环冗余码(CRC)"></a><strong>循环冗余码(CRC)</strong></h4><p>发送方和接受方事先商定一个多项式(多项式的最高位和最低位必须为 1)</p>
<p><code>除数</code>由多项式可得:例如 CRC = X^3^ + X^2^ + 1</p>
<p>则除数为 1101</p>
<p><code>被除数</code>为待校验数后加上述多项式最大阶个 0</p>
<p><code>余数</code>长度为多项式最大阶的位数(X^n^+……+1 即 n 位)</p>
<p>除法中相减为<code>模2运算</code>(异或运算 → 同 0 异 1)</p>
<p>最后的发送的帧或报文结构为待校验数+余数(FCS)</p>
<p>接受方用收到的帧除以商定的多项式 G(x),若能整除,那么认为无差错</p>
<blockquote>
<p>循环冗余码(CRC)是具有纠错功能的,只是数据链路层只使用了它的检错功能</p>
<p>检测到错误的帧直接丢弃,是为了方便协议的实现</p>
</blockquote>
<h3 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h3><h4 id="海明码"><a href="#海明码" class="headerlink" title="==海明码=="></a>==海明码==</h4><ol>
<li><p><strong>确定海明码位数</strong></p>
<p>设 n 为有效信息位数,k 为校验位的位数</p>
<p>则信息位 n 和校验位 k 应满足</p>
<p>n+k ≤ 2^k^-1</p>
</li>
</ol>
<blockquote>
<p>因为他只能校验一位错误</p>
<p>即为编码后错误的情况的个数</p>
<p>为 n+k 位 每 1 个单独的位出错情况,还有一种情况为每一位均无错的情况</p>
<p>所以总的出错的情况有 n+k+1 种</p>
<p>校验位 k 位能表示的错误情况为 2^k^个</p>
<p>k 位校验码表示的错误数应大于 n+k+1 的情况</p>
</blockquote>
<ol>
<li><p><strong>确定校验码在原码的位置</strong></p>
<p>==设原信息码为 1010==</p>
<p>校验位在海明码的 2^i-1^(海明码位数为信息位数+校验位数)</p>
<p>则有 4 位信息位,3 位校验位</p>
<p>海明码为 H~7~H~6~H~5~H~4~H~3~H~2~H~1~</p>
<p>校验码位置:P~1~ = 2 ^1-1^→ 第 1 位 P~2~ = 2^2-1^ → 第 2 位 P~3~^3-1^ = 4 → 第 4 位</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/haiming1.svg" alt="haiming1"></p>
<p>D 为信息位</p>
<p>P 为校验码所处的位置</p>
</li>
</ol>
<ol>
<li><p><strong>分组以形成校验关系</strong></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/haiming.svg" alt="haiming"></p>
<p>按照 P~i~的 i 位上的数去找信息位上相同位来进行分组,若 P~i~的 i 位上的数与信息位 i 位上的数相同,则为一组</p>
<p>即 G~P1~ = D~1~D~2~D~4~ G~P2~ = D~1~D~3~D~4~ G~P3~ = D~2~D~3~D~4~</p>
</li>
</ol>
<ol>
<li><p><strong>检验位取值</strong></p>
<p>P~i~的值为其组的信息位去异或(同 0 异 1)所得</p>
<p>即:</p>
<p>P~1~ = D~1~ ⊕ D~2~ ⊕ D~4~ = 0 ⊕ 1 ⊕ 1 = 0</p>
<p>P~2~ = D~1~ ⊕ D~3~ ⊕ D~4~ = 0 ⊕ 0 ⊕ 1 = 1</p>
<p>P~1~ = D~2~ ⊕ D~3~ ⊕ D~4~ = 1 ⊕ 0 ⊕ 1 = 1</p>
<p>则最后所得的海明码为:1010010</p>
</li>
</ol>
<blockquote>
<p>校验原理:每个校验组与该校验位进行异或操作后结果为 0,则该校验组正确</p>
<p>海明码纠错 d 位需要码距 2d+1</p>
<p> 检错 d+1</p>
</blockquote>
<h2 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h2><p>把比特组合成以帧为单位进行传输,为了在出错时只重发出错的帧而不用重发全部数据,从而提高效率</p>
<p>组帧主要解决三个问题</p>
<p><code>帧定界</code>、<code>帧同步</code>、<code>透明传输</code></p>
<h3 id="帧定界"><a href="#帧定界" class="headerlink" title="帧定界"></a>帧定界</h3><h4 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h4><p>在帧的头部使用一个计数字段来表明帧内字符数</p>
<h4 id="字符填充法"><a href="#字符填充法" class="headerlink" title="字符填充法"></a>字符填充法</h4><p><code>SOH</code>代表一帧的开始</p>
<p><code>EOT</code>代表一帧的结束</p>
<blockquote>
<p>若帧的数据字段中包含有<code>SOH</code>和<code>EOT</code>则在其前插入<code>ESC</code>(转义字符),若有<code>ESC</code>则在<code>ESC</code>前插入<code>ESC</code></p>
</blockquote>
<h4 id="零比特填充法"><a href="#零比特填充法" class="headerlink" title="零比特填充法"></a>零比特填充法</h4><p>以<code>01111110</code>来标志一帧的开始或结束</p>
<blockquote>
<p>在信息位中 5 个连续的 1 后加一个 0 以此区分<code>01111110</code></p>
</blockquote>
<h2 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h2><h3 id="停止等待流量控制"><a href="#停止等待流量控制" class="headerlink" title="停止等待流量控制"></a>停止等待流量控制</h3><p>发送方每发送一帧都要等待对方的应答信号才能发送下一帧</p>
<p>接收方每接受一帧都要反馈一个应答信号接收下一帧</p>
<h3 id="滑动窗口流量控制"><a href="#滑动窗口流量控制" class="headerlink" title="滑动窗口流量控制"></a>滑动窗口流量控制</h3><p>发送方每收到一个确认帧,发送窗口就往后滑动一帧位置</p>
<p>接受方每发送一个确认帧,接受窗口就往后滑动一帧位置</p>
<p><strong>==多帧滑动窗口与后退 N 帧协议(GBN→Go-Back-N)==</strong></p>
<p>当发送方发送了 N 个帧后,该 N 帧的前一个帧在计时器超时后仍未被确认</p>
<p>则发送方重传该出错帧以及发送的 N 帧</p>
<p>为了减少开销,GBN 规定可以在连续收到几个正确的帧后,才对最后一个数据帧发送确认信息(累积确认)</p>
<p>(即表明该数据帧和此前收到的帧已均被正确无误的收到)</p>
<blockquote>
<p>==序号==：因为可靠数据传输的重传机制，所以必不可免的会产生重复帧问题，这时就需要对发送方的数据帧和接收方的确认帧标明序号。一般序号采用 n 位二进制的形式，比如 3 位二进制(000-111)可以表示序号 0-7，所以可以使用的序号空间大小为 8。如果 n 位二进制，则序号空间大小为 2^n^，序号最大值 MAX_SEQ 为 2^n^-1。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/序号空间.svg" alt="序号空间"></p>
<p>🤔<strong>为什么发送窗口~max~ ≤ 序号空间大小-1</strong>❓</p>
<p>假设一种实际情况，发送方发送了 0-7 号数据帧，过了不久收到了来自接收方的 7 号确认帧，然后发送方又连续发了新的 0-7 号数据帧，然后过不久又收到了来自接收方对 7 号的确认帧,此时便出现了问题，发送方无法分辨：</p>
<ul>
<li>7 号确认帧是对之前的一组 0-7 号数据帧的确认，而新发送的数据全部丢失了</li>
<li>7 号帧是对新发送的一组数据进行确认</li>
</ul>
</blockquote>
<p><strong>==多帧滑动窗口与选择重传协议(SR→Selective Repeat)==</strong></p>
<p>选择重传中，接收窗口是大于 1 的，接收方设有缓存，这也就意味着接收方可以不再是按序接收，只要接收到的数据帧在接收窗口的范围内，即可被接收，即使是乱序到达的，仍然放入缓存，等都按序到达一起提交。为了实现只重传某些数据帧，<strong>所以与回退 N 不同，选择重传的接收方对接收到的每个数据帧单独确认（收到谁确认谁），发送方只重传没有收到 ACK 的帧，并为每个帧设定一个定时器。</strong></p>
<blockquote>
<p><strong>发送窗口 + 接收窗口 &lt;= 序号空间</strong></p>
<p><strong>发送窗口与接收窗口大小相同时，发送窗口~MAX~ &lt;= （序号空间 / 2）</strong></p>
<p>🤔<strong>为什么</strong>❓</p>
<p>假设序列号空间仍为 8(0-7)，发送窗口大小为 7，避免了回退 N 帧中的问题。接收窗口与发送窗口大小相同。假设发送方连续发送 0-6 号帧后，等待确认帧。接收方成功接收到 0-6 号帧，向前移动窗口如图，回复对接收数据的确认帧。现在假设一种极端情况 0-6 号确认帧全部丢失，发送方直到 0 号数据帧定时器超时未收到确认，重发 0 号数据帧，接收方收到 0 号数据帧恰好落在自己的接收窗口，当做新帧放入缓存，接收方此时希望接收到的最小数据帧为 7 号帧，直到接收方收到一个 7 号帧后，一起交付给网络层，但是这一批并不是正确的帧，而是包含与之前已提交的 0-6 号重复的数据，故产生了错误。在这种情况下，接收方无法分辨到来的 0 号帧是对之前帧的重传还是新帧的到来，因为接收方的新老窗口序号发生了重叠</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/滑动窗口.png" alt="在这里插入图片描述"></p>
</blockquote>
<h2 id="信道利用率-1"><a href="#信道利用率-1" class="headerlink" title="信道利用率"></a>信道利用率</h2><p>有效地发送数据的时间占整个发送周期的比率</p>
<blockquote>
<p>发送周期:发送方从开始发送数据到收到第一个确认帧的周期</p>
</blockquote>
<h2 id="信道吞吐率"><a href="#信道吞吐率" class="headerlink" title="信道吞吐率"></a>信道吞吐率</h2><p>信道利用率 × 发送方的发送速率</p>
<h2 id="介质访问控制-MAC-子层"><a href="#介质访问控制-MAC-子层" class="headerlink" title="介质访问控制(MAC 子层)"></a>介质访问控制(MAC 子层)</h2><h3 id="信道划介质访问控制"><a href="#信道划介质访问控制" class="headerlink" title="信道划介质访问控制"></a>信道划介质访问控制</h3><h4 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h4><h5 id="频分复用-FDM"><a href="#频分复用-FDM" class="headerlink" title="频分复用(FDM)"></a>频分复用(FDM)</h5><p>Frequency-division multiplexing</p>
<p>系统传输效率高,由于技术较为成熟,实现也较为容易</p>
<h5 id="时分复用-TDM"><a href="#时分复用-TDM" class="headerlink" title="时分复用(TDM)"></a>时分复用(TDM)</h5><p>Time-division multiplexing</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/TDM.svg" alt="TDM"></p>
<p>所以可知若线路传输速率为 800Mb/s</p>
<p>则 A、B、C、D 每个用户的最高速率为 200Mb/s</p>
<p><strong>统计时分复用(STDM)</strong></p>
<p>动态分配每个用户的时间片</p>
<p>则上述每个用户的最高速率为 800Mb/s</p>
<h5 id="波分多路复用-WDM"><a href="#波分多路复用-WDM" class="headerlink" title="波分多路复用(WDM)"></a>波分多路复用(WDM)</h5><p>光的频分多路复用</p>
<h5 id="码分复用-CDM"><a href="#码分复用-CDM" class="headerlink" title="==码分复用(CDM)=="></a>==码分复用(CDM)==</h5><pre><code class="lang-css">例题:共有四个站点进行码分多址通信,四个站的码片分别为:

A(-1,-1,-1,+1,+1,-1,+1,+1)
B(-1,-1,+1,-1,+1,+1,+1,-1)
C(-1,+1,-1,+1,+1,+1,-1,-1)
D(-1,+1,-1,-1,-1,-1,+1,-1)

现收到这样的码片序列(-1,+1,-3,+1,-1,+3,+1,+1)请问哪个站发送了数据,发送的是0还是1?

解:
设: K1为A站发送的数据
    K2为B站发送的数据
    K3为C站发送的数据
    K4为D站发送的数据

即可得四元一次方程组:
    K1×(-1)+K2×(-1)+K3×(-1)+K4×(-1) = -1
    K1×(-1)+K2×(-1)+K3×1+K4×1 = 1
    K1×(-1)+K2×1+K3×(-1)+K4×(-1) = -3
    K1×1+K2×1+K3×1+K4×(-1) = 1

    可解得:K1 = 1;K2 = -1;K3 = 0;K4 = 1
    即AD发送原码,B发送反码,C没有发送
</code></pre>
<blockquote>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/CDM-1686210653669-8.svg" alt="CDM"></p>
</blockquote>
<h3 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h3><p>为了解决随机接入发生的碰撞,每个用户需要按照一定的规则反复重传他的帧,直到该帧无碰撞地通过</p>
<p><strong>常用的协议</strong></p>
<h4 id="ALOHA-协议"><a href="#ALOHA-协议" class="headerlink" title="ALOHA 协议"></a>ALOHA 协议</h4><p>全称:Additive Link One-Line Hawaii System</p>
<ol>
<li><p><strong>纯 ALOHA 协议</strong></p>
<p>思想:想发就发,不监听信道,不按时间槽发送,超时/收到 NAK 否认帧后随机重发</p>
</li>
<li><p><strong>时隙 ALOHA 协议</strong></p>
<p>思想:把各个站点的时间同步,再划分时间片,所有用户只能在时间片的开始发送数据</p>
<p>遇到冲突的情况也只能在时间片的开始发</p>
</li>
</ol>
<h4 id="CSMA-协议"><a href="#CSMA-协议" class="headerlink" title="==CSMA 协议=="></a>==CSMA 协议==</h4><p>载波监听多路访问协议</p>
<ol>
<li><p><strong>1-坚持 CSMA</strong></p>
<p>侦听到信道忙,继续侦听信道,侦听到信道空闲立刻发送数据,若冲突,随机等待,再重新监听</p>
</li>
<li><p><strong>非坚持 CSMA(0-坚持 CSMA)</strong></p>
<p>发送数据时,首先侦听信道,如果信道空闲,立即发送,如果信道繁忙,放弃侦听,等待一个随机时间后重复</p>
</li>
<li><p><strong>P-坚持 CSMA</strong></p>
<p>(用于时分信道)</p>
<p>持续监听信道,若信道空闲则有 P 概率发送数据,1-P 的概率推迟到下一个时隙</p>
</li>
</ol>
<h4 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="==CSMA/CD 协议=="></a>==CSMA/CD 协议==</h4><p>基于冲突检测的载波监听多路访问技术</p>
<p>802.3 中的核心，应用在 10M/100M 的半双工有线网络中(总线型局域网(以太网))</p>
<p><strong>主要思想:</strong></p>
<p> ==先听后发==,==边听边发==,==冲突停发==,==随机重发==</p>
<p>在冲突发生时，为了使两个站点都能及时正确接受到冲突发生的信号，要满足传输一帧的时间大于 2 倍的信道传输时延</p>
<p>CSMA/CD 协议下最小帧长的计算:</p>
<p> 最小帧长 = <a href="###往返时延(RRT Round Trip Time">RRT</a>) × 数据发送速率</p>
<p>争用期为 RRT</p>
<blockquote>
<p><strong>随机重发:</strong></p>
<p>==二进制指数退避算法==</p>
<p>思想:</p>
<p> 1.定义参数 K(K 为重传次数) K 的取值为[重传次数,10]</p>
<p> 当重传次数超过 10 后,K 就一直取 10</p>
<p> 2.从整数集合[0,1,……,2^k^-1]中随机取一个数 r</p>
<p> 重传所退避的时间为 rRRT</p>
<p> 重传 16 次说明此时网络太拥挤,认为此帧无法发送,抛弃此帧</p>
</blockquote>
<h4 id="CSMA-CA-协议"><a href="#CSMA-CA-协议" class="headerlink" title="CSMA/CA 协议"></a>CSMA/CA 协议</h4><p>载波监听多点接入 / 碰撞避免 协议</p>
<p>应用于 802.11 无线局域网</p>
<h4 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h4><p>用于令牌环网</p>
<p>一个站点只有取得令牌(token)后才能发送数据,因此不会产生冲突</p>
<p>令牌和数据传输的过程为</p>
<ol>
<li>网络空闲,令牌循环传递</li>
<li>令牌到有数据要发送的站点,该站点修改令牌的一个标志位并在令牌中附加自己需要传输的数据帧,将令牌变为一个数据帧发送出去</li>
<li>源站通过返回的帧来检验是否要重传</li>
<li>无错后源站重新产生一个令牌,交出信道控制权</li>
</ol>
<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h3 id="局域网的基本概念和体系结构"><a href="#局域网的基本概念和体系结构" class="headerlink" title="局域网的基本概念和体系结构"></a><strong>局域网的基本概念和体系结构</strong></h3><p>局域网（Local Area Network）：简称 LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道。</p>
<p>特点 1：覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</p>
<p>特点 2：使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb/s~10Gb/s）。</p>
<p>特点 3：通信延迟时间端，误码率低，可靠性较高。</p>
<p>特定 4：各站为平等关系，共享传输信道。</p>
<p>特点 5：多采用分布式控制和广播式通信，能进行广播和组播。</p>
<p>决定局域网的主要要素为：网络拓扑，传输介质与介质访问控制方法。</p>
<p><strong>三种特殊局域网拓扑:</strong></p>
<p><strong>==以太网==</strong></p>
<p>使用范围最广</p>
<p>逻辑拓扑为<a href="####总线型">总线型结构</a></p>
<p>物理拓扑为<a href="####星型">星型或者拓展星型</a></p>
<p>以太网采用两项措施以简化通信</p>
<ol>
<li>采用无连接的工作方式,不对发送的数据帧编号,也不要求接受方发送确认,即以太网尽最大努力交付数据,提供的是不可靠服务,对于差错的纠正则由高层完成</li>
</ol>
<blockquote>
<p>🙋‍♂️ 严格来说以太网是指符合 DIX Ethernet V2 标准的以太网,但 DIX Ethernet V2 与 802.3 标准只有很小的差距</p>
<p>所以将 802.3 局域网简称为以太网</p>
</blockquote>
<p><strong>令牌环</strong></p>
<p>IEEE 802.5</p>
<p>逻辑拓扑为<a href="####环形">环形结构</a></p>
<p>物理拓扑是<a href="####星型">星型结构</a></p>
<p><strong>FDDI</strong></p>
<p>光纤分布数字接口</p>
<p>IEEE802.8</p>
<p>逻辑拓扑为<a href="####环形">环形结构</a></p>
<p>物理拓扑为双环结构</p>
<blockquote>
<p>🙋‍♂️IEEE802 标准定义的局域网参考模型只对应 OSI 模型中的数据链路层和物理层</p>
<p>并将数据链路层拆分为两个子层:逻辑链路控制(LLC)子层和媒体接入控制(MAC)子层</p>
<p>与接入媒体有关的内容都放在 MAC 子层,它向上屏蔽对物理层访问的各种差异,提供对物理层的统一访问</p>
<p>由于以太网在局域网市场取得垄断地位,几乎称为局域网代名词</p>
<p>而 802 协会制定的 LLC 子层的作用已经不大,因此现在许多网卡仅装有 MAC 协议而没有 LLC 协议</p>
</blockquote>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><h3 id="以太网传输介质与-网卡"><a href="#以太网传输介质与-网卡" class="headerlink" title="以太网传输介质与==网卡=="></a>以太网传输介质与==网卡==</h3><h4 id="传输介质-1"><a href="#传输介质-1" class="headerlink" title="传输介质"></a>传输介质</h4><p>各种传输介质以及其情况:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">10BASE5</th>
<th style="text-align:center">10BASE2</th>
<th style="text-align:center">10BASE-T</th>
<th style="text-align:center">10BASE-FL</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">传输媒体</td>
<td style="text-align:center">基带同轴电缆(粗缆)</td>
<td style="text-align:center">基带同轴电缆(细缆)</td>
<td style="text-align:center">非屏蔽双绞线</td>
<td style="text-align:center">光纤对(850nm)</td>
</tr>
<tr>
<td style="text-align:center">编码</td>
<td style="text-align:center"><a href="###编码与调制">曼彻斯特编码</a></td>
<td style="text-align:center"><a href="###编码与调制">曼彻斯特编码</a></td>
<td style="text-align:center"><a href="###编码与调制">曼彻斯特编码</a></td>
<td style="text-align:center"><a href="###编码与调制">曼彻斯特编码</a></td>
</tr>
<tr>
<td style="text-align:center">拓扑结构</td>
<td style="text-align:center">总线型</td>
<td style="text-align:center">总线型</td>
<td style="text-align:center">星型</td>
<td style="text-align:center">点对点</td>
</tr>
<tr>
<td style="text-align:center">最大段长</td>
<td style="text-align:center">500m</td>
<td style="text-align:center">185m</td>
<td style="text-align:center">100m</td>
<td style="text-align:center">2000m</td>
</tr>
<tr>
<td style="text-align:center">最多节点数</td>
<td style="text-align:center">100</td>
<td style="text-align:center">30</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
</div>
<p><code>10</code>是 10Mbit/s 的传输速率 <code>BASE</code>表示使用基带传输 <code>T</code>代表双绞线 <code>FL</code>代表光纤</p>
<blockquote>
<p>🙋‍♂️10BASE-T 非屏蔽双绞线以太网拓扑结构为星型,星型网中心为<code>集线器</code>,但使用集线器的以太网在逻辑上仍然是一个总线型网,属于一个冲突域</p>
<p>上表的内容是常识,题目中不会显示告诉你上述信息</p>
</blockquote>
<h4 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h4><p>计算机与外部局域网的连接是通过主板上的网络接口板[又称网络适配器(Adapter)或者网络接口卡(Network Interface Card,NIC)]来实现的</p>
<p>网卡与局域网之间的通信是通过电缆或双绞线以<code>串行</code>的方式进行的,而网卡和计算机的通信是通过计算机主板上的 I/O 总线以<code>并行</code>的方式进行的,</p>
<p>所以网卡的重要功能就是:<strong>进行数据的串并转换</strong></p>
<p>网卡不仅能实现与局域网传输媒介之间的物理连接和电信号匹配,还涉及到帧的发送与接收,帧的封装与拆封,介质访问控制,数据的编码与解码,及数据缓冲功能</p>
<p>全世界的每块网卡出厂时都有一块唯一的代码,称为<code>介质访问控制(MAC)地址</code>,这个地址控制主机在网络中的数据通信</p>
<p>数据链路层设备(网桥,交换机等)都使用各个网卡的 MAC 地址</p>
<p>所以<strong>网卡工作在数据链路层和物理层</strong></p>
<h3 id="以太网的-MAC-帧"><a href="#以太网的-MAC-帧" class="headerlink" title="以太网的 MAC 帧"></a>以太网的 MAC 帧</h3><p>MAC 地址(物理地址)</p>
<p>MAC 地址长 6 字节,一般为连字符或冒号分隔</p>
<p>12 个十六进制数表示如:</p>
<pre><code class="lang-css">02-60-8c-e4-b1-21
</code></pre>
<p>高 24 位为厂商代码</p>
<p>低 24 位为厂商自行分配的网卡序列号</p>
<h4 id="DIX-Ethernet-V2-MAC-帧"><a href="#DIX-Ethernet-V2-MAC-帧" class="headerlink" title="DIX Ethernet V2 MAC 帧"></a>DIX Ethernet V2 MAC 帧</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/v2MAC-1686307099365-2.svg" alt="v2MAC"></p>
<p>==地址==:通常使用 6 字节(48bit)的数据(MAC 地址)</p>
<p>==类型==:2 字节指出出数据域中携带的数据应交给哪个协议实体处理</p>
<p>==数据==:包含高层的协议消息,数据较小的时候进行填充</p>
<blockquote>
<p>由以上图可知以太网的最小帧长为 64 字节</p>
<p>🤔<strong>这个数据位为什么最小为 64 字节</strong>❓</p>
<p>规定 10Mbit/s 的以太网争用期为 51.2μs,然后考虑到传输过程中的干扰最小帧长为 64B,MAC 头部和尾部占用 18 字节,所以数据位最小长度为 46B,而 1500 是规定的,没有为什么</p>
<p>循环冗余校验码需要校验包括数据部分(最后加上)</p>
</blockquote>
<h4 id="802-3-MAC-帧"><a href="#802-3-MAC-帧" class="headerlink" title="802.3 MAC 帧"></a>802.3 MAC 帧</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/802.svg" alt="802"></p>
<p>802.3 帧格式与 DIX 以太帧的格式不同之处在于,使用了长度域替代了 DIX 中的类型域,指出数据域的长度</p>
<blockquote>
<p>但是在实践中,上述长度/类型两种机制可以并存,由于 IEEE802.3 数据段的最大字节数为 1500</p>
<p>所以长度段的最大值是 1500,因此从 1501→65535 的值可用于类型段标识符</p>
</blockquote>
<h4 id="IEEE802-11-无线局域网-wifi"><a href="#IEEE802-11-无线局域网-wifi" class="headerlink" title="IEEE802.11 无线局域网(wifi)"></a>IEEE802.11 无线局域网(wifi)</h4><p>无线局域网课分为两大类:</p>
<p><code>有固定基础设施的无线局域网</code>和<code>无固定基础设施的移动自组织网络</code></p>
<p><strong>有固定基础设施的无线局域网</strong></p>
<p> 对于固定基础设施的无线局域网,IEEE 指定了无线局域网的 802.11 系列协议标准</p>
<p>包括 802.11a/b/g/n 等.使用 XIN 星型拓扑,其中心称为<code>接入点(Access Point, AP)</code>,在 MAC 层使用 CSMA/CA 协议.使用 802.11 系列协议的局域网又称 Wi-Fi</p>
<p> 802.11 标准规定无线局域网最小构件是<code>基本服务集BSS(Basic Service Set)</code>.一个基本服务集包括一个接入点和若干个移动站.各站在本 BSS 内之间通信,或与本 BSS 外部站的通信,都必须通过本 BSS 的 AP,安装 AP 时没必须为该 AP 分配一个不超过 32 字节的<code>服务集标识符(Service Set IDentifier, SSID)</code>和一个信道.SSID 是指使用该 AP 的无线局域网的名字,一个基本服务集覆盖的地理范围称为一个<code>基本服务区(Basic Service Area,BSA)</code>,无线局域网的基本服务区范围直径一般不超过 100m</p>
<p> 一个基本服务集可以是孤立的,也可以通过 AP 连接到一个<code>分配系统(Distribution System,DS)</code>,然后再连接到另一个基本服务集,就构成了一个<code>拓展服务集(Extended Service Set, ESS)</code>.分配系统的作用就是使拓展服务集对上层表现的就像一个基本服务集一样,ESS 还可以通过一种称为 Portal(门户)的设备为无线用户提供到有线连接的以太网的接入,门户的作用相当于一个网桥</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/ESS-1686449906009-2.svg" alt="ESS"></p>
<p>上图中 AP1 中的移动站如需要跟 AP2 中的移动站进行通信,就必须经过 AP1 和 AP2,即 A→AP~1~→AP~2~→B.</p>
<p>若移动站 A 从某个基本服务集<code>漫游</code>到另一个基本服务集时,仍可以和 B 进行通信,但 A 在不同服务集中使用的 AP 改变了</p>
<p><strong>无固定基础设施移动自组织网络</strong></p>
<p>又称自组网络(ad hoc network).自组网络没有上述基本服务集中的 AP,而是由一些平等状态的移动站相互通信组成的临时网络,各节点直接地位平等,中间节点都为转发节点,因此都具有路由器的功能</p>
<p><strong>802.11 MAC 帧</strong></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/802.11.svg" alt="802.11"></p>
<p>802.11 帧最重要的是 4 个地址字段,上述地址都是 MAC 硬件地址,这里仅讨论前三个地址字段(第四个地址字段用于自组网络).这三个地址字段的内容取决于帧控制字段中的<code>去往AP</code>和<code>来自AP</code>这两个字段的数值</p>
<p>地址 1 是接收地址,地址 2 是发送地址,下表给出了 802.11 帧地址字段的最常用的两种情况</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>去往 AP</th>
<th>来自 AP</th>
<th>地址 1</th>
<th>地址 2</th>
<th>地址 3</th>
<th>地址 4</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>接收地址=目的地址</td>
<td>发送地址=AP 地址</td>
<td>源地址</td>
<td>——</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>接收地址=AP 地址</td>
<td>发送地址=源地址</td>
<td>目的地址</td>
<td>——</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>🙋‍♂️ 接收地址和目的地址并不等同</p>
<p>发送地址和源地址并不等同</p>
</blockquote>
<h4 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h4><p>通过虚拟局域网(Virtual LAN),可以把一些较大的局域网分割成一些较小的与地理位置无关的的逻辑上的 VLAN,而每个 VLAN 是一个较小的广播域</p>
<p>802.ac 标准定义支持 VLAN 的以太网帧格式的拓展.它在以太网帧中插入了一个 4 字节的标识符,称为 VLAN 标签,用来指明发送该帧的计算机属于哪个虚拟局域网.</p>
<p>插入 VLAN 标签的帧被称为<code>802.1Q帧</code></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/802.1Q.svg" alt="802.1Q"></p>
<p>VLAN 标签的前两个字节置为 0x8100,表示这是一个 802.1Q 帧,在后两个字节中前 4 位无用,后 12 位标识了这个帧属于哪个 VLAN</p>
<h3 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h3><p>速率达到或者超过 100Mb/s 的以太网被称为高速以太网</p>
<p><strong>100BASE-T 以太网</strong></p>
<p> <em>100BASE-T</em>以太网是在双绞线上传输 100Mb/s 基带信号的星型拓扑结构以太网,它使用<a href="#####==CSMA/CD协议==">CSMA/CD</a>协议.</p>
<p>这种以太网既支持全双工,又支持半双工方式,可在全双工方式下工作无冲突发生.因此,在全双工方式下不使用<a href="#####==CSMA/CD协议==">CSMA/CD</a>协议</p>
<p> MAC 帧格式仍然是 802.3 标准规定的.保持最短帧长不变,但将一个网段的最大线缆长度减小到 100m.</p>
<p>帧的时间间隔从原来的 9.6μs 改为现在的 0.96μs.</p>
<p><strong>吉比特以太网</strong></p>
<p> 又称千兆以太网,允许在 1Gb/s 的速率下使用全双工和半双工两种方式工作.使用 802.3 协议规定的帧格式</p>
<p><strong>10 吉比特以太网</strong></p>
<p> 不再使用铜线而只使用光纤作为传输媒体,,10 吉比特以太网只工作在全双工方式,因此没有争用问题,不适用<a href="#####==CSMA/CD协议==">CSMA/CD</a>协议</p>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p>WAN,又称外网/公网</p>
<p>广域网和局域网的区别和联系如下表所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>广域网</th>
<th>局域网</th>
</tr>
</thead>
<tbody>
<tr>
<td>范围</td>
<td>广、跨区域</td>
<td>较小,在一个区域内</td>
</tr>
<tr>
<td>连接方式</td>
<td>结点之间点到点连接,一个结点与多个结点交换机相连</td>
<td>多点接入</td>
</tr>
<tr>
<td>OSI 参考模型层</td>
<td>网络层,数据链路层,物理层</td>
<td>数据链路层,物理层</td>
</tr>
<tr>
<td>联系与相似点</td>
<td>1.广域网和局域网都是互联网的重要构成,从互联网的角度上来看,二者平等<br>2.连接到一个局域网或一个广域网上的主机在该网内进行通时,只需要使用其网络的物理地址</td>
<td></td>
</tr>
<tr>
<td>着重点</td>
<td>强调资源共享</td>
<td>强调数据传输</td>
</tr>
</tbody>
</table>
</div>
<h3 id="广域网数据链路层协议"><a href="#广域网数据链路层协议" class="headerlink" title="广域网数据链路层协议"></a>广域网数据链路层协议</h3><h4 id="PPP-协议"><a href="#PPP-协议" class="headerlink" title="PPP 协议"></a>PPP 协议</h4><p>PPP(Point-To-Point Protocol)是使用串行线路通信的面向字节的协议,该协议应用在直接连接两个结点的链路上.设计的目的主要是用来通过拨号或者专线方式建立点对点连接发送数据</p>
<p>PPP 协议有三个组成部分:</p>
<ol>
<li>链路控制协议(LCP)。一种拓展链路控制协议,用于建立、测试和管理数据链路</li>
<li>网络控制协议(NCP)。PPP 协议允许同时采用多种网络层协议,每个不同的网络层协议要用一个相应的 NCP 来配置,为网络层协议建立和配置逻辑连接</li>
<li><p>一个将 IP 数据报封装到串行链路的方法,IP 数据报在 PPP 帧中就是其信息部分,这个信息部分的长度受最大传送单元(MTU)的限制</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/ppp.svg" alt="ppp"></p>
</li>
</ol>
<blockquote>
<ol>
<li><p>PPP 提供差错检测但不提供纠错功能,只保证无差错接收(通过硬件进行 CRC 校验)</p>
</li>
<li><p>它仅支持点对点的链路通信,不支持多点线路</p>
</li>
<li><p>PPP 只支持全双工链路</p>
</li>
<li><p>PPP 的两端可以运行不用的网络层协议,但仍然可以使用同一个 PPP 进行通信</p>
</li>
<li><p>PPP 是面向字节的,当信息字段出现和标志字段一致的比特组合时,PPP 有两种处理方法:若 PPP 用在异步线路(默认),采用<a href="#####字符填充法">字符填充法</a></p>
<p>若 PPP 用在 SONET/SDH 等同步线路,则协议规定采用硬件来完成比特填充</p>
</li>
</ol>
<p>==TCP/IP 协议族==</p>
<p>SLIP PPP IP ICMP ARP TCP UDP FTP DNS SMTP</p>
</blockquote>
<h2 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h2><h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p>工作在链路层的 MAC 子层</p>
<p>可以使以太网各个网段成为隔离的碰撞域(一个广播域)</p>
<p>一个网段的故障不会影响另一网段的运行</p>
<h3 id="局域网交换机"><a href="#局域网交换机" class="headerlink" title="局域网交换机"></a>局域网交换机</h3><p>又称以太网交换机,其实质是一个多端口的网桥</p>
<p>交换机的每个端口结点所占用的带宽并不会因为端口结点数目的增加而减少</p>
<p>整个交换机的总带宽会随着端口结点的增加而增加</p>
<p>利用交换机可以实现虚拟局域网(VLAN)</p>
<p>不仅可以隔离冲突域也可以隔离广播域</p>
<p><strong>以太网交换机的特点</strong></p>
<p>✅ 以太网交换机的每个端口,都直接与单台主机相连,并且一般都工作在全双工方式</p>
<p>✅ 以太网交换机能同时连接多对端口,使每对相互通信的主机都能像独占通信媒体那样无碰撞地传输数据</p>
<p>✅ 以太网交换机是一种即插即用设备,其内部的帧的转发表是通过自学习算法自动建立起来的</p>
<p>✅ 以太网交换机由于使用专用的交换结构芯片,交换效率较高</p>
<p>✅ 以太网交换机独占传输媒体带宽</p>
<p><strong>以太网交换机的交换模式</strong></p>
<ul>
<li>直通式交换机,只检查帧的目的地址,这使帧在接收后几乎能被马上转发出去.这种方式速度快,但缺乏智能性和安全性,也不支持具有不同速率的端口的交换</li>
<li>存储转发式交换机,先将收到的帧缓存到高速缓冲器中,并检查数据是否正确,确认无误后通过查找转发表转换为成输出端口将该帧转发.如果帧有错,那么将其丢弃.优点是可靠性高,能支持不同速率端口间的转换,缺点是延迟较大</li>
</ul>
<p><strong>交换机的自学习功能</strong></p>
<p>交换表一开始是空的</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/自学.svg" alt="自学"></p>
<p>具体的流程如下</p>
<pre><code class="lang-mermaid">sequenceDiagram
    participant 交换机
    participant A
    participant B

    Note over 交换机: 初始状态：交换表为空

    A-&gt;&gt;交换机: 发送帧（源MAC地址：A，目标MAC地址：B）
    Note over 交换机: 接收到帧

    交换机-&gt;&gt;交换机: 学习源MAC地址（MAC地址：A，接收端口：端口1）
    交换机--&gt;&gt;A: 发送帧（源MAC地址：A，目标MAC地址：B）
    Note over 交换机: 广播，因为未知目标

    B-&gt;&gt;交换机: 发送帧（源MAC地址：B，目标MAC地址：A）
    Note over 交换机: 接收到帧

    交换机-&gt;&gt;交换机: 学习源MAC地址（MAC地址：B，接收端口：端口2）
    交换机--&gt;&gt;A: 发送帧（源MAC地址：B，目标MAC地址：A）
    Note over 交换机: 知道目标在端口1，转发到端口1
</code></pre>
<p>交换两帧后的交换表:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/自学2.svg" alt="自学2"></p>
<p>过滤指决定一个帧应该转发到某个接口还是应当丢弃。<br>转发是决定一个帧应该被导向哪个接口。<br>交换机的转发和过滤功能是借助交换机表实现的。交换机表的表项包括：一个 MAC 地址，通向该 MAC 地址的交换机接口以及表项放置在表中的时间。<br>假设一个目的地址为 DD-DD-DD-DD-DD-DD 的帧从交换机接口 x 到达，交换机用 MAC 地址 DD-DD-DD-DD-DD-DD 索引它的表，有三种可能情况 1.表中没有 DD-DD-DD-DD-DD-DD，此时，交换机向除 x 外的所有接口广播该帧 2.表中有 DD-DD-DD-DD-DD-DD，但该表项对应的接口为 x。此时，交换机丢弃该帧 3.表中有 DD-DD-DD-DD-DD-DD，且该表项对应的接口为 y！=x。此时，交换机向接口 y 转发该帧。<br>交换机的自学习</p>
<p>交换机表初始为空。对于每个接口接收到的每个入帧，该交换机在其表中存储。如果一段时间后没有接收到以该地址为源地址的帧，则会删除该地址。</p>
<p><strong>交换机和路由器的比较</strong></p>
<p>1.交换机使用 MAC 地址转发分组，而路由器使用 IP 地址。 2.交换机即插即用，而路由器需要配置 3.交换机对于分组的转发和过滤效率更高。因为交换机只处理至协议栈的第二层，而路由器处理至第三层。 4.为了防止广播帧的循环，交换机的拓扑结构被限制为一颗生成树，而网络寻址是分层次的，且 IP 有特殊字段来限制寿命，因此路由器的拓扑结构没有限制。</p>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p><strong>关于物理层、数据链路层、网络层设备对于隔离冲突域和广播域的总结</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">设备名称</th>
<th style="text-align:center">能否隔离冲突域</th>
<th style="text-align:center">能否隔离广播域</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">集线器</td>
<td style="text-align:center">不能</td>
<td style="text-align:center">不能</td>
</tr>
<tr>
<td style="text-align:center">中继器</td>
<td style="text-align:center">不能</td>
<td style="text-align:center">不能</td>
</tr>
<tr>
<td style="text-align:center">交换机</td>
<td style="text-align:center">能</td>
<td style="text-align:center">不能</td>
</tr>
<tr>
<td style="text-align:center">网桥</td>
<td style="text-align:center">能</td>
<td style="text-align:center">不能</td>
</tr>
<tr>
<td style="text-align:center">路由器</td>
<td style="text-align:center">能</td>
<td style="text-align:center">能</td>
</tr>
</tbody>
</table>
</div>
<h1 id="网络层-1"><a href="#网络层-1" class="headerlink" title="==网络层=="></a>==网络层==</h1><h2 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a>网络层的功能</h2><p> 向上只提供简单灵活,无连接的,尽最大努力交付的数据报服务(还提供可靠的面向连接的虚电路服务)</p>
<h2 id="异构网络互联"><a href="#异构网络互联" class="headerlink" title="异构网络互联"></a>异构网络互联</h2><p>将两个以上的计算机网络通过一定的方法,用一些中间设备(又称中继系统)相互连接起来</p>
<p>根据所在的层次,中继系统分为以下 4 种</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/中继系统.svg" alt="中继系统"></p>
<blockquote>
<p>🙋‍♂️ 网络的异构性是指传输介质、数据编码、链路控制协议及不同的数据单元格式和转发机制</p>
</blockquote>
<h2 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h2><p>路由器主要完成两个功能:一个是路由选择(确定哪一条路径),二是分组转发(当一个分组到达时所采取的动作)</p>
<p><strong>路由选择</strong></p>
<p>按照复杂的分布式算法,根据从各组相邻路由器所得到的关于整个网络拓扑的变化情况,动态地改变所选择的路由</p>
<p><strong>分组转发</strong></p>
<p>指路由器根据转发表将用户的 IP 数据报从合适的端口转发出去</p>
<p>路由表是根据路由选择算法得出的,而转发表是从路由表得出的.转发表结构应当使查找过程最优化,路由表则需要对网络拓扑变化的计算最优化</p>
<p>讨论路由选择原理时往往不去区分转发表和路由表,而是笼统的使用路由表一词</p>
<h2 id="SDN-软件定义网络"><a href="#SDN-软件定义网络" class="headerlink" title="SDN(软件定义网络)"></a>SDN(软件定义网络)</h2><p>在传统的互联网中,每个路由器既有转发表,又有数据选择软件</p>
<p>即一个路由器又有数据层面,又有控制层面</p>
<p>在 SDN 网络中</p>
<p>路由器之间不再交换信息,网络层面有一个逻辑上的远程控制器</p>
<p>优点:</p>
<ol>
<li>控制与转发功能分离</li>
<li>控制层面集中化</li>
<li>接口开放可编程</li>
</ol>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>判断网络是否进入拥塞控制的方法是:<code>观察网络的吞吐量与网络负载关系</code></p>
<p>若随着网络负载的 ↑ 吞吐量明显小于正常吞吐量</p>
<p>那么可以判断网络出现了轻度拥塞</p>
<p>若随着网络负载 ↑ 吞吐量 ↓ 则网络出现拥塞</p>
<p>若随着网络负载 ↑ 吞吐量=0 则网络出现死锁</p>
<h2 id="路由算法"><a href="#路由算法" class="headerlink" title="==路由算法=="></a>==路由算法==</h2><blockquote>
<p>路由是指分组从源到目的地时,决定端到端路径的网络范围的进程</p>
</blockquote>
<p><strong>名词介绍:<code>自治系统</code></strong></p>
<p>自治系统 <code>AS</code> (Autonomous System) ：</p>
<p>自治系统就是几个路由器组成了一个小团体 👨‍👩‍👧‍👧，小团体内部使用专用的协议进行通信，而小团体和小团体之间也使用专用的协议进行通信。</p>
<p>就像这个一样 👇</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<blockquote>
<p>🙋‍♂️ 值得一提的是，尽管一个 AS 内部使用了路由选择协议，但是一个 AS 对其他 AS 还是相当于两个普通的路由器在通信。</p>
</blockquote>
<h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>非适应性路由算法</p>
<p>由管理员手动配置路由信息</p>
<p>适用于拓扑变化不大的小网络</p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>自适应路由算法</p>
<h4 id="距离-向量路由协议"><a href="#距离-向量路由协议" class="headerlink" title="距离-向量路由协议"></a>距离-向量路由协议</h4><p>每个结点定期将整个路由选择表传送给与之相应的结点</p>
<p>每个路由选择表包含</p>
<ol>
<li>每条路径的目的地(另一个结点)</li>
<li>路径的代价(距离)</li>
</ol>
<blockquote>
<p>🙋‍♂️ 这里的距离是一个抽象的概念,如<code>路由信息协议(Routing Information Protocol, RIP)</code>就将距离定义为”跳数”,跳数是指从源端口到达目的端口所经过的路由器的个数,每经过一个路由器,跳数+1</p>
</blockquote>
<h5 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h5><p>路由信息协议(Routing Information Protocol, RIP)是<code>应用层协议</code>,它使用==UDP==传输数据(端口 520)</p>
<p>关于距离的定义：</p>
<ul>
<li><p>从一个路由器到直接连接的网络的距离定义为 1。</p>
</li>
<li><p>从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。</p>
</li>
<li><p>“距离” 也称为 “跳数”(hop count)，因为每经过一个路由器，跳数就加 1。</p>
</li>
<li><p>这里的“距离”实际上指的是“最短距离”。</p>
</li>
</ul>
<p><strong>RIP 规定</strong>:</p>
<p>🔢 一条路径最多只能包含 <code>15</code>个路由器。</p>
<p>⏲ 默认为任意两个使用 RIP 的路由器每<code>30s</code>广播一次 RIP 路由更新信息,如果<code>180s</code>没有收到相邻路由器的更新那么将其距离设置为 16(不可达)</p>
<p>⭐RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”。但这这意味着 RIP 只会选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。</p>
<p>📢 在 RIP 中不支持子网掩码的 RIP 广播,所以 RIP 中每个网络的子网掩码必须相同,但在新的 RIP2 中,支持变长子网掩码和 CIDR</p>
<p><strong>RIP 协议的三个特点</strong></p>
<p>1️⃣ 仅和相邻路由器交换信息。<br>2️⃣ 交换的信息是当前本路由器所知道的全部信息，即自己的路由表。<br>3️⃣ 按固定的时间间隔交换路由信息，例如，每隔 30 秒。</p>
<p><strong>RIP 路由表更新</strong></p>
<p>假定网络中的路由器 B 的路由表有如下的项目（这三列分别表示“目的网络”、“距离”和“下一跳路由器”）：</p>
<p><strong>B 的路由表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">目的网络</th>
<th style="text-align:center">距离</th>
<th style="text-align:center">下一跳路由器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">N1</td>
<td style="text-align:center">7</td>
<td style="text-align:center">A</td>
</tr>
<tr>
<td style="text-align:center">N2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">N6</td>
<td style="text-align:center">8</td>
<td style="text-align:center">F</td>
</tr>
<tr>
<td style="text-align:center">N8</td>
<td style="text-align:center">4</td>
<td style="text-align:center">E</td>
</tr>
<tr>
<td style="text-align:center">N9</td>
<td style="text-align:center">4</td>
<td style="text-align:center">F</td>
</tr>
</tbody>
</table>
</div>
<p>现在 B 收到从 C 发来的路由信息（这两列分别表示“目的网络”“距离”）：</p>
<p><strong>B 收到 C 发来的路由信息</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>目的网络</th>
<th>距离</th>
</tr>
</thead>
<tbody>
<tr>
<td>N2</td>
<td>4</td>
</tr>
<tr>
<td>N3</td>
<td>8</td>
</tr>
<tr>
<td>N6</td>
<td>4</td>
</tr>
<tr>
<td>N8</td>
<td>3</td>
</tr>
<tr>
<td>N9</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<p><strong>B 将收到的信息进行整理可得</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">目的网络</th>
<th style="text-align:center">距离</th>
<th style="text-align:center">下一跳路由器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">N2</td>
<td style="text-align:center">4+1 = 5</td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">N3</td>
<td style="text-align:center">8+1 =9</td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">N6</td>
<td style="text-align:center">4+1 = 5</td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">N8</td>
<td style="text-align:center">3+1 =4</td>
<td style="text-align:center">C</td>
</tr>
<tr>
<td style="text-align:center">N9</td>
<td style="text-align:center">5+1 =6</td>
<td style="text-align:center">C</td>
</tr>
</tbody>
</table>
</div>
<p>因为 B 距离 C 有一跳所以在 C 发来的路由信息中需要加一跳</p>
<p><strong>B 将整理后的路由表与原表进行对比,选出到目的网络最短的距离后,得出最终表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">目的网络</th>
<th style="text-align:center">距离</th>
<th style="text-align:center">下一跳路由器</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">N1</td>
<td style="text-align:center">7</td>
<td style="text-align:center">A</td>
<td style="text-align:center">无新信息，不改变</td>
</tr>
<tr>
<td style="text-align:center">N2</td>
<td style="text-align:center">5</td>
<td style="text-align:center">C</td>
<td style="text-align:center">相同的下一跳，更新</td>
</tr>
<tr>
<td style="text-align:center">N3</td>
<td style="text-align:center">9</td>
<td style="text-align:center">C</td>
<td style="text-align:center">新的项目，添加进来</td>
</tr>
<tr>
<td style="text-align:center">N6</td>
<td style="text-align:center">5</td>
<td style="text-align:center">C</td>
<td style="text-align:center">不同的下一跳，距离更短，更新</td>
</tr>
<tr>
<td style="text-align:center">N8</td>
<td style="text-align:center">4</td>
<td style="text-align:center">E</td>
<td style="text-align:center">不同的下一跳，距离一样，不改变</td>
</tr>
<tr>
<td style="text-align:center">N9</td>
<td style="text-align:center">4</td>
<td style="text-align:center">F</td>
<td style="text-align:center">不同的下一跳，距离更大，不改变</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>相同的下一跳，且更新后的距离不变,不更新</p>
</blockquote>
<p><strong>RIP 缺点</strong></p>
<p>1️⃣ RIP 限制了网络的规模,他能使用的最大距离为 15(16 表示不可达)</p>
<p>2️⃣ 路由器之间交换的是路由器中的完整路由表,因此网络规模越大,开销越大</p>
<p>3️⃣ 网络出现故障时,会出现”慢收敛”现象</p>
<blockquote>
<p>🤔<strong>为什么 RIP 会出现好消息传送得快,坏消息传的慢这种现象</strong>❓</p>
<p>即网络出故障的传播时间往往需要较长的时间(例如数分钟)</p>
<p>当网络出现故障时，要经过较长的时间才能将此信息传送到所有的路由器，即<code>“慢收敛”</code>。</p>
<p><em>“收敛”就是在自治系统中所有的结点都得到正确的路由选择信息的过程。</em></p>
<p><em>“慢收敛”又被称为<code>路由回路</code></em></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/router.png" alt="在这里插入图片描述"></p>
<p>当出现坏消息时，比如网 1 出现了故障：</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/20200512234553365.png" alt="在这里插入图片描述"></p>
<p>这个时候 R1 是知道是无法到达的，则其到网 1 的距离为 16，并且为直接交付。<br>但是 R2 在收到 R1 报文之前，即在 R2 并不知道 R1 出故障时，发送了原来的报文，1 2 R1。<br>于是，R1 收到 R2 更新报文后，误以为可以经过 R2 到网 1，于是更新自己的路由表，1 3 R2，并且将次更新信息发送给 R2.<br>然后 R2 以后又跟新自己的路由表为 1 4 R1, 30s 后，又把这个信息发送给 R1.<br>……………………<br>然后就这样一直循环</p>
<p>一直到知道了距离等于 16 为止，R2 将网 1 标记为不可到达(即距离为 16)。</p>
</blockquote>
<h4 id="链路状态路由协议"><a href="#链路状态路由协议" class="headerlink" title="链路状态路由协议"></a>链路状态路由协议</h4><p>一个结点检查自身所有直通链路状态,并将所得的状态信息发送给网络上所有的结点</p>
<p>每当结点收到链路状态报文,结点就利用状态去更新字节的网络拓扑和状态,一但链路状态发生改变就对网络图利用<code>Dijkstra算法</code>重新计算</p>
<p>特点:</p>
<p>1️⃣ 向自治系统的所有路由器发送信息。使用的是<code>洪泛法</code>即路由器通过所有端口向所有相邻路由器发送信息,每个相邻路由器又将消息发送给其相邻的路由器(不包括刚发送信息的路由器)。</p>
<p>2️⃣ 发送的信息是与路由器相邻的所有路由器的链路状态,但这只是路由器所知道的部分信息。所谓的”链路状态”,是指说明本路由与哪些路由器相邻及该链路的”度量”。对于<code>OSPF算法</code>,链路状态的”度量”主要用来表示费用、距离、时延、带宽</p>
<p>3️⃣ 只有链路状态改变才会向所有路由器发送信息。</p>
<p><strong>典型协议:</strong><code>OSPF</code></p>
<h5 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h5><p>开放最短;路径优先协议(Open Shortest Path First)</p>
<p><strong>OSPF 除了具有链路状态路由算法的特点,还有以下特点</strong>:</p>
<p>4️⃣OSPF 是网络层协议,他不使用 UDP 或者 TCP 而直接用 IP 数据报传送(IP 数据报首部的协议字段为 89)</p>
<p>5️⃣OSPF 对不同的链路可根据 IP 分组的不同服务类型(TOS)而设置成不同的代价。因此,OSPF 对不同类型的业务可计算不同的路由,十分灵活</p>
<p>6️⃣ 如果在同一个目的网络有多条代价相同的路径,那么可以将通信量分配给这几条路径。这称为<code>多路径间的负载均衡</code></p>
<p>7️⃣ 所有在 OSPF 路由器之间交换的分组都有鉴别功能,因而保证了仅在可信赖的路由之间交换链路状态信息</p>
<p>8️⃣ 支持可变长度的子网划分和无分类编制 CIDR</p>
<p>9️⃣ 每个链路状态都带上一个 32 位的序号,序号越大,状态越新</p>
<h4 id="路径向量路由协议"><a href="#路径向量路由协议" class="headerlink" title="路径向量路由协议"></a>路径向量路由协议</h4><h5 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h5><p><strong>边界网关协议(Border Gateway Protocol, BGP) 是不同自治系统的路由器之间交换路由信息的协议。</strong>==BGP 是应用层协议,它是基于 TCP 的==。 默认为当前较新的版本 BGP-4。</p>
<p><strong>BGP 发言人</strong> :</p>
<p>每个 自治系统 ( Autonomous System ) 都要 选择一个路由器 , 当做本 自治系统 的发言人 , 该路由器 称为 “BGP 发言人” ; 该 BGP 发言人 路由器大多数情况 是之前说的 OSPF 协议 主干区域的自治系统边界路由器 ; ( 也有例外 )</p>
<p>BGP 协议 简介 :</p>
<p>① 交换对象 : 与 其它 自治系统 的 BGP 发言人 交换信息 ;</p>
<p>② 交换信息 : 交换 网络可达性 信息 , 到达某个网络 , 所要经过的 自治系统 ;</p>
<p>③ 交换周期 : 发生变化时 才更新 , 并且只 更新有变化的部分 ;</p>
<p><strong>BGP 协议信息交换过程</strong></p>
<p>BGP 交换的 网络可达性信息 , 就是到达某个网络 , 所要经过的 一系列的自治系统 ( Autonomous System ) ;</p>
<p>当 BGP 发言人交换了网络可达性信息后 , 各个 BGP 发言人就可以根据采用的策略 , 从收到的路由信息中 , 找到到达指定 自治系统 ( Autonomous System ) 的 较好的路由 ; ( 注意不是最佳路由 )</p>
<p>交换的信息 本质是一组完整的路径 ;</p>
<p><strong>BGP 协议的特点 :</strong></p>
<p>① 路由表内容 : BGP 协议支持 CIDR 无分类编址 , BGP 路由表项目内容是 : 网络前缀 , 下一跳路由 , 到达目的网络所要经过的自治系统序列 ;</p>
<p>② 更新数据时机 : 在 BGP 刚启动时 , BGP 与 相邻 BGP 发言人 交换<code>整个 BGP 路由表</code> , 之后只需要在发生变化时, <code>更新有变化的部分</code> ; 这样能节省资源开销 ;</p>
<h3 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h3><p> 当网络规模扩大时,路由器的路由表成比例的增大,这不仅会消耗越来越多的路由器缓冲区空间,而且需要用更多的 CPU 时间来扫描路由表,用更多的带宽来交换路由状态信息.因此路由选择必须按照层次的方式进行</p>
<p> 因特网将整个互联网划分为许多较小的自治系统(注意一个自治系统包含很多个局域网),每个自治系统有权自主的决定本系统内应采用何种路由选择协议,如果两个自治系统之间需要通信,那么就需要一种在两个自治系统之间的协议来屏蔽这些差异,因此因特网把路由选择协议分为两大类:<code>内部网关协议</code>和<code>外部网关协议</code></p>
<p>具体示意图如下 👇</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70-1686545505778-11.png" alt="img"></p>
<p>✅<strong>内部网关协议(Interior Gateway Protocol, IGP)</strong></p>
<p>自治系统内部使用的路由选择协议(域内路由选择)</p>
<p>典型协议:<code>RIP</code>、<code>OSPF</code></p>
<p><code>OSPF</code>将一个<code>自治系统(AS)</code>再划分为若干区域(Area),每个路由器只知道如何将分组路由到自己所在区域的目标地址,对其他区域内的结构毫不知情</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70-1686545751064-17.png" alt="img"></p>
<p>✅<strong>外部网关协议(Exterior Gateway Protocol, EGP)</strong></p>
<p>自治系统间使用的路由选择协议(域间路由选择)</p>
<p>典型协议:<code>BGP</code></p>
<p>具体示意图如下 👇</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70-1686545582072-14.png" alt="img"></p>
<blockquote>
<p><strong>分组的直接交付和间接交付</strong></p>
<p>✅<code>直接交付</code>:接收端的 IP 地址与发送方的 IP 地址同属一个子网</p>
<p>✅<code>间接交付</code>:接收端的 IP 地址与发送方的 IP 地址不同属一个子网</p>
</blockquote>
<h2 id="IPv4"><a href="#IPv4" class="headerlink" title="==IPv4=="></a>==IPv4==</h2><p>IPv4 即现在普遍使用的 IP 协议(版本 4).IP 协议定义数据传送的基本单元——IP 分组及其确切的数据结构</p>
<h3 id="IPv4-分组"><a href="#IPv4-分组" class="headerlink" title="IPv4 分组"></a>IPv4 分组</h3><p>一个 IP 分组由首部和数据部分组成,首部前一部分的长度固定,共 20B,是所有 IP 分组所必有的,在首部固定部分的后面是一些可选字段,其长度可变</p>
<p>IP 分组格式如下 👇</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/IP分组.svg" alt="未命名绘图-第 9 页.drawio"></p>
<blockquote>
<p>🤔<strong>报文，数据报，分片，分组，帧的区别</strong>❓</p>
<p><strong>报文（message）</strong>：传输协议交给 ip 的数据称为报文；典型的报文包含一个传输层首部和应用程序数据；</p>
<p><strong>数据报（datagram）</strong>：在报文首部加上 ip 首部形成一个数据报；</p>
<p><strong>分片（fragment）</strong>：如果在选定网络中，数据报的长度太大，ip 就会把数据报分裂成几个分片，每个分片含有它自己的 ip 首部和一段原来数据报的数据；</p>
<p><strong>分组（packet）</strong>:提交给数据链路层进行传送时，一个 ip 分片或者一个很小的无需分片的 ip 数据报成为分组；</p>
<p><strong>帧（frame）</strong>:数据链路层在分组前面加上它自己的首部形成帧，并发送该帧；</p>
</blockquote>
<p>IP 首部的重要字段含义如下:</p>
<ol>
<li>✅ 版本。指 IP 协议的版本,目前广泛使用的版本为 4</li>
<li>✅<strong>首部长度</strong>。占 4 位,可以表示的最大十进制数 15。==以 32 位(4B)为单位==,最大值为 60B(15×4B)</li>
<li>✅<strong>总长度</strong>。占 16 位。指首部和数据之和的长度,==单位为字节==,因此数据报的最大长度为 2^16^-1 = 65535B。以太网帧的最大传送单元(MTU)为 1500B,因此当一个 IP 数据报封装成帧时,数据报总长度(首部＋数据)一定不能超过下层数据链路层的 MTU</li>
<li>✅ 标识。占 16 位。它是一个计数器,每产生一个数据报就+1,并赋值给标识字段。但他不是”序号”(因为 IP 是无连接的服务)。当一个数据报的长度超过网络的 MTU 时,必须分片,此时每个数据报片都复制一次标识号,以便能重装成原来的数据报</li>
<li>标志。占 3 位,但只有低两位有效。标志字段的最低位为 MF,MF=1 表示后面还有分片,MF=0 表示最后一个分片。标志字段中间一位是 DF,只有当 DF=0 时才允许分片</li>
<li>✅<strong>片偏移</strong>。占 13 位。它指出较长的分组在分片后,某片在原分组中的相对位置。片偏移==以 8 个字节为偏移单位==。除最后一个分片外,每个分片长度一定是 8B 的整数倍</li>
<li>✅ 生存时间(TTL)。占 8 位。数据报在网络中可以通过的路由器数的最大值,标识分组在网络中的寿命,以确保分组不会永远在网络中循环。路由器在转发分组前,先把 TTL 减 1。若 TTL 被减为 0,则该分组必须被丢弃</li>
<li>✅ 协议。占 8 位。指出此分组携带的数据使用的何种协议,即分组的数据部分应该上交给哪个协议进行处理,如 TCP、UDP 等。其中值 6 表示 TCP,值 17 表示 UDP</li>
<li>✅ 首部校验和。占 16 位。首部校验和只校验分组的首部,而不校验数据部分。</li>
<li>✅ 源地址字段。占 4B,标识发送方的 IP 地址</li>
<li>✅ 目的地址字段。占 4B,标识接收方的 IP 地址</li>
</ol>
<blockquote>
<p>关于长度的标记需要记住,需要熟悉 IP 数据报首部的各个字段的意义与功能,但不需要记忆 IP 数据报首部,正常情况下如果需要参考首部,题目都会直接给出</p>
</blockquote>
<h3 id="IP-数据报分片"><a href="#IP-数据报分片" class="headerlink" title="IP 数据报分片"></a>IP 数据报分片</h3><pre><code class="lang-css">一个数据报长度为4000B(固定首部长度)。现经过一个网络传送,但这此网络能够传送的数据最大长度为1500B。试问应当划分为几个短一点的数据报片?每个数据片段的数据字段长度、片偏移字段和MF标志应为何值?

分析:
1️⃣使用固定首部:IP数据报首部字节固定部分为20字节
2️⃣源数据报中数据部分占4000-20 = 3980B
3️⃣ 网络能传送的最大有效载荷为(即MTU的数据部分)1500 - 20 = 1480B
4️⃣片偏移字段的长度单位为8B


#应当划分为几个短一点的数据报片?
3980/1480 = 2 余 1020B
所以应该分为3个短一些的片


#每个数据片段的数据字段长度?
1480B 1480B 1020B


#每个数据片段的片偏移字段的值?

第一个 0
第二个 1480/8 = 185
第三个 (1480×2)/8 = 370

#每个数据片段的MF标志的值?
1 1 0
</code></pre>
<p><strong>修改 MTU 的数值后需要注意!!</strong></p>
<pre><code class="lang-css">一个长4000B的IP数据报(固定首部长度)现经过一个网络传送,但这此网络能够传送的数据最大长度为800B。试问应当划分为几个短一点的数据报片?每个数据片段的数据字段长度、片偏移字段和MF标志应为何值

分析:
1️⃣使用固定首部:IP数据报首部字节固定部分为20字节
2️⃣源数据报中数据部分占4000-20 = 3980B
3️⃣ 网络能传送的最大有效载荷为(即MTU的数据部分)800 - 20 = 780B
4️⃣片偏移字段的长度单位为8B,那么其数据部分必须为8的整数倍,由分析3所得的780B则无法满足,应修改为776B(8的整数倍中最接近780B的数)
</code></pre>
<blockquote>
<p>注意:MF=0 并不能确定是独立数据报还是分片得来的,只有当 MF=0 且偏移字段&gt;0 时,才能确定是分片的最后一个分片</p>
</blockquote>
<h3 id="IPv4-与-NAT"><a href="#IPv4-与-NAT" class="headerlink" title="IPv4 与 NAT"></a>IPv4 与 NAT</h3><h4 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h4><p>每台主机所拥有的 32 位比特的全球标识</p>
<p>格式为: 网络号+主机号</p>
<p>IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/IP的分类.svg" alt="IP的分类"></p>
<p><strong>IP 地址中有特殊用途,不用于主机的 IP 地址</strong></p>
<p>✅ 主机号全为 0 表示网络本身</p>
<p>✅ 主机号全为 1 表示本网络的广播地址</p>
<p>✅127.x.x.x 保留为回环自检地址,表示任意主机本身,目的地址为回环自检地址的 IP 报永远不会出现在任何网络上</p>
<p>✅32 位全为 0 表示本网络的本主机(在 IPV4 中表示的是无效的目标地址，但是在服务器端它表示本机上的所有 IPV4 地址)</p>
<p>✅ 全为 1 表示整个 TCP/IP 网络的广播地址,但由于路由器对广播域的隔离 255.255.255 等效于本网络中的广播地址</p>
<h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>网络地址转换(Network Adress Translation)</p>
<p>网络地址转换是指用通过将专用网络转换为公用网络从而隐藏内部管理的 IP 地址。它使整个专用网只需要一个全球 IP 地址就可与因特网连通,由于专用网本地 IP 是可重用的,所以 NAT 大大节省了 IP 地址的消耗,同时,它隐藏了内部网络结构,从而降低了内部网络受到攻击的风险</p>
<p>以下是一些私有 IP 地址网段</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">网段数</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A 类</td>
<td style="text-align:center">1</td>
<td style="text-align:center">10.x.x.x</td>
</tr>
<tr>
<td style="text-align:center">B 类</td>
<td style="text-align:center">16</td>
<td style="text-align:center">172.16.x.x~172.31.x.x</td>
</tr>
<tr>
<td style="text-align:center">C 类</td>
<td style="text-align:center">256</td>
<td style="text-align:center">192.168.x.x~192.255.x.x</td>
</tr>
</tbody>
</table>
</div>
<p><strong>NAT 路由器</strong></p>
<p>使用 NAT 转换表</p>
<p>NAT 转换表中存放着{全球 IP 地址:端口号}到{私有 IP 地址:端口号}的映射</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/NAT.svg" alt="NAT"></p>
<p>通过这种映射可以使多个私有 IP 映射到一个全球 IP</p>
<blockquote>
<p>🙋‍♂️ 普通路由器在转发 IP 数据报时,不改变其源 IP 地址和目的 IP 地址。而 NAT 路由器在转发 IP 数据报时,一定要更换其 IP 地址(转换源 IP 地址或目的 IP 地址)。普通路由器仅工作在网络层,而 NAT 路由器转发数据报时需要查看和转换传输层的端口号</p>
</blockquote>
<h3 id="子网划分与子网掩码、CIDR"><a href="#子网划分与子网掩码、CIDR" class="headerlink" title="子网划分与子网掩码、CIDR"></a>子网划分与子网掩码、CIDR</h3><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>将一个大的网络划分成几个较小的网络，而每一个网络都有其自己的子网地址</p>
<p><strong>划分子网的意义</strong><br>在了解子网划分这个问题，首先要明白划分子网到底有什么意义。大家都知道所谓广播传输，就是向本网段的所有节点都发送同样的数据包，这就势必要占用相当多的网络资源（因为每个广播数据包硬件设备都要对它进行分析），特别是带宽资源。然而最令人讨厌的就是在这些广播传输中对终端真正有用的只是所有广播接收用户中的一个。而且网络规模越大，广播数据包发送所占用的资源越多。<br>明白以上这样一个事实后我们就知道划分子网的一下几方面意义：<br>✅ 减少广播：因为广播数据包只能在同一网段中传输，网络规模小了，网络中用户少了，当然占用的资源也就少了。<br>✅ 节省 IP 地址资源：对本身规模较大（200 个用户以上）的网络，划分子网 后，可用的 IP 地址是减少了，但是如果对于那些很小的企业网络来说，划分子网后，又可节省大量的 IP 地址资源。因为几个小网络可以共用一个大的网络地址范围，而且同样可以取到隔离的作用。有四个机房，每个机房 25 台机器，需要给这些机器配置 IP 地址和子网掩码。如果采用 4 个 C 类地址段，每个机房一个，然后在一一配置，一共浪费了（254-25）*4=916 个 IP 地址。<br>✅ 安全性高：由于不同子网之间是不能直接通信的（但可通过路由器或网关进行），在网络形式不容乐观的今天，网络越小，安全性就相对越高。</p>
<p>✅ 便于维护：一个大的网络要查找故障点是相当困难的，如果把网络规模缩小了，查找的范围也就小了，维护起来也更方便了。</p>
<p><strong>子网划分的基本思路</strong></p>
<p>✅ 子网划分纯属单位内部的事,单位对外仍表现为一个没有划分子网的网络</p>
<p>✅ 从主机号借用若干比特位,作为子网号,当然主机号就减少了相应的比特位。三级 IP 地址的结构如下: IP 地址 = {&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</p>
<p>✅ 凡是从其他网络发送给本单位网络,</p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p> 为了告诉主机或路由器对 A、B、C 类网络进行了划分,使用子网掩码来表示源网络中子网号对主机号的借位</p>
<p> 子网掩码是一个与 IP 地址相对应的、长 32bit 的二进制串,1 对应 IP 地址及子网号,0 对应于主机号计算机只需要将 IP 地址和其对应的子网掩码逐位相<code>与(逻辑AND运算)</code>,就可以得出对应子网的网络地址</p>
<blockquote>
<p>现在的因特网标准规定:所有的网络都必须使用子网掩码。如果一个网络未发生子网,就采用默认子网掩码。</p>
<p>A、B、C 类地址的默认子网掩码为 255.0.0.0、255.255.0.0、255.255.255.0</p>
</blockquote>
<h4 id="无分类编址-CIDR"><a href="#无分类编址-CIDR" class="headerlink" title="无分类编址 CIDR"></a>无分类编址 CIDR</h4><p><strong>无分类域间路由选择 CIDR</strong>是在变长子网掩码的基础上提出的一种消除传统的 A、B、C 类网络划分,并且可以在软件的支持下实现<code>超网</code>构造的一种 IP 地址的划分方法</p>
<p><strong>CIDR 最主要的特点</strong>:<br>✅CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。<br>✅CIDR 使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。<br>✅IP 地址从三层编址（使用子网掩码）又回到了两层编址。<br>✅CIDR 使用“斜线记法” ，它又称为 CIDR 记法，即在 IP 地址后面加上一个斜线“/”，然后写上网络前缀所占的位数（这个数值对应于三层编址中子网掩码中 1 的个数）。<br>✅CIDR 把网络前缀都相同的连续的 IP 地址组成“CIDR 地址块”。</p>
<p><strong>CIDR 结构记法</strong></p>
<pre><code class="lang-css">IP::=&#123;&lt;网络前缀&gt;,&lt;主机号&gt;&#125;
</code></pre>
<p><strong>CIDR 地址块</strong>:</p>
<p>128.14.32.0/20 表示的地址块共有 212 个地址（因为斜线后面的 20 是网络前缀的位数，所以这个地址的主机号是 12 位）。<br>这个地址块的起始地址是 128.14.32.0。<br>在不需要指出地址块的起始地址时，也可将这样的地址块简称为“/20 地址块”。<br>128.14.32.0/20 地址块的最小地址：128.14.32.0<br>128.14.32.0/20 地址块的最大地址：128.14.47.255<br>全 0 和全 1 的主机号地址一般不使用。<br>举个栗子<br>128.14.32.0/20 表示的地址（2^12^ 个地址）</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/1868057-20200116113955907-746362849.png" alt="img"></p>
<p><strong>路由聚合(route aggregation)</strong><br>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。<br><code>路由聚合也称为构成超网(supernetting)</code>。<br>CIDR 地址块划分举例<br>一个大学把 c 类地址分配给各个系</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/1868057-20200116113934556-1532572828.png" alt="img"></p>
<p>这个 ISP （互联网服务提供商）共有 64 个 C 类网络。如果不采用 CIDR 技术，则在与该 ISP 的路由器交换路由信息的每一个路由器的路由表中，就需要有 64 个项目。但采用地址聚合后，只需用路由聚合后的 1 个项目 206.0.64.0/18 就能找到该 ISP。</p>
<p>构成超网<br>前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C 类地址。<br>这些 C 类地址合起来就构成了超网。<br>网络前缀越短，其地址块所包含的地址数就越多。而在三层结构的 IP 地址中，划分子网是使网络前缀变长。</p>
<p><strong>最长前缀匹配(最佳匹配)</strong>:</p>
<p>使用 CIDR 时,查找路由表时应当匹配结果中选择最长网络前缀的路由</p>
<p>原因：网络前缀越长，其地址块就越小，因而路由就越具体(more specific)越准确 。</p>
<blockquote>
<p>得到下一跳路由器的 IP 地址后,并不是直接将该地址填入待发送的数据报,而是将该 IP 地址转换为 MAC 地址(通过 ARP),将此 MAC 地址放到 MAC 帧的首部,,然后根据这个 MAC 地址找到下一条路由器.在不同网络中传送时,MAC 帧的源地址和目的地址要发生变化,但是在网桥转发帧时,不改变帧的源地址,请注意区分</p>
</blockquote>
<h2 id="ARP、DHCP-与-ICMP"><a href="#ARP、DHCP-与-ICMP" class="headerlink" title="ARP、DHCP 与 ICMP"></a>ARP、DHCP 与 ICMP</h2><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>地址解析协议 Address Rsolution Protocol</p>
<p>无论网络层使用何种协议,在链路层传送数据帧时都必须使用 MAC 地址</p>
<p>所以使用 ARP 来完成 IP → MAC 地址的映射</p>
<p>每台主机都有一个 ARP 高速缓存</p>
<p>主机 A 欲向某台主机 B 发送 IP 数据报,先在 ARP 高速缓存中查看有无主机 B 的 IP 地址,如果有,查出其 MAC 地址,将其 MAC 地址写入 MAC 帧的目标地址,如果没有则通过使用目的地址为: FF:FF:FF:FF:FF:FF 的帧来封装并广播 ARP 请求分组,使同一局域网的所有主机都收到此 ARP 请求,主机 B 收到 ARP 请求后向主机 A 发送 ARP 相应分组,分组中包含主机 B 的 IP 和 MAC 地址的映射,主机 A 收到 ARP 响应分组后,将其映射写入 ARP 缓存</p>
<blockquote>
<p>🙋‍♂️ARP 在 TCP/IP 中是网络层协议,在 OS 模型中是链路层协议,但是我的理解是其更应该是属于链路层和网络层协议中间的协议,因为其能看到 IP 地址,又能对 MAC 帧进行操作(修改其目的 MAC 地址)</p>
</blockquote>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>动态主机配置协议(Dynamic Host Conficuration Protocol),常用于给主机动态分配 IP 地址,它提供了即插即用的联网机制,该机制允许以太计算机加入新的网络和获取 IP 地址而不用手工参与.DHCP 是<code>应用层协议</code>,它是基于<code>UDP</code>的</p>
<p>DHCP 工作原理如下:</p>
<p> 使用客户端/服务器模式</p>
<p> 需要 IP 的主机在启动时就向 DHCP 服务器广播发送报文,此时主机成为<code>DHCP客户</code>.本地网络上所有的主机都能接收到该<code>发现报文</code>,但只有<code>DHCP服务器</code>才能回应此报文,DHCP 服务器先在其数据库上查找该计算机的配置,若找到则返回找到的信息,若未找到,则从服务器的<code>IP池</code>中取一个地址分配给该计算机,DHCP 的回答报文称为<code>提供报文</code></p>
<blockquote>
<p>DHCP 允许网络上配置多台 DHCP 服务器,当客户端发出”DHCP 发现”消息时可能会收到多个应答报文,客户端只会挑选其中一个,通常是最先到达的</p>
</blockquote>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>网际控制信息协议(Internet Control Message Protocol)</p>
<p>使用 ICMP 让主机或路由器报告差错和异常情况。ICMP 报文作为 IP 层数据报的数据,加上数据报的首部,组成 IP 数据报发送出去。<code>ICMP是IP层协议</code>。</p>
<p>ICMP 报文的种类有两种,即<code>ICMP差错报文</code>和<code>ICMP询问报文</code></p>
<p><strong>ICMP 差错报告报文</strong>分为 5 种类型</p>
<ol>
<li><strong>终点不可达</strong>:当主机或路由器不能交付数据报时,向源终点发终点不可达</li>
<li><strong>源点抑制</strong>:当路由器或者主机拥塞而丢弃数据报时,就向源点发送源点抑制报文,使源点知道应当把数据报的发送速率放慢</li>
<li><strong>时间超过</strong>:当路由器收到生存时间为(TTL)为零的数据报时,除丢弃该数据报外,还要向源点发送时间超过报文。当终点在预先规定时间内不能收到一个数据报的全部数据报片时,就把已收到的数据报片全丢弃,并向源点发送时间超过报文</li>
<li><strong>参数问题</strong>:当路由或目的主机收到数据报首部中有的字段值不正确时,就丢弃该数据报,并向源点发送参数问题报文</li>
<li><strong>改变路由(重定向)</strong>:路由器把改变路由报文发送给主机,让主机知道下次应将数据报发送给另外的路由器(可通过更好的路径)</li>
</ol>
<p>🚨 不应发送 ICMP 差错报告报文的有以下几种:</p>
<ol>
<li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文</li>
<li>对第一个分片的数据报片的所有后续数据报片不再发送 ICMP 差错报告报文</li>
<li>对有组播地址的数据报都不发送 ICMP 报告报文</li>
<li>对具特殊地址(如 127.0.0.0 或 0.0.0.0)的数据报发送 ICMP 差错报告报文</li>
</ol>
<p><strong>ICMP 询问报文</strong>分 4 种类型:<code>回送请求和回答报文</code>、<code>时间戳请求和回答报文</code>、<code>地址掩码请求和回答报文</code>、<code>路由器询问和通告报文</code> 。最常用的是前两种</p>
<p>ICMP 最常见的应用是<code>分组网间探测PING</code>(用来测试两台主机之间的连通性,使用 ICMP 回送和请求报文)和<code>Traceroute(路由追踪)</code>(这是 UNIX 的命令,Windows 中是 Tracert,可以用来跟踪分组经过的路由,使用了 ICMP 时间时间超过报文)</p>
<blockquote>
<p>🙋‍♂️PING 工作在应用层,它直接使用网络层的 ICMP,而未使用传输层测 TCP 或 UDP。Traceroute 工作在网络层</p>
</blockquote>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p><strong>为了解决 IP 地址耗尽的措施有 3 种</strong>:</p>
<ol>
<li>采用 DIDR</li>
<li>采用 NAT 以节省全球 IP 地址</li>
<li>采用更大空间地址空间的新版本的 IPv6</li>
</ol>
<p>IPv6 地址的主要特点如下:</p>
<ul>
<li>从 32 位增大到 128 位</li>
<li>拓展的地址层次结构</li>
<li>灵活的首部格式</li>
<li>改进的选项</li>
<li>允许协议继续扩充</li>
<li>支持即插即用(即自动配置)</li>
<li>支持资源的预分配</li>
<li>IPv6 只有在包的源节点才能分片,是端到端的,传输路径中的路由器不能分片,所以从一般意义上说,IPv6 不允许分片(不允许类似 IPv4 的路由分片)</li>
<li>IPv4 首部长度必须是 8B 的整数倍,IPv4 是 4B 的整数倍</li>
<li>增大了安全性。身份验证和保密功能是 IPv6 的关键特征</li>
</ul>
<h3 id="IPv6-地址"><a href="#IPv6-地址" class="headerlink" title="IPv6 地址"></a>IPv6 地址</h3><p>IPv6 数据报的目的地址可以是以下三种部分:</p>
<ol>
<li>单播。单播就是传统的点对点通信</li>
<li>多播。多播是一点对多点的通信,分组被交付到一组计算机的每台计算机</li>
<li>任播。这使 IPv6 增加的一种类型。任播的目的站是一组计算机,但数据报在交付时只交付其中一台计算机,通常是距离最近的一台计算机</li>
</ol>
<p><strong>IPv6 地址的缩写</strong></p>
<p>IPv4 地址通常使用点分十进制表示法。如果 IPv6 也用这种表示法,那么地址书写起来将相当长,所以 IPv6 采用了冒号 16 进制表示法,即用每 4 位二进制数用一个 16 进制数表示,并用冒号将每 4 位 16 进制数用冒号分隔</p>
<p>例:point_down:</p>
<pre><code class="lang-css">4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170
</code></pre>
<p>每 16 位二进制我们将其称之为域</p>
<p><strong>当 16 位域的开头有一些 0,可以直接省略,但必须保留 1 个字符</strong></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/ipv6缩写.svg" alt="ipv6缩写"></p>
<p><strong>当有相连的 0 值域时,还可以进一步缩写,这些域可以用双冒号缩写</strong></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/缩写.svg" alt="缩写"></p>
<blockquote>
<p>🚨 双冒号表示法在一个地址中仅能出现一次,选择相邻数最多的 0 值域进行使用</p>
</blockquote>
<p><strong>IPv4 向 IPv6 过渡可以采用的两种方法</strong></p>
<p>1️⃣<em>双协议栈</em></p>
<p>即一台设备上同时装有 IPv4 和 IPv6 的协议栈</p>
<p>如果是路由器不同接口,可能分别配置了 IPv4 和 IPv6 地址,如果是计算机,则同时具有 IPv4 和 IPv6 地址</p>
<p>2️⃣<em>隧道技术</em></p>
<p>将 IPv6 数据报封装到 IPv4 数据报的数据部分,使 IPv6 能在 IPv4 网络中传输</p>
<h2 id="IP-组播"><a href="#IP-组播" class="headerlink" title="IP 组播"></a>IP 组播</h2><h3 id="IP-数据报的三种传输方式"><a href="#IP-数据报的三种传输方式" class="headerlink" title="IP 数据报的三种传输方式"></a>IP 数据报的三种传输方式</h3><p><strong>单播</strong>：单播用于发送数据包到单个目的地，且每 发送一份单播报文都使用一个单播 IP 地址作为目的地址。是一种点对点传输方式。</p>
<p><strong>广播</strong>：广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种点对多点传输方式。</p>
<p><strong>组播（多播）</strong>：当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分 发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点传输方式。</p>
<h4 id="单播和组播的比较"><a href="#单播和组播的比较" class="headerlink" title="单播和组播的比较"></a>单播和组播的比较</h4><p>单播在发送者和每一接收者之间需要单独的数据信道。<br>组播提高了数据传送效率。减少了主干网出现拥塞的可能性。组播组中的主机可以是在同一个物理网络，也可以来自不同的物理网络（如果有组播路由器的支持=&gt;组播路由器：运行组播协议的路由器）。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/af6f6abead684157a3871ca83a5c8b7a_无水印 (2" alt="af6f6abead684157a3871ca83a5c8b7a_无水印">.png)</p>
<h3 id="IP-组播地址"><a href="#IP-组播地址" class="headerlink" title="IP 组播地址"></a>IP 组播地址</h3><p>IP 组播地址让源设备能够将分组发送给一组设备。属于多播组的设备将被分配一个组播组 IP 地址（一群共同需求主机的相同标识）。</p>
<p>组播地址范围为 224.0.0.0 ～ 239.255.255.255（D 类地址），一个 D 类地址表示一个组播组。只能用作分组的目标地址。源地址总是为单播地址。</p>
<p><strong>IP 组播地址的特点</strong>： 1.组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于 UDP。 2.对组播数据报不产生<code>ICMP差错报文</code>。 3.并非所有 D 类地址都可以作为组播地址</p>
<h3 id="IP-组播的分类"><a href="#IP-组播的分类" class="headerlink" title="IP 组播的分类"></a>IP 组播的分类</h3><p>组播可以分为两种:一种只在本局域网上进行<strong>硬件组播</strong>;另一种则在<strong>因特网的范围内进行组播</strong>。在因特网上进行组播的最后阶段，还是要把组播数据报在局域网上用硬件组播交付给组播组的所有成员。</p>
<p>IANA(互联网地址指派机构)拥有的以太网组播地址范围是从 01-00-5E-00-00-00 到 01-00-5E-7F-FF-FF。不难看出,每个 MAC 地址种只有 23 位可以用作组做。这只能和 D 类 IP 地址中的 23 位有一一对应的关系</p>
<p>下面是硬件组播映射关系:point_down:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/组播.svg" alt="组播"></p>
<blockquote>
<p>🤔<strong>以太网组播 IP 地址 224.215.145.230 应该映射到的组播 MAC 地址是</strong>❓</p>
<p>以太网组播地址块的范围是 01-00-5E-00-00-00~01-00-5E-7F-FF-FF，而且在每个地址中，只有后 23 位可用组播。这样，只能和 D 类 P 地址中的后 23 位有–一对应关系。D 类 P 地址可供分配的有 28 位,可见这 28 位中的前 5 位不能用来构成以太网硬件地址。215 的二进制为 11010111,其中，在映射过程中最高位为 0，因此 215.145.230 的二进制为 01010111.10010001.11100110，对应的十六进制数是 57-91-E6。</p>
<p>所以是 01-00-5E-57-91-E6</p>
</blockquote>
<h3 id="IGMP-协议与组播路由选择协议"><a href="#IGMP-协议与组播路由选择协议" class="headerlink" title="IGMP 协议与组播路由选择协议"></a>IGMP 协议与组播路由选择协议</h3><p>ROUND 1：</p>
<p>某主机要加入组播组时，该主机向组播组的组播地址发送一个 IGMP 报文，声明自己要称为该组的成员。<br>本地组播路由器收到 IGMP 报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</p>
<p>ROUND 2：<br>本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。<br>只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的；如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</p>
<p>组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/8e7826dcd85e4dd6a52abfdff4642fb8_无水印.png" alt="8e7826dcd85e4dd6a52abfdff4642fb8_无水印"></p>
<h2 id="移动-IP"><a href="#移动-IP" class="headerlink" title="移动 IP"></a>移动 IP</h2><h3 id="移动-IP-的概念"><a href="#移动-IP-的概念" class="headerlink" title="移动 IP 的概念"></a>移动 IP 的概念</h3><p>移动 IP 技术是移动结点(计算机/服务器等)以<strong>固定的网络 IP 地址</strong>，实现<strong>跨越不同网段的漫游</strong>功能，并保证了基于网络 IP 的网络权限在漫游过程中不发生任何改变。</p>
<p>基于 IPv4 的移动 IP 定义三种功能实体:移动结点、归属代理（也称本地代理）和外埠代理(也称外部代理)。归属代理和外埠代理又统称为移动代理。</p>
<p><strong>移动结点</strong>：具有永久 IP 地址的移动设备。<br><strong>归属代理（本地代理）</strong>：一个移动结点的永久“居所”称为归属网络，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理。<br><strong>永久地址（归属地址/主地址）</strong>：移动站点在归属网络中的原始地址。<br><strong>外部代理（外地代理）</strong>：在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理。<br><strong>转交地址（辅地址）</strong>：可以是外部代理的地址或动态配置的一个地址。</p>
<p>移动 P 技术的基本通信流程如下:</p>
<ol>
<li>移动结点在本地网时，按传统的 TCP/IP 方式进行通信（在本地网中有固有的地址)。</li>
<li>移动结点漫游到一个外地网络时，仍然使用固定的 P 地址进行通信。为了能够收到通信对端发给它的 IP 分组，移动结点需要向本地代理注册当前的位置地址，这个位置地址就是转交地址（它可以是外部代理的地址或动态配置的一个地址)。</li>
<li>本地代理接收来自转交地址的注册后，会构建一条通向转交地址的隧道，将截获的发给移动结点的 P 分组通过隧道送到转交地址处。</li>
<li>在转交地址处解除隧道封装，恢复原始的 IP 分组，最后送到移动结点，这样移动结点在外网就能够收到这些发送给它的 IP 分组。</li>
<li>移动结点在外网通过外网的路由器或外部代理向通信对端发送 IP 数据包。</li>
<li>移动结点来到另一个外网时，只需向本地代理更新注册的转交地址，就可继续通信。</li>
<li>移动结点回到本地网时，移动结点向本地代理注销转交地址，这时移动结点又将使用传统的 TCP/IP 方式进行通信。</li>
</ol>
<blockquote>
<p>🙋‍♂️ 移动 P 为移动主机设置了两个 P 地址，即主地址和辅地址（转交地址)。移动主机在本地网时，使用的是主地址。当移动到另一个网络时，需要获得一个临时的辅地址，但此时主地址仍然不变。从外网移回本地网时，辅地址改变或撤销，而主地址仍然保持不变。</p>
</blockquote>
<h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h2><h3 id="冲突域和广播域"><a href="#冲突域和广播域" class="headerlink" title="冲突域和广播域"></a>冲突域和广播域</h3><h4 id="冲突域"><a href="#冲突域" class="headerlink" title="冲突域"></a>冲突域</h4><p> 冲突域是指连接到同一物理介质上的所有结点的集合,这些结点之间存在介质争用现象,在 OSI 模型中,冲突域被视为第一层的概念,像中继器、集线器等简单无脑复制转发信号的第一层设备所链接的结点都属于一个冲突域,也就是说他们不能划分冲突域</p>
<h4 id="广播域"><a href="#广播域" class="headerlink" title="广播域"></a>广播域</h4><p> 广播域是指接收相同广播消息的结点集合。也就是说在该集合中任何一个节点发送一个广播帧,其他能收到这个帧的结点都被认为是该广播域的一部分。在 OSI 模型中,广播域被视为第二层概念,像第一层(集线器等)、第二层(交换机等)设备所连接的结点都属于同一个广播域</p>
<p> 通常所说的局域网(LAN)特指使用路由器分割的网络,也就是广播域</p>
<h1 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h1><p>传输层对收到的报文进行差错检测(首部数据部分)网络层只检查 IP 数据报的首部,不检验数据部分</p>
<h2 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h2><h3 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h3><p> 端口能让应用层的各种进程将其数据通过通过端口向下交付给传输层,以及让传输层应当将其报文段的数据通过端口交付给应用层相应进程</p>
<p>端口是传输层的服务访问端口(Transport Service Access Point,TSAP)</p>
<p>数据链路层的 SAP 是 MAC 地址</p>
<p>网络层的 SAP 是 IP 地址</p>
<p>传输层的 SAP 是端口</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>应用进程用过端口号进行标识,端口长度为==16bit==,能够表示 65536(2^16^)个不同的端口号。端口号具有本地意义,即端口号只标识本计算机应用层各个进程,在因特网中不同计算机相同端口号是没有联系的。根据端口号范围,可将端口分为两类:</p>
<p>🖥︎ 服务端使用的端口号</p>
<ol>
<li><p>熟知端口号:0~1023(IANA 将其指派给了 TCP/IP 最重要的一些应用程序)</p>
<p>常用的熟知端口号</p>
<p>| 应用程序 | 熟知端口号 |<br>| :———: | :————: |<br>|   FTP    |     21     |<br>|  TELNET  |     23     |<br>|   SMTP   |     25     |<br>|   DNS    |     53     |<br>|   TFTP   |     69     |<br>|   HTTP   |     80     |<br>|   SNMP   |    161     |<br>|  HTTPS   |    443     |</p>
</li>
<li><p>登记端口号:1024~49151(供没有使用熟知端口号的应用使用,必须在 IANA 登记,以防止重复)</p>
</li>
</ol>
<p>💻︎ 客户端使用的端口号</p>
<p>49152~65535</p>
<p>仅在客户进程运行时才动态选择,又称临时端口(短暂端口)</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>在网络中通过 IP 地址来标识区别不同的主机。通过端口号来标识和区分一台主机中不同的应用进程。端口号拼接到 IP 地址即构成<code>套接字Socket</code>。在网络中采用发送方和接受方的套接字来识别端点。套接字,实际上是一个通信端点,即:</p>
<pre><code class="lang-css">套接字Socket = (IP地址:端口号)
</code></pre>
<p>它唯一地标识网络中一台主机和其上的一个应用(进程)</p>
<h2 id="无连接服务和面向连接服务"><a href="#无连接服务和面向连接服务" class="headerlink" title="无连接服务和面向连接服务"></a>无连接服务和面向连接服务</h2><p><a href="####服务的种类">无连接服务和面向连接服务</a></p>
<p>TCP/IP 协议族在 IP 层之上使用了两个传输协议:<code>TCP</code>与<code>UDP</code></p>
<p>TCP 提供面向连接的服务,使用 TCP 的应用有:<code>FTP(文件传输协议)</code>、<code>HTTP(超文本传输协议)</code>、<code>TELNET(远程登录)</code></p>
<p>UDP 提供无连接的服务,使用 UDP 的应用有:<code>TFTP(小文件传输协议)</code>、<code>DNS</code>、<code>SNMP</code>和<code>RTP(实时传输协议)</code></p>
<blockquote>
<p>🤔<strong>IP 数据报与 UDP 数据报的区别</strong>❓</p>
<p>UDP 数据报是封装在 IP 数据报的数据部分进行传输的</p>
<p>🤔<strong>TCP 和网络层虚电路的区别</strong>❓</p>
<p>TCP 报文在传输层抽象的逻辑信道中传输,对路由器不可见;虚电路所经过的交换结点,都必须保存虚电路的状态信息,而网络层采用的虚电路方式则无法提供无连接的服务而传输层采用 TCP 不影响网络层提供无连接的服务</p>
</blockquote>
<h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><p> UDP 仅在 IP 数据报服务之上增加了两个最基本的服务:复用/分用以及差错检测</p>
<p> UDP 常用于传输较少数据的网络应用,如 DNS,SNMP。UDP 也常用于多媒体应用(如 IP 电话、实时视频会议、流媒体等),可靠数据可靠数据传输对其并不重要,但较大的延迟无法容忍</p>
<p>UDP 的优点有以下 5 点:</p>
<ol>
<li><p>UDP 无须建立连接,因此 UDP 不会引入建立连接的时延</p>
</li>
<li><p>无连接状态</p>
</li>
<li><p>分组开销少,为 8B</p>
</li>
<li><p>UDP 没有拥塞控制,因此网络中的拥塞不会影响主机的发送效率</p>
</li>
<li><p>UDP 支持一对一、一对多、多对一的交互通信</p>
</li>
</ol>
<h3 id="UDP-数据报"><a href="#UDP-数据报" class="headerlink" title="UDP 数据报"></a>UDP 数据报</h3><p> UDP 是面向报文的,UDP 对应用层交下的报文添加首部后就交付给网络层,既不合并,也不拆分,接收方 UDP 对网络层上交的 UDP 数据报,去除首部,原封不动交付上层应用进程,”报文”是 UDP 数据报处理的最小单位,<code>UDP的报文长度发送应用进程决定</code>。</p>
<p><strong>以下为 UDP 首部格式</strong>👇</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/UDP首部.svg" alt="UDP首部"></p>
<p>各字段意义如下 👇</p>
<ol>
<li><em>源端口</em>:需要对方回信时使用,不使用就全为 0</li>
<li><em>目的端口</em>:目的端口号。这在终点交付报文中必须使用到</li>
<li><em>长度</em>:UDP 数据报长度(首部+数据),其最小值为 8(仅有首部)</li>
<li><em>校验和</em>:检测 UDP 在传输中是否有错,有错就丢弃。该字段是可选的,当源主机不想计算校验和时,则直接令该字段全为 0</li>
</ol>
<h4 id="UDP-校验"><a href="#UDP-校验" class="headerlink" title="UDP 校验"></a>UDP 校验</h4><p> 在计算校验和时要在 UDP 首部临时添加一个 12B 的”伪首部”,计算完后移除,如果数据部分长度不是偶数位,则需要在数据部分尾部填入一个全零字节(计算后移除,不发送)</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/udp校验.svg" alt="udp校验"></p>
<p>检验和主要是基于反码求和运算:</p>
<blockquote>
<p>反码算数运算：两个数进行二进制反码求和的运算很简单。它的规则是从低位到高位逐列进行计算。0 和 0 相加是 0，0 和 1 相加是 1，1 和 1 相加是 0，但要产生一个进位 1，加到下一列。如果最高位相加后产生进位，则最后得到的结果要加 1。</p>
</blockquote>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/2053630-20200602184154246-457729371.jpg" alt="img"></p>
<p>UDP 校验和的计算方法:</p>
<p>发送方:</p>
<p>1.将校验和字段置零。</p>
<p>2.把所有比特位按 16-bit（2 字节）一组进行划分。</p>
<p>3.把 2 中划分好的组进行向加，如果遇到进位，将进位值加到值的最低位上。举例：（用 16 进制表示）</p>
<p>0xBB5E+0xFCED = 0x1 B84B, 可以看出在这个例子中结果有进位，所以将进位值 1 加到值的最低位上，得到结果是 0xB84C</p>
<p>4.把所有的组相加到一起后，得到的结果是一个 16 位的数，<code>将这个结果取反后则得到了校验码</code>。</p>
<p>接收方:</p>
<ol>
<li>将 4 个 16 比特的数（包含校验和）加起来，一定等于 1111 1111 1111 1111（相当于两个反码相加），<strong>这也是取反码做校验和的原因</strong></li>
<li>如果不等，校验和错误，传输出现问题</li>
</ol>
<h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="==TCP 协议=="></a>==TCP 协议==</h2><p>TCP 是在不可靠的 IP 层之上实现的可靠的数据传输协议,它主要解决传输可靠、有序、无丢失和不重复的问题。</p>
<p><strong>TCP 的主要特点如下</strong>:</p>
<ol>
<li>TCP 是面向连接的传输层协议,TCP 连接时一条逻辑链路</li>
<li>每条 TCP 连接只能有两个端点,每条 TCP 的连接只能是端到端的(进程对进程)</li>
<li><p>TCP 提供全双工通信,允许通信双方的应用程序在任何时候都能发送数据。为此 TCP 连接的两端都设有发送缓存和接受缓存,用来临时存放双方通信的数据</p>
<p>发送缓存用来存放以下数据:</p>
<p>① 发送应用程序出纳送给发送方 TCP 准备发送的数据;</p>
<p>② 发送方已发送但尚未收到确认的数据</p>
<p>接收缓存用来存放以下数据:</p>
<p>① 按序到达但尚未被接受应用程序读取的数据</p>
<p>② 不按序到达的数据</p>
</li>
</ol>
<pre><code class="lang-css">4) TCP是面向字节流的,虽然应用程序和TCP的交互是一次一个数据块(大小不等),但TCP把应用程序交下来的数据仅视为一连串的无结构的字节流
4) TCP提供可靠交付的服务,保证传送的数据无差错,不丢失,不重复且有序
</code></pre>
<h3 id="TCP-报文段"><a href="#TCP-报文段" class="headerlink" title="TCP 报文段"></a>TCP 报文段</h3><p><strong>以下为 TCP 首部格式</strong>👇</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/TCP报文-1686806714799-4.svg" alt="TCP报文"></p>
<p><strong>TCP 首部各字段意义如下</strong>:</p>
<ol>
<li><em>源端口和目的端口</em>:各占 2B。端口是运输层与应用层的服务接口,==运输层的复用和分用的功能都要靠端口实现==</li>
<li><em>序号</em>:占 4B,范围是 0~2^23^-1。因为 TCP 是面向字节流的(即 TCP 的传输时是逐个字节传送的),所以 TCP 连接传送的字节流中的每个字节都按顺序编号。序号字段的值指的是本报文段所发送的数据的第一个字节的序号</li>
<li><em>确认号</em>:占 4B,是期望收到对方下一个报文段的第一个数据字节的序号,若确认号为 N 则表明到序号 N-1 为止的所有数据都已正确收到</li>
<li><em>数据偏移(首部长度)</em>:占 4 位。注意与<a href="####IPv4分组">IP 数据报分片的数据偏移</a>进行区分,这里表示的是首部长度,即 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。数据偏移以==4B 为单位==,而 4 位二进制最多能表示 15,所以 TCP 首部最大长度为 60B</li>
<li><em>保留</em>:占 6 位,保留为今后使用,但目前应置为 0</li>
<li><em>紧急位 URG</em>:当 URG = 1 时表明紧急指针字段有效。他告诉系统此报文中有紧急数据,应当尽快传送</li>
<li><strong><em>确认位 ACK</em></strong>:仅当 ACK = 1 时确认字段有效,ACK = 0 时确认号无效</li>
<li><em>推送位 PUSH</em>:接收方收到 PUSH = 1 的报文时应尽快交付给应用程序,而不用等到整个缓存满了再向上交付</li>
<li><em>复位位 RST</em>:RST = 1 时表明连接出现严重差错(如主机崩溃或其他原因)必须释放连接再重新建立连接</li>
<li><strong><em>同步位 SYN</em></strong>:SYN = 1 时表明这是一个请求连接或者连接接受报文当 SYN = 1 ACK =0 时表明是连接请求;SYN = 1 ACK = 1 表明同意建立连接</li>
<li><em>终止位 FIN</em>:用来释放一个连接,当 FIN = 1 时表示此报文的发送方数据已经发送完毕,并要求释放运输连接</li>
<li><em>窗口</em>:允许对方发送给的数据量</li>
<li><em>校验和</em>:要求将 TCP 报文首部加上一个 12B 的”伪首部”后再进行计算(只需要将 UDP 伪首部中的协议字段从<code>17</code>改为<code>6</code>,其他部分与 UDP 一样)</li>
<li><em>紧急指针</em>:占 2B。紧急指针在 URG = 1 时才有效,它指出在本报文段中紧急数据共有多少字节(紧急指针在报文段数据的最前面)</li>
<li><em>选项</em>:长度可变。TCP 最初之规定了一种选项,即最大报文长度(Maximum Segment Size, MSS)。MSS 是 TCP 报文段中的数据字段的最大长度(仅仅是数据字段)</li>
<li>填充。这是为了使整个首部长度是 4B 的整数倍</li>
</ol>
<h3 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h3><p> TCP 是面向连接的服务,因此每个 TCP 连接都有三个阶段:<code>连接建立</code>、<code>数据传输</code>、<code>连接释放</code></p>
<p> TCP 把连接作为最基本的抽象,每条 TCP 连接有两个端点,TCP 连接的端点不是主机,不是主机的 IP 地址,不是应用进程,也不是传输层的协议端口。TCP 连接的端口即为<a href="####套接字">套接字(Socket)</a>或插口。,每条 TCP 连接唯一地被通信的两个端点(即两个套接字)确定。</p>
<p> TCP 连接的建立采用客户端/服务器模式(C/S 模式)。主动发起连接的应用进程称为客户(Client),而被动等待连接建立的应用进程称为服务器(Server)</p>
<h4 id="TCP-连接的建立"><a href="#TCP-连接的建立" class="headerlink" title="TCP 连接的建立"></a>TCP 连接的建立</h4><p>连接的建立经历以下 3 个步骤,通常称为<code>&quot;三次握手&quot;</code>👇</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/2019110521581684_无水印.jpg" alt="2019110521581684_无水印"></p>
<ol>
<li><p>服务器进程准备好接受外来的连接，这通常是通过调用 socket，bind，listen 这三个函数来完成，我们称之为被动打开（passive open）。然后服务器进程就处于<code>LISTEN</code>状态，等待客户的连接请求，如有，则作出响应。</p>
</li>
<li><p>客户通过调用 connect 发起主动打开（active open），向服务器发出连接请求报文段，请求中的首部的同步位 SYN = 1，同时选择一个初始序号 seq = x。TCP 规定，<code>SYN报文段不能携带数据，但要消耗一个序号</code>。<br>这时，TCP 客户进入<code>SYN-SEND（同步已发送）</code>状态。</p>
</li>
<li><p>服务器收到客户端连接请求后，必须确认（ACK）客户的 SYN 报文段。在确认报文段中，把 SYN 和 ACK 位都置为 1，确认号为<code>ack = x + 1</code>，同时也为自己选择一个初始序号<code>seq = y</code>。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。<br>这时，TCP 服务器进入<code>SYN-RCVD（同步收到）</code>状态。</p>
</li>
<li><p>客户在收到服务器的确认后，还要向服务器进程给出确认。确认报文段的 ACK 置 1，确认号<code>ack = y + 1</code>，而自己的序号<code>seq = x + 1</code>。TCP 规定，这个报文段可以携带数据，也可以不携带数据，如果不携带数据，下一个数据报文段的序号仍是<code>seq = x + 1</code>。<br>这时，TCP 连接已经建立，客户进入<code>ESTABLISHED（已建立连接）</code>状态。</p>
</li>
<li><p>服务器收到客户的确认后，也进入<code>ESTABLISHED</code>状态。</p>
<p>在上述的建立连接的过程中，前后发送了三个报文段，因此 TCP 建立连接<br>的过程也称之为三次握手（three-way handshake）。</p>
</li>
</ol>
<blockquote>
<p>🤔<strong>为什么需要三次握手?而不是 2 次</strong>❓</p>
<p>为什么客户在收到服务器的确认后，还要向服务器发送一次确认呢？这主要是为了防止已失效的连接请求报文段突然又传送到了服务器，因而发生错误。<br>考虑一种情况，客户发出连接请求后，但因连接请求报文丢失而未收到确认。于是客户再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。客户共发送了两个连接请求报文段，其中第一个丢失，第二个到达了服务器。没有“已失效的连接请求报文段”。<br>现假定一种异常情况。即客户发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达服务器。本来这是一个早已失效的报文段，但服务器收到此失效的连接请求后，就误认为是客户又一次发出一次新的连接请求。于是就向客户发出确认报文段，同意建立连接。假定不采用三次握手，那么只要服务器发出确认，新的连接就建立了。<br>由于现在客户端并没有发出建立连接的请求，因此不会理睬服务器的确认，也不会向服务器发送数据。但服务器却以为新的连接已经建立了，并一直等待客户发送数据。服务器的许多资源就这样白浪费了。<br>采用三次握手的办法可以防止上述现象的发生。例如刚才的情况下，客户不会向服务器的确认发出确认，由于服务器收不到确认，就知道客户并没有要求建立连接。</p>
<p>🚨 值得注意的是,服务器在第二次握手的时候就已经预先分配了资源,而客户端分配缓存资源的时间在第三次握手,这就使得服务器易受到<code>SYN洪泛攻击</code></p>
</blockquote>
<h4 id="TCP-连接的释放"><a href="#TCP-连接的释放" class="headerlink" title="TCP 连接的释放"></a>TCP 连接的释放</h4><p>天下没有不散的筵席,TCP 也同样如此。参与 TCP 连接的两个进程中的任意一个都能终止该连接。TCP 连接释放的过程被称为<code>&quot;四次挥手&quot;</code>👇</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/20191105215832763_无水印_无水印.jpg" alt="20191105215832763_无水印_无水印"></p>
<ol>
<li>A 的应用进程先发出释放连接报文段，并停止发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部 FIN 置 1，其序号为 seq = u。这时 A 进入<code>FIN-WAIT-1（终止等待1）</code>状态。</li>
<li>B 收到连接释放报文段后即发出确认确认号为 ack = u + 1，而自己的序号为 seq = v。然后 B 就进入<code>CLOSE-WAIT（关闭等待）</code>状态。TCP 服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍接收。</li>
<li>A 收到来自 B 的确认后，就进入<code>FIN-WAIT-2（终止等待2）</code>状态，等待 B 发出的连接释放报文段。</li>
<li>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放 连接。这时 B 发出的连接释放报文段 FIN = 1，还必须重复上次已发送过的确认号 ack = u + 1。假定 B 的序号为 w（在半关闭期间 B 可能又发送了一些数据）。这时 B 就进入了<code>LAST-ACK（最后确认）</code>状态，等待 A 的确认。</li>
<li>A 收到了的连接释放报文段后，必须对此发出确认。其确认号为 ack = w + 1，而自己的序号为 seq = u + 1。然后进入到<code>TIME-WAIT（时间等待）</code>状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器（TIME-WAIT timer）设置的时间 2MSL 后，A 才进入到 CLOSED 状态。时间 MSL 叫做最长报文段寿命（Maximum Segment Lifetime）。</li>
<li>B 只要收到 A 发出的确认，就进入 CLOSED 状态。我们注意到，B 结束 TCP 连接的时间要比 A 早一些。<br>由于释放 TCP 连接的过程需要发送四个报文段，因此释放连接的过程也称之为<code>四次挥手</code>。</li>
</ol>
<blockquote>
<p>🙋‍♂️<strong>TIME_WAIT 状态</strong><br>上述释放连接的过程中，A 在 TIME-WAIT 状态必须等待 2MSL，才进入 CLOSED 状态，上面也提到，这个 MSL 是报文段的最长寿命。那么 MSL 的真实含义是什么呢？<br>MSL 是任何 IP 数据报能够在网络中存活的最长时间。我们知道这个时间是有限的，因为每个数据报含有一个称为跳限（hop limit）的 8 位字段，它的最大值是 255，即最大为 255 跳。尽管这是一个跳数限制而不是真正的时间限制，我们仍然假设：具有最大跳限的数据报在网络中存在的时间不可能超过 MSL 秒。<br>任何 TCP 实现都必须为 MSL 选择一个值。RFC 1122 的建议值为 2 分钟，对于现在的网络，MSL = 2 分钟可能太长了，故一些实现采用 30 秒的值，这意味着，TIME-WAIT 状态的持续时间在 1 分钟到 4 分钟之间。<br><strong>为什么客户在 TIME-WAIT 状态必须 2MSL 的时间呢？这有两个理由</strong>：</p>
<p>1）<strong>可靠地实现 TCP 全双工连接的终止</strong><br>客户 A 最后一个 ACK 报文段可能丢失，这样服务器 B 处于 LAST-ACK 状态而收不到确认。接下来 B 会超时重传 FIN + ACK 报文段，而 A 就能在 2MSL 时间内收到这个重传的 FIN + ACK 报文段，并再重传一次确认，并重新启动 2MSL 计时器。最后，A 和 B 都正常进入 CLOSED 状态。<br>如果 A 在发送完最后一个 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样 B 就无法按照正常步骤进入 CLOSED 状态。</p>
<p>2）<strong>防止“已失效的连接请求报文段”出现在本连接中</strong><br>客户 A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都会网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
<p><strong>对于应用程序来说，什么情况下会出现大量 TIME_WAIT 的状态</strong>？</p>
<p>TIME_WAIT 的出现是一般是客户主动关闭 TCP 连接而出现的，即出现在客户端机器，服务端机器一般不会出现 TIME_WAIT 状态。</p>
</blockquote>
<h3 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h3><p> TCP 的任务是在 IP 层的不可靠、尽力而为服务的基础上建立一种可靠数据传输服务。TCP 提供的可靠数据传输服务就是要保证接收方进程从缓冲区读出的字节流与发送方发出的字节流是完全一样的。TCP 使用了校验、序号、确认和重传机制来达到这个目的。</p>
<p>其中校验机制与<a href="#####UDP校验">UDP 校验机制</a>一致,只不过将其协议段从 17 改为 6</p>
<p><strong>序号</strong></p>
<p> TCP 首部的序号字段用来保证数据能有序提交给应用层，TCP 把数据看成一个无结构但是有序的字节流，而序号是建立在传送的字节流之上，而不是建立在报文段之上。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</p>
<p><strong>确认</strong></p>
<p> TCP 首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。TCP 默认使用累计确认，即 TCP 只确认数据流中至第一个丢失字节为止的字节。例如，接收方 B 收到了发送方 A 发送的包含字节 0~2 和 6 ~7 的报文段。由于某些原因，B 还没有收到字节 3~5 的报文段，此时 B 仍在等待字节 3(和其后面的字节)，因此，B 到 A 的下一个报文段将确认号字段设置为 3。</p>
<p><strong>重传</strong></p>
<p> 有两种事件会导致 TCP 对报文段进行重传：</p>
<ol>
<li><p><em>超时</em></p>
<p>TCP 每发送一个报文设置一个计时器</p>
<p>当计时器的时间高于加权平均往返时间 RTT~s~(随着 RRT 样本值的变化而变化)还未收到确认,就重传该报文</p>
</li>
<li><p><em>冗余 ACK(冗余确认)</em></p>
<p>TCP 规定当发送方收到对同一个报文段的 3 个冗余 ACK 时,就可以认为跟在这个确认报文段之后的报文段已经丢失</p>
<p>每当比期望序号大的失序报文段到达时，发送一个冗余 ACK，指明下一个期待字节的序号。</p>
<p>发送方已发送 1，2，3，4，5 报文段<br>​ 接收方收到 1，返回给 1 的确认(确认号为 2 的第一个字节)<br>​ 接收方收到 3，仍返回给 1 的确认(确认号为 2 的第一个字节)<br>​ 接收方收到 4，仍返回给 1 的确认(确认号为 2 的第一个字节)<br>​ 接收方收到 5，仍返回给 1 的确认(确认号为 2 的第一个字节)</p>
<p>发送方收到 3 个对于报文段 1 的冗余 ACK——认为 2 报 文段丢失，重传 2 号报文段</p>
</li>
</ol>
<h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><p>基于数据链路层所介绍的<a href="####滑动窗口流量控制">滑动窗口</a></p>
<p><code>传输层</code>和<code>数据链路层</code>的流量控制的区别是:</p>
<pre><code class="lang-css">1) 传输层是定义`端到端之间的流量控制`,数据链路层定义中间`两个相邻结点的流量控制`
1) 传输层的窗口可以动态变化,数据链路层的滑动窗口协议的窗口大小不能动态变化
</code></pre>
<h3 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h3><p><strong>拥塞控制和流量控制的区别</strong></p>
<p>拥塞控制是让网络能够承受现有的网络负荷,是一个全局性的过程,涉及所有主机、路由器</p>
<p>流量控制往往是点到点的通信量的控制,是一个端到端的访问</p>
<h4 id="TCP-的拥塞控制算法"><a href="#TCP-的拥塞控制算法" class="headerlink" title="TCP 的拥塞控制算法"></a>TCP 的拥塞控制算法</h4><p>慢开始、拥塞避免、快重传、快恢复</p>
<p><strong>TCP 协议要求发送方维护两个窗口</strong>:</p>
<ol>
<li><p>接收窗口<code>rwnd</code></p>
<p>接收方根据目前接收缓存大小所许诺的的最新窗口值</p>
</li>
<li><p>拥塞窗口<code>cwnd</code></p>
<p>发送方根据字节估算的网络拥塞程度而设置的窗口值</p>
</li>
</ol>
<p>发送窗口的上限值应取接收窗口 rwnd 和拥塞窗口 cwnd 中较小的一个即:</p>
<pre><code class="lang-css">发送MAX = min[rwnd,cwnd]
</code></pre>
<h5 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h5><p>思想:</p>
<ol>
<li><p>先令 cwnd = 1 (此处这里的 1 代表 1 个 MSS 的长度(最大报文段长度),<code>窗口是以字节为单位的</code>)</p>
</li>
<li><p>每当过一个<a href="###往返时延(RRT Round Trip Time">RRT(往返时延)</a>)cwnd 的值翻倍</p>
<p>一直到一个阈值 → 慢开始门限(ssthresh)</p>
</li>
<li><p>然后进行拥塞避免算法</p>
</li>
</ol>
<h5 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h5><p>思想:</p>
<ol>
<li>每过一个 RRT 就把 cwnd+1</li>
<li>若网络出现拥塞(即未按时收到确认),就把慢开始门限(ssthresh)设置为出现拥塞时的 cwnd 的一半,然后将 cwnd 重新设置为 1,重新执行慢开始算法</li>
</ol>
<p><strong>以下是拥塞避免和慢开始的流程图</strong>👇</p>
<pre><code class="lang-mermaid">graph TD
A(开始) --&gt; B[cwnd = 1]
B --&gt; C&#123;cwnd &lt; ssthresh&#125;
C -- 是 --&gt; D[慢开始: cwnd翻倍]
D --&gt; C
C -- 否 --&gt; E[拥塞避免: cwnd + 1]
E --&gt; F&#123;出现拥塞?&#125;
F -- 是 --&gt; G[ssthresh = cwnd / 2, cwnd = 1]
G --&gt; C
F -- 否 --&gt; E
</code></pre>
<blockquote>
<p>当 cwnd = ssthresh 既可以使用慢开始算法,又可以使用拥塞避免算法(通常使用)</p>
</blockquote>
<h5 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h5><p><strong>快重传(利用了冗余 ACK)</strong></p>
<p> 当收到 3 个对同一个报文段的 ACK 确认,立即重传对方尚未收到的报文段,而不必等待那个报文段设置的重传计时器超时。快重传并非取消重传计时器,而是在某些情况下可更早地重传丢失的报文段</p>
<blockquote>
<p>🤔<strong>TCP 是使用的 GBN 还是 SR 选择重传</strong>❓</p>
<p>TCP 使用累计确认,值看起来像是 GBN 的风格,但是正确收到但失序的报文并不会丢弃,而是缓存起来,TCP 至多一次重传一个报文段(即冗余 ACK 之后的报文段),而 GBN 需要重传错误报文段后的所有报文段,,另外 TCP 提供一个 SACK 选项,即选择确认选项,而使用选择确认选项时,TCP 看起来就和 SR 非常相似。因此,TCP 的差错恢复机制可视为 GBN 和 SR 协议的混合体</p>
</blockquote>
<p><strong>快恢复</strong></p>
<p>当网络拥塞发生时(发送方连续收到三个冗余 ACK 时),进行网络拥塞的处理后(将慢开始门限设置为此时发送方 cwnd 的一半),将 cwnd 设置为慢开始 sstresh 的值,然后执行拥塞避免算法,由于跳过了拥塞窗口 cwnd 从 1 起始的慢开始过程,所以被称为快恢复</p>
<h1 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h1><h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><h3 id="客户-服务器模型"><a href="#客户-服务器模型" class="headerlink" title="客户/服务器模型"></a>客户/服务器模型</h3><p>Client/Server 模型(C/S 模型)中有一个总是打开的主机称为<code>服务器</code>,它服务于许多来自其他称为<code>客户机</code>的主机请求。</p>
<p><strong>最主要的特征</strong>:<em>客户是服务请求方.服务器是服务提供方</em></p>
<p>主要特点还有:</p>
<ol>
<li>网络各计算机地位不平等</li>
<li>客户机之间不直接通信</li>
<li>可拓展性不佳</li>
</ol>
<p><strong>常见应用</strong>:<code>web</code>、<code>文件传输协议(FTP)</code>、<code>远程登录</code>和<code>电子邮件</code></p>
<h3 id="P2P-模型"><a href="#P2P-模型" class="headerlink" title="P2P 模型"></a>P2P 模型</h3><p>P2P 网络是指在互联网中由对等结点组成的覆盖网络(Overlay Network),是一种动态的逻辑网络,它没有固定的客户和服务器划分,<em>任意一对计算机(对等方)直接通信</em>(显著特点)</p>
<p>P2P 缺点:占用较多内存影响整机速度,经常进行 P2P 下载会对硬盘造成较大的损伤</p>
<h2 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统(DNS)"></a>域名系统(DNS)</h2><p>域名系统(Domain Name System, DNS)用来把便于人们记忆具有特定含义的主机名转换为便于机器处理的 IP 地址。</p>
<p>DNS 使用 C/S 模型,其协议运行在<a href="###UDP协议">UDP</a>之上,使用<code>53</code>号端口</p>
<p>概念上可将 DNS 分为三个部分:<code>层次域名空间</code>、<code>域名服务器</code>和<code>解析器</code></p>
<h3 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h3><p>层次域名空间结构如下 👇</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/域名.svg" alt="域名"></p>
<ol>
<li>标号中的英文不区分大小写</li>
<li>标号中除连字符(-)外不能使用其他标点符号</li>
<li>每个标号不能超过 63 个字符,多标号组成的完整域名不超过 255 个字符</li>
<li>级别最低的域名写最左边,级别最高的顶级域名写最右边</li>
</ol>
<p><strong>顶级域名</strong>分为三类<br>(Top Level Domain, TLD)</p>
<ol>
<li><p><em>国家(地名)顶级域名(nTLD)</em>:”.cn”表示中国;”.us”代表美国;”.uk”表示英国</p>
</li>
<li><p><em>通用顶级域名(gTLD)</em>:常见的有”.com”→ 公司;”.net”→ 网络服务机构;”.org”→ 非盈利组织和”.gov”→ 国家或政府部门</p>
</li>
<li><p><em>基础结构域名</em>:这种顶级域名只有一个,即 arpa 用于反向域名解析(又称反向域名)</p>
</li>
</ol>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/域名树状.svg" alt="域名树状"></p>
<h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><p> DNS 将域名地址解析成 IP 地址,其使用了大量的域名服务器并将它们以层次的方式组织,没有一台域名服务器有因特网上所有主机的映射,相反映射分布在所有 DNS 上,采用”分布式”设计的 DNS,是一个在因特网上实现分布式数据库的精彩范例</p>
<p>总共四种类型的域名服务器:</p>
<h4 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a>根域名服务器</h4><p> 所有根域名服务器都知道所有的顶级域名服务器的 IP 地址</p>
<p> 本地域名服务器只要字节无法解析们都要首先求助于根域名服务器,通常它不直接把待查询的域名直接转换为 IP 地址,而是告诉本地域名服务器下一步应当找哪个顶级域名服务器进行查询</p>
<blockquote>
<p>🙋‍♂️ 因特网上有<code>13</code>个域名服务器(其实为 13 个 IP 地址,每个 IP 地址后都是一个冗余服务器的集群),中国没有根域名服务器(IPv4),只有根镜像域名服务器</p>
<p>(我国已有 IPv6 根域名服务器)</p>
</blockquote>
<h4 id="顶级域名服务器"><a href="#顶级域名服务器" class="headerlink" title="顶级域名服务器"></a>顶级域名服务器</h4><p> 这些域名服务器管理在该顶级域名服务器注册的所有二级域名,收到 DNS 请求时,就给出相应的回答(可能是最后的结果,也可能是下一步应当查找的域名服务器的 IP)</p>
<h4 id="授权域名服务器"><a href="#授权域名服务器" class="headerlink" title="授权域名服务器"></a>授权域名服务器</h4><p> 每台主机都必须在授权域名服务器处登记。为了更可靠地工作,一台主机最好至少有两个授权域名服务器。实际上许多域名服务器同时充当本地域名服务器和授权域名服务器</p>
<p> 授权域名服务器总能将其管辖的主机名转换为该主机的 IP 地址</p>
<blockquote>
<p>🤔<strong>到底什么是授权域名服务器</strong>❓</p>
<p>假设你有一家网上商店，网址是www.example.com。为了让人们能够访问你的网站，你需要注册一个域名，并将其映射到你的网站服务器的IP地址上。你选择了一个域名注册公司来注册你的域名，比如GoDaddy。注册完成后，你需要将域名服务器配置为GoDaddy的域名服务器。</p>
<p>此时，GoDaddy 就是你的授权域名服务器。当有人在浏览器中输入www.example.com时，浏览器会向本地域名服务器发送一个查询请求，询问该网址对应的IP地址是什么。本地域名服务器可能不知道答案，因此会向更高级别的域名服务器发送查询请求，该请求最终会到达GoDaddy的域名服务器。</p>
<p>GoDaddy 的域名服务器保存了你的域名信息，包括将www.example.com映射到哪个IP地址上。它会将这个信息返回给本地域名服务器，本地域名服务器再将其返回给浏览器，浏览器就可以通过该IP地址连接到你的网站了。</p>
<p>因此，授权域名服务器的作用是确保每个域名的真实信息只能由授权的机构进行管理和修改，从而防止了恶意攻击和网络欺诈。</p>
</blockquote>
<h4 id="本地域名服务器"><a href="#本地域名服务器" class="headerlink" title="本地域名服务器"></a>本地域名服务器</h4><p> 每个因特网服务提供者(ISP) 或一所大学甚至一所大学中的各个系,都可以拥有一个本地域名服务器,每当一台主机发出 DNS 请求时,这个报文就发送给该主机的本地域名服务器</p>
<h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p><em>正向解析</em>:把域名映射成 IP 地址</p>
<p><em>反向解析</em>:把 IP 地址映射成域名</p>
<p> 客户端要域名解析时,通过本机的 DNS 客户端构造一个 DNS 请求报文,以 UDP 数据报的方式发往本地域名服务器</p>
<p>域名解析由两种方式:<code>递归查询</code>和<code>递归与迭代相结合的查询</code>:</p>
<p><strong>递归查询</strong></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/递归查询.svg" alt="递归查询"></p>
<p>上图中 1-8 表示顺序</p>
<p>(对根域名服务器造成的负载过大,实际中不使用)</p>
<p><strong>递归与迭代相结合的查询(实际使用)</strong></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/迭代查询.svg" alt="迭代查询"></p>
<p>假定某客户机想获知域名为 y.abc.com 主机的 IP 地址，域名解析的过程（共使用 8 个 UDP 报文）如下：<br>① 客户机向其本地域名服务器发出 DNS 请求报文<br>② 本地域名服务器收到请求后，查询本地缓存，若没有该记录，则以 DNS 客户的身份向根域名服务器发出解析请求<br>③ 根域名服务器收到请求后，判断该域名属于.com 域，将对应的顶级域名服务器 dns.com 的 IP 地址返回给本地域名服务器<br>④ 本地域名服务器向顶级域名服务器 dns.com 发出解析请求报文<br>⑤ 顶级域名服务器 dns.com 收到请求后，判断该域名属于 abc.com 域，因此将对应的授权域名服务器 dns.abc.com 的 IP 地址返回给本地域名服务器<br>⑥ 本地域名服务器向授权域名服务器 dns.abc.com 发起解析请求报文<br>⑦ 授权域名服务器 dns.abc.com 收到请求后，将查询结果返回给本地域名服务器<br>⑧ 本地域名服务器将查询结果保存到本地缓存，同时返回给客户机</p>
<p>为了提高 DNS 的查询效率，并减少因特网上的 DNS 查询报文数量，在域名服务器中广泛地使用了高速缓存。当一个 DNS 服务器接收到 DNS 查询结果时，它能将该 DNS 信息缓存在<code>高速缓存</code>中。 这样，当另一个相同的域名查询到达该 DNS 服务器时，该服务器就能够直接提供所要求的 IP 地址，而不需要再去向其他 DNS 服务器询问。 因为主机名和 IP 地址之间的映射不是永久的，所以 DNS 服务器将在一段时间后丢弃高速缓存中的信息。</p>
<blockquote>
<p>🙋‍♂️ 为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器，并处理超过合理时间的项（如每个项目只存放两天）。当权限域名服务器回答一个查询请求时，在响应中指明绑定有效存在的时间值。增加此时间值可减少网络开销，减少此时间值可以提高域名转换的准确性。</p>
</blockquote>
<h2 id="文件传输协议-FTP"><a href="#文件传输协议-FTP" class="headerlink" title="文件传输协议(FTP)"></a>文件传输协议(FTP)</h2><p>FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。它屏蔽了各计算机系统的细节，因而适合于在异构网络中的任意计算机之间传送文件。<br>  FTP 提供以下功能：<br>  ① 提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力<br>  ② 以用户权限管理的方式提供用户对远程 FTP 服务器上的文件管理能力<br>  ③ 以匿名 FTP 的方式提供公用文件共享的能力</p>
<p>FTP 采用==客户/服务器的工作方式，它使用 TCP 可靠的传输服务==。 一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接收新的请求；另外有若干从属进程，负责处理单个请求。其工作步骤如下：<br>  ① 打开熟知==端口 21（控制端口）==，使客户进程能够连接上<br>  ② 等待客户进程发连接请求<br>  ③ 启动从属进程来处理客户进程发来的请求。主进程与从属进程并发执行，从属进程对客户进程的请求处理完毕后即终止<br>  ④ 回到等待状态，继续接收其他客户进程的请求</p>
<p>FTP 服务器必须在整个会话期间保留用户的状态信息。特别是服务器必须把指定的用户账户与控制连接联系起来，服务器必须追踪用户在远程目录树上的当前位置。</p>
<h3 id="控制连接与数据连接"><a href="#控制连接与数据连接" class="headerlink" title="控制连接与数据连接"></a>控制连接与数据连接</h3><h4 id="控制连接"><a href="#控制连接" class="headerlink" title="控制连接"></a>控制连接</h4><p>服务器监听==21 号端口==，等待客户连接，建立在这个端口上的连接称为控制连接，控制连接用来传输控制信息（如连接请求、传送请求等），并且控制信息都以 7 位 ASCII 格式传送。FTP 客户发出的传送请求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。在传输文件时还可以使用控制连接（如客户在传输中途发一个中止传输的命令），==因此控制连接在整个会话期间一直保持打开状态==。</p>
<h4 id="数据连接"><a href="#数据连接" class="headerlink" title="数据连接"></a>数据连接</h4><p>服务器端的控制进程在接收到 FTP 客户发来的文件传输请求后，就创建“数据传送进程”和“数据连接”。数据连接用来连接客户端和服务器端的数据传送进程，数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。<br>   因为 FTP 使用了一个分离的控制连接，所以也称 FTP 的控制信息是带外（Out-of-band）传送的。==使用 FTP 时，若要修改服务器上的文件，则需要先将此文件传送到本地主机，然后再将修改后的文件副本传送到原服务器==。 网络文件系统（NFS）允许进程打开一个远程文件，并在该文件的某个特定位置开始读写数据。这样，NFS 可使用户复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</p>
<p><code>数据连接在每次数据传输完毕后就关闭</code></p>
<p>数据连接有两种传输模式:</p>
<p><strong>主动模式 PORT</strong></p>
<p>登录成功后要读取数据时,客户端随机开放一个端口,并发送命令给服务器,服务器收到 PORT 命令和端口号后,通过 20 号端口和客户端提供的端口连接</p>
<p>即==”服务器固定端口 20 连接到客户端端口”==</p>
<blockquote>
<p>🙋‍♂️ 匿名用户使用<code>anonymous</code>作为用户名</p>
</blockquote>
<p><strong>被动模式 PASV</strong></p>
<p>客户端要读取数据时,发送 PASV 到服务器,服务器随机开放一个端口,并告知客户端,客户端再连接到服务器开放的端口进行数据传输</p>
<h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="电子邮件系统的组成结构"><a href="#电子邮件系统的组成结构" class="headerlink" title="电子邮件系统的组成结构"></a>电子邮件系统的组成结构</h3><p>电子邮件是一种异步通信方式，通信时不需要双方同时在场。电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可以随时上网到自己使用的邮件服务器进行读取。<br>   一个电子邮件系统应具有下图所示的三个最主要的组成构件，即<code>用户代理（User Agent）</code>、<code>邮件服务器</code>和<code>电子邮件使用的协议</code>，如<code>SMTP</code>、<code>POP3（或IMAP）</code>等。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/电子邮件系统.svg" alt="电子邮件系统"></p>
<p><strong>用户代理（UA）</strong>：<code>用户与电子邮件系统的接口</code>。用户代理使用户能够通过一个很友好的接口发送和接收邮件，用户代理至少应当具有撰写、显示和邮件处理的能力。通常情况下，用户代理就是一个运行在 PC 上的程序，常见的有 Outlook、Foxmail 等</p>
<p><strong>邮件服务器</strong>：组成电子邮件系统的核心。邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况（已交付、被拒绝、丢失等）。邮件服务器采用客户/服务器方式工作，但它能够同时充当客户和服务器。例如，当邮件服务器 A 向邮件服务器 B 发送邮件时，A 就作为 SMTP 客户，而 B 是 SMTP 服务器；反之，当 B 向 A 发送邮件时，B 就是 SMTP 客户，而 A 就是 SMTP 服务器。</p>
<p><strong>邮件发送协议和读取协议</strong>：==邮件发送协议用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，通常使用的是 SMTP；邮件读取协议用于用户代理从邮件服务器读取邮件，如 POP3==。 <code>SMTP采用的是“推”（Push）的通信方式</code>，即在用户代理向邮件服务器发送邮件及在邮件服务器之间发送邮件时，SMTP 客户端主动将邮件“推”送到 SMTP 服务器端。而<code>POP3采用的是“拉”（Pull）的通信方式</code>，即用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件。</p>
<h3 id="电子邮件格式与-MIME"><a href="#电子邮件格式与-MIME" class="headerlink" title="电子邮件格式与 MIME"></a>电子邮件格式与 MIME</h3><h4 id="电子邮件格式"><a href="#电子邮件格式" class="headerlink" title="电子邮件格式"></a>电子邮件格式</h4><p>一个电子邮件分为信封和内容两大部分，邮件内容又分为首部和主体两部分。RFC 822 规定了邮件的首部格式，而邮件的主体部分则让用户自由撰写。用户写好首部后，邮件系统自动地将信封所需的信息提取出来并写在信封上，用户不需要亲自填写信封上的信息。<br>   邮件内容的首部包含一些首部行，每个首部行由一个关键字后跟冒号再后跟值组成。有些关键字是必需的，有些则是可选的。最重要的关键字是<code>To:</code>和<code>Subject：</code>。<br>  ==To 是必需的关键字==，后面填入<code>一个</code>或<code>多个</code>收件人的电子邮件地址。电子邮件地址的规定格式为：收件人邮箱名@邮箱所在主机的域名，如abc@test.com，其中收信人邮箱名即用户名，abc 在 test.com 这个邮件服务器上必须是唯一的。这也就保证了abc@test.com这个邮件地址在整个因特网上是唯一的。<br>  Subject 是可选关键字，是邮件的主题，反映了邮件的主要内容<br>   当然，还有一个必填的关键字是 From，但它通常由邮件系统自动填入。首部和主体之间用一个空行进行分割。典型的邮件内容如下：</p>
<pre><code class="lang-css">From:hoopdog@hust.edu.com
To:abc@test.com
Subject:Say hello to Internet

balabalabala...
...
</code></pre>
<h4 id="多用途网际邮件扩充（MIME）"><a href="#多用途网际邮件扩充（MIME）" class="headerlink" title="多用途网际邮件扩充（MIME）"></a>多用途网际邮件扩充（MIME）</h4><p>由于 SMTP 只能传送一定长度的 ASCII 码，许多其他非英语国家的文字就无法传送，且无法传送可执行文件及其他二进制对象，因此提出了多用途网络邮件扩充（Multipurpose Internet Mail Extensions,MIME）<br>  <code>MIME并未改动SMTP或取代它</code>。MIME 的意图是继续使用目前的格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则。也就是说，MIME 邮件可在现有的电子邮件程序和协议下传送。MIME 与 SMTP 的关系如图：</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/mime.svg" alt="mime"></p>
<p>MIME 主要包括以下三部分内容：<br> ①5 个新的邮件首部字段，包括 MIME 版本、内容描述、内容标识、内容传送编码和内容类型<br> ② 定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化<br> ③ 定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变</p>
<h3 id="SMTP-和-POP3"><a href="#SMTP-和-POP3" class="headerlink" title="SMTP 和 POP3"></a>SMTP 和 POP3</h3><h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><p>简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）是一种提供可靠且有效的电子邮件传输的协议，它控制两个相互通信的 SMTP 进程交换信息。由于 SMTP 使用客户/服务器方式，因此负责发送邮件的 SMTP 进程就是 SMTP 客户，而负责接收邮件的 SMTP 进程就是 SMTP 服务器。==SMTP 使用的是 TCP 连接，端口号为 25==。 SMTP 通信有以下三个阶段：<br>  （1）连接建立<br>   发件人的邮件发送到发送方邮件服务器的邮件缓存中后，==SMTP 客户就每隔一定时间对邮件缓存扫描一次==。如发现有邮件，就使用 SMTP 的熟知端口号（25）与接收方邮件服务器的 SMTP 服务器建立 TCP 连接。连接建立后，接收方 SMTP 服务器发出 220 Service ready（服务就绪）。然后 SMTP 客户向 SMTP 服务器发送 HELO 命令，附上发送方的主机名。<br>  ==SMTP 不使用中间邮件服务器。TCP 连接总是在发送方和接收方这两个邮件服务器之间直接建立，而不管它们相隔多远==。接收方的邮件服务器因故障暂时不能建立连接时，发送方的邮件服务器只能等待一段时间后再次尝试连接。<br>  （2）邮件传送<br>   连接建立后，就可开始传送邮件。邮件的传送从 MAIL 命令开始，MAIL 命令后面有发件人的地址。如 MAIL FROM：hoopdog@hust.edu.cn。若 SMTP 服务器已准备好接收邮件，则回答 250 OK。接着 SMTP 客户端发送一个或多个 RCPT（收件人 recipient 的缩写）命令，格式为 RCPT TO：&lt;收件人地址&gt;。每发送一个 RCPT 命令，都应有相应的信息从 SMTP 服务器返回，如 250OK 或 550 No such user here（无此用户）<br>  RCPT 命令的作用是，先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮件，以便不至于发送了很长的邮件后才知道地址错误，进而避免浪费通信资源。<br>   获得 OK 的回答后，客户端就使用 DATA 命令，表示要开始传输邮件的内容。正常情况下，SMTP 服务器回复信息是 354 Start mail input;end with &lt; CRIF &gt;.&lt; CRIF &gt;。&lt; CRIF &gt;表示回车换行。此时 SMTP 客户端就可开始传送邮件内容，并用&lt; CRIF &gt;.&lt; CRIF &gt;（两个回车，中间一个点）表示邮件内容的结束。<br>  （3）连接释放<br>   邮件发送完毕后，SMTP 客户应发送 QUIT 命令。SMTP 服务器返回的信息是 221（服务关闭），表示 SMTP 同意释放 TCP 连接。邮件传送的全部过程就此结束。</p>
<h4 id="POP3-和-IMAP"><a href="#POP3-和-IMAP" class="headerlink" title="POP3 和 IMAP"></a>POP3 和 IMAP</h4><p><code>邮局协议（Post Office Protocol,POP）</code>是一个非常简单但功能有限的邮件读取协议，现在使用的是它的第三个版本 POP3。POP3 采用的是“拉”（Pull）的通信方式，当用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件。<br>  POP 也使用客户/服务器的工作方式，==在传输层使用 TCP，端口号为 110==。接收方的用户代理上必须运行 POP 客户程序，而接收方的邮件服务器上则运行 POP 服务器程序。POP 有两种工作方式：<code>“下载并保留”</code>和<code>“下载并删除”</code>。 在“下载并保留”方式下，用户从邮件服务器上读取邮件后，邮件依然会保存在邮件服务器上，用户可再次从服务器上读取该邮件；而使用“下载并删除”方式时，邮件一旦被读取，就在邮件服务器上被删除，用户不能再次从服务器上读取。<br>   另一个邮件接收协议是<code>因特网报文存取协议（IMAP）</code>，它比 POP 复杂得多，IMAP 为用户提供了创建文件夹、在不同文件夹之间移动邮件及在远程文件夹中查询邮件的命令，为此 IMAP 服务器维护了会话用户的状态信息。IMAP 的另一特性是允许用户代理只获取报文的某些部分，例如可以只读取一个报文的首部，或一个多部分 MIME 报文的一部分。这非常适用于低带宽的情况，用户可能并不想取回邮箱中的所有邮件，尤其是包含很多音频或视频的大邮件。</p>
<p>目前有很多<code>基于万维网的电子邮件</code>，如 Hotmail、Gmail 等。这种电子邮件的特点是，==用户浏览器与 Hotmail 或 Gmail 的邮件服务器之间的邮件发送或接收使用的是 HTTP，而仅在不同邮件服务器之间传送邮件时才使用 SMTP==。</p>
<h2 id="万维网-www"><a href="#万维网-www" class="headerlink" title="万维网(www)"></a>万维网(www)</h2><p>==万维网（World Wide Web，WWW）是一个资料空间,在这个空间中：一样有用的事物称为一种“资源”，并由一个全域“统一资源定位符”（URL）标识。这些资源通过超文本传输协议（HTTP）传送给使用者，而后者通过单击链接来获取资源。==</p>
<p>万维网的内核部分是由三个标准构成的：</p>
<p>（1）<em>统一资源定位符（URL）</em><br>   负责标识万维网上的各种文档，并使每个文档在整个万维网的范围内具有唯一的标识符 URL。<br>（2）<em>超文本传输协议（HTTP）</em><br>   一个应用层协议，它使用 TCP 连接进行可靠的传输， HTTP 是万维网客户程序和服务器程序之间交互所必须严格遵守的协议<br>（3）<em>超文本标记语言（HTML）</em><br>   一种文档结构的标记语言，它使用一些约定的标记对页面上的各种信息（包括文字、声音、图像、视频等）、格式进行描述</p>
<p>URL 是对可以从因特网上得到的资源的位置和访问方法的一种简洁表示。URL 相当于一个文件名在网络范围的扩展。<br>  URL 的一般形式是：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;<br>  &lt;协议&gt;是指用什么协议来获取万维网文档,常见的协议有 http、ftp 等；&lt;主机&gt;是存放资源的主机在因特网中的域名，也可以是 IP 地址；&lt;端口&gt;和&lt;路径&gt;有时可以省略。</p>
<h3 id="超文本传输协议（HTTP）"><a href="#超文本传输协议（HTTP）" class="headerlink" title="超文本传输协议（HTTP）"></a>超文本传输协议（HTTP）</h3><p> <code>HTTP定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器</code>。 从层次的角度看，HTTP 是面向事务的（Transaction-oriented）应用层协议，<code>它规定了在浏览器和服务器之间的请求和响应的格式与规则</code>，是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础</p>
<p>每个万维网站点都有一个服务器进程,他不断监听 TCP 的端口 80(HTTP 端口<code>80</code>,HTTPS 端口<code>443</code>)</p>
<p> HTTP 采用 TCP 作为传输层协议，保证了数据的可靠传输。 HTTP 不必考虑数据在传输过程中被丢弃后又怎样被重传。但是，HTTP 本身是无连接的。 也就是说，虽然 HTTP 使用了 TCP 连接，但通信的双方在交换 HTTP 报文之前不需要先建立 HTTP 连接。</p>
<p>HTTP 既可以使用<code>非持久连接</code>，也可以使用<code>持久连接（HTTP/1.1支持）</code><br>   对于非持久连接，每个网页元素对象（如 JPEG 图形、Flash 等）的传输都需要单独建立一个 TCP 连接。也就是说，请求一个万维网文档所需的时间是该文档的传输时间（与文档大小成正比）加上两倍往返时间 RTT（一个 RTT 用于 TCP 连接，另一个 RTT 用于请求和接收文档）</p>
<blockquote>
<p>🙋‍♂️ 所谓持久连接，是指万维网服务器在发送响应后仍然保持这条连接，使同一个客户和服务器可以继续在这条连接上传送后续的 HTTP 请求与响应报文。</p>
</blockquote>
<p> 持久连接又分为非流水线和流水线两种方式。对于非流水线方式，客户在收到前一个响应后才能发出下一个请求。HTTP/1.1 的默认方式是使用流水线的持久连接。这种情况下，客户每遇到一个对象引用就立即发出一个请求，因而客户可以逐个地连续发出对各个引用对象的请求。如果所有的请求和响应都是连续发送的，那么所有引用的对象共计经历 1 个 RTT 延迟，而不是像非流水线方式那样，每个引用都必须有 1 个 RTT 延迟。</p>
<h4 id="HTTP-的报文结构"><a href="#HTTP-的报文结构" class="headerlink" title="HTTP 的报文结构"></a>HTTP 的报文结构</h4><p>HTTP 是面向文本的（Text-Oriented），因此报文中的每个字段都是一些 ASCII 码串，并且每个字段的长度都是不确定的。有两类 HTTP 报文：</p>
<p> 请求报文(resquest)：从客户向服务器发送的请求报文<br>  响应报文(response)：从服务器到客户的回答</p>
<p>请求和响应报文格式如下 👇</p>
<p><img src="计算机网络基础/http报文.svg" alt="http报文"></p>
<p>总结:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/12.jpg" alt="img"></p>
<p>以下一图总结并回顾<a href="####TCP报文段">报文段</a>、<a href="####IPv4分组">IP 数据报</a>、<a href="#####以太网的MAC帧">MAC 帧</a>的相关知识 👇</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/总结.svg" alt="总结"></p>
<h4 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h4><h5 id="请求报文中几个常用方法"><a href="#请求报文中几个常用方法" class="headerlink" title="请求报文中几个常用方法"></a>请求报文中几个常用方法</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:center">请求读取由 URL 标识的信息</td>
</tr>
<tr>
<td style="text-align:center">HEAD</td>
<td style="text-align:center">请求读取由 URL 标识的信息的首部</td>
</tr>
<tr>
<td style="text-align:center">POST</td>
<td style="text-align:center">给服务器添加信息(如注释)</td>
</tr>
<tr>
<td style="text-align:center">CONNECT</td>
<td style="text-align:center">用于代理服务器</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">请求服务器删除指定数据</td>
</tr>
</tbody>
</table>
</div>
<h5 id="响应报文中的状态码"><a href="#响应报文中的状态码" class="headerlink" title="响应报文中的状态码"></a>响应报文中的状态码</h5><div class="table-container">
<table>
<thead>
<tr>
<th>状态码</th>
<th>名字</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>Continue</td>
<td>继续</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td>切换协议</td>
</tr>
<tr>
<td>102</td>
<td>Processing</td>
<td>处理中</td>
</tr>
<tr>
<td>103</td>
<td>Early Hints</td>
<td>早期提示</td>
</tr>
<tr>
<td>200</td>
<td>OK</td>
<td>请求成功</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>已创建</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>已接受</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>非官方信息</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>无内容</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>重置内容</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>部分内容</td>
</tr>
<tr>
<td>207</td>
<td>Multi-Status</td>
<td>多状态</td>
</tr>
<tr>
<td>208</td>
<td>Already Reported</td>
<td>已报告</td>
</tr>
<tr>
<td>226</td>
<td>IM Used</td>
<td>IM 已使用</td>
</tr>
<tr>
<td>300</td>
<td>Multiple Choices</td>
<td>多种选择</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>永久重定向</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>找到</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>参见其他</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>未修改</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>使用代理</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>临时重定向</td>
</tr>
<tr>
<td>308</td>
<td>Permanent Redirect</td>
<td>永久重定向</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>错误的请求</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>未经授权</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>需要付款</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>禁止访问</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>未找到</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>方法不允许</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>不可接受</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>需要代理身份验证</td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout</td>
<td>请求超时</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>冲突</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>已删除</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>需要 Content-Length 头部</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>前提条件失败</td>
</tr>
<tr>
<td>413</td>
<td>Payload Too Large</td>
<td>请求有效载荷过大</td>
</tr>
<tr>
<td>414</td>
<td>URI Too Long</td>
<td>请求的 URI 过长</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>不支持的媒体类型</td>
</tr>
<tr>
<td>416</td>
<td>Range Not Satisfiable</td>
<td>范围不可满足</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>预期失败</td>
</tr>
<tr>
<td>418</td>
<td>I’m a teapot</td>
<td>我是一个茶壶</td>
</tr>
<tr>
<td>421</td>
<td>Misdirected Request</td>
<td>被错导的请求</td>
</tr>
<tr>
<td>422</td>
<td>Unprocessable Entity</td>
<td>无法处理的实体</td>
</tr>
<tr>
<td>423</td>
<td>Locked</td>
<td>已锁定</td>
</tr>
<tr>
<td>424</td>
<td>Failed Dependency</td>
<td>依赖关系失败</td>
</tr>
<tr>
<td>425</td>
<td>Too Early</td>
<td>过早</td>
</tr>
<tr>
<td>426</td>
<td>Upgrade Required</td>
<td>需要升级</td>
</tr>
<tr>
<td>428</td>
<td>Precondition Required</td>
<td>需要前提条件</td>
</tr>
<tr>
<td>429</td>
<td>Too Many Requests</td>
<td>请求过多</td>
</tr>
<tr>
<td>431</td>
<td>Request Header Fields Too Large</td>
<td>请求头字段过大</td>
</tr>
<tr>
<td>451</td>
<td>Unavailable For Legal Reasons</td>
<td>由于法律原因不可用</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器内部错误</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>未实现</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>错误的网关</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>服务不可用</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout</td>
<td>网关超时</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version Not Supported</td>
<td>不支持的 HTTP 版本</td>
</tr>
<tr>
<td>506</td>
<td>Variant Also Negotiates</td>
<td>变体协商也有问题</td>
</tr>
<tr>
<td>507</td>
<td>Insufficient Storage</td>
<td>存储空间不足</td>
</tr>
<tr>
<td>508</td>
<td>Loop Detected</td>
<td>检测到循环</td>
</tr>
<tr>
<td>510</td>
<td>Not Extended</td>
<td>未扩展</td>
</tr>
<tr>
<td>511</td>
<td>Network Authentication Required</td>
<td>需要网络认证</td>
</tr>
</tbody>
</table>
</div>
<p>HTTP 是无状态的协议,也就是说同一个客户端第二次访问同一个服务器上的页面,服务器的相应与第一次访问相同,因为服务器不记得曾经访问过这个客户,也不记得客户端的访问次数</p>
<p>在实际应用中常使用 🍪<code>cookie/token + 数据库</code>的方式来跟踪用户活动</p>
<p>客户端发送 http 请求,服务器接受 client 请求后建立一个<code>session</code>,并 sent 一个 http respone 到 client,这个 response head 中包含了一个<code>set-cookie头部</code>该头部包含<code>sessionid</code></p>
<p><code>set-cookie</code>格式如下:</p>
<pre><code class="lang-css">set-cookie : value[; Expries : date][;Domain = domain][;Path = path][;Max-Age : value][;Secure ...]
</code></pre>
<p><em>Expries</em>:cookie 最长有效时间(时间戳),没有设置则表示这是一个会话期 cookie,当会话被关闭此时会话期 cookie 在彼时被移除</p>
<blockquote>
<p>🙋‍♂️ 在服务端渲染的页面,其 Expries 的时间戳是服务器时间</p>
<p>而在客户端渲染的页面,其 Expries 的时间戳是客户端时间</p>
</blockquote>
<p><em>Max-Age</em>:cookie 失效前需要经过的秒数,秒数为 0 或-1 会将 cookie 直接过期。Max-Age 的优先级比 Expries 更高</p>
<p><em>Domain</em>:指定 cookie 可以送达的主机名,没指定的话默认值为当前文档访问地址中的主机部分</p>
<p><em>Secure</em>:一个带有安全属性的 cookie(只有在请求使用 https 的时候才会被发送到服务端,以阻止中间人攻击)</p>
<p><em>HttpOnly</em>:用于阻止 JS 通过 Document.cookie 属性访问 cookie,其用来防范跨站攻击脚本 xss</p>
<p><em>samesite</em>:<samesite-value>:允许一则 cookie 不随跨站请求一起被发送,这可以一定程度上防范跨站请求伪造攻击(CSRF)</samesite-value></p>
<p> samesite-value:</p>
<pre><code class="lang-css">    1) strict:意味着浏览器只对同一站点发送请求,即请求来自设置cookie的站点(同域,同协议)
    1) Lax:cookie不会在跨站请求中被发送。如加载图像或frame的请求,但cookie在用户从外站导航到源站时cookie也将被发送,这是samesite未被设置时的默认行为
    1) None:浏览器在跨站和同站均会发送cookie,设置这一值的同时必须同时设置secure属性
</code></pre>
<h5 id="什么是跨站-什么是跨域-二者有何区别"><a href="#什么是跨站-什么是跨域-二者有何区别" class="headerlink" title="什么是跨站?什么是跨域?二者有何区别?"></a>什么是跨站?什么是跨域?二者有何区别?</h5><p>跨域的定义并不是域名不同或者域不同,而是”不同源”</p>
<p>同源的定义是协议、域名、端口号三者都相同的 URL</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/源.svg" alt="源"></p>
<p>具有相同协议、主机名、端口号的组合的网站被视为”相同来源”(same-origin)其他所有内容均视为”跨域”(cross-origin)</p>
<p>站(site)</p>
<p>站是指有效顶级域名(effective Top-LeveL Domain, eTLD)和其前面的二级域名的一个整体,即(eTLD+1)</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/站.svg" alt="站"></p>
<blockquote>
<p>eTLD 列表在 publicsuffix.org/list 上进行维护</p>
</blockquote>
<p><strong>同站和跨站</strong></p>
<p>具有相同的 eTLD+1 的网端被视为同站(same-site)</p>
<p>具有不同的 eTLD+1 的网端被视为跨站(cross-site)</p>
<blockquote>
<p>尽管同站忽略了协议(无协议的同站)在某些情况下必须严格区分协议,以防 HTTP 被用作弱通道,一些文档将同站更明确的定义为 schemeful same site(协议与 eTLD+1 都相同)</p>
<p>即<a target="_blank" rel="noopener" href="https://www.example与http://www.example.com视为跨站">https://www.example与http://www.example.com视为跨站</a></p>
</blockquote>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
            <ul id="audio-list" style="display:none">
                
                
                <li title='0' data-url='/statics/chengdu.mp3'></li>
                
                    
            </ul>
            
                        
            
            
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci='7bbd114371cb2cd73dc2'
        data-cs='fd7cda0eb23cbb69b65e291c5b607b196613a6b1'
        data-r='nd-ljq.github.io'
        data-o='ND-LJQ'
        data-a='ND-LJQ'
        data-d=''
        data-p='https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    >Comments</div>


            
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="/img/head.jpg" height=300 width=300></img>
                    <p>ND_LJQ</p>
                    <span>Think like an artist, develop like an artisan</span>
                    <dl>
                        
                            
                                <dd><a href="https://github.com/ND-LJQ'" target="_blank"><span
                                    class=" iconfont icon-github"></span></a></dd>
                            
                            
                            
                        
                        
                    </dl>
                </div>
                <ul>
                    <li><a href="/">20 <p>Articles</p></a></li>
                    <li><a href="/categories">11 <p>Categories</p></a></li>
                    <li><a href="/tags">10 <p>Tags</p></a></li>
                </ul>
            </div>
            
            
            
            <div class="box sticky animated fadeInRight faster">
                <div id="toc" class="subbox">
                    <h4>Contents</h4>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">计算机网络体系概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.1.</span> <span class="toc-text">计算机网络的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.</span> <span class="toc-text">计算机网络的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">计算机网络的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%88%86%E5%B8%83%E8%8C%83%E5%9B%B4%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">按分布范围分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">按传输技术分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.3.</span> <span class="toc-text">按拓扑结构分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%BF%E7%94%A8%E8%80%85%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.4.</span> <span class="toc-text">按使用者分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.5.</span> <span class="toc-text">按传输介质分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.4.</span> <span class="toc-text">&#x3D;&#x3D;计算机网络的性能指标&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%AE%BD"><span class="toc-number">1.4.1.</span> <span class="toc-text">带宽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BB%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">时延</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF"><span class="toc-number">1.4.3.</span> <span class="toc-text">时延带宽积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%80%E8%BF%94%E6%97%B6%E5%BB%B6-RRT-Round-Trip-Time"><span class="toc-number">1.4.4.</span> <span class="toc-text">往返时延(RRT Round Trip Time)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">1.4.5.</span> <span class="toc-text">吞吐量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9F%E7%8E%87-%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87%E3%80%81%E6%95%B0%E6%8D%AE%E7%8E%87%E3%80%81%E6%AF%94%E7%89%B9%E7%8E%87"><span class="toc-number">1.4.6.</span> <span class="toc-text">速率(传输速率、数据率、比特率)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">1.4.7.</span> <span class="toc-text">信道利用率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E3%80%81%E6%9C%8D%E5%8A%A1%E3%80%81%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.</span> <span class="toc-text">协议、服务、接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.5.1.</span> <span class="toc-text">协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.2.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.5.3.</span> <span class="toc-text">服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI-%E4%B8%8E-TCP-IP-%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">&#x3D;&#x3D;OSI 与 TCP&#x2F;IP 模型&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">1.6.1.</span> <span class="toc-text">物理层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">1.6.2.</span> <span class="toc-text">数据链路层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">1.6.3.</span> <span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">1.6.4.</span> <span class="toc-text">传输层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E5%B1%82"><span class="toc-number">1.6.5.</span> <span class="toc-text">会话层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%B1%82"><span class="toc-number">1.6.6.</span> <span class="toc-text">表示层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">1.6.7.</span> <span class="toc-text">应用层</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82-1"><span class="toc-number">2.</span> <span class="toc-text">物理层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E6%BA%90%E3%80%81%E4%BF%A1%E5%AE%BF%E3%80%81%E4%BF%A1%E9%81%93"><span class="toc-number">2.1.</span> <span class="toc-text">信源、信宿、信道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%8F%8C%E6%96%B9%E7%9A%84%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">通信双方的交互方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9F%E7%8E%87%E3%80%81%E6%B3%A2%E7%89%B9%E4%B8%8E%E5%B8%A6%E5%AE%BD"><span class="toc-number">2.3.</span> <span class="toc-text">&#x3D;&#x3D;速率、波特与带宽&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%88%E6%B0%8F%E5%87%86%E5%88%99%E5%92%8C%E9%A6%99%E5%86%9C%E5%AE%9A%E5%BE%8B"><span class="toc-number">2.4.</span> <span class="toc-text">&#x3D;&#x3D;奈氏准则和香农定律&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%88%E6%B0%8F%E5%87%86%E5%88%99"><span class="toc-number">2.4.1.</span> <span class="toc-text">奈氏准则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A6%99%E5%86%9C%E5%AE%9A%E5%BE%8B"><span class="toc-number">2.4.2.</span> <span class="toc-text">香农定律</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6"><span class="toc-number">2.5.</span> <span class="toc-text">编码与调制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2-%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2%E4%B8%8E%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.6.</span> <span class="toc-text">电路交换,报文交换与分组交换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.6.1.</span> <span class="toc-text">电路交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.6.2.</span> <span class="toc-text">报文交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.6.3.</span> <span class="toc-text">分组交换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8"><span class="toc-number">2.7.</span> <span class="toc-text">传输介质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%BB%9E%E7%BA%BF"><span class="toc-number">2.7.1.</span> <span class="toc-text">双绞线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86"><span class="toc-number">2.7.2.</span> <span class="toc-text">同轴电缆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E7%BA%A4"><span class="toc-number">2.7.3.</span> <span class="toc-text">光纤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%BA%BF%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8"><span class="toc-number">2.7.4.</span> <span class="toc-text">无线传输介质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E6%8E%A5%E5%8F%A3%E5%B1%82%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">2.8.</span> <span class="toc-text">物理接口层的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="toc-number">2.9.</span> <span class="toc-text">物理层设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%BB%A7%E5%99%A8"><span class="toc-number">2.9.1.</span> <span class="toc-text">中继器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BA%BF%E5%99%A8"><span class="toc-number">2.9.2.</span> <span class="toc-text">集线器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q-A"><span class="toc-number">2.9.3.</span> <span class="toc-text">Q.A</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82-1"><span class="toc-number">3.</span> <span class="toc-text">&#x3D;&#x3D;数据链路层&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.</span> <span class="toc-text">数据链路层的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.2.</span> <span class="toc-text">为网络层提供的服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">链路的管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6-OSI-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.</span> <span class="toc-text">流量控制(OSI 体系结构)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6"><span class="toc-number">3.5.</span> <span class="toc-text">&#x3D;&#x3D;差错控制&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E9%94%99%E7%BC%96%E7%A0%81"><span class="toc-number">3.5.1.</span> <span class="toc-text">检错编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A0%E9%94%99%E7%BC%96%E7%A0%81"><span class="toc-number">3.5.2.</span> <span class="toc-text">纠错编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%B8%A7"><span class="toc-number">3.6.</span> <span class="toc-text">组帧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A7%E5%AE%9A%E7%95%8C"><span class="toc-number">3.6.1.</span> <span class="toc-text">帧定界</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6"><span class="toc-number">3.7.</span> <span class="toc-text">流量控制与可靠传输机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">3.7.1.</span> <span class="toc-text">停止等待流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">3.7.2.</span> <span class="toc-text">滑动窗口流量控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87-1"><span class="toc-number">3.8.</span> <span class="toc-text">信道利用率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E5%90%9E%E5%90%90%E7%8E%87"><span class="toc-number">3.9.</span> <span class="toc-text">信道吞吐率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-MAC-%E5%AD%90%E5%B1%82"><span class="toc-number">3.10.</span> <span class="toc-text">介质访问控制(MAC 子层)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E5%88%92%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">3.10.1.</span> <span class="toc-text">信道划介质访问控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">3.10.2.</span> <span class="toc-text">随机访问介质访问控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">3.11.</span> <span class="toc-text">局域网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">3.11.1.</span> <span class="toc-text">局域网的基本概念和体系结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">3.12.</span> <span class="toc-text">以太网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8%E4%B8%8E-%E7%BD%91%E5%8D%A1"><span class="toc-number">3.12.1.</span> <span class="toc-text">以太网传输介质与&#x3D;&#x3D;网卡&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84-MAC-%E5%B8%A7"><span class="toc-number">3.12.2.</span> <span class="toc-text">以太网的 MAC 帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">3.12.3.</span> <span class="toc-text">高速以太网</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%9F%9F%E7%BD%91"><span class="toc-number">3.13.</span> <span class="toc-text">广域网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%9F%9F%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.13.1.</span> <span class="toc-text">广域网数据链路层协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="toc-number">3.14.</span> <span class="toc-text">数据链路层设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A1%A5"><span class="toc-number">3.14.1.</span> <span class="toc-text">网桥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">3.14.2.</span> <span class="toc-text">局域网交换机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QA"><span class="toc-number">3.15.</span> <span class="toc-text">QA</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82-1"><span class="toc-number">4.</span> <span class="toc-text">&#x3D;&#x3D;网络层&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">4.1.</span> <span class="toc-text">网络层的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%9E%84%E7%BD%91%E7%BB%9C%E4%BA%92%E8%81%94"><span class="toc-number">4.2.</span> <span class="toc-text">异构网络互联</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%B8%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">4.3.</span> <span class="toc-text">路由与转发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SDN-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="toc-number">4.4.</span> <span class="toc-text">SDN(软件定义网络)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">4.5.</span> <span class="toc-text">拥塞控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95"><span class="toc-number">4.6.</span> <span class="toc-text">&#x3D;&#x3D;路由算法&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1"><span class="toc-number">4.6.1.</span> <span class="toc-text">静态路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1"><span class="toc-number">4.6.2.</span> <span class="toc-text">动态路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E8%B7%AF%E7%94%B1"><span class="toc-number">4.6.3.</span> <span class="toc-text">层次路由</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPv4"><span class="toc-number">4.7.</span> <span class="toc-text">&#x3D;&#x3D;IPv4&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv4-%E5%88%86%E7%BB%84"><span class="toc-number">4.7.1.</span> <span class="toc-text">IPv4 分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87"><span class="toc-number">4.7.2.</span> <span class="toc-text">IP 数据报分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv4-%E4%B8%8E-NAT"><span class="toc-number">4.7.3.</span> <span class="toc-text">IPv4 与 NAT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E4%B8%8E%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E3%80%81CIDR"><span class="toc-number">4.7.4.</span> <span class="toc-text">子网划分与子网掩码、CIDR</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARP%E3%80%81DHCP-%E4%B8%8E-ICMP"><span class="toc-number">4.8.</span> <span class="toc-text">ARP、DHCP 与 ICMP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ARP"><span class="toc-number">4.8.1.</span> <span class="toc-text">ARP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DHCP"><span class="toc-number">4.8.2.</span> <span class="toc-text">DHCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP"><span class="toc-number">4.8.3.</span> <span class="toc-text">ICMP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPv6"><span class="toc-number">4.9.</span> <span class="toc-text">IPv6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv6-%E5%9C%B0%E5%9D%80"><span class="toc-number">4.9.1.</span> <span class="toc-text">IPv6 地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP-%E7%BB%84%E6%92%AD"><span class="toc-number">4.10.</span> <span class="toc-text">IP 组播</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F"><span class="toc-number">4.10.1.</span> <span class="toc-text">IP 数据报的三种传输方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E7%BB%84%E6%92%AD%E5%9C%B0%E5%9D%80"><span class="toc-number">4.10.2.</span> <span class="toc-text">IP 组播地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E7%BB%84%E6%92%AD%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.10.3.</span> <span class="toc-text">IP 组播的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IGMP-%E5%8D%8F%E8%AE%AE%E4%B8%8E%E7%BB%84%E6%92%AD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.10.4.</span> <span class="toc-text">IGMP 协议与组播路由选择协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8-IP"><span class="toc-number">4.11.</span> <span class="toc-text">移动 IP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8-IP-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.11.1.</span> <span class="toc-text">移动 IP 的概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="toc-number">4.12.</span> <span class="toc-text">网络层设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B2%E7%AA%81%E5%9F%9F%E5%92%8C%E5%B9%BF%E6%92%AD%E5%9F%9F"><span class="toc-number">4.12.1.</span> <span class="toc-text">冲突域和广播域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82-1"><span class="toc-number">5.</span> <span class="toc-text">传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E5%AF%BB%E5%9D%80%E4%B8%8E%E7%AB%AF%E5%8F%A3"><span class="toc-number">5.1.</span> <span class="toc-text">传输层的寻址与端口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">5.1.1.</span> <span class="toc-text">端口的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">5.1.2.</span> <span class="toc-text">端口号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">5.1.3.</span> <span class="toc-text">套接字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1"><span class="toc-number">5.2.</span> <span class="toc-text">无连接服务和面向连接服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.3.</span> <span class="toc-text">UDP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-%E6%95%B0%E6%8D%AE%E6%8A%A5"><span class="toc-number">5.3.1.</span> <span class="toc-text">UDP 数据报</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.4.</span> <span class="toc-text">&#x3D;&#x3D;TCP 协议&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E6%8A%A5%E6%96%87%E6%AE%B5"><span class="toc-number">5.4.1.</span> <span class="toc-text">TCP 报文段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number">5.4.2.</span> <span class="toc-text">TCP 连接管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">5.4.3.</span> <span class="toc-text">TCP 可靠传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">5.4.4.</span> <span class="toc-text">TCP 流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">5.4.5.</span> <span class="toc-text">TCP 的拥塞控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82-1"><span class="toc-number">6.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">网络应用模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.1.1.</span> <span class="toc-text">客户&#x2F;服务器模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P2P-%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.1.2.</span> <span class="toc-text">P2P 模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F-DNS"><span class="toc-number">6.2.</span> <span class="toc-text">域名系统(DNS)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E5%9F%9F%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">6.2.1.</span> <span class="toc-text">层次域名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">6.2.2.</span> <span class="toc-text">域名服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">6.2.3.</span> <span class="toc-text">域名解析过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-FTP"><span class="toc-number">6.3.</span> <span class="toc-text">文件传输协议(FTP)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5"><span class="toc-number">6.3.1.</span> <span class="toc-text">控制连接与数据连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6"><span class="toc-number">6.4.</span> <span class="toc-text">电子邮件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84"><span class="toc-number">6.4.1.</span> <span class="toc-text">电子邮件系统的组成结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%8E-MIME"><span class="toc-number">6.4.2.</span> <span class="toc-text">电子邮件格式与 MIME</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMTP-%E5%92%8C-POP3"><span class="toc-number">6.4.3.</span> <span class="toc-text">SMTP 和 POP3</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%87%E7%BB%B4%E7%BD%91-www"><span class="toc-number">6.5.</span> <span class="toc-text">万维网(www)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%EF%BC%88HTTP%EF%BC%89"><span class="toc-number">6.5.1.</span> <span class="toc-text">超文本传输协议（HTTP）</span></a></li></ol></li></ol></li></ol>
                </div>
            </div>
            
            
        </div>
    </div>
</div>

    </div>
</div>
    <div id="back-to-top" class="animated fadeIn faster">
        <div class="flow"></div>
        <span class="percentage animated fadeIn faster">0%</span>
        <span class="iconfont icon-top02 animated fadeIn faster"></span>
    </div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2023
        <span class="gradient-text">
            ND_LJQ
        </span>.
        Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
        Theme
        <span class="gradient-text">
            <a href="https://github.com/TriDiamond/hexo-theme-obsidian" title="Obsidian" target="_blank" rel="noopener">Obsidian</a>
        </span>
        <small><a href="https://github.com/TriDiamond/hexo-theme-obsidian/blob/master/CHANGELOG.md" title="v1.4.9.3" target="_blank" rel="noopener">v1.4.9.3</a></small>
        
        
    </p>
</footer>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX", "TeX"],
      linebreaks: {
        automatic: true
      },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"]
      ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      noUndefined: {
        attributes: {
          mathcolor: "red",
          mathbackground: "#FFEEEE",
          mathsize: "90%"
        }
      },
      Macros: {
        href: "{}"
      }
    },
    messageStyle: "none"
  });
</script>
<script>
  function initialMathJax() {
    MathJax.Hub.Queue(function () {
      var all = MathJax.Hub.getAllJax(),
        i;
      // console.log(all);
      for (i = 0; i < all.length; i += 1) {
        console.log(all[i].SourceElement().parentNode)
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  }

  function reprocessMathJax() {
    if (typeof MathJax !== 'undefined') {
      MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }
</script>


 
<link rel="stylesheet" href="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.css">
 
<script src="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.js"></script>
  
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>
 
<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>
 
<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>
 
<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>
 
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/sql/sql.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/java/java.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/c/c.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/html/html.min.js"></script>
   
<script src="/js/busuanzi.min.js"></script>

<script>
  $(document).ready(function () {
    if ($('span[id^="busuanzi_"]').length) {
      initialBusuanzi();
    }
  });
</script>
 
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
  

<script>
  function initialTyped() {
    var typedTextEl = $('.typed-text');
    if (typedTextEl && typedTextEl.length > 0) {
      var typed = new Typed('.typed-text', {
        strings: ['Think like an artist, develop like an artisan', '艺术家思维去思考问题，工匠创造精神去开发'],
        typeSpeed: 90,
        loop: true,
        loopCount: Infinity,
        backSpeed: 20,
      });
    }
  }

  if ($('.article-header') && $('.article-header').length) {
    $(document).ready(function () {
      initialTyped();
    });
  }
</script>




<!-- 引用依赖 -->
<script>document.write(aplayerconf)</script>




</html>
