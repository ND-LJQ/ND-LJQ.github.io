
<!DOCTYPE html>
<html lang="cn" class="loading">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
      name="viewport"
      content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>计算机组成原理基础 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="google" content="notranslate" />
    
    <meta name="keywords" content="TriDiamond Obsidian," />
     
    <meta name="description" content="计算机的系统概述
计算机的层次结构
计算机系统的组成
硬件系统和软件系统共同构成了一个完整的计算机系统。硬件是指有形的物理设备,是计算机系统重实际物理装置的总称。软件是指在硬件上运行的程序和相关的数," />
     
    <meta name="author" content="ND_LJQ" />
     
    <link
      rel="alternative"
      href="atom.xml"
      title="Hexo"
      type="application/atom+xml"
    />
     
    <link rel="icon" href="/img/favicon.png" />
     
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">
 
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">
 
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">
 
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">
 
<link rel="stylesheet" href="/css/obsidian.css">
 
<link rel="stylesheet" href="/css/ball-atom.min.css">
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
 
    <link
      href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css"
      rel="stylesheet"
    />
    <script>
      var musiclist = '';
    </script>
    
<script src="/js/loadaplayer.js"></script>

    <!-- 引用依赖 -->
    
<link rel="stylesheet" href="/aplayer/dist/APlayer.min.css">
 
<script src="/aplayer/dist/APlayer.min.js"></script>
<script src="/js/Meting.min.js"></script>
 
  <meta name="generator" content="Hexo 6.3.0"></head>
</html>


<body class="loading">
    <div class="loader">
        <div class="la-ball-atom la-2x">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="/img/favicon.png" alt="" data-url="http://example.com">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">计算机组成原理基础</h3>
        <div class="social">
            <!--        <div class="like-icon">-->
            <!--            <a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
            <!--        </div>-->
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
            animation-delay: 600ms;
            animation-duration: 1.2s;
            background-image: 
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url('/img/cover.jpg') ">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                <a href="/categories/计算机基础"><b>「
                    </b>计算机基础<b> 」</b></a>
                
                July 18, 2023
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/" title="计算机组成原理基础" class="">计算机组成原理基础</a>
            </h3>
            
            <p class="post-count animated fadeInDown">
                
                <span>
                    <b class="iconfont icon-text2"></b> <i>Words count</i>
                    321k
                </span>
                
                
                <span>
                    <b class="iconfont icon-timer__s"></b> <i>Reading time</i>
                    4:52
                </span>
                
                
                
                <span id="busuanzi_container_page_pv">
                    <b class="iconfont icon-read"></b> <i>Read count</i>
                    <span id="busuanzi_value_page_pv">0</span>
                </span>
                
            </p>
            
            
            <ul class="animated fadeInDown post-tags-list" itemprop="keywords"><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag">计算机组成原理</a></li></ul>
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s"></span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <h1 id="ji-suan-ji-de-xi-tong-gai-shu">计算机的系统概述</h1>
<h2 id="ji-suan-ji-de-ceng-ci-jie-gou">计算机的层次结构</h2>
<h3 id="ji-suan-ji-xi-tong-de-zu-cheng">计算机系统的组成</h3>
<p><strong>硬件系统</strong>和<strong>软件系统</strong>共同构成了一个完整的计算机系统。硬件是指有形的物理设备,是计算机系统重实际物理装置的总称。软件是指在硬件上运行的程序和相关的数据及文档</p>
<h3 id="ji-suan-ji-ying-jian">计算机硬件</h3>
<h4 id="feng-nuo-yi-man-ji-de-ji-ben-si-xiang">冯诺依曼机的基本思想</h4>
<p>冯诺依曼在研究 EDVAC 机时提出了<code>&quot;存储程序&quot;</code>的概念,存储程序的思想奠定了现代计算机的基本结构,以此概念为基础的各类计算机通称为冯诺依曼机其特点如下 👇:</p>
<ol>
<li class="lvl-3">
<p>采用<code>&quot;存储程序&quot;</code>的工作方式,基本工作方式为**<code>控制流驱动方式</code>**</p>
</li>
<li class="lvl-3">
<p>计算机硬件系统由<strong>运算器</strong>、<strong>存储器</strong>、<strong>控制器</strong>、<strong>输入设备</strong>和<strong>输出设备</strong>5 大部件组成</p>
</li>
<li class="lvl-3">
<p><code>指令</code>和<code>数据</code>以同等地位存储中,形式上没有区别,但计算机等区分他们</p>
</li>
<li class="lvl-3">
<p><code>指令</code>和<code>数据</code>均用<strong>二进制代码</strong>表示。<code>指令</code>由<strong>操作码</strong>和<strong>地址码</strong>组成,操作码指出操作的类型,地址码指出操作数的地址</p>
</li>
</ol>
<blockquote>
<p>🙋‍♂️<strong>存储程序的基本思想是</strong>:</p>
<p>将事先编写好的程序和原始数据送入主存后才能执行,一旦程序成功执行,就无须操作人员干预,计算机会自动逐条执行指令,直至程序执行结束</p>
</blockquote>
<h4 id="ji-suan-ji-de-gong-neng-bu-jian">计算机的功能部件</h4>
<p>后面详细介绍</p>
<p><strong>输入设备</strong></p>
<p><strong>输出设备</strong></p>
<p><a href="##%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0"><strong>存储器</strong></a></p>
<p><a href><strong>运算器</strong></a></p>
<p><a href="##%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><strong>控制器</strong></a></p>
<p>冯诺依曼结构的模型机示意图 👇</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%9C%BA.svg" alt="冯诺依曼机"></p>
<h3 id="ji-suan-ji-ruan-jian">计算机软件</h3>
<h4 id="xi-tong-ruan-jian-he-ying-yong-ruan-jian">系统软件和应用软件</h4>
<p>软件按其功能分类,可分为<strong>系统软件</strong>和<strong>应用软件</strong></p>
<p><em>系统软件</em>是一组保证计算机系统高效、正确运行的基础软件,通常作为系统资源提供给用户使用</p>
<p>系统软件主要有:</p>
<p><code>操作系统(OS)</code>、<code>数据库管理系统(DBMS)</code>、<code>语言处理程序</code>、<code>分布式软件系统</code>、<code>网络软件系统</code>、<code>标准库程序</code>、<code>服务性程序</code></p>
<p><em>应用软件</em>是指用户为解决某个应用领域中的各类问题而编制的程序,如各种科学计算类程序、工业设计类程序、数据统计与处理程序</p>
<h4 id="san-ge-ji-bie-de-yu-yan">三个级别的语言</h4>
<p>1️⃣<strong>机器语言</strong></p>
<p>二进制代码语言。<mark>机器语言是计算机唯一可以直接识别和执行的语言</mark></p>
<p>2️⃣<strong>汇编语言</strong></p>
<p>汇编语言用英文单词或其缩写替代二进制指令代码,更容易为人们记忆和理解.使用汇编语言编写的那些的程序,必须经过一个称为汇编程序的系统软件的翻译,将其转换为机器语言程序后,才能在计算机的硬件系统上执行</p>
<p>3️⃣<strong>高级语言</strong></p>
<p>高级语言需要经过汇编程序编译成汇编语言程序,然后经过汇编操作得到机器语言程序,或直接由高级语言翻译成机器语言程序</p>
<p>由于计算机无法直接理解和执行高级语言程序,需要将高级语言程序转化为机器语言程序,通常把进行这种转换的软件统称为翻译程序。翻译程序由以下三类 👇:</p>
<ol>
<li class="lvl-3">
<p><strong>汇编程序(汇编器)</strong>。将汇编语言程序翻译成机器语言程序。</p>
</li>
<li class="lvl-3">
<p><strong>解释程序(解释器)</strong>。将源程序中的语句按执行顺序逐条翻译成机器指令并立即执行</p>
</li>
<li class="lvl-3">
<p><strong>编译程序(编译器)</strong>。将高级语言程序翻译成汇编语言或机器语言程序</p>
</li>
</ol>
<blockquote>
<p>🙋‍♂️<strong>硬件和软件的逻辑功能等价性</strong>即对某一功能来说,既可以由硬件实现,又可以用软件实现</p>
<p>硬件实现具有更高的执行速度,软件实现具有更好的灵活性,执行频繁、硬件实现代价不是很高的功能通常由硬件实现</p>
</blockquote>
<h3 id="ji-suan-ji-de-ceng-ci-jie-gou-1">计算机的层次结构</h3>
<p><strong>计算机是一个硬软件组成的综合体</strong>。由于软/硬件的设计者和使用者从不同的角度、用不同的语言来对待同一个计算机系统,因此他们看到的计算机系统的属性,对计算机系统提出的要求也就各不相同。</p>
<p>以下是计算机系统的多级层次机构示意图 👇:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.svg" alt="层次结构"></p>
<p>第 1 级是<strong>微程序机器层</strong>,这是一个实在的硬件层,它由机器硬件直接执行微指令</p>
<p>第 2 级是<strong>传统机器语言层</strong>,它也是一个实在的硬件层,它由微程序解释机器指令系统</p>
<p>第 3 级是<strong>操作系统层</strong>,它由操作系统程序实现。操作系统程序是由机器指令和广义指令组成的,所以这一层也被称为<code>混合层</code></p>
<p>第 4 级是<strong>汇编语言层</strong>,它为用户提供一种符号化的语言,借此可编写汇编语言源程序。这一层由汇编程序支持和执行</p>
<p>第 5 级是<strong>高级语言层</strong>,它是面向用户的,是为了方便用户编写以应用程序而设置的,该层由各种高级语言编译程序支持和执行</p>
<p>高级语言层之上还可以由应用程序层,它由解决实际问题和应用问题的处理程序组成,如文字处理软件、数据库软件、多媒体处理软件和办公自动化软件</p>
<p>没有配备软件的纯硬件系统称为<code>裸机</code>。第 3 层~第 5 层称为<code>虚拟机</code>,简单来说就是软件实现的机器,虚拟机只对该层的观察者存在</p>
<p>层次之间关系紧密,下层是上层的基础,上层是下层的拓展</p>
<blockquote>
<p>🙋‍♂️<em>计算机组成原理主要讨论传统机器 M1 和微程序机器 M0 的组成原理和设计思想</em></p>
</blockquote>
<h2 id="ji-suan-ji-de-xing-neng-zhi-biao">计算机的性能指标</h2>
<h3 id="ji-suan-ji-de-zhu-yao-xi-tong-zhi-biao">计算机的主要系统指标</h3>
<p>🥖<strong>字长</strong></p>
<p>指计算机进行一次整数运算(即定点整数运算)所能处理的二进制数据的位数,通常与 CPU 的寄存器位数、加法器有关。因此字长一般等于内部寄存器的大小,字长越长,数的表示范围越大,计算精度越高。计算机字长通常选定为字节(8 位)的整数倍</p>
<blockquote>
<p>🤔<a name="字、字长、机器字长、指令字长、存储字长的区别和联系是什么?"><strong>字、字长、机器字长、指令字长、存储字长的区别和联系是什么?</strong></a></p>
<p>在通常所说的<code>&quot;某32位或64位机器&quot;</code>中,32、64 指的是字长,也称机器字长。所谓字长,通常是指 CPU 内部用于证书运算的数据通路的宽度,<strong>因此字长等于 CPU 内部用于整数运算的运算器位数和通用寄存器宽度</strong>,它反应了计算机处理信息的能力。字和字长概念不同。字用来表示被处理信息的单位,用来度量数据类型的宽度,如 x86 机器中将一个字定义为 16 位</p>
<p><strong>指令字长</strong>:一个指令字中包含的二进制代码的位数</p>
<p><strong>存储字长</strong>:一个存储单元存储的二进制代码的长度</p>
<p>指令字长一般取存储字长的整数倍,若指令字长等于存储字长的 2 倍,则需要两个存储周期来取出一条指令;若指令字长等于存储字长,则取指周期等于机器周期</p>
<p><strong>他们必须是字节的整数倍</strong></p>
</blockquote>
<p>📼<strong>数据通路带宽</strong></p>
<p>数据带宽是指数据总线一次所能并行传送信息的位数。这里说的数据通路宽度是指外部数据总线的宽度,它与 CPU 内部的数据总线的宽度(内部寄存器的大小)有可能不同</p>
<blockquote>
<p>🙋‍♂️ 各个子系统通过数据总线连接形成的数据传送路径称为数据通路</p>
</blockquote>
<p>🍼<strong>主存容量</strong></p>
<p>主存容量是指主存储器所能存储信息的最大容量,通常以字节来衡量,也可以用字数 × 字长(如 512K×16 位)来表示存储容量。其中 MAR 的位数反映存储单元可寻址范围的最大值(而不一定是实际存储器的存储容量)</p>
<blockquote>
<p>例如,MAR 为 16 位,表示 2<sup>16</sup>=65536,即此存储体内有 65536 个存储单元(可称为 64K 内存,1K=1024)</p>
</blockquote>
<p>🚅<strong>运算速度</strong></p>
<p><mark>吞吐量和响应时间</mark></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>吞吐量</p>
</li>
</ul>
<p>系统在单位时间内处理请求的数量。它取决于信息能多快地输入内存,CPU 能多快地取指令,数据能多快地动内存取出或读入,以及所得结果能多快地从内存送给一台外部设备。每一步都涉及主存。因此<strong>系统吞吐量主要取决于主存的存取周期</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>响应时间</p>
</li>
</ul>
<p>指从用户向计算机发送一个请求,到系统对该请求做出的响应并获得所需结果的等待时间。通常包括 CPU 时间(运行一个程序所花费的时间)与等待时间(用于磁盘访问、存储器访问、I/O 访问、操作系统开销等的时间)</p>
<p><mark>主频和 CPU 时钟周期</mark></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>CPU 时钟周期</p>
</li>
</ul>
<p>通常为节拍脉冲(被称之为<code>节拍</code>或者<code>拍</code>)或者 T 周期,即主频的倒数,它是 CPU 中最小的时间单位,执行指令的每个动作至少需要 1 个时钟周期</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>主频(CPU 时钟频率)</p>
</li>
</ul>
<p>机器内部主时钟的频率,是衡量机器速度的重要参数。对于同一个型号的计算机,其主频越高完成一个执行步骤的时间越短</p>
<blockquote>
<p>🙋‍♂️CPU 时钟周期 = 1/主频,主频通常以 Hz 时(赫兹)为单位,1Hz 表示每秒一次</p>
</blockquote>
<blockquote>
<p>🤔<strong>时钟周期、机器周期与指令周期的概念与联系是什么?</strong></p>
<p><strong>指令周期</strong>:</p>
<p>CPU 从存储器中<strong>取出并执行一条指令所需的全部时间</strong>称之为指令周期。</p>
<p>计算机每执行一条指令的过程，可分解为如下步骤：</p>
<ol>
<li class="lvl-3">
<p><strong>Instruction Fetch（取指令</strong>：指令放在存储器，通过 PC 寄存器和指令寄存器取出指令的过程，由控制器（Control Unit）操作。 从 PC 寄存器找到对应指令地址，据指令地址从内存把具体指令加载到指令寄存器，然后 PC 寄存器自增；</p>
</li>
<li class="lvl-3">
<p><strong>Instruction Decode（译码</strong>：据指令寄存器里面的指令，是哪一种类型的指令，解析成要进行什么操作，具体要操作哪些寄存器、数据或内存地址。该阶段也是由控制器执行；</p>
</li>
<li class="lvl-3">
<p><strong>Execute（执行）</strong>：实际执行算术逻辑操作、数据传输或者直接的地址跳转操作。无论是算术操作、逻辑操作的指令，还是数据传输、条件分支的指令，都由算术逻辑单元（ALU）操作，即由运算器处理。如果是一个简单的无条件地址跳转，那可直接在控制器里完成，无需运算器</p>
</li>
</ol>
<p>重复 1 ～ 3 的过程，这个循环完成的时间即指令周期。</p>
<p><strong>机器周期</strong>:</p>
<p>又称为<strong>CPU 周期（CPU Cycle）</strong>。一个机器周期内包含若干时钟周期，包含时钟周期的个数称之为机器周期的<strong>时间宽度</strong>。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230703222734882.png" alt="image-20230703222734882"></p>
<p><strong>总结</strong>:</p>
<p><strong><mark>一个指令周期包含多个机器周期，而一个机器周期包含多个时钟周期</mark></strong></p>
</blockquote>
<p><mark>CPI</mark></p>
<p>CPI(Clock cycle Per Instruction),即执行一条指令所需要的时钟周期数</p>
<blockquote>
<p>🙋‍♂️ 不同指令的时钟周期数可能不同,因此对于一个程序或一台机器来说,其 CPI 是指该程序或机器啊指令集中所有指令执行所需的平均时钟周期数,此时 CPI 是一个平均值</p>
</blockquote>
<p><mark>CPU 执行时间</mark></p>
<p>指运行一个程序所要花费的时间</p>
<pre><code class="language-css">CPU执行时间 = CPU时钟周期数/主频 = (指令条数×CPI)/主频
</code></pre>
<blockquote>
<p>🙋‍♂️ 上式表 CPU 性能(CPU 执行时间)取决于三个要素:① 主频(时钟频率);② 每条指令执行所用的时钟周期数;③ 指令条数</p>
<p>主频、CPI 和指令条数时相互制约的,例如,更改指令集可以减少程序所含指令的条数,但可能会引起 CPU 结构的调整,从而可能会增加时钟周期的宽度(降低主频)</p>
</blockquote>
<p><mark>MIPS</mark></p>
<p>每秒执行多少百万条指令</p>
<p><mark>MFLOPS、GFLOPS、TFLOPS、PFLOPS、ZFLOPS 和 EFLOPS</mark></p>
<p>每秒执行多少百万、千万…条浮点指令</p>
<blockquote>
<p>🚨 在描述容量存储容量、文件大小等时,K、M、G、T 通常用 2 的幂次来表示,例如 1Kb = 2<sup>10</sup>b;</p>
<p>在描述速率、频率等时 k、M、G、T 通常用 10 的幂次方表示,如 1kb/s = 10<sup>3</sup>b/s。通常前者用大写的 K,后者用小写的 k,但其他前缀均为大写,表示含义取决于所用场景</p>
</blockquote>
<p>👨‍💻<strong>基准程序</strong></p>
<p>基准程序是专门用来进行性能评价的一组程序,能够很好的反映机器在运行实际负载时的性能,可以通过在不同机器上运行相同的基准程序来比较在不同机器上的运行时间,从而评价其性能</p>
<h3 id="ji-ge-zhuan-ye-zhu-yu">几个专业术语</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>系列机</strong>:具有基本相同的体系结构,使用相同的基本指令系统的多个不同型号的计算机组成的一个产品系列。</p>
</li>
<li class="lvl-2">
<p><strong>兼容</strong>:指软件或硬件的通用性,即运行在某个型号的计算机系统重的硬件/软件也应用于另一个型号的计算机系统时,称这两台计算机在硬件或软件上存在兼容性</p>
<ul class="lvl-2">
<li class="lvl-4">
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>软件可移植性</strong>:指把某个系列计算机中的软件直接或进行很少的修改就能运行在另一个系列计算机中的可能性</p>
</li>
<li class="lvl-2">
<p><strong>固件</strong>:将程序固话在<code>ROM</code>中组成的部件称为固件。固件是一种具有软件特性的硬件,吸收了软/硬件各自的优点,其执行速度快于软件,灵活优于硬件,是软/硬结合的产物</p>
</li>
<li class="lvl-2">
<p><strong>透明性</strong>:在计算机领域中,站在某类用户的角度,若感觉不到某个事物或者属性的存在,即&quot;看&quot;不到某个事物或者属性,则称为&quot;对该用户而言,某个事物或属性是透明的&quot;,这与日常生活中&quot;透明&quot;的概念(公开、看得见)正好相反</p>
</li>
</ul>
<p>例如:对于高级语言程序员来说,浮点数格式、乘法指令等这些指令的格式、数据如何在运算器中运算等都是透明的,而对于机器语言或者汇编语言程序员来说,指令的格式、机器结构、数据格式等则不是透明的</p>
<p>在 CPU 中<code>IR</code>、<code>MAR</code>和<code>MDR</code>对各类程序员都是透明的</p>
<blockquote>
<p>🤔<strong>计算机体系结构和计算机组成的区别是和联系是什么?</strong></p>
<p>计算机体系结构是指机器语言或汇编语言程序员所看到的传统机器的属性,包括指令集、数据类型、存储器寻址技术等,大多都属于抽象的属性。</p>
<p>计算机组成是指如何实现计算机体系结构所体现的属性,它包含对许多程序员类说透明的硬件细节。</p>
<p>例如:指令系统属于结构的问题,但指令的实现即如何取指令、分析指令、如何运算等都属于组成的问题。因此,当两台机器指令系统相同时,只能认为他们具有相同的结构,至于这两台机器如何实现其指令,完全可以</p>
</blockquote>
<h1 id="shu-ju-de-biao-shi-he-yun-suan">数据的表示和运算</h1>
<h2 id="mark-shu-zhi-yu-bian-ma-mark"><mark>数制与编码</mark></h2>
<h3 id="jin-wei-ji-shu-zhi-ji-qi-xiang-hu-zhuan-huan">进位计数制及其相互转换</h3>
<h4 id="jin-wei-ji-shu-fa">进位计数法</h4>
<p>常用的进位计数法有十进制、二进制、八进制、十六进制等</p>
<p>一个<code>r进制数</code>(K<sub>n</sub>K<sub>n-1</sub>…K<sub>0</sub>K<sub>-1</sub>…K<sub>-m</sub>)的数值可表示为:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>n</mi></msub><msup><mi>r</mi><mi>n</mi></msup><mo>+</mo><msub><mi>K</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mi>r</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>K</mi><mn>0</mn></msub><msup><mi>r</mi><mn>0</mn></msup><mo>+</mo><msub><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msub><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>K</mi><mrow><mo>−</mo><mi>m</mi></mrow></msub><msup><mi>r</mi><mrow><mo>−</mo><mi>m</mi></mrow></msup><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>n</mi></mrow><mrow><mo>−</mo><mi>m</mi></mrow></msubsup><msub><mi>K</mi><mi>i</mi></msub><msup><mi>r</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">K_n r^n+K_{n-1} r^{n-1}+\cdots+K_0 r^0+K_{-1} r^{-1}+\cdots+K_{-m} r^{-m}=\sum_{i=n}^{-m} K_i r^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.824664em;"></span><span class="strut bottom" style="height:1.101528em;vertical-align:-0.276864em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="minner">⋯</span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="minner">⋯</span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord">−</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord">−</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mop"><span class="op-symbol small-op mop" style="top:-0.0000050000000000050004em;">∑</span><span class="vlist"><span style="top:0.276864em;margin-left:0em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathit">n</span></span></span></span><span style="top:-0.403131em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord">−</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p>
<p>其中<code>r</code>是<mark>基数</mark>;r<sup>i</sup>是第 i 位的位权(整数位最低位规定为第 0 位);K<sub>i</sub>的取值可以是 0,1,…,r-1 共 r 个数码中的任意一个</p>
<p>数制的表示有 2 种方法，一种表示方法是<code>数字下标法</code>，对于不同进制的数可以将它们加上括号再用数字下标表示进制：</p>
<p>例如：（110010011111）2 代表二进制数 ； （6137）8 代表八进制数</p>
<p>另一种是用<code>后缀字母表示进制</code>：</p>
<p>二进制 <code>B</code> (binary)<br>
八进制 <code>O</code> (octal)<br>
十进制 <code>D</code> (decimal)<br>
十六进制 <code>H</code> (hexadecimal)</p>
<p>例如：（3AB）H 代表十六进制数；（2654）O 代表八进制数</p>
<blockquote>
<p>当没有下标或后缀时默认为十进制数。</p>
</blockquote>
<ol>
<li class="lvl-3">
<p><em>二进制</em>。计算机中用得最多的是基数为 2 的计数制,即 2 进制</p>
</li>
<li class="lvl-3">
<p><em>八进制</em>。只有 0~7 共 8 位数字,计数&quot;逢八进一&quot;,因为 r = 2<sup>3</sup>所以只要把二进制中的 3 位数码编为一组就是一位八进制数</p>
</li>
</ol>
<p>举个 🌰:将二进制数 1111000010.011101 转为 8 进制数</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E4%BA%8C%E8%BD%AC%E5%85%AB-1688436552298-4.svg" alt="二转八"></p>
<p>所以对应的 8 进制数为(1702.32)<sub>8</sub></p>
<ol start="3">
<li class="lvl-3">
<p><em>十六进制数</em>。也是二进制的一种常用的书写方式,其基数为 16,“逢十六进一”。每个十六进制数位可以取 0~9、A、B、C、D、E、F,A~F 表示 10~15。因为 r = 16 = 2<sup>4</sup>,所以只要把二进制中的 4 位数码编写为一组就是一位十六进制数</p>
</li>
</ol>
<p>举个 🌰:将二进制数 1111000010.011101 转为 16 进制数</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E4%BA%8C%E8%BD%AC%E5%8D%81%E5%85%AD.svg" alt="二转十六"></p>
<p>所以对应的 16 进制数为(3C2.68)<sub>16</sub></p>
<p><strong>将任意进制数转换为十进制数</strong></p>
<p>将任意一个进制数的各位数码与他们的权值相乘,再把乘积相加,就得到了一个十进制数。这种方法称为<code>按权展开相加法</code></p>
<p>举个 🌰:将二进制数 11011.1 转为 10 进制数</p>
<p>(11011.1)<sub>2</sub> = 1×2<sup>4</sup> + 1×2<sup>3</sup> + 1×2<sup>1</sup> + 1×2<sup>0</sup> + 1×2<sup>-1</sup> = 27.5</p>
<p><strong>将十进制数转换为任意进制数</strong></p>
<p>一个十进制数转换为任意进制数,其整数部分常采用**<code>除基取余法</code><strong>,余数部分常采用</strong><code>乘基取余法</code>**</p>
<p><mark>除基取余法</mark></p>
<p>整数部分除基取余,最先取得的余数为数的最低位,最后取得的余数为数的最高位,商为 0 时结束</p>
<p><mark>乘基取整法</mark></p>
<p>小数部分乘基取整,最先取得的整数为数的最高位,最后取得的整数为数的最低位,乘积为 1.0(或满足精度要求)时结束</p>
<p>举个 🌰:将十进制数 123.6875 转为 2 进制数</p>
<p><strong>整数部分</strong>:<code>除基取余</code></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E9%99%A4%E5%9F%BA%E5%8F%96%E4%BD%99.svg" alt="除基取余"></p>
<p><strong>小数部分</strong>:<code>乘基取整</code></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E4%B9%98%E5%9F%BA%E5%8F%96%E6%95%B4.svg" alt="乘基取整"></p>
<p>所以(123.6875)<sub>10</sub> = (1111011.1011)<sub>2</sub></p>
<blockquote>
<p>🚨 在计算机中,小数和整数不一样,整数可以连续表示,但小数是离散的,所以并不是每一个十进制小数都可以准确地用二进制表示。例如 0.3。但任意一个二进制小数都可以用十进制小数表示</p>
</blockquote>
<p><strong>真值和机器数</strong></p>
<p>在计算机中,通常将数的符号和数值部分一起编码,将数据的符号数字化,通常使用<code>&quot;0&quot;</code>表示<code>&quot;正&quot;</code>,用<code>&quot;1&quot;</code>表示<code>&quot;负&quot;</code>。这种把符号&quot;数字化&quot;的数称为<code>机器数</code>。常用的有原码、补码和反码表示法。如 0,101(这里的逗号&quot;,&quot;仅为区分符号位与数值位)表示+5</p>
<h3 id="ding-dian-shu-de-bian-ma-biao-shi">定点数的编码表示</h3>
<p>根据小数点的位置是否固定,在计算机中有两种数据格式:<mark>定点表示</mark>和<mark>浮点表示</mark>。在现代计算机中,通常用定点补码整数表示整数,用定点原码小数表示浮点数的尾数部分,用移码表示浮点数的阶码部分。</p>
<h4 id="ji-qi-shu-de-ding-dian-biao-shi">机器数的定点表示</h4>
<p><strong>定点小数</strong>:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B0.svg" alt="定点小数"></p>
<p><strong>定点整数</strong>:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9A%E7%82%B9%E6%95%B4%E6%95%B0-1688458349449-11.svg" alt="定点整数"></p>
<blockquote>
<p>🙋‍♂️ 上图中的小数点其实并不真实存在,而是隐含位,是由计算机硬件进行处理的</p>
</blockquote>
<p><code>定点数编码表示法</code>主要有以下 4 种:<mark>原码</mark>、<mark>补码</mark>、<mark>反码</mark>和<mark>移码</mark></p>
<h4 id="yuan-ma-bu-ma-fan-ma-yi-ma">原码、补码、反码、移码</h4>
<h5 id="yuan-ma-biao-shi-fa">原码表示法</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p><em>纯小数原码定义</em></p>
</li>
</ul>
<p>[x]_{\text{原}} = \begin{cases} x & 1 > x \geq 0 \\ 1 - x = 1 + | x | & 0 \geq x > - 1 \end{cases} ( [ x ] _ { 原 }\text{是原码机器数,x 是真值})</p>
<p>例如,若 x<sub>1</sub> = +0.1101, x<sub>2</sub> = -0.1101,字长为 8 位,则其原码表示为[x<sub>1</sub>]<sub>原</sub> = <strong>0</strong>.1101000,[x<sub>2</sub>]<sub>原</sub> = <strong>1</strong>.1101000</p>
<p>若字长为 n+1,则原码小数的表示范围为 -(1-2<sup>-n</sup>) &lt;= x &lt;= 1-2<sup>-n</sup>(关于原点对称)</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><em>纯整数原码定义<sup>*</sup></em></p>
</li>
</ul>
<p>[x]_\text{原}=\begin{cases}0,x&2^n>x\geq0\\2^n-x=2^n+|x|&0\geq x>-2^n\end{cases}(x+\text{是真值,}n\text{ 是整数位数)}</p>
<blockquote>
<p>🚨 真值零的原码表示有正零和负零两种形式,即[+0]<sub>原</sub> = <strong>0</strong>0000 和[-0]<sub>原</sub> = <strong>1</strong>0000</p>
</blockquote>
<p>原码的优点是 与真值的对应关系简单、直观,与真值的转换简单,并且用原码实现乘除运算比较简单。</p>
<p>缺点是,0 的表示不唯一,更重要的是原码加减运算比较复杂(其复杂体现在对于两个不同符号数的加法(或同符号数的减法),先要比较两个数绝对值大小,再用绝对值大的数减去绝对值小的数,最后还要给结果选择合适的符号)</p>
<h5 id="bu-ma-biao-shi-fa">补码表示法</h5>
<p>补码的加减运算同一用加法操作实现</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>纯小数补码定义(了解)</p>
</li>
</ul>
<p>[x]_{\text{补}}=\begin{cases}x&1>x\geq0\\2+x=2-\mid x\mid&0>x\geq-1\end{cases}({\mathrm{mod}}2)</p>
<p>若字长为 n+1,则补码表示范围为-1 &lt;= x &lt;= 1-2<sup>-n</sup> (比原码多表示-1)</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>纯整数的补码定义</p>
</li>
</ul>
<p>[x]_\text{补}=\begin{cases}0,x&2^n>x\geq0\\2^{n+1}+x=2^{n+1}-\mid x\mid&0\geq x\geq-2^n\end{cases}\pmod{2^{n+1}}</p>
<p>若字长为 n+1,则补码的表示范围为-2<sup>n</sup> &lt;= x &lt;= 2<sup>n-1</sup> (比原码多-2<sup>n</sup>)</p>
<p><strong>补码计算法定义：非负数的补码是其原码本身；负数的补码是其绝对值的原码最高位符号位不变，其它位取反，再加 1。</strong></p>
<p>一个字节 8 位，如果采用原码表示正整数（含 0），可以表达 0-255，即 2<sup>8</sup>=256，一共 256 种状态，从全 0 到全 1 的各种排列组合。如果要表示负数，则符号位需要占用一位（最高位，1 代表负数，0 代表正数），因此其绝对值最大范围为 0-127，即 2<sup>7</sup>=128，一共正负各 128 种状态，如果不采用特殊处理，这时候 0 占用 2 个编码（10000000 和 00000000），数据表示范围为-127 到-0 及+0 到 127，这样总体上一个字节只有 255 种状态，因为其中 0 具有正 0 和负 0 之分，这不符合数学意义也浪费一个编码。</p>
<pre><code class="language-css">  除了以上的弊端，还有个原因是，早期硬件很昂贵，一位或者一个编码的浪费都是不可饶恕的，因此人们想到了另一种编码把负0利用起来，即当遇到负数时，采用补码来表示就可以解决这个问题，而遇到正数或0时还是保留原码表示。因此这个负0通过补码算法处理后自然而然地被利用起来，用来表示-128.

补码的算法为：绝对值的原码各位取反后加1.
例1：负1的补码：
    绝对值的8位原码为00000001
    取反：11111110
    加1 ：11111111
    此时最高位被处理为1，满足高位为1代表负数的定义。
例2：负128的补码：
    绝对值的8位原码为10000000
    取反：01111111
    加1 ：10000000
</code></pre>
<p>此时同样的最高位被置为 1，同样满足高位为 1 代表负数的定义,同时原先表示负 0 的编码被利用起来表示-128。因此一个字节的有符号整数范围为-128 到 127。</p>
<p>综上为：</p>
<pre><code class="language-css"> 原码+反码：8位原码和反码能够表示数的范围是-127~127；

 补码：8位补码能够表示数的范围是 -128~127。

（在补码中用(-128)代替了(-0)，所以补码的表示范围为：(-128~0~127)共256个）
</code></pre>
<ul class="lvl-0">
<li class="lvl-2">
<p>变形补码</p>
</li>
</ul>
<p>变形补码,又称模 4 补码,双符号位的补码小数</p>
<p>概念:</p>
<p>用两个二进制位来表示符号位，其余位与补码相同，【例如模 2 补码的-3 为 1101,模 2 用 1 位，这里是最高位表示符号位，剩下 3 位是 3 的补码，同样模 4 补码表示-3 为 11_101,模 4 用两位表示符号位，这里是最高两位 11，其余 3 位为 3 的补码】总的说来就是符号位左边那一位表示正确的符号(这就说明了选择题里面存储模 4 补码只需要一个符号位是正确的，因为任意一个正确的数值，模 4 补码的符号位两个都是一样的，只需存储一个就行了)，0 为正，1 为负；右边那一位如果和左边的相同，如 &quot;00”表示正且无溢出，&quot;11&quot;表示负且无溢出。如果右边那一位与左边那一位不一样，则表示有溢出。</p>
<h5 id="fan-ma-biao-shi-fa">反码表示法</h5>
<p>反码表示法的定义就是,负数补码的最后一位减 1,整正数反码的的定义与相应的补码(或原码)表示相同</p>
<p>0 的表示不唯一</p>
<h5 id="yi-ma-biao-shi-fa">移码表示法</h5>
<p>移码常用来表示浮点数的阶码,他只能表示整数</p>
<p>移码就是真值 X 上加上一个常数(偏置值),通常这个常数取 2<sup>n</sup>,相当于 X 在数轴上正方向偏移了若干单位,这就是&quot;移码&quot;一词的由来。</p>
<p>移码的定义为:</p>
<p>[x]_{移}=2^{n}+x(2^{n}>x\geq-2^{n},\text{ 其中机器字长为 }n+1)</p>
<p>若正数 x<sub>1</sub> = +10101,x<sub>2</sub> = -10101,字长为 8 位则其移码表示为 x~1 移~ = 2<sup>7</sup>+10101 =&gt; 1,0010101 ;x~2 移~ = 2<sup>7</sup>+(-10101) =&gt; 0,1101011</p>
<p>一个真值的移码与补码仅差一个符号位,[x]<sub>补</sub>的符号位取反即得[x]<sub>移</sub></p>
<p>移码中零的表示唯一</p>
<p>移码全 0,对应真值的最小值-2<sup>n</sup>;移码全 1 时,对应真值最大值 2<sup>n</sup>-1</p>
<h2 id="yun-suan-fang-fa-he-yun-suan-dian-lu">运算方法和运算电路</h2>
<h3 id="ji-ben-yun-suan-bu-jian">基本运算部件</h3>
<p>在计算机中,运算器由算数逻辑单元(Arithmetic Logic Unit, ALU)、移位器、状态寄存器和通用寄存器等组成的。运算器的基本功能包括加减乘除四则运算,与、或、非、异或等逻辑运算,以及移位、求补等操作。<code>ALU</code>的核心部件是<code>加法器</code></p>
<p><strong>以下是一些常用的逻辑符号</strong>👇:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7.svg" alt="逻辑符号"></p>
<h4 id="strong-gong-shi-he-ding-li-strong"><strong>公式和定理</strong>👨‍🏫</h4>
<p><em>常量之间的关系</em>:</p>
<p>\begin{aligned}&\text{公式1} && 0 \cdot 0 = 0 \\&\text{公式}1' && 1 + 1 = 1 \\&\text{公式2} && 0 \cdot 1 = 0 \\&\text{公式}2' && 1 + 0 = 1 \\&\text{公式3} && 1 \cdot 1 = 1 \\&\text{公式}3' && 0 + 0 = 0 \\&\text{公式4} && \overline{0} = 1 \\&\text{公式}4' && \overline{1} = 0 \\\end{aligned}</p>
<p><em>常量与变量的关系</em></p>
<p>\begin{aligned}&\text{公式5} && A\cdot1=A \\&\text{公式}5' &&  A+0=A \\&\text{公式6} && A\cdot0=0 \\&\text{公式}6' && A+1=1 \\&\text{公式7} && A\cdot\overline{A}=0 \\&\text{公式}7' && A+\overline{A}=1 \end{aligned}</p>
<p><em>与普通代数相似的定理</em></p>
<p>\begin{aligned}&\textbf{交换律} \\&\text{公式8}&& A\cdot B=B\cdot A  \\&\text{公式8}'&& A+B=B+A  \\&\textbf{结合律} \\&\text{公式9}&& \left(A\cdot B\right)\cdot C=A\cdot\left(B\cdot C\right)  \\&\text{公式}9'&& \left(A+B\right)+C=A+\left(B+C\right)  \\&\textbf{分配律} \\&\text{公式10}&& A\cdot\left(B+C\right)=A\cdot B+A\cdot C  \\&公式10^{\prime}&& A+B\cdot C=\left(A+B\right)\cdot\left(A+C\right) \end{aligned}</p>
<p><em>逻辑代数的一些特殊定理</em></p>
<p>\begin{aligned}&\textbf{同一律} \\&\text{公式 11}&& A\cdot A=A  \\&\text{公式 11}'&& A+A=A  \\&\textbf{德·摩根定理} \\&\text{公式 12}&& \overline{A\cdot B}=\overline{A}+\overline{B}  \\&\text{公式 12}'&& \overline{A+B}=\overline{A}\cdot\overline{B}  \\&\textbf{还原律} \\&\text{公式13}&& \overline{\overline{A}}=A \end{aligned}</p>
<p><em>若干常用公式</em></p>
<p>\begin{aligned} &\text{公式14} && A \cdot B + A \cdot \overline{B} = A \\ &\text{公式15} && A + A \cdot B = A \\ &\text{公式16} &&A+\overline{A}\cdot B=A+B\end{aligned}</p>
<h4 id="luo-ji-han-shu-de-gong-shi-hua-jian-fa">逻辑函数的公式化简法</h4>
<p><strong>一、并项法</strong></p>
<p>利用公式 14 把两个乘积项合并起来,消除一个变量。</p>
<p>🌰:化简函数 Y = ABC + AB┐C+ ┐AB</p>
<pre><code class="language-css">AB C + AB ┐C =&gt; AB
AB + ┐AB =&gt; B
</code></pre>
<p><strong>二、吸收法</strong></p>
<p>利用公式 15,吸收掉多余的乘积项</p>
<p>🌰:化简函数 Y =┐(AB) + ┐AD+ ┐BE</p>
<pre><code class="language-css">利用摩根公式
┐(AB) = ┐A + ┐B
┐A + ┐AD =&gt; ┐A
┐B + ┐BE =&gt; ┐B
=&gt; ┐A + ┐B
</code></pre>
<p><strong>三、消去法</strong></p>
<p>利用公式 16 消去乘积中多余的乘积项</p>
<p>🌰:化简函数 Y = ┐(AB) + AC+ BD</p>
<pre><code class="language-css">利用摩根公式
┐(AB) = ┐A + ┐B
=&gt; ┐A + ┐B + C + D
</code></pre>
<h4 id="luo-ji-han-shu-de-tu-xing-hua-jian-fa">逻辑函数的图形化简法</h4>
<p>用卡诺图化简逻辑函数,求最简与或表达式的方式被称为图形化简法。图形化简法有较明确的步骤可以遵循,但是变量超过 6 个以上的时候就没什么实用价值了</p>
<p><strong>卡诺图化简法</strong></p>
<p>卡诺图是一种最小项方块图,卡诺图的特点是用几何相邻形象地表示各变量各个最小项在逻辑上的相邻性</p>
<p>下图为变量 AB 的卡诺图:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/2%E5%8D%A1%E8%AF%BA%E5%9B%BE.svg" alt="2卡诺图"></p>
<blockquote>
<p>🚨 上图中 ┐A┐B 不能画作 ┐(AB)只是画图时连接在了一起,二者并不等价</p>
<p>之后的图省略 ┐A┐B 等为 0 或 1,在逻辑函数中的最小项有 ┐A┐B 则在 卡诺图中 00 位置 填 1</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/test1.svg" alt="test1"></p>
</blockquote>
<p>三变量的卡诺图:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/3%E5%8D%A1%E8%AF%BA%E5%9B%BE.drawio.svg" alt="3卡诺图.drawio"></p>
<p>下图为四变量的卡诺图:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/4%E5%8D%A1%E8%AF%BA%E5%9B%BE.svg" alt="4卡诺图"></p>
<p>五变量的卡诺图:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/5%E5%8D%A1%E8%AF%BA%E5%9B%BE.drawio.svg" alt="5卡诺图.drawio"></p>
<p>六变量的卡诺图:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/6%E5%8D%A1%E8%AF%BA%E5%9B%BE.svg" alt="6卡诺图"></p>
<blockquote>
<p>🤔<strong>为什么卡诺图中的变量取值是 00 01 11 10 而不是 00 01 10 11?</strong></p>
<p>因为卡诺图的画法是按循环码排列变量取值顺序。<strong>循环码的特点是相邻编码之间只有 1 位码元不同</strong>,而若是 01 10 则有两位码元相同。变量取值之所以按循环码排列,是因为保证卡诺图中,凡是几何相邻的最小项,在逻辑上是相邻的这一重要特点</p>
</blockquote>
<p><strong>卡诺图的化简</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><em>几何相邻</em></p>
<ul class="lvl-2">
<li class="lvl-4">相接——紧挨着的方块</li>
<li class="lvl-4">相对——任一行或者一列的两头</li>
<li class="lvl-4">相重——对折起来后位置重合</li>
</ul>
</li>
<li class="lvl-2">
<p><em>逻辑相邻</em></p>
</li>
</ul>
<p>如果两个最小项,除了一个变量的形式不同以外,其余的都相同,那么这两个最小项就称为在逻辑上相邻</p>
<p>卡诺图中凡是几何相邻的最小项均可合并,合并时能消除有关变量。两个最小项合并成一项时可以消去一个变量,4 个最小项合并成一项可以消除 2 个变量,8 个最小项合并可以消除 3 个变量。所以一般来说 2<sup>n</sup>个最小项合并时可以消去 n 个变量。(即一次看一列或者一行,若有一个码元发生改变,即消除那个发生改变的码元)</p>
<p>🌰:用图形化化简函数</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi><mo>=</mo><mover accent="true"><mrow><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mi>C</mi><mi>D</mi><mo>+</mo><mi>B</mi><mover accent="true"><mrow><mi>C</mi></mrow><mo stretchy="true">‾</mo></mover><mo>+</mo><mover accent="true"><mrow><mi>A</mi></mrow><mo stretchy="true">‾</mo></mover><mspace width="0.22222em"></mspace><mover accent="true"><mrow><mi>C</mi></mrow><mo stretchy="true">‾</mo></mover><mi>D</mi><mo>+</mo><mi>A</mi><mover accent="true"><mrow><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mi>C</mi></mrow><annotation encoding="application/x-tex">Y=\overline{B}CD+B\overline{C}+\overline{A}\:\overline{C}D+A\overline{B}C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8833300000000001em;"></span><span class="strut bottom" style="height:0.9666600000000001em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="mrel">=</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">A</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mord mspace mediumspace"></span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mbin">+</span><span class="mord mathit">A</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span></p>
<blockquote>
<p>┐A┐CD</p>
</blockquote>
<p>① 画出函数的卡诺图</p>
<p>观察函数,发现函数只有 4 个不同的变量 ABCD,画出四变量卡诺图,在图中标出 Y 所包含的全部最小项,如下图<br>
<img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/1testtest.svg" alt="1"></p>
<p>② 合并最小项</p>
<p>合并原则是:</p>
<pre><code class="language-css">- 必须包含函数的所有最小项,并且保证合并后的乘积项的总数最少
- 相邻的最小项合并时,蕴含的最小项数越多,则合并后的乘积因子最少
- 每次合并时,为了消去更多变量,可以重复使用函数的最小项,但是必须保证至少包含1个新的最小项(未被重复使用过),以避免冗余项的出现
</code></pre>
<p><strong>圈要少、圈最大（先少后大）</strong></p>
<p>化简中注意的问题:</p>
<p>➢ 每一个标 1 的方格必须至少被圈一次;</p>
<p>➢ 每个圈中包含的相邻小方格数,必须为 2 的整数次幂;</p>
<p>➢ 为了得到尽可 能大的圈，圈与圈之间可以重叠;</p>
<p>➢ 若某个圈中的标 1 方格,已经完全被其它圈所覆盖,则该圈为多余的。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%8C%96%E7%AE%80.svg" alt="化简"></p>
<p>结果为:Y = B┐C + ┐A┐BD + A┐BC</p>
<p><strong>五变量化简卡诺图</strong></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/5%E5%8C%96%E7%AE%80.svg" alt="5化简"></p>
<p>因为红圈部分为 ┐E 所独有,则在 ┐E 中的化简中 ┐E 不能消除,绿圈中为 ┐E 和 E 图中共有,则消去 E 变量,再把二图中的所得结果相与则可得出最终答案</p>
<h4 id="yi-wei-quan-jia-qi">一位全加器</h4>
<p>全加器(FA)是最基本的加法单元,有加数 A<sub>i</sub>、加数 B<sub>i</sub>与低位传来的进位 C<sub>i-1</sub>共三个输入,有本位和 S<sub>i</sub>与向高位的进位 C<sub>i</sub>共两个输出。</p>
<p>其真值表为:</p>
<table>
<thead>
<tr>
<th style="text-align:center">A<sub>i</sub>(加数)</th>
<th style="text-align:center">B<sub>i</sub>(加数)</th>
<th style="text-align:center">C<sub>i-1</sub>(低位进位)</th>
<th style="text-align:center">S<sub>i</sub>(本位)</th>
<th style="text-align:center">C<sub>i</sub>(向高位进位)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>表中目标值(S<sub>i</sub>、C<sub>i</sub>)为 1 的行保留,其他行舍弃</p>
<p>可得:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">S</mi><mo>=</mo><mover accent="true"><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><mo stretchy="true">‾</mo></mover><mspace width="0.22222em"></mspace><mover accent="true"><mrow><msub><mi>B</mi><mi>i</mi></msub></mrow><mo stretchy="true">‾</mo></mover><msub><mi mathvariant="normal">C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mover accent="true"><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><mo stretchy="true">‾</mo></mover><msub><mi mathvariant="normal">B</mi><mi>i</mi></msub><mover accent="true"><mrow><msub><mi>C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><mo stretchy="true">‾</mo></mover><mo>+</mo><msub><mi mathvariant="normal">A</mi><mi>i</mi></msub><mover accent="true"><mrow><msub><mi>B</mi><mi>i</mi></msub></mrow><mo stretchy="true">‾</mo></mover><mspace width="0.22222em"></mspace><mover accent="true"><mrow><msub><mi>C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><mo stretchy="true">‾</mo></mover><mo>+</mo><msub><mi mathvariant="normal">A</mi><mi>i</mi></msub><msub><mi mathvariant="normal">B</mi><mi>i</mi></msub><msub><mi mathvariant="normal">C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\mathrm S=\overline{A_i}\:\overline{B_i}\mathrm C_{i-1}+\overline{A_i}\mathrm B_i\overline{C_{i-1}}+\mathrm A_i\overline{B_i}\:\overline{C_{i-1}} +\mathrm A_i\mathrm B_i\mathrm C_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8833300000000001em;"></span><span class="strut bottom" style="height:1.091661em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">S</span><span class="mrel">=</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mord mspace mediumspace"></span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05017em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05017em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mord mspace mediumspace"></span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p>
<p>由卡诺图化简得:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">S</mi><mo>=</mo><msub><mi mathvariant="normal">A</mi><mi mathvariant="normal">i</mi></msub><mo>⊗</mo><msub><mi mathvariant="normal">B</mi><mi mathvariant="normal">i</mi></msub><mo>⊗</mo><msub><mi mathvariant="normal">C</mi><mrow><mi mathvariant="normal">i</mi><mo>−</mo><mn mathvariant="normal">1</mn></mrow></msub></mrow></mrow><annotation encoding="application/x-tex">\mathrm{S=A_i\otimes B_i\otimes C_{i-1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">S</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">⊗</span><span class="mord"><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">⊗</span><span class="mord"><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">C</mi><mrow><mi mathvariant="normal">i</mi></mrow></msub><mo>=</mo><msub><mi mathvariant="normal">A</mi><mi>i</mi></msub><msub><mi mathvariant="normal">B</mi><mi>i</mi></msub><mo>+</mo><msub><mi mathvariant="normal">B</mi><mi>i</mi></msub><msub><mi mathvariant="normal">C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi mathvariant="normal">C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi mathvariant="normal">A</mi><mi>i</mi></msub><mo>=</mo><msub><mi mathvariant="normal">A</mi><mi>i</mi></msub><msub><mi mathvariant="normal">B</mi><mi>i</mi></msub><mo>+</mo><mo>(</mo><mi mathvariant="normal">A</mi><mo>⊗</mo><mi mathvariant="normal">B</mi><mo>)</mo><msub><mi mathvariant="normal">C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\mathrm C_{\mathrm i}=\mathrm A_i\mathrm B_i+\mathrm B_i\mathrm C_{i-1}+\mathrm C_{i-1}\mathrm A_i=\mathrm A_i\mathrm B_i+(\mathrm A\otimes\mathrm B)\mathrm C_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">i</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathrm">A</span><span class="mbin">⊗</span><span class="mord mathrm">B</span><span class="mclose">)</span><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p>
<p>可以由此画出一位全加器的逻辑结构为:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%8A%A0%E6%B3%95%E5%99%A8.svg" alt="加法器"></p>
<p>由此可以得出<strong>N 位串行进位加法器</strong>的结构:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/N-1688645147129-17.svg" alt="N"></p>
<blockquote>
<p>🙋‍♂️ 在串行进位加法器的最长运算时间是由产生的进位信号所产生的传递延迟所决定的,位数越多延迟时间越长.所以人们又设计出了并行进位加法器</p>
</blockquote>
<p><strong>并行进位加法器</strong></p>
<p>由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">C</mi><mrow><mi mathvariant="normal">i</mi></mrow></msub><mo>=</mo><msub><mi mathvariant="normal">A</mi><mi>i</mi></msub><msub><mi mathvariant="normal">B</mi><mi>i</mi></msub><mo>+</mo><msub><mi mathvariant="normal">B</mi><mi>i</mi></msub><msub><mi mathvariant="normal">C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi mathvariant="normal">C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi mathvariant="normal">A</mi><mi>i</mi></msub><mo>=</mo><msub><mi mathvariant="normal">A</mi><mi>i</mi></msub><msub><mi mathvariant="normal">B</mi><mi>i</mi></msub><mo>+</mo><mo>(</mo><mi mathvariant="normal">A</mi><mo>⊗</mo><mi mathvariant="normal">B</mi><mo>)</mo><msub><mi mathvariant="normal">C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\mathrm C_{\mathrm i}=\mathrm A_i\mathrm B_i+\mathrm B_i\mathrm C_{i-1}+\mathrm C_{i-1}\mathrm A_i=\mathrm A_i\mathrm B_i+(\mathrm A\otimes\mathrm B)\mathrm C_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">i</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathrm">A</span><span class="mbin">⊗</span><span class="mord mathrm">B</span><span class="mclose">)</span><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,令 G<sub>i</sub>= A<sub>i</sub>B<sub>i</sub>,P<sub>i</sub>=A⊕B,可得 C<sub>i</sub>=G<sub>i</sub>+P<sub>i</sub>C<sub>i-1</sub></p>
<p>将 G<sub>i</sub>和 P<sub>i</sub>带入前面的 C<sub>1</sub>~C<sub>4</sub>中可得:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mtext><mi mathvariant="normal">C</mi><mn>1</mn></mtext><mo>=</mo><msub><mi>G</mi><mrow><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>1</mn></mrow></msub><msub><mi>C</mi><mrow><mn>0</mn></mrow></msub></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><msub><mi>C</mi><mrow><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>G</mi><mrow><mn>2</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>2</mn></mrow></msub><msub><mi>C</mi><mrow><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>G</mi><mrow><mn>2</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>2</mn></mrow></msub><msub><mi>G</mi><mrow><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>2</mn></mrow></msub><msub><mi>P</mi><mrow><mn>1</mn></mrow></msub><msub><mi>C</mi><mrow><mn>0</mn></mrow></msub></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><msub><mi>C</mi><mrow><mn>3</mn></mrow></msub><mo>=</mo><msub><mi>G</mi><mrow><mn>3</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>3</mn></mrow></msub><msub><mi>C</mi><mrow><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>G</mi><mrow><mn>3</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>3</mn></mrow></msub><msub><mi>G</mi><mrow><mn>2</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>3</mn></mrow></msub><msub><mi>P</mi><mrow><mn>2</mn></mrow></msub><msub><mi>G</mi><mrow><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>3</mn></mrow></msub><msub><mi>P</mi><mrow><mn>2</mn></mrow></msub><msub><mi>P</mi><mrow><mn>1</mn></mrow></msub><msub><mi>C</mi><mrow><mn>0</mn></mrow></msub></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><msub><mi>C</mi><mrow><mn>4</mn></mrow></msub><mo>=</mo><msub><mi>G</mi><mrow><mn>4</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>4</mn></mrow></msub><msub><mi>C</mi><mrow><mn>3</mn></mrow></msub><mo>=</mo><msub><mi>G</mi><mrow><mn>4</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>4</mn></mrow></msub><msub><mi>G</mi><mrow><mn>3</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>4</mn></mrow></msub><msub><mi>P</mi><mrow><mn>3</mn></mrow></msub><msub><mi>G</mi><mrow><mn>2</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>4</mn></mrow></msub><msub><mi>P</mi><mrow><mn>3</mn></mrow></msub><msub><mi>P</mi><mrow><mn>2</mn></mrow></msub><msub><mi>G</mi><mrow><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>4</mn></mrow></msub><msub><mi>P</mi><mrow><mn>3</mn></mrow></msub><msub><mi>P</mi><mrow><mn>2</mn></mrow></msub><msub><mi>P</mi><mrow><mn>1</mn></mrow></msub><msub><mi>C</mi><mrow><mn>0</mn></mrow></msub></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}&amp;\text{C1} =G_{1}+P_{1}C_{0}  \\&amp;C_{2} =G_{2}+P_{2}C_{1}=G_{2}+P_{2}G_{1}+P_{2}P_{1}C_{0}  \\&amp;C_{3} =G_{3}+P_{3}C_{2}=G_{3}+P_{3}G_{2}+P_{3}P_{2}G_{1}+P_{3}P_{2}P_{1}C_{0}  \\&amp;C_{4} =G_{4}+P_{4}C_{3}  =G_{4}+P_{4}G_{3}+P_{4}P_{3}G_{2}+P_{4}P_{3}P_{2}G_{1}+P_{4}P_{3}P_{2}P_{1}C_{0} \end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:2.6500000000000004em;"></span><span class="strut bottom" style="height:4.800000000000001em;vertical-align:-2.1500000000000004em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-1.8100000000000003em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span style="top:-0.6100000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span style="top:0.5900000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span style="top:1.7900000000000003em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="col-align-l"><span class="vlist"><span style="top:-1.8100000000000003em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="text mord textstyle uncramped"><span class="mord mathrm">C</span><span class="mord mathrm">1</span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.6100000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:0.5900000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:1.7900000000000003em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></p>
<p>可知 G<sub>i</sub>在 A<sub>i</sub>B<sub>i</sub>输入时就已得出,唯一需要等待的是 C<sub>0</sub>(因为 C<sub>i</sub>可以用 C<sub>0</sub>推导出)</p>
<p>所以其他位在 C<sub>0</sub>形成时就可同时生成,但是这样的缺陷是,位数越多,电路越复杂</p>
<h3 id="ding-dian-shu-de-yun-suan">定点数的运算</h3>
<h4 id="ding-dian-shu-de-yi-wei-yun-suan">定点数的移位运算</h4>
<p>移位运算根据操作对象的不同分为<code>算术移位</code>和<code>逻辑移位</code>。<strong>有符号数的移位称为算术移位</strong>，<strong>逻辑移位的操作对象是逻辑代码,可视为无符号数</strong>。</p>
<h5 id="suan-zhu-yi-wei">算术移位</h5>
<p>算术移位的对象是有符号数，在移位过程中<code>符号位保持不变</code> 。</p>
<p>对于正数，由于[x]<sub>原</sub> = [x]<sub>补</sub> = [x]<sub>反</sub> = 真值，因此移位后出现的空位均以 0 添之。对于负数，由与原码，补码，反码的表示形式不同，因此当机器数移位时，对其空位的添补规则也不同</p>
<blockquote>
<p>🙋‍♂️ 不论是正数还是负数，移位后其符号位均不变，且移位后都相当于对真值补 0，根据补码、反码的特性，所以在负数时填补代码有区别。</p>
</blockquote>
<p>对于原码，左移一位若不产生溢出，相当于乘以 2(与十进制的左移一位相当于乘以 10 类似)，右移一位，若不考虑因移出而舍去的末位尾数，相当于除以 2。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210706102244.png" alt="img"></p>
<p>由表 2.1👆 可以得出如下结论。</p>
<p>正数的原码、补码与反码都相同，因此移位后出现的空位均以 0 添之。对于负数，由于原码、补码和反码的表示形式不同，因此当机器数移位时，对其空位的添补规则也不同。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>负数的原码数值部分与真值相同，因此在移位时只要使符号位不变，其空位均添 0。</p>
</li>
<li class="lvl-2">
<p>负数的反码各位除符号位外与负数的原码正好相反，因此移位后所添的代码应与原码相反，即全部添 1。</p>
</li>
<li class="lvl-2">
<p>分析由原码得到补码的过程发现，当对其由低位向高位找到第一个“1”时，在此“1”左边的各位均与对应的反码相同，而在此“1”右边的各位（包括此“1”在内）均与对应的原码相同。因此负数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添 0;右移时因空位出现在高位，则添补的代码应与反码相同，即添 1。</p>
</li>
</ul>
<h5 id="luo-ji-yi-wei">逻辑移位</h5>
<p>逻辑移位将操作数视为无符号数，移位规则:逻辑左移时，高位移丢，低位添 0;逻辑右移时，低位移丢，高位添 0。</p>
<blockquote>
<p>🙋‍♂️ 逻辑移位不管是左移还是右移，都添 0。</p>
</blockquote>
<p>循环移位分为带进位标志位 CF 的循环移位(大循环）和不带进位标志位的循环移位（小循环)，过程如图 2.7 所示。</p>
<p>循环移位的主要特点是，移出的数位又被移入数据中，而是否带进位则要看是否将进位标志位加入循环位移。例如，带进位位的循环左移〔见图 2.7(d)]就是数据位连同进位标志位一起左移，数据的最高位移入进位标志位 CF，而进位位则依次移入数据的最低位。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210706102442.png" alt="img"></p>
<p>循环移位操作特别适合将数据的低字节数据和高字节数据互换。</p>
<pre><code class="language-css">带进位标志位CF的循环左移（大循环）：
假设有一个8位的二进制数：10101010，进位标志位CF的初始值为0。

带进位标志位CF的循环左移一位：

初始状态：10101010
左移一位后，数据位与进位标志位一起左移，数据的最高位移入进位标志位CF，而进位位则依次移入数据的最低位：
新状态：01010101，CF=1
带进位标志位CF的循环左移三位：

初始状态：10101010
左移三位后，数据位与进位标志位一起左移，数据的最高位移入进位标志位CF，而进位位则依次移入数据的最低位：
新状态：01010101，CF=1



不带进位标志位的循环左移（小循环）：
假设有一个8位的二进制数：10101010

不带进位标志位的循环左移一位：
初始状态：10101010
左移一位后，数据位循环左移，最高位移入最低位，不涉及进位标志位：
新状态：01010101

不带进位标志位的循环左移三位：
初始状态：10101010
左移三位后，数据位循环左移，最高位移入最低位，不涉及进位标志位：
新状态：01010101
</code></pre>
<h4 id="yuan-ma-ding-dian-shu-de-jia-jian-fa-yun-suan">原码定点数的加减法运算</h4>
<p>设[X]_\text{原}=x_s.x_1x_2\cdots x_n和[Y]_\text{原}=y_s.y_1y_2\cdots y_n,进行加减运算的规则如下。</p>
<p><code>加法规则</code>:先判符号位，若相同，则绝对值相加，结果符号位不变;若不同，则做减法，绝对值大的数减去绝对值小的数，结果符号位与绝对值大的数相同。</p>
<p><code>减法规则</code>:两个原码表示的数相减，首先将减数符号取反，然后将被减数与符号取反后的减数按原码加法进行运算。</p>
<blockquote>
<p>🙋‍♂️ 运算时注意机器字长，当左边位出现溢出时，将溢出位丢掉。</p>
</blockquote>
<h4 id="bu-ma-ding-dian-shu-jia-jian-fa-yun-suan">补码定点数加减法运算</h4>
<p>补码加减运算规则简单，易于实现，因此计算机系统中普遍采用补码加减运算。补码运算的特点如下（设机器字长为 n+1)。</p>
<ol>
<li class="lvl-3">
<p>参与运算的两个操作数均用补码表示。</p>
</li>
<li class="lvl-3">
<p>按二进制运算规则运算，逢二进一。</p>
</li>
<li class="lvl-3">
<p>符号位与数值位按同样规则一起参与运算，符号位运算产生的进位要丢掉，结果的符号位由运算得出。</p>
</li>
<li class="lvl-3">
<p>补码加减运算依据下面的公式进行。当参加运算的数是定点小数时，模 M= 2;当参加运算的数是定点整数时，模 M = 2<sup>n</sup>+1。</p>
</li>
</ol>
\begin{cases}{[A+B]_{\text {补 }}=[A]_{\text {补 }}+[B]_{\text {补 }},} & (\bmod M) \\ {[A-B]_{\text {补 }}=[A]_{\text {补 }}+[-B]_补,} & (\bmod M)\end{cases}

<blockquote>
<p>🙋‍♂️mod M 运算是为了将溢出位丢掉。</p>
</blockquote>
<p>也就是说，若做加法，则两数的补码直接相加;若做减法，则将被减数与减数的机器负数相加。</p>
<p><strong>补码运算的结果亦为补码</strong></p>
<p>设机器字长为 8 位（含 1 位符号位)，A= 15，B=24，求补[A+B]<sub>补</sub>和[A−B]<sub>补</sub>。</p>
<p>解：</p>
<p>A=+15=+0001111，B=+24=+0011000;得补[A]<sub>补</sub>= 00001111，[B]<sub>补</sub>=00011000。</p>
<p>求得[−B]<sub>补</sub> = 11101000。所以</p>
<p>[A+B]<sub>补</sub>=00001111+ 00011000 = 00100111，其符号位为 0，对应真值为+39。</p>
<p>[A−B]<sub>补</sub>=[A]<sub>补</sub>+[−B]<sub>补</sub>=00001111 + 11101000= 11110111，其符号位为 1，对应真值为-9。</p>
<h4 id="fu-hao-kuo-zhan">符号扩展</h4>
<p>在计算机算术运算中，有时必须把采用给定位数表示的数转换成具有不同位数的某种表示形式。例如，某个程序需要将一个 8 位数与另外一个 32 位数相加，要想得到正确的结果，在将 8 位数与 32 位数相加之前，必须将 8 位数转换成 32 位数形式，这称为“符号扩展”。</p>
<p>正数的符号扩展非常简单，即原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用 0 进行填充。</p>
<p>负数的符号扩展方法则根据机器数的不同而不同。原码表示负数的符号扩展方法与正数相同，只不过此时符号位为 1。补码表示负数的符号扩展方法:原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用 1(对于整数）或 0(对于小数）进行填充。反码表示负数的符号扩展方法:原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用 1 进行填充。</p>
<blockquote>
<p>正数相当于位数往左边扩展，负数相当于位数往右边扩展</p>
</blockquote>
<h4 id="yi-chu-gai-nian-he-pan-bie-fang-fa">溢出概念和判别方法</h4>
<p>溢出是指运算结果超过了数的表示范围。通常，称大于机器所能表示的最大正数为上溢，称小于机器所能表示的最小负数为下溢。定点小数的表示范围为|x|&lt;1，如图 2.8 所示。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210706143612.png" alt="img"></p>
<p>仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出，如两个正数相加，而结果的符号位却为 1(结果为负);一个负数减去一个正数，结果的符号位却为 0(结果为正)。定点数加减运算出现溢出时，运算结果是错误的。</p>
<p>补码定点数加减运算溢出判断的方法有 3 种。</p>
<p>(1）采用一位符号位</p>
<p>由于减法运算在机器中是用加法器实现的，因此无论是加法还是减法，只要参加操作的两个数符号相同，结果又与原操作数符号不同，则表示结果溢出。</p>
<p>设 A 的符号为 A<sub>s</sub>,B 的符号为 B<sub>s</sub>，运算结果的符号为 S<sub>s</sub>,则溢出逻辑表达式为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo>=</mo><msub><mi>A</mi><mi>s</mi></msub><msub><mi>B</mi><mi>s</mi></msub><msub><mover accent="true"><mrow><mi>S</mi></mrow><mo>¯</mo></mover><mi>s</mi></msub><mo>+</mo><msub><mover accent="true"><mrow><mi>A</mi></mrow><mo>¯</mo></mover><mi>s</mi></msub><msub><mover accent="true"><mrow><mi>B</mi></mrow><mo>¯</mo></mover><mi>s</mi></msub><msub><mi>S</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">V=A_sB_s\bar{S}_s+\bar{A}_s\bar{B}_sS_s
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8201099999999999em;"></span><span class="strut bottom" style="height:0.9701099999999999em;vertical-align:-0.15em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05017em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle cramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span style="top:-0.25233em;margin-left:0.16668em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>¯</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle cramped"><span class="mord mathit">A</span></span></span><span style="top:-0.25233em;margin-left:0.27778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>¯</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span style="top:-0.25233em;margin-left:0.16668em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>¯</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></p>
<p>若 V = 0，表示无溢出；若 V = 1，表示有溢出</p>
<p>(2）采用双符号位</p>
<p>双符号位法也称模 4 补码。运算结果的两个符号位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>s</mi><mn>1</mn></mrow></msub><msub><mi>S</mi><mrow><mi>s</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{s1}S_{s2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>相同，表示未溢出;运算结果的两个符号位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>s</mi><mn>1</mn></mrow></msub><msub><mi>S</mi><mrow><mi>s</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{s1}S_{s2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>不同，表示溢出，此时最高位符号位代表真正的符号。</p>
<p>符号位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>s</mi><mn>1</mn></mrow></msub><msub><mi>S</mi><mrow><mi>s</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{s1}S_{s2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>的各种情况如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>s</mi><mn>1</mn></mrow></msub><msub><mi>S</mi><mrow><mi>s</mi><mn>2</mn></mrow></msub><mo>=</mo><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">S_{s1}S_{s2} = 00</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span>:表示结果为正数，无溢出</p>
</li>
<li class="lvl-2">
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>s</mi><mn>1</mn></mrow></msub><msub><mi>S</mi><mrow><mi>s</mi><mn>2</mn></mrow></msub><mo>=</mo><mn>0</mn><mn>1</mn></mrow><annotation encoding="application/x-tex">S_{s1}S_{s2} = 01</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span></span></span></span>:表示结果为正溢出</p>
</li>
<li class="lvl-2">
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>s</mi><mn>1</mn></mrow></msub><msub><mi>S</mi><mrow><mi>s</mi><mn>2</mn></mrow></msub><mo>=</mo><mn>1</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">S_{s1}S_{s2} = 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span></span></span></span>:表示结果为负溢出</p>
</li>
<li class="lvl-2">
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>s</mi><mn>1</mn></mrow></msub><msub><mi>S</mi><mrow><mi>s</mi><mn>2</mn></mrow></msub><mo>=</mo><mn>1</mn><mn>1</mn></mrow><annotation encoding="application/x-tex">S_{s1}S_{s2} = 11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span></span></span></span>:表示结果为负数，无溢出</p>
</li>
</ul>
<p>即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>s</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>S</mi><mrow><mi>s</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{s1},S_{s2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>相等，无溢出，不等，溢出</p>
<h4 id="ding-dian-shu-de-cheng-fa-yun-suan">定点数的乘法运算</h4>
<p><strong>带符号的阵列乘法器</strong></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230716075309183.png" alt="image-20230716075309183"></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230715210620124.png" alt="image-20230715210620124"></p>
<blockquote>
<p>🚨 最后的补级输出是，先加上符号后，再求补</p>
</blockquote>
<h5 id="yuan-ma-yi-wei-cheng-fa">原码一位乘法</h5>
<h4 id="shu-ju-de-cun-chu-he-pai-lie">数据的存储和排列</h4>
<h5 id="shu-ju-de-da-duan-fang-shi-he-xiao-duan-fang-shi-cun-chu">数据的“大端方式”和“小端方式”存储</h5>
<p>在存储数据时，数据从低位到高位可以按从左到右排列，也可以按从右到左排列。因此，无法用最左或最右来表征数据的最高位或最低位，通常用<code>最低有效字节(Least Significant Bit,LSB)</code>和<code>最高有效字节(Most Significant Bit,MSB)</code>来分别表示数的低位和高位。例如，在 32 位计算机中，一个 int 型变量 i 的机器数为 0123 4567H，其最高有效字节 MSB= 01H，最低有效字节 LSB=67H。</p>
<p>现代计算机基本上都采用字节编址，即每个地址编号中存放 1 字节。不同类型的数据占用的字节数不同，int 和 float 型数据占 4 字节，double 型数据占 8 字节等，而程序中对每个数据只给定一个地址。假设变量 i 的地址为 80 00H，字节 01H、23H、45H、67H 应该各有一个内存地址，那么地址 08 00H 对应 4 字节中哪字节的地址呢?这就是字节排列顺序问题。</p>
<p>多字节数据都存放在连续的字节序列中，根据数据中各字节在连续字节序列中的排列顺序不同，可以采用两种排列方式:<code>大端方式(big endian)</code>和<code>小端方式(little endian)</code>，如图 2.9 所示 👇。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210706152204.png" alt="img"></p>
<p><code>大端方式</code><strong>按从最高有效字节到最低有效字节的顺序存储数据，即最高有效字节存放在前面</strong>;</p>
<p><code>小端方式</code><strong>按从最低有效字节到最高有效字节的顺序存储数据，即最低有效字节存放在前面</strong>。</p>
<p>在检查底层机器级代码时，需要分清各类型数据字节序列的顺序，例如以下是由反汇编器(汇编的逆过程，即将机器代码转换为汇编代码）生成的一行机器级代码的文本表示:</p>
<p>4004d3:01 05 64 94 04 08 add %eax,0x8049464</p>
<p>其中，“4004d3”是十六进制表示的地址，“01 05 43 0b 20 00”是指令的机器代码，“add %eax，Ox8049464”是指令的汇编形式，该指令的第二个操作数是一个立即数 0x8049464，执行该指令时，从指令代码的后 4 字节中取出该立即数，立即数存放的字节序列为 64H、94H、04H、08H，正好与操作数的字节顺序相反，即采用的是小端方式存储，得到 08049464H<br>
去掉开头的 0，得到值 0x8049464，在阅读小端方式存储的机器代码时，要注意字节是按相反顺序显示的。</p>
<pre><code class="language-css">【2019统考真题】某计算机采用大端方式，按字节编址。某指令中操作数的机器数为 1234 FF00H，该操作数采用基址寻址方式，形式地址（用补码表示）为 FF12H，基址寄存器的内容为 F000 0000H， 则该操作数的 LSB（最低有效字节）所在的地址是()
A.F000 FF12H
B.F000 FF15H
C.EFFF FF12H
D.EFFF FF15H

解：
由题中给出
形式地址由补码表示为FF12H(1111 1111 0001 0010B)，所以由对补码求补可得原码为1000 0000 1110 1110B 可知其真值为一个负数
将符号位提出后为000 0000 1110 1110B 转换为16进制可得 0000(补0)0000 1110 1110B =&gt; 00EEH 加上符号位后为 -00EEH

由操作数采用基址寻址可知 EA = (BR) + A = 即 F000 0000H - 0000 00EE
</code></pre>
<h5 id="shu-ju-an-bian-jie-dui-qi-fang-shi-cun-chu">数据按“边界对齐”方式存储</h5>
<p>假设存储字长为 32 位，可按字节、半字和字寻址。对于机器字长为 32 位的计算机，数据以边界对齐方式存放，半字地址一定是 2 的整数倍，字地址一定是 4 的整数倍,这样无论所取的数据是字节、半字还是字，均可一次放存取出。所存储的数据不满足上述要求时，通过填充空白字节使其符合要求。这样虽然浪费了一些存储空间，但可提高取指令和取数的速度。</p>
<p>数据不按边界对齐方式存储时，可以充分利用存储空间，但半字长或字长的指令可能会存储在两个存储字中，此时需要两次访存，并且对高低字节的位置进行调整、连接之后才能得到所要的指令或数据，从而影响了指令的执行效率。</p>
<p>例如，“字节 1、字节 2、字节 3、半字 1、半字 2、半字 3、字 1”的数据按序存放在存储器中，按边界对齐方式和不对齐方式存放时，格式分别如图 2.10 和图 2.11 所示。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210706152754.png" alt="img"></p>
<p>边界对齐方式相对边界不对齐方式是一种空间换时间的思想。RISC 如 ARM 采用边界对齐方式，而 CISC 如 x86 对齐和不对齐都支持。因为对齐方式取指令时间相同，因此能适应指令流水。</p>
<h2 id="c-yu-yan-xiang-guan">c 语言相关</h2>
<h4 id="ji-ben-shu-ju-lei-xing-suo-zhan-de-zi-jie-shu">基本数据类型所占的字节数</h4>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>32 位环境</th>
<th>64 位环境</th>
<th>16 位环境</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>8 位</td>
<td>8 位</td>
<td>8 位</td>
</tr>
<tr>
<td>unsigned char</td>
<td>8 位</td>
<td>8 位</td>
<td>8 位</td>
</tr>
<tr>
<td>short</td>
<td>16 位</td>
<td>16 位</td>
<td>16 位</td>
</tr>
<tr>
<td>unsigned short</td>
<td>16 位</td>
<td>16 位</td>
<td>16 位</td>
</tr>
<tr>
<td>int</td>
<td>32 位</td>
<td>32 位</td>
<td>16 位</td>
</tr>
<tr>
<td>unsigned int</td>
<td>32 位</td>
<td>32 位</td>
<td>16 位</td>
</tr>
<tr>
<td>long</td>
<td>32 位</td>
<td>64 位</td>
<td>32 位</td>
</tr>
<tr>
<td>unsigned long</td>
<td>32 位</td>
<td>64 位</td>
<td>32 位</td>
</tr>
<tr>
<td>long long</td>
<td>64 位</td>
<td>64 位</td>
<td>32 位</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>64 位</td>
<td>64 位</td>
<td>32 位</td>
</tr>
<tr>
<td>float</td>
<td>32 位</td>
<td>32 位</td>
<td>32 位</td>
</tr>
<tr>
<td>double</td>
<td>64 位</td>
<td>64 位</td>
<td>32 位</td>
</tr>
<tr>
<td>long double</td>
<td>96 位</td>
<td>128 位</td>
<td>80 位</td>
</tr>
</tbody>
</table>
<blockquote>
<p>sizeof(数据类型)会返回字节数 例如 sizeof(double) → 8</p>
</blockquote>
<p>2<sup>8</sup> = 256</p>
<p>2<sup>16</sup> = 65536</p>
<p>2<sup>32</sup> = 4294967296</p>
<p>2<sup>64</sup> = 18446744073709551616</p>
<pre><code class="language-CSS">【2018统考真题】按字节编址的计算机中，某 double 型数组 A 的首地址为 2000H，使用变址寻址和循环结构访问数组 A，保存数组下标的变址寄存器初值为 0，每次循环取一个数组元素，其偏移地址为变址值乘以 sizeof(double)，取完后变址寄存器内容自动加 1。若某次循环所取元素的地址2100H，则进入该次循环时变址寄存器的内容是()
A.25	B.32	C.64	D.100

sizeof(double) = 8
2000H + 8*i = 2100H
8*i = 100H
H表示该数为16进制，所以100H = 2^8 = 256
i = 32
答案选B
</code></pre>
<h1 id="cun-chu-xi-tong">存储系统</h1>
<h2 id="cun-chu-qi-gai-shu">存储器概述</h2>
<h3 id="cun-chu-qi-de-fen-lei">存储器的分类</h3>
<p><strong>按在计算机中的层次进行分类</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>主存</p>
</li>
<li class="lvl-2">
<p>辅存</p>
</li>
<li class="lvl-2">
<p>高速缓冲寄存器(cache)</p>
</li>
</ul>
<p><strong>按存储介质分类</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>磁表面存储器(磁盘、磁带)</p>
</li>
<li class="lvl-2">
<p>磁芯存储器</p>
</li>
<li class="lvl-2">
<p>半导体存储器(MOS 型存储器、双极型存储器)</p>
</li>
<li class="lvl-2">
<p>光盘存储器(光盘)</p>
</li>
</ul>
<p><strong>按存取方式分类</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>随机存储器(RAM)。存储器的任何一个存储单元都可以随机存取,而且存取时间与存储单元的物理位置无关。其优点是读写方便,使用灵活,主要用于主存或者高速缓冲寄存器。RAM 又分<code>静态RAM</code>和<code>动态RAM</code></p>
</li>
<li class="lvl-2">
<p>只读存储器(ROM)。存储器的内容只能随机读出而不能写入。信息一旦写入存储器就固定不变,即使断电,内容也不会丢失。因此,通常用它来存放固定不变的程序、常数和汉字字库等</p>
</li>
</ul>
<blockquote>
<p>ROM 和 RAM 的存取方式均为随机存取</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p>串行访问存储器。对存取单元进行读写操作时,需按其物理位置的先后顺序寻址,包括<code>顺序存取存储器</code>(磁带 📼),与<code>直接存取存储器</code>(如磁盘 💾、光盘 💿)</p>
</li>
</ul>
<blockquote>
<p>顺序存储只能按照某种顺序存取,直接存取介于随机存取和顺序存取之间</p>
</blockquote>
<p><strong>按信息的可保存性分类</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>易失性存储器:断电后,存储信息即消失的存储器,如 RAM</p>
</li>
<li class="lvl-2">
<p>非易失性存储器:断电后信息仍然保留的存储器</p>
</li>
</ul>
<blockquote>
<p>🙋‍♂️ 破坏性读出:被读单元原存储信息被破坏</p>
<p>非破坏性性读出:被读单元原存储信息不被破坏</p>
<p>具有破坏性读出性能的存储器,每次读出操作后,都必须有再生操作,以便恢复被破坏的信息</p>
</blockquote>
<h3 id="cun-chu-qi-de-xing-neng-zhi-biao">存储器的性能指标</h3>
<h4 id="cun-chu-rong-liang">存储容量</h4>
<p>存储容量 = 存储字数 × 存储字长 (字数表示存储器的地址空间大小,字长表示一次存取操作的数据量)</p>
<h4 id="dan-wei-cheng-ben">单位成本</h4>
<p>每位价格 = 总成本/总容量</p>
<h4 id="cun-chu-su-du">存储速度</h4>
<p>存储速度: 数据传输率 = 数据的宽度/存储周期</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>存取时间(T<sub>a</sub>):存取时间是指从启动一次存储器操作到完成该操作所经历的时间,分为读取时间和写入时间</p>
</li>
<li class="lvl-2">
<p>存取周期(T<sub>m</sub>):又称读写周期或访问周期,它是指存储器进行一次完整的读写操作所需的全部时间,即连续两次独立访问存储器操作(读或写操作)之间所需的最小时间间隔</p>
</li>
<li class="lvl-2">
<p>主存带宽(B<sub>m</sub>):又称数据传输率,表示每秒从主存进出信息的最大数量,单位为字每秒、字节每秒(B/s)或位每秒(b/s)</p>
</li>
</ul>
<blockquote>
<p>🙋‍♂️ 存储周期通常大于存取时间,因为上面介绍的破坏性读出的机制,存储器需要在信息读出后花费时间来进行再生</p>
</blockquote>
<h3 id="duo-ceng-ci-de-cun-chu-xi-tong">多层次的存储系统</h3>
<p>基本知识点两个图总结完事:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AD%98%E5%82%A8.svg" alt="存储"></p>
<p>上一级作为低一层存储器的高速缓存,上一层的内容是下一层部分内容的副本</p>
<h2 id="zhu-cun-chu-qi-mm">主存储器(MM)</h2>
<p>主存储器由 DRAM 实现,靠处理器的那一层(Cache)则由 SRAM 实现,他们都属于易失性存储器</p>
<h3 id="sram-he-dram">SRAM 和 DRAM</h3>
<p>通常把存放一个二进制位的物理器件称为<code>存储元</code>,它是存储器最基本的构件。地址码相同的多个<code>存储元</code>构成一个<code>存储单元</code>。若干<code>存储单元</code>的集合构成<code>存储体</code></p>
<h4 id="sram">SRAM</h4>
<p>静态随机存储器(SRAM)的存储元是用<code>双稳态触发器(六晶体管MOS)</code>记忆信息的,因此即使信息被读出后,它仍然保持其状态而不需要再生(<strong>非破坏性读出</strong>)</p>
<p>SRAM 存储速度快,但集成度低,功耗大,价格昂贵,一般用于高速缓冲存储器</p>
<h4 id="dram">DRAM</h4>
<p>动态随机存储器(DRAM)利用存储元电路中的<code>栅极电容</code>上的电荷进行存储信息的,DRAM 的基本存储元通常只使用一个晶体管,所以它比 SRAM 的密度要高得多。相对于 SRAM,DRAM 具有容易集成、位价低、容量大和功耗低等优点,但 DRAM 存取速度比 SRAM 的慢,一般用于大容量主存系统</p>
<p>DRAM 电容上的电荷一般只能维持 1~2ms,因此即使电源不断电,信息也会自动消失。为此,每个一段时间必须刷新,通常取 2ms,称为<code>刷新周期</code>。常用的刷新方式有 3 种</p>
<ol>
<li class="lvl-3">
<p><strong>集中刷新</strong>:指在一个刷新周期内,利用好一段固定的时间,依次对存储器所有行进行逐一再生,在此期间停止对存储器的读写操作,称为<code>死时间</code>,又称<code>访存死区</code>。优点是读写操作时不受刷新工作的影响;缺点是在集中刷新期间(死区)不能访问存储器。</p>
</li>
<li class="lvl-3">
<p><strong>分散刷新</strong>:把对每行的刷新分散到各个工作周期中。这样一个存储器的系统工作周期分为两部分,前半部分用于正常读、写或保持,后半部分用于刷新,优点是没有了死区,缺点是加长了系统的存取周期,降低了整机速度</p>
</li>
<li class="lvl-3">
<p><strong>异步刷新</strong>:是前两种方法的结合。将刷新周期除以行数,得到两次刷新操作之间的时间间隔 t,利用逻辑电路每隔时间 t 产生一次刷新请求,这样可以避免 CPU 连续等待过长的时间,减少了刷新次数</p>
</li>
</ol>
<h4 id="cun-chu-qi-xin-pian-de-nei-bu-jie-gou">存储器芯片的内部结构</h4>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AD%98%E5%82%A8%E5%99%A8%E8%8A%AF%E7%89%87.svg" alt="存储器芯片"></p>
<p>DRAM 采用<code>分时复用</code>的技术,当其选择存储元时,不是由上图 X(A<sub>0</sub>~A<sub>5</sub>)Y(A<sub>6</sub>~A<sub>11</sub>)直接得出,而是所有地址线(A<sub>0</sub>~A<sub>11</sub>)作为行/列,分两次输入,所以相同地址线数下 DRAM 容量很大但是速度没有 SRAM 快</p>
<h3 id="zhi-du-cun-chu-qi">只读存储器</h3>
<p><strong>制度存储器 ROM 的特点</strong>:</p>
<ol>
<li class="lvl-3">
<p>结构简单,所以密度比可读写存储器的高</p>
</li>
<li class="lvl-3">
<p>具有非易失性,所以可靠性高</p>
</li>
</ol>
<p><strong>ROM 的类型</strong>:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>掩模式只读存储器(MROM)</strong>:由半导体制造厂在芯片的制造过程中写入,任何人无法改变其内容,优点:可靠性高,集成度高,价格便宜;缺点是灵活性差</p>
</li>
<li class="lvl-2">
<p><strong>一次可编程只读存储器(PROM)</strong>:允许用户利用专门的设备(编程器)写入自己的程序,一旦写入,无法改变</p>
</li>
<li class="lvl-2">
<p><strong>可擦除可编程只读存储器(EPROM)</strong>:光可擦除 E<sup>2</sup>PROM(电擦除) 允许用户对编程器写入的信息重复改写,但是改写速度慢,改写次数有限</p>
</li>
<li class="lvl-2">
<p><strong>闪存(Flash 存储器)</strong></p>
</li>
<li class="lvl-2">
<p><strong>固态硬盘(SSD)</strong></p>
</li>
</ul>
<h3 id="duo-mo-kuai-cun-chu-qi">多模块存储器</h3>
<h4 id="dan-ti-duo-zi-cun-chu-qi">单体多字存储器</h4>
<p>存储器中只有一个存储体,每个存储单元存储 m 个字,总线宽度也为 m 个字。一次并行读出 m 个字,地址必须顺序排列并处于同一存储器</p>
<h4 id="strong-duo-ti-bing-xing-cun-chu-qi-strong"><strong>多体并行存储器</strong></h4>
<h5 id="gao-wei-jiao-cha-bian-zhi-shun-xu-fang-shi">高位交叉编址(顺序方式)</h5>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%88%B6.svg" alt="高位交叉编制"></p>
<p>高位是存储体体号(M<sub>0</sub>~M<sub>3</sub> =&gt; 0~3),低位是体内地址,访问一串连续的主存地址时,总是先在一个体内访问完后,再转到下一个模块进行访问,所以其本质上还是顺序存储器,存取方式是串行存取,不能提高存储器的吞吐率</p>
<h5 id="di-wei-jiao-cha-bian-zhi-jiao-cha-fang-shi">地位交叉编址(交叉方式)</h5>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80.svg" alt="低位交叉编址"></p>
<p>低位地址为体号,高位为体内地址,由十进制内存地址来确定其存储体号可以使用 <code>体号 = 内存地址 mod 模块数</code>来确定体号</p>
<p>CPU 同时访问四个模块，由存储器控制部件控制它们分时使用数据总线进行信息传递。 这样，对每一个存储模块来说，从 CPU 给出访存命令直到读出信息仍然使用了一个存取周 期时间；而对 CPU 来说，它可以在一个存取周期内连续访问四个模块。各模块的读写过程 将重叠进行(流水线)，所以多模块交叉存储器是一种并行存储器结构。</p>
<p>下面进行定量分析。设模块字长等于数据总线宽度，又假设模块存取一个字的存储周期为<code> T</code>，总线传送周期为<code>τ</code>，存储器的交叉模块数为<code> m</code>，那么为了实现流水线方式存取，应当满足</p>
\textit{T}\leqslant m\mathbb{\tau}

<p>即成块传送可按 τ 间隔流水方式进行，也就是每经<code>τ</code>时间延迟后启动下一个模块。图 3.25 示出了 m=4 的流水线方式存取示意图。</p>
<p><code>m </code>的最小值 <strong>m<sub>min</sub>=T/τ</strong> 称为<code>交叉存取度</code>。<strong>交叉存储器要求其模块数必须大于或等于 m<sub>min</sub></strong>， 以保证启动某模块后经 <code>mτ </code>时间再次启动该模块时，它的上次存取操作已经完成。这样，连续读取 m 个字所需的时间为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>=</mo><mi>T</mi><mo>+</mo><mo>(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">t_1= T+(m-1) \tau 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mord mathit" style="margin-right:0.1132em;">τ</span></span></span></span></span></p>
<p>而顺序方式存储器连续读取 m 个字所需时间为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>=</mo><mi>m</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">t_2= mT 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit">m</span><span class="mord mathit" style="margin-right:0.13889em;">T</span></span></span></span></span></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230707165249740.png" alt="image-20230707165249740"></p>
<pre><code class="language-css">🌰设存储器容量为 32 字，字长 64 位，模块数 m=4，分别用顺序方式和交叉方式进行组织。存储周期 T=200ns，数据总线宽度为 64 位，总线传送周期τ=50ns。若连续读出 4 个字，问顺序存储器和交叉存储器的带宽各是多少?
解 顺序存储器和交叉存储器连续读出 m=4 个字的信息总量都是
	q=64bit×4=256bit
   顺序存储器和交叉存储器连续读出 4 个字所需的时间分别是
	t2=mT=4×200ns=800ns=8×10^–7s
	t1=T+(m–1)τ=200ns+3×50ns=350ns=3.5×10^–7s
   顺序存储器和交叉存储器的带宽分别是
	W2=q/t2=256bit÷(8×10–7)s=320Mbit/s
	W1=q/t1=256bit÷(3.5×10–7)s=730Mbit/s
</code></pre>
<h3 id="zhu-cun-chu-qi-yu-cpu-de-lian-jie">主存储器与 CPU 的连接</h3>
<h4 id="lian-jie-yuan-li">连接原理</h4>
<p>主存储器与 CPU 的连接如下图所示 👇:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/CPU%E8%BF%9E%E6%8E%A5.svg" alt="CPU连接"></p>
<p><code>存储控制器</code>、<code>存储总线</code>和<code>内存条</code>之间的连接关系 👇:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E8%BF%9E%E6%8E%A5%E5%85%B3%E7%B3%BB.svg" alt="连接关系"></p>
<h4 id="zhu-cun-rong-liang-de-kuo-zhan">主存容量的扩展</h4>
<h5 id="wei-tuo-zhan-fa">位拓展法</h5>
<p>若给定的芯片的字数(地指数)符合要求，但位数较短，不满足设计要求的存储器字长， 则需要进行位扩展，让多片给定芯片并行工作。三组信号线中，地址线和控制线公用而数据线单独分开连接。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230707203146542.png" alt="image-20230707203146542"></p>
<h5 id="zi-tuo-zhan-fa">字拓展法</h5>
<p>若给定的芯片存储容量较小(字数少)，不满足设计要求的总存储容量，则需要进行字 扩展，让多片给定芯片分时工作。三组信号线中给定芯片的地址总线和数据总线公用，读 写控制信号线公用，由地址总线的高位译码产生片选信号，让各个芯片分时工作</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230707204129727.png" alt="image-20230707204129727"></p>
<blockquote>
<p>图中数据总线每个芯片组都是 D<sub>0</sub>~D<sub>7</sub></p>
</blockquote>
<blockquote>
<p><strong>片选有效性</strong>：和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mtext><mi mathvariant="normal">R</mi><mi mathvariant="normal">A</mi><mi mathvariant="normal">S</mi></mtext></mrow><mo stretchy="true">‾</mo></mover><mo>(</mo><mi>R</mi><mi>o</mi><mi>w</mi><mi>A</mi><mi>d</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>S</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>c</mi><mi>t</mi><mo>)</mo><mo separator="true">,</mo><mover accent="true"><mrow><mtext><mi mathvariant="normal">C</mi><mi mathvariant="normal">A</mi><mi mathvariant="normal">S</mi></mtext></mrow><mo stretchy="true">‾</mo></mover><mo>(</mo><mi>C</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>m</mi><mi>n</mi><mi>A</mi><mi>d</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>S</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>c</mi><mi>t</mi><mo>)</mo><mo separator="true">,</mo><mover accent="true"><mrow><mtext><mi mathvariant="normal">W</mi><mi mathvariant="normal">E</mi></mtext></mrow><mo stretchy="true">‾</mo></mover><mo>(</mo><mi>W</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi>E</mi><mi>n</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\overline{\text{RAS}}(Row Address Select) 
,\overline{\text{CAS}}(Column Address Select) 
,\overline{\text{WE}}(Write Enable) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8833300000000001em;"></span><span class="strut bottom" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="text mord textstyle cramped"><span class="mord mathrm">R</span><span class="mord mathrm">A</span><span class="mord mathrm">S</span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">A</span><span class="mord mathit">d</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="text mord textstyle cramped"><span class="mord mathrm">C</span><span class="mord mathrm">A</span><span class="mord mathrm">S</span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">n</span><span class="mord mathit">A</span><span class="mord mathit">d</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="text mord textstyle cramped"><span class="mord mathrm" style="margin-right:0.01389em;">W</span><span class="mord mathrm">E</span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.13889em;">W</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mclose">)</span></span></span></span>一样，<strong>都是低电平有效</strong>。</p>
</blockquote>
<h5 id="zi-wei-kuo-zhan">字位扩展</h5>
<p>若给定的芯片的字数和位数均不符合要求，则需要先进行<code>位扩展</code>，再进行<code>字扩展</code>。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230707175242165.png" alt="image-20230707175242165"></p>
<h4 id="cun-chu-qi-he-cpu-lian-jie">存储器和 CPU 连接</h4>
<p>以下是存储器与 CPU 连接时需要注意的原则:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>地址线的连接</strong>:因为存储芯片容量不同,其地址线也不同,而 CPU 的地址线数往往比存储芯片地址线要更多,所以需要注意</p>
<ul class="lvl-2">
<li class="lvl-4">将 CPU 地址线的低位与存储芯片的地址线相连,以选择芯片中的某一单元</li>
<li class="lvl-4">将 CPU 地址线的高位与译码器相连,以实现芯片(组)间的片选</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>数据线的连接</strong>:CPU 的数据线数与存储芯片的数据线数不一定相等,相等时可以直接相连;在不相等时必须对存储芯片扩位,使之与 CPU 数据线数相等</p>
</li>
</ul>
<h2 id="wai-bu-cun-chu-qi">外部存储器</h2>
<h3 id="ci-pan-cun-chu-qi">磁盘存储器</h3>
<p>优点:</p>
<ol>
<li class="lvl-3">
<p>存储容量大,位价格低</p>
</li>
<li class="lvl-3">
<p>记录介质可重复使用</p>
</li>
<li class="lvl-3">
<p>记录信息可长时间保存不丢失,甚至可以脱机存档</p>
</li>
<li class="lvl-3">
<p>非破坏性读出,读出时不需要再生</p>
</li>
</ol>
<p>缺点:</p>
<p>存取速度慢,机械结构复杂,对工作环境要求较高</p>
<h4 id="ci-pan-she-bei-de-zu-cheng">磁盘设备的组成</h4>
<h5 id="ying-pan-cun-chu-qi-de-zu-cheng">硬盘存储器的组成</h5>
<ul class="lvl-0">
<li class="lvl-2">
<p>磁盘驱动器。核心部件是磁头组件和盘片组件</p>
</li>
<li class="lvl-2">
<p>磁盘控制器。硬盘存储器和主机的接口,主流的标准有 IDE、SCSI、SATA 等</p>
</li>
</ul>
<h5 id="cun-chu-qu-yu">存储区域</h5>
<p>以下是磁盘存储器的主要结构示意图 👇:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E7%A3%81%E7%9B%98-1688740119293-28.svg" alt="磁盘"></p>
<blockquote>
<p>扇区是磁盘读写的最小单位,即磁盘按块存取</p>
<p>由于扇区的 Size 比较小，数目众多时寻址时比较困难，所以在操作系统中就将相邻的扇区组合在一起，形成一个<code>簇</code>，再对块进行整体的操作。</p>
<p><a href><strong>如何将一个内存中的簇号来转化为磁盘上的物理地址?</strong></a></p>
</blockquote>
<h5 id="ci-pan-de-xing-neng-zhi-biao">磁盘的性能指标</h5>
<ol>
<li class="lvl-3">
<p><strong>记录密度</strong>:记录密度是指盘片单位面积上记录的二进制信息量,通常以<code>道密度</code>,<code>位密度</code>和<code>面密度</code>表示。</p>
<ol>
<li class="lvl-6"><code>道密度</code>是沿磁盘半径方向单位长度上的磁道数</li>
<li class="lvl-6"><code>位密度</code>是磁道单位长度上能记录的二进制代码位数</li>
<li class="lvl-6"><code>面密度</code>是道密度和位密度的乘积</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>磁盘容量</strong>:</p>
<ol>
<li class="lvl-6"><code>非格式化容量</code>:指磁记录表面可利用的磁化单元总数,由道密度和位密度计算而来</li>
<li class="lvl-6"><code>格式化容量</code>:按照某种特定记录格式所能存储的信息总量</li>
</ol>
<p><em>格式化后的容量比非格式化容量要小</em></p>
</li>
<li class="lvl-3">
<p><strong>平均存取时间</strong>。平均存取时间由三部分构成:</p>
<ol>
<li class="lvl-6"><code>寻道时间</code>:磁头移动到目的磁道的时间</li>
<li class="lvl-6"><code>旋转延迟时间</code>:磁头定位道要读写的扇区的时间</li>
<li class="lvl-6"><code>传输时间</code>:传输数据所花费的时间</li>
</ol>
</li>
<li class="lvl-3">
<p><strong>数据传输率</strong>:从盘存储器在单位时间向主机传送数据的字节数</p>
<p>假设磁盘转速位 r 转/s,每条磁道容量位 N 字节,则数据传输率为: D<sub>r</sub> = rN</p>
</li>
</ol>
<h5 id="ci-pan-di-zhi">磁盘地址</h5>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%9C%B0%E5%9D%80.svg" alt="地址"></p>
<h5 id="ci-pan-zhen-lie">磁盘阵列</h5>
<p>RAID(独立冗余磁盘阵列(又称廉价冗余磁盘阵列))是指将多个独立的物理磁盘罪成一个独立的逻辑盘,数据在多个物理盘上分割交叉存储、并行访问,具有更好的存储性能、可靠性和安全性。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>RAID0:无冗余无校验的磁盘阵列(将数据块交叉存放在不同的物理磁盘的扇区中,几个磁盘交叉并行读写)</p>
</li>
<li class="lvl-2">
<p>RAID1:镜像磁盘阵列(一个使用,一个备份)</p>
</li>
<li class="lvl-2">
<p>RAID2:采用纠错的海明码的磁盘阵列</p>
</li>
<li class="lvl-2">
<p>RAID3:位交叉奇偶校验的磁盘阵列</p>
</li>
<li class="lvl-2">
<p>RAID4:块交叉奇偶校验的磁盘阵列</p>
</li>
<li class="lvl-2">
<p>RAID5:无独立校验的奇偶校验磁盘阵列</p>
</li>
</ul>
<blockquote>
<p>还有 RAID01 和 RAID10</p>
</blockquote>
<h4 id="gu-tai-ying-pan">固态硬盘</h4>
<p>是一种基于闪存技术的存储器,与 U 盘并没有本质上的差别,只是容量更大,存取性能更好</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/SSD-1688781567110-32.svg" alt="SSD"></p>
<p>一个闪存由 B 块组成,每块由 P 页组成。数据是以页为单位读写的。只有在一页所属的块整个被擦除后,才能写这一页。某个块经历了约 10 万次的擦写后,就会损坏,无法使用(坏块),所以闪存翻译层中有一个平均磨损逻辑试图通过将擦除平均分布在所有块上来最大化每个块的寿命</p>
<p>闪存的随机写很慢,因为首先,擦除块就很慢(1ms 级),比访问页要高一个数量级,其次若要修改一个块中包含数据的一个页,那么就要把这个块中所有含有数据的页复制到一个新(被擦除过的)块中,才能进行对那页的写</p>
<h2 id="gao-su-huan-chong-chu-cun-qi">高速缓冲储存器</h2>
<p><strong>程序的局部性原理</strong>:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><mark>空间局部性</mark>:在最近的未来要用的的信息,很可能与正在使用的信息在存储空间上是邻近的,因为指令通常是顺序存放,顺序执行的,数据一本是以向量,数组等形式簇聚地储存在一起的</p>
</li>
<li class="lvl-2">
<p><mark>时间局部性</mark>:最近未来要使用到的信息,很可能是现在正在使用的信息,因为程序中存在循环</p>
</li>
</ul>
<p>基于上述的程序的局部性原理,人们制造出了 Cache(高速缓冲寄存器)</p>
<h3 id="cache-de-ji-ben-gong-zuo-yuan-li">Cache 的基本工作原理</h3>
<p>Cache 是介于 CPU 和主存 之间的小容量存储器，但存取速度比主存快，容量远小于主存。cache 能高速地向 CPU 提供指令和数据，从而加快了程序的执行速 度。从功能上看，它是主存的缓冲存储器，由高速的 SRAM 组成。为追求高速，包括管理 在内的全部功能由硬件实现，因而对程序员是透明的。</p>
<p>为便于 Cache 和主存交换信息,Cache 和主存都被划分为相等的块,<code>Cache块</code>又称为<code>Cache行</code>,所以 Cache 中的块数要远小于主存中的块数,它仅仅保存主存中最活跃的若干块的副本。</p>
<p>CPU 与 Cache 之间的数据交换以<code>字</code>为单位,而 Cache 与主存之间的数据交换则以<code>Cache块</code>为单位</p>
<p>问题也随之而来:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>数据查找。如何快速判断数据是否在 Cache 中</p>
</li>
<li class="lvl-2">
<p>地址映射。主存块如何存放在 Cache 中,如何将主存地址转换为 Cache 地址</p>
</li>
<li class="lvl-2">
<p>替换策略。Cache 满了以后,使用何种策略对 Cache 块进行替换或淘汰</p>
</li>
<li class="lvl-2">
<p>写入策略。如何既保证主存块和 Cache 块的数据一致性,又尽量提升效率</p>
</li>
</ul>
<h3 id="cache-he-zhu-cun-de-ying-she-fang-shi">Cache 和主存的映射方式</h3>
<p>地址映射方式有全相联方式、直接方式和组相联方式三种，下面分别介绍。</p>
<h4 id="quan-xiang-lian-ying-she">全相联映射</h4>
<p>我的理解是主存中的任意一个块,可以映射到 Cache 中的任意一行(块)中</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230708140308405.png" alt="image-20230708140308405"></p>
<p>CPU 访存指令指定了一个主存地址，为了 快速检索，指令中的块号与 cache 中所有行的标记同时在比较器中进行比较。如果块号命中， 则按字地址从 cache 中读取一个字；如果块号未命中，则按主存地址从主存中读取这个字。 在全相联 cache 中，全部标记用一个相联存储器来实现，全部数据存储用一个普通 RAM 来 实现。全相联方式的主要缺点是高速比较器电路难于设计和实现，因此只适合于小容量 cache 采用。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230708170005023.png" alt="image-20230708170005023"></p>
<h4 id="zhi-jie-ying-she">直接映射</h4>
<p>直接映射方式也是一种多对一的映射关系，但一个主存块只能拷贝到 cache 的一个特定 行位置上去。cache 的行号 i 和主存的块号 j 有如下函数关系：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mi>j</mi><mspace width="1em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="1em"></mspace><mi>m</mi></mrow><annotation encoding="application/x-tex">i=j\quad\mathrm{mod}\quad m
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mord mspace quad"></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span><span class="mord mspace quad"></span><span class="mord mathit">m</span></span></span></span></span></p>
<p>式中，m 为 cache 中的总行数。显然，主存的第 0 块，第 m 块，第 2m 块，…，第 2s –m 块 只能映射到 cache 的第 0 行；而主存的第 1 块，第 m+1 块，第 2m+1 块，…，第 2s –m+1 块</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230708170627625.png" alt="image-20230708170627625"></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230708170722759.png" alt="image-20230708170722759"></p>
<p>直接映射方式的优点是硬件简单，成本低，地址变换速度快。缺点是每个主存块只有 一个固定的行位置可存放。如果连续访问块号相距 m 整数倍的两个块，因两个块映射到同 一 cache 行时，就会发生冲突。发生冲突时就要将原先存入的行换出去，但很可能过一段时 间又要换入。频繁的置换会使 cache 效率下降。因此直接映射方式适合于需要大容量 cache 的场合，更多的行数可以减小冲突的机会。</p>
<h4 id="zu-xiang-lian-ying-she">组相联映射</h4>
<p>我的理解为组内全相联映射,组间直接映射</p>
<p>这种方式将 cache 分成 u 组，每组 v 行。主存块存放到哪个组是固定的，取决于主存块 在主存区中是第几块。至于存到该组哪一行是灵活的，即有如下函数关系：</p>
\begin{aligned}m&=u\times v\\\text{组号}\quad q&=j\quad\mathrm{mod}\quad u\end{aligned}

<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230708171256557.png" alt="image-20230708171256557"></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230708171327757.png" alt="image-20230708171327757"></p>
<p>组相联映射方式中的<code>每组行数 v</code> 一般取值较小，典型值是 2、4、8、16。这种规模的<code> v 路</code>比较器容易设计和实现。而块在组中的排放又有一定的灵活性，使冲突减少。为强调比 较器的规模和存放的灵活程度，常称之为 <code>v 路组相联 cache</code>。</p>
<p>v=4 路组相联的内存地址格式如下所示:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230708172232560.png" alt="image-20230708172232560"></p>
<h3 id="cache-zhong-zhu-cun-kuai-de-ti-huan-suan-fa">Cache 中主存块的替换算法</h3>
<ol>
<li class="lvl-3">
<p><strong>随机算法</strong>(RAND)</p>
</li>
</ol>
<p>字面意思</p>
<ol start="2">
<li class="lvl-3">
<p><strong>先进先出算法</strong>(FIFO)</p>
</li>
</ol>
<p>字面意思</p>
<ol start="3">
<li class="lvl-3">
<p><strong>近期最少使用算法</strong>(LRU)</p>
</li>
</ol>
<p>LRU 算法将近期内长久未被访问过的行换出。为此，每行也设置一个计数器，但它们 是 cache 每命中一次，命中行计数器清零，其他各行计数器增 1。当需要替换时，比较各特 定行的计数值，将计数值最大的行换出。这种算法保护了刚复制到 cache 中的新数据行，符 合 cache 工作原理，因而使 cache 有较高的命中率。</p>
<ol start="4">
<li class="lvl-3">
<p><strong>最不经常使用算法</strong>(LFU):</p>
</li>
</ol>
<p>LFU 算法认为应将一段时间内被访问次数最少的那行数据换出。为此，每行设置一个 计数器。新行调入后从 0 开始计数，每访问一次，被访行的计数器增 1。当需要替换时，对 这些特定行的计数值进行比较，将计数值最小的行换出，同时将这些特定行的计数器都清 零。这种算法将计数周期限定在两次替换之间的间隔时间内，因而不能严格反映近期访问情况。</p>
<p><a href>具体的复习留到操作系统的该知识点</a></p>
<h3 id="cache-xie-ce-lue">Cache 写策略</h3>
<p>因为 Cache 中的内容是主存块中的副本,所以当 CPU 对 Cache 中的内容进行更新时,就需要用写策略使 Cache 内容和主存内容保持一致</p>
<p>对于<code>Cache写命中</code>有两种处理方法</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>全写法</strong>:CPU 对 Cache 写命中时,需要把数据同时下写入 Cache 和主存的对应块中</p>
</li>
</ul>
<p>缺点是增加了访存次数,降低了 Cache 的效率</p>
<p>为了减少(缓解)直接写入主存的时间消耗在主存和 Cache 之间加一个<code>写缓冲器</code>(逻辑上为 FIFO 队列),写缓冲虽然可以解决速度不匹配的问题,但若出现频繁写时,会使写缓冲饱和溢出(Cache 和主存速度不匹配)</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%86%99%E7%BC%93%E5%86%B2.svg" alt="写缓冲"></p>
<p>增加 L2cache 可以有效避免写缓冲饱和溢出问题</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%86%99%E7%BC%93%E5%86%B2%E6%94%B9%E8%BF%9B-1688820281371-3.svg" alt="写缓冲改进"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>回写法</strong>:每个 Cache 行设置一个修改位(脏位),CPU 对 Cache 写命中时,只需要把数据写入 Cache 中的某一个块中,当这一个块需要被替换时,检查其脏位是否为 1,为 1 则说明被修改过,将其写回内存,反之,无须写回内存</p>
</li>
</ul>
<p>对于<code>Cache写不命中</code>也有两种处理方法</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>写分配法</strong>:CPU 将块写入主存中,Cache 从主存中将该块调入 Cache 中</p>
</li>
<li class="lvl-2">
<p><strong>非写分配法</strong>:只写主存,不调块</p>
</li>
</ul>
<p>非写分配法——全写法 写分配法——回写法 通常是这两个组合</p>
<h2 id="xu-ni-cun-chu-qi">虚拟存储器</h2>
<p>主存和辅存共同构成了虚拟存储器,二者在硬件和软件系统共同的管理下工作,对于程序员来而言,虚拟存储器是透明的。虚拟存储器具有主存的速度和辅存的容量</p>
<p>用户编制程序时使用的地址称为<code>虚地址</code>或<code>逻辑地址</code>，其对应的存储空间称为<code>虚存空间</code>或<code>逻辑地址空间</code>；而计算机物理内存的访问地址则称为<code>实地址</code>或<code>物理地址</code>，其对应的存储空间称为<code>物理存储空间</code>或<code>主存空间</code>。程序进行虚地址到实地址转换的过程称为程序的再定位</p>
<p>虚存机制也要解决一些关键问题。</p>
<ol>
<li class="lvl-3">
<p>调度问题 决定哪些程序和数据应被调入主存。</p>
</li>
<li class="lvl-3">
<p>地址映射问题 在访问主存时把虚地址变为主存物理地址(这一过程称为内地址变 换)；在访问辅存时把虚地址变成辅存的物理地址(这一过程称为外地址变换)，以便换页。 此外还要解决主存分配、存储保护与程序再定位等问题。</p>
</li>
<li class="lvl-3">
<p>替换问题 决定哪些程序和数据应被调出主存。</p>
</li>
<li class="lvl-3">
<p>更新问题 确保主存与辅存的一致性。</p>
</li>
</ol>
<h3 id="ye-shi-xu-ni-cun-chu-qi">页式虚拟存储器</h3>
<p>页式虚拟存储器以<code>页</code>为基本单位。把虚拟空间和主存空间都划分成一个一个大小相等的<code>页</code>,主存的<code>页</code>被称为<code>实页</code>、<code>页框</code>,虚存的页被称为<code>虚页</code>。我们把虚拟地址分为两个字段,<code>虚页号</code>和<code>页内地址</code>。虚拟地址到物理地址的转换是通过<code>页表</code>来实现的。页表是一张存放虚存号和实存号的对照表,它记录程序的虚页调入主存时被安排在主存中的位置。页表一般长久地保存在内存中。</p>
<h3 id="ye-biao">页表</h3>
<p>页式虚拟存储器以页为基本单位,虚拟空间与主存空间都被划分为相同的大小</p>
<p>以下为一个页表式例:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>有效位</code>也称<em>装入位</em>,用来表示对应页面是否在主存,若为 1 则表示该虚拟页已从外存调入主存,此时页表项存放该页的物理页号;(内页表)若为 0,则表示没有调用主存,此时页表项可以存放该页的磁盘地址(外页表)</p>
</li>
<li class="lvl-2">
<p><code>脏位</code>也称<em>修改位</em>,用来表示页面是否被修改过,虚存机制中采用回写策略,利用脏位可判断替换时是否需要写回磁盘</p>
</li>
<li class="lvl-2">
<p><code>引用位</code>也称<em>使用位</em>,用来配合替换策略进行设置,例如是否实现最先调入(FIFO 位)或最近最少用(LRU 位)策略等</p>
</li>
</ul>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E4%B8%BB%E5%AD%98%E4%B8%AD%E7%9A%84%E9%A1%B5.svg" alt="主存中的页"></p>
<p>CPU 执行指令时将虚拟地址转换为主存物理地址。页表基址寄存器存放进程(每一个进程都有一个页表/段表)的页表首地址,然后根据虚拟地址高位部分的虚拟页号找到对应的页表项,若装入位为 1,则取出物理页号,和虚拟地址低位部分的页内地址拼接,形成实际物理地址;若装入位为 0,则说明缺页,需要操作系统进行缺页处理。</p>
<p>以下页式虚拟存储器的地址变化过程示意图:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230709104250288.png" alt="image-20230709104250288"></p>
<p>每个进程所需的页数并不固定，所以页表的长度是可变的，因此通常的实现方法是把 页表的基地址保存在寄存器中，而页表本身则放在主存中。由于虚存地址空间可以很大， 因而每个进程的页表有可能非常长。例如，如果一个进程的虚地址空间为 2GB，每页的大 小为 512B，则总的虚页数为 231/29 =222。 为了节省页表本身占用的主存空间，一些系统把页表安排存储在虚存空间，因而页表本身也要进行分页。当一个进程运行时，其页表中一部分在主存中，另一部分则在辅存中 保存。 另一些系统采用二级页表结构。每个进程有一个页目录表，其中的每个表项指向一个 页表。因此，若页目录表的长度(表项数)是 m，每个页表的最大长度(表项数)为 n，则一个 进程最多可以有 m×n 个页</p>
<p>优点是,页面的长度固定,页面的长度固定,页表简单,调入方便。缺点是,由于程序不可能正好是页面的整数倍,最后一页的零头将无法利用而造成浪费,并且页不是逻辑上独立的实体,所以处理、保护和共享都不及段式虚拟存储器方便</p>
<h3 id="kuai-biao-tlb">快表(TLB)</h3>
<p>地址变换高速缓存(Translation Look-aside Buffer,TLB)</p>
<p>由于页表通常在主存中，因而即使逻辑页已经在主存中，也至少要访问两次物理存储 器才能实现一次访存，这将使虚拟存储器的存取时间加倍。为了避免对主存访问次数的增 多，可以对页表本身实行二级缓存，把页表中最活跃的部分存放在高速存储器中。这个专用于页表缓存的高速存储部件通常称为转换后援缓冲器(TLB)，又称为快表。而保存在主存中的完整页表则称为慢表。快表的作用是加快地址变换 👇</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230709164335824.png" alt="image-20230709164335824"></p>
<p><strong>TLB、页表、Cache、主存之间的访问关系</strong></p>
<p>简而言之，TLB 是地址缓存，那个 cache 是数据缓存。那么其实就分为了三个情况：</p>
<ol>
<li class="lvl-3">
<p>TLB 缺失，要去页表中找地址</p>
</li>
<li class="lvl-3">
<p>cache 缺失，要向内存要数据</p>
</li>
<li class="lvl-3">
<p>缺页，要向磁盘要数据，同时更新 TLB 和 页表</p>
</li>
</ol>
<p>先查找 TLB，如果缺失，那么查找页表，还缺就缺页了。如果查找 TLB 命中，那么根据 TLB 获取物理地址，然后查找数据 cache，就算普通的 cache 查找了。</p>
<p>以下是 TLB 虚拟存储器的 CPU 访存过程 👇:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/390f3c60-d634-4858-a257-f018e7e2e048.png" alt="390f3c60-d634-4858-a257-f018e7e2e048"></p>
<h3 id="duan-shi-xu-ni-cun-chu-qi">段式虚拟存储器</h3>
<p>段式存储器中的<code>段</code>是按照程序的逻辑结构划分的,各个<code>段</code>的长度因程序而异。把虚拟地址分为两个部分:<code>段号</code>和<code>段内地址</code>。虚拟地址到实地址的变换是通过<code>段表</code>来实现的。段表是程序逻辑段和在主存中存放位置的对照表。段表的每行记录与某个段对应的<code>段号</code>、<code>装入位(有效位)</code>、<code>段起点地址</code>和<code>段长</code>。由于段的长度可变,所以段表中要给出各段的起始位置与段的长度</p>
<p>CPU 根据虚拟地址访存时，首先根据段号与段表基地址拼接成对应的段表行，然后根据该段表行的装入位判断该段是否已调入主存(装入位为“1”，表示该段已调入主存；装入位为“0”，表示该段不在主存中)。已调入主存时，从段表读出该段在主存中的起始地址，与段内地址(偏移量)相加，得到对应的主存实地址。段式虚拟存储器的地址变换如下图所示:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230709205758778.png" alt="image-20230709205758778"></p>
<p>因为段的长度不固定，段式虚拟存储器也有一些缺点：</p>
<p>① 主存空间分配比较麻烦。</p>
<p>② 容易在段间留下许多外碎片，造成存储空间利用率降低。</p>
<p>③ 由于段长不一定是 2 的整数次幂，因而不能简单地像分页方式那样用虚地址和实地址的最低若干二进制位作为段内偏移量，并与段号进行直接拼接，必须用加法操作通过段起址与段内偏移量的求和运算求得 物理地址。因此，段式存储管理比页式存储管理方式需要更多的硬件支持。</p>
<p>优点:段的分界与程序的自然分界相对应,因而具有逻辑独立性,使得它易于编译、管理、修改和保护,也便于多道程序的共享</p>
<h3 id="duan-ye-shi-xu-ni-cun-chu-qi">段页式虚拟存储器</h3>
<p>把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页程序对主存的调入、调出仍以页为基本传送单位，这样的虚拟存储器称为段页式虚拟存像器。在段页式虚拟存储器中，每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。​ 虚地址分为<code>段号</code>、<code>段内页号</code>、<code>页内地址</code>三部分。CPU 根据虚地址访存时，首先根据段号有到段表地址：然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址；最后从页表中取出实页号，与页内地址拼接形成主存实地址。段页式虚拟存储器的优点是，兼具页式和段式虚拟存储器的优点，可以按段实现共享和像护。缺点是在地址变换过程中需要两次查表，系统开销较大。</p>
<h3 id="xu-ni-cun-chu-qi-yu-cache-de-bi-jiao">虚拟存储器与 Cache 的比较</h3>
<p>虚拟存储器与 Cache 既有很多相同之处，又有很多不同之处</p>
<p><strong>相同之处</strong></p>
<ol>
<li class="lvl-3">
<p>最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度。</p>
</li>
<li class="lvl-3">
<p>都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大。</p>
</li>
<li class="lvl-3">
<p>都有地址的映射、替换算法、更新策略等问题。</p>
</li>
<li class="lvl-3">
<p>依据程序的局部性原理应用“快速缓存的思想”，将活跃的数据放在相对高速的部件中。</p>
</li>
</ol>
<p><strong>不同之处</strong></p>
<ol>
<li class="lvl-3">
<p>Cache 主要解决系统速度，而虚拟存储器却是为了解决主存容量。</p>
</li>
<li class="lvl-3">
<p>Cache 全由硬件实现，是硬件存体器，对所有程序员透明；而虚拟存储器由 OS 和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明。</p>
</li>
<li class="lvl-3">
<p>对于不命中性能影响，因为 CPU 的速度的为 Cache 的 10 倍，主存的速度为硬盘的 100 倍以上，因此虚拟存储器系统不命中时对系统性能影响更大。</p>
</li>
<li class="lvl-3">
<p>CPU 与 Cache 和主存都建立了直接访问的通路.而辅存 CPU 没有直接通路。也就是说在 Cache 不命中时主存能和 CPU 直接通信,同时将数据调入 Cache;而虚拟存储器系统不命中时,只能先由硬盘调入主存，而不能直接和 CPU 通信。</p>
</li>
</ol>
<h1 id="zhi-ling-xi-tong">指令系统</h1>
<p><strong>指令就是计算机执行某种操作的命令。一台计算机所有的指令的集合构成该机的指令系统,也称指令集,指令系统是计算机的主要属性,位于硬件和软件交界面上</strong></p>
<h2 id="zhi-ling-de-ji-ben-xing-shi">指令的基本形式</h2>
<p><strong>基本专业词汇</strong>:</p>
<p>一条指令通常包括<code>操作码</code>和<code>地址码</code>字段两部分</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作码字段</th>
<th style="text-align:center">地址码字段</th>
</tr>
</thead>
</table>
<p><code>操作码</code>指出指令中指令应该执行什么性质的操作以及具有何种功能。操作码是识别指令,了解指令功能及区分操作数地址的组成和使用方法等的关键信息。例如指出的是算数加运算还是算数减运算,是程序转移还是返回操作。</p>
<p><code>地址码</code>给出被操作的信息(指令或数据)的地址,包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序入口地址等</p>
<p><strong>指令的长度</strong>是指一条指令中所包含的二进制代码的位数,指令字长取决于<code>操作码长度</code>、<code>操作数地址码的长度</code>和<code>操作数地址的个数</code>。指令长度与机器字长没有固定的关系,它可以等于<a href="#字、字长、机器字长、指令字长、存储字长的区别和联系是什么?">机器字长</a>,也可以大于或小于机器字长。通常,把指令字长等于机器字长的指令称为<code>单字长指令</code>,指令长度等于半个机器字长的指令称为<code>半字长指令</code>,指令长度等与两个机器字长的指令称为<code>双字长指令</code></p>
<p>在一个指令系统中,若所有指令的长度都是相等的,则称为<code>定长指令字结构</code>。定长指令的执行速度快,控制简单。若各种指令的长度随功能而异,则称为<code>变长指令字结构</code>。然而,因为主存一般都是按<a href="#字、字长、机器字长、指令字长、存储字长的区别和联系是什么?">字节编址</a>的,所以指令字长多为字节的整数倍</p>
<p>根据指令中操作数地址码的数目不同,可将指令分为以下几种格式:</p>
<p><strong>零地址指令</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">OP</th>
</tr>
</thead>
</table>
<p>只给出操作码 OP,没有显式地址,这种指令有两种可能</p>
<ol>
<li class="lvl-3">
<p>不需要操作数的指令,如空操作指令、停机指令、关中断指令等。</p>
</li>
<li class="lvl-3">
<p>零地址的运算类指令仅用在堆栈计算机中。通常参与运算的两个操作数隐含地从栈顶和次栈顶弹出,再送到运算器进行运算,运算结构再隐含地压入堆栈</p>
</li>
</ol>
<p><strong>一地址指令</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">OP</th>
<th style="text-align:center">A<sub>1</sub></th>
</tr>
</thead>
</table>
<p>这种指令也有两种常见的形态,要根据操作码的含义确定究竟是哪种。</p>
<ol>
<li class="lvl-3">
<p>只有目的操作数的单操作指令,按 A<sub>1</sub>的地址读取操作数,进行 OP 操作后,结果存回原地址(A<sub>1</sub>)</p>
</li>
</ol>
<p>指令含义:OP(A<sub>1</sub>) → A<sub>1</sub></p>
<p>如操作码的含义是加 1、减 1、求反、求补等</p>
<ol start="2">
<li class="lvl-4">
<p>隐含约定目的地址的双操作数指令,按指令地址 A<sub>1</sub>可读取源操作数,指令可隐含约定另外一个操作数由 ACC(累加器)提供,运算结果也将存放在 ACC 中</p>
</li>
</ol>
<p>指令含义:(ACC)OP(A<sub>1</sub>) → ACC</p>
<p><strong>二地址指令</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">OP</th>
<th style="text-align:center">A<sub>1</sub>(目的操作数地址)</th>
<th style="text-align:center">A<sub>2</sub>(源操作数地址)</th>
</tr>
</thead>
</table>
<p>指令含义: (A<sub>1</sub>)OP(A<sub>2</sub>) → A<sub>1</sub></p>
<p>其中目的操作数地址还用来保存此次的运算结果</p>
<p><strong>三地址指令</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">OP</th>
<th style="text-align:center">A<sub>1</sub></th>
<th style="text-align:center">A<sub>2</sub></th>
<th style="text-align:center">A<sub>3</sub>(结果)</th>
</tr>
</thead>
</table>
<p>指令含义: (A<sub>1</sub>)OP(A<sub>2</sub>) → A<sub>3</sub></p>
<p>若地址字段均为主存地址,则完成一条三地址需要 4 次访存(取指令 1 次,取两个操作数 2 次,存放结果 1 次)</p>
<p><strong>四地址指令</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">OP</th>
<th style="text-align:center">A<sub>1</sub></th>
<th style="text-align:center">A<sub>2</sub></th>
<th style="text-align:center">A<sub>3</sub>(结果)</th>
<th style="text-align:center">A<sub>4</sub>(下条需要执行的指令的地址)</th>
</tr>
</thead>
</table>
<p>设某等长指令字结构机器的指令长度为 16 位包括 4 位基本操作码字段和 三个 4 位地址字段:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230710175330239.png" alt="image-20230710175330239"></p>
<p>4 位基本操作码若全部用于三地址指令， 则只能安排 16 种三地址指令。通常一个指令系统中指令的地址码个数不一定相同，为了确保指令字长度尽可能统一，可以采用<strong>扩展操作码技术</strong>，向地址码字段扩展操作码的长度。如 表 4.2 所示，三地址指令的操作码占用 4 位基 本操作码编码空间的 0000 ～ 1110 共 24 –1=15 种组合，剩下一个编码 1111 用于把操作码扩 展到 A1 地址域，即从 4 位操作码扩展到 8 位。 二地址指令的操作码占用 8 位操作码编码空间 的 1111, 0000 ～ 1111, 1101 共 24 –2=14 种，剩 下两个编码 1111, 1110 和 1111, 1111 用于把操 作码扩展到 A2 地址域，即从 8 位操作码扩展 到 12 位。一地址指令的操作码占用 12 位操作 码编码空间的 1111, 1110, 0000 ～ 1111, 1111, 1110 共 25 –1=31 种编码，剩下一个编码 1111,1111,1111 用于把操作码扩展到 A3 地址域，即 从 12 位操作码扩展到 16 位。零地址指令的操作码占用 16 位操作码编码空间的 1111,1111,1111,0000 ～ 1111,1111,1111,1111 共 24 =16 种编码</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230710175459752.png" alt="image-20230710175459752"></p>
<p>设计拓展操作码指令格式时啊,必须注意以下两点:</p>
<ol>
<li class="lvl-3">
<p>不允许短码是长码的前缀,即短操作码不能与长操作码前面部分的代码相同</p>
</li>
<li class="lvl-3">
<p>各指令的操作码一定不能重复</p>
</li>
</ol>
<p>通常情况下,对使用频率较高的指令分配较短的操作码,对使用频率较低的指令分配较长的操作码,从而尽可能减少指令译码和分析的时间。</p>
<blockquote>
<p>🤔<strong>采用扩展操作码设计方案的目的是</strong>?：</p>
<p>保持指令字长度不变而增加指令的数量</p>
</blockquote>
<h2 id="zhi-ling-de-cao-zuo-lei-xing">指令的操作类型</h2>
<ol>
<li class="lvl-3">
<p><strong>数据传送</strong></p>
</li>
</ol>
<p>传送指令通常有<code>寄存器之间的传送(MOV)</code>、<code>从内存单元读取数据到CPU寄存器(LOAD)</code>、<code>从CPU寄存器写数据到内存单元中是(STORE)</code>等。</p>
<ol start="2">
<li class="lvl-3">
<p><strong>算数和逻辑运算</strong></p>
</li>
</ol>
<p>这类指令主要有加(ADD)、减(SUB)、比较(CMP)、乘(MUL)、除(DIV)、加 1(INC)、减 1(DEC)、与(AND)、或(OR)、取反(NOT)、异或(XOR)等</p>
<ol start="3">
<li class="lvl-3">
<p><strong>移位操作</strong></p>
</li>
</ol>
<p>移位指令主要有算法移位、逻辑移位、循环移位</p>
<ol start="4">
<li class="lvl-3">
<p><strong>转移操作</strong></p>
</li>
</ol>
<p>转移指令主要有无条件转移(JMP)、条件转移(BRANCH)、调用(CALL)、返回(RET)、陷阱(TRAP)等。</p>
<p>无条件转移指令在任何情况下都执行转移操作</p>
<p>条件转移一般是某个标志位的值,或几个标志位的组合。</p>
<p>调用指令和转移指令的区别:执行调用指令时必须保存下一条指令的地址(返回地址),当程序执行结束时,根据返回地址返回到主程序继续执行;而转移指令则不返回执行。</p>
<ol start="5">
<li class="lvl-3">
<p><strong>输入输出操作</strong></p>
</li>
</ol>
<p>用于完成 CPU 与外部设备交换数据或传送控制命令及状态信息</p>
<h2 id="zhi-ling-de-xun-zhi-fang-shi">指令的寻址方式</h2>
<p>寻址方式是寻找指令或操作数有效地址的方式,即确定本条指令的数据地址及下一条待执行指令的地址的方法。寻址方式分为<code>指令寻址</code>和<code>数据寻址</code>两大类</p>
<h3 id="zhi-ling-xun-zhi">指令寻址</h3>
<p>寻找下一条将要执行的指令地址称为指令寻址</p>
<p>指令寻址有两种方式:一种是<code>顺序寻址方式</code>,另一种是<code>跳跃寻址方式</code></p>
<p><strong>顺序寻址</strong></p>
<p>通过程序计数器 PC 加 1(一个指令字长),自动形成下一条指令地址</p>
<p><strong>跳跃寻址</strong></p>
<p>通过转移类指令实现。所谓的跳跃是指下一条指令的地址不由程序计算器 PC 自动给出,而由本条指令给出的下条指令地址的计算方式。而是否跳跃可能受到状态寄存器和操作数的控制,跳跃的地址分为<code>绝对地址(由标记符直接得到)</code>和<code>相对地址(相对于当前指令地址的偏移量)</code>。跳跃的结果是当前指令修改 PC 值,所以下一条指令仍然通过 PC 给出。</p>
<h3 id="shu-ju-xun-zhi">数据寻址</h3>
<p>数据寻址是指如何在指令中表示一个操作数的地址,如何用这种表示得到操作数或怎么样计算出操作数的地址</p>
<p>数据寻址的方式较多,为区分各种方式,通常在指令字中涉案之一个字段,用来表明属于哪一种寻址方式</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作码</th>
<th style="text-align:center">寻址地址</th>
<th style="text-align:center">形式地址 A(偏移量)</th>
</tr>
</thead>
</table>
<p>以下是一些常见的数据寻址方式:</p>
<h4 id="yin-han-xun-zhi">隐含寻址</h4>
<p>这种类型的指令，不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址， 如图所示。例如，单地址的指令格式，就不是明显地在地址字段中指出第二操作数 的地址，而是规定累加寄存器 ACC 作为第二操作数地址。指令格式明显指出的仅是第一操作数的地址 A。因此，累加寄存器 AC 对单地址指令格式来说是隐含地址。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711072851580.png" alt="image-20230711072851580"></p>
<h4 id="li-ji-shu-xun-zhi">立即数寻址</h4>
<p>指令的地址字段指出的不是操作数的地址，而是操作数本身，这种寻址方式称为立即 寻址，如图所示。指令中的操作数称为立即数。立即寻址方式的特点是指令中包含 的操作数立即可用，节省了访问内存的时间。</p>
<table>
<thead>
<tr>
<th style="text-align:center">OP</th>
<th style="text-align:center">立即寻址特征</th>
<th style="text-align:center">A</th>
</tr>
</thead>
</table>
<p>A 部分即位立即数本身,以补码的形式存储</p>
<h4 id="zhi-jie-xun-zhi">直接寻址</h4>
<p>直接寻址是一种基本的寻址方法，其特点是：在指令格式的地址字段中直接指出操作 数在内存的地址 A。由于操作数的地址直接给出而不需要经过某种变换，所以称这种寻址 方式为直接寻址方式。采用直接寻址方式时，指令字中的形式地址 A 就是操作数的有效地址 EA。因此通常把 形式地址 A 又称为<code>直接地址</code>。</p>
<p>下图是直接寻址方式的示意图 👇</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711085829114.png" alt="image-20230711085829114"></p>
<h4 id="jian-jie-xun-zhi">间接寻址</h4>
<p>间接寻址是相对于直接寻址而言的，在间接寻址的情况下，指令地址字段中的形式地址 A 不是操作数的真正地址，而是操作数地址有效地址所在的存储单元的地址,也就是<code>操作数地址的地址</code>。间接寻址可以是一次间接寻址,还可以是多次间接寻址</p>
<p>下面是间接寻址的示意图 👇</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711090943348.png" alt="image-20230711090943348"></p>
<p>由于访问速度过慢,这种寻址方式并不常见。一般问到扩大寻址范围,通常指的是<code>寄存器间接寻址</code></p>
<h4 id="ji-cun-qi-xun-zhi">寄存器寻址</h4>
<p>寄存器寻址是指在指令字种直接给出操作数所在的寄存器编号,即 EA = R,其操作数在由 R<sub>i</sub>所指的寄存器内</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711092026375.png" alt="image-20230711092026375"></p>
<h5 id="ji-cun-qi-jian-jie-xun-zhi">寄存器间接寻址</h5>
<p>寄存器 R<sub>i</sub>种给出的不是一个操作数,而是操作数所在的主存单元的地址即 EA = (R<sub>i</sub>)</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711092540650.png" alt="image-20230711092540650"></p>
<h4 id="pian-yi-xun-zhi">偏移寻址</h4>
<p>一种强有力的寻址方式是直接寻址和寄存器间接寻址方式的结合，它有几种形式，我 们称它为偏移寻址。有效地址计算公式为 EA=A+®</p>
<p>常用的三种偏移寻址是<code>相对寻址</code>、<code>基址寻址</code>、<code>变址寻址</code>。</p>
<h5 id="xiang-dui-xun-zhi">相对寻址</h5>
<p>相对寻址是把 PC 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址,即 EA = (PC) +A,其中 A 是相对于前指令地址的偏移量,可正可负,补码表示</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711094719377.png" alt="image-20230711094719377"></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711100601565.png" alt="image-20230711100601565"></p>
<blockquote>
<p>注意对于转移指令 JMP A,当 CPU 从存储器中取出一字节时,会自动执行(PC) + 1 → PC。若转移指令地址为 X,且占 2B 在取出该指令后 PC 的值会加 2 即(PC) = X+2,这样在执行完该指令后,会自动跳转到 X + 2 + A 的地址继续执行</p>
</blockquote>
<blockquote>
<p>🙋‍♂️ 多道程序设计中，各个程序段可能要在内存中浮动，而相对寻址特别利于程序浮动</p>
</blockquote>
<h5 id="ji-zhi-xun-zhi">基址寻址</h5>
<p>将 CPU 中基址寄存器(BR)的内容加上指令格式中形式地址 A 而形成的操作数的有效地址,即 EA = (BR) + A。其中基址寄存器既可采用专用寄存器,又可采用通用寄存器</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711094605323.png" alt="image-20230711094605323"></p>
<blockquote>
<p>注:基址寄存器是<strong>面向操作系统</strong>的，<strong>其内容由操作系统或管理程序确定</strong>。在程序执行过程中，基址寄存器的内容不变(作为基地址)，形式地址可变(作为偏移量)。当采用通用寄存器作为基址寄存器时，可由<strong>用户决定哪个寄存器作为基址寄存器</strong>，但其<strong>内容仍由操作系统确定</strong>。</p>
</blockquote>
<p>优点:可扩大寻址范围(基址寄存器的位数大于形式地址 A 的位数) ;用户不必考虑自己的程序存于主存的哪一空间区域，故有利于多道程序设计，以及可用于编制浮动程序。</p>
<h5 id="bian-zhi-xun-zhi">变址寻址</h5>
<p>地址域引用一个主存地址，被引用的专用寄存器含有对那个地址的正偏移量。这意味着主存地址位数大于寄存器中的偏移量位数，与基址寻址刚好相反。但是二者 有效地址的计算方法是相同的。变址的用途是为重复操作的完成提供一种高效机制。例如， 主存位置 A 处开始放一个数值列表，打算为表的每个元素加 1。我们需要取每个数位，对 它加 1，然后再存回，故需要的有效地址序列是 A, A+1, A+2, …直到最后一个位置。此时 值 A 存入指令地址字段，再用一个变址寄存器 IX(初始化为 0)。每次操作之后，变址寄存器 内容增 1。此时，EA=A+®，R←(R+1)</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711104751971.png" alt="image-20230711104751971"></p>
<p>变址寻址的优点是可扩大寻址范围(变址寄存器的位数大于形式地址 A 的位数);在数组处理过程中，可设定 A 为数组的首地址，不断改变变址寄存器 IX 的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。偏移量(变址寄存器 IX)的位数足以表示整个存储空间。</p>
<p>显然，变址寻址与基址寻址的有效地址形成过程极为相似。但从本质上讲，两者有较大区别。<strong>基址寻址面向系统，主要用于为多道程序或数据分配存储空间，因此基址寄存器的内容通常由操作系统或管理程序确定，在程序的执行过程中其值不可变，而指令字中的 A 是可变的</strong>:<strong>变址寻址立足于用户，主要用于处理数组问题，在变址寻址中，变址寄存器的内容由用户设定，在程序执行过程中其值可变，而指令字中的 A 是不可变的。</strong></p>
<h4 id="dui-zhan-xun-zhi">堆栈寻址</h4>
<p>堆栈有<code>寄存器堆栈(硬堆栈)</code>和<code>存储器堆栈(软堆栈)</code>两种形式，它们都以后进先出(LIFO)的原理存储数据。不论是寄存器堆栈，还是存储器堆栈，数据的存取都与栈顶地址打交通，为此需要一个<code>隐式或显式的堆栈指示器(寄存器)</code>,该寄存器被称为<code>堆栈指针(SP)</code>。数据进栈时使用 PUSH 指令，将数据压入栈顶地址，堆栈指示器减 1；数据退栈时，使用 POP 指令，数据从栈顶地址弹出，堆栈指示器加 1。从而保证了堆栈中数据先进后出的存取顺序。</p>
<h4 id="ge-ge-xun-zhi-fang-shi-bi-jiao">各个寻址方式比较</h4>
<table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:center">有效地址</th>
<th style="text-align:center">访存次数(执行阶段)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">隐含寻址</td>
<td style="text-align:center">程序指定</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">立即寻址</td>
<td style="text-align:center">A 即是操作数</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">直接寻址</td>
<td style="text-align:center">EA = A</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">一次间接寻址</td>
<td style="text-align:center">EA = (A)</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">寄存器寻址</td>
<td style="text-align:center">EA = R<sub>i</sub></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">寄存器一次寻址</td>
<td style="text-align:center">EA = (R<sub>i</sub>)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">相对寻址</td>
<td style="text-align:center">EA = (PC) + A</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">基址寻址</td>
<td style="text-align:center">EA = (BR) + A</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">变址寻址</td>
<td style="text-align:center">EA = (IX) + A</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<h2 id="cheng-xu-de-ji-qi-ji-dai-ma-biao-shi">程序的机器级代码表示</h2>
<h3 id="chang-yong-hui-bian-zhi-ling-jie-shao">常用汇编指令介绍</h3>
<h4 id="xiang-guan-ji-cun-qi">相关寄存器</h4>
<p>x86 处理器中有 8 个 32 位的通用寄存器,各寄存器及说明如下图所示。为了向后兼容,<code>EAX</code>、<code>EBX</code>、<code>ECX</code>和<code>EDX</code>的高两位字节和低两位字节可以独立使用,<code>E</code>为<code>Extended(拓展)</code>,表示 32 位寄存器;<code>D</code>表示<code>Destination(目标)</code>(Destination Index, DI, 目标索引);<code>S</code>表示<code>Source(源)</code>(Source Index, SI, 源索引)。例如,<code>EAX</code>的低两位称为<code>AX</code>,而<code>AX</code>的高低字节又可以分别作为两个 8 位寄存器,分别称为<code>AH</code>和<code>AL</code>。寄存器的名称与大小写无关,既可以用<code>EAX</code>,又可以用<code>eax</code>。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AF%84%E5%AD%98%E5%99%A8.svg" alt="寄存器"></p>
<p>除了 EBP 和 ESP 外,其他几个寄存器的用途是比较任意的</p>
<h4 id="hui-bian-zhi-ling-ge-shi">汇编指令格式</h4>
<p>使用不同编程工具开发程序,用到的汇编程序也不同,一般有两种不同汇编格式:<code>AT&amp;T格式</code>和<code>Intel格式</code>。</p>
<blockquote>
<p>AT&amp;T 格式是一种汇编语言的语法格式，主要用于 Unix 和 Linux 等操作系统中。</p>
</blockquote>
<p>他们的区别主要体现如下:</p>
<p>以下简称为<strong>A 格式</strong>和<strong>I 格式</strong></p>
<p>①A 格式的指令只能用小写字母,而 I 格式的指令对大小写不敏感</p>
<p>② 在 A 格式中,第一个为<code>源操作数</code>,第二个为<code>目的操作数</code>,方向<strong>从左到右</strong>,合乎日常顺序,I 格式中,第一个为<code>目的操作数</code>,第二个为<code>源操作数</code>,方向<strong>由右向左</strong></p>
<p>③ 在 A 格式中,寄存器需要加前缀&quot;%“,立即数需要加前缀”$&quot;;在 I 格式中,寄存器和立即数都不需要加</p>
<p>④ 在内存寻址方面,A 格式使用&quot;()“,而 I 格式使用”[]&quot;</p>
<p><s>⑤ 在 A 格式中，操作码和源操作数、目标操作数之间用逗号隔开，而在 I 格式中则用空格隔开</s></p>
<p>⑥ 在处理负责寻址方式时,例如 A 格式的内存操作数&quot;<code>disp(base,index,scale)</code>“分别表示<code>偏移量(disp)</code>、<code>基址寄存器(base)</code>、<code>变址寄存器(index)</code>和<code>比例因子(scale)</code>,如&quot;8(%edx,%eax,2)“表示操作数为 M[R[edx]+R[eax]×2+8],其对应的 I 格式的操作数为”[edx+eax×2+8]”</p>
<blockquote>
<p><code>M</code>: 表示内存操作，即对内存进行读取或写入操作。</p>
<p><code>R[edx]</code>:表示以通用寄存器 edx 的内容作为值参与计算</p>
<p><code>比例因子</code>:是一个常数，用于与变址寄存器的值相乘。</p>
<p><code>R[eax]×2</code>:将寄存器 eax 的内容乘以 2 作为变址寄存器的偏移量</p>
</blockquote>
<p>⑦ 在指定数据长度方面,A 格式指令操作码的后面紧跟一个字符,表明操作数大小,&quot;b&quot;表示 byte(字节)、&quot;w&quot;表示 word(字)或&quot;l&quot;表示 Long(双字)。I 格式也有类似的语法,他在操作码后面显示地注明 byte ptr、word ptr、dword ptr。</p>
<p>例子:将一个 16 位的数据保存到内存地址 0x200 处</p>
<p>AT&amp;T 格式:</p>
<pre><code class="language-x86asm">movb $0x56, 0x200
</code></pre>
<p>Intel 格式</p>
<pre><code class="language-x86asm">mov word ptr [0x200], 0x56
</code></pre>
<blockquote>
<p>由于 32 位和 64 位都是由 16 位拓展而来,因此用 word(字)表示 16 位</p>
</blockquote>
<p>以下是两种格式指令格式的对比</p>
<table>
<thead>
<tr>
<th style="text-align:center">AT&amp;T 格式</th>
<th style="text-align:center">Intel 格式</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mov $100, %eax</td>
<td style="text-align:center">mov eax, 100</td>
<td style="text-align:center">100 → R[eax]</td>
</tr>
<tr>
<td style="text-align:center">mov %eax, %ebx</td>
<td style="text-align:center">mov ebx, eax</td>
<td style="text-align:center">R[eax] → R[ebx]</td>
</tr>
<tr>
<td style="text-align:center">mov %eax, (%ebx)</td>
<td style="text-align:center">mov [ebx], eax</td>
<td style="text-align:center">R[eax] → M[R[ebx]]</td>
</tr>
<tr>
<td style="text-align:center">mov %eax, -8(%ebp)</td>
<td style="text-align:center">mov [ebp-8], eax</td>
<td style="text-align:center">R[eax] →M[R[ebx]-8]</td>
</tr>
<tr>
<td style="text-align:center">lea 8(%edx, %eax, 2), %eax</td>
<td style="text-align:center">lea eax, [edx+eax*2+8]</td>
<td style="text-align:center">R[edx]+R[eax]×2+8 → R[eax](这个 lea 指令（effective address）的意思是计算有效地址,而不是直接从内存中加载数据到寄存器,所以这里不是 M[R[edx]+R[eax]×2+8])</td>
</tr>
<tr>
<td style="text-align:center">movl %eax, %ebx</td>
<td style="text-align:center">mov dword ptr ebx, eax</td>
<td style="text-align:center">长度为 4 字节的 R[eax] → R[ebx]</td>
</tr>
</tbody>
</table>
<blockquote>
<p>R[r]表示寄存器 r 的内容,M[addr]表示主存单元 addr 的内容,→ 表示信息传送方向</p>
</blockquote>
<h4 id="chang-yong-zhi-ling">常用指令</h4>
<p>汇编指令通常可以分为<code>数据传送指令</code>、<code>逻辑计算指令</code>和<code>控制流指令</code>下面是以 Intel 格式为例的一些重要指令</p>
<p>以下是一些格式介绍:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>&lt;reg&gt;</code>:表示任意寄存器,若其后带有数字,则指定其位数,如&lt;reg32&gt;表示 32 位寄存器(eax、ebx、ecx、edx、esi、edi、ebp、esp);&lt;reg16&gt;代表 16 位寄存器(ax、bx、cx、dx、si、di、bp、sp);&lt;reg8&gt;代表 8 位寄存器(ah、al、bh、bl、ch、cl、dh、dl)</p>
</li>
<li class="lvl-2">
<p><code>&lt;mem&gt;</code>:表示内存地址(如[eax]、[var+4]或 dword ptr [eax+ebx])</p>
</li>
<li class="lvl-2">
<p><code>&lt;con&gt;</code>:表示 8 位、16 位或 32 位常数。&lt;con8&gt;表示 8 位常数;&lt;con16&gt;表示 16 位常数;&lt;con32&gt;表示 32 位常数</p>
</li>
<li class="lvl-2">
<p><code>&lt;cl&gt;</code>:表示要移动的位数，它可以是一个立即数或者是另一个寄存器。</p>
</li>
</ul>
<p>x86 中的指令机器码长度为 1 字节,对同一指令的不同用途有多种编码方式,比如 mov 指令就有 28 种机内编码,用于不同的操作数类型或用于特定的寄存器:</p>
<pre><code class="language-x86asm">mov &lt;con16&gt;, ax						#机器码为B8H
mov &lt;con8&gt;, al						#机器码为B0H
mov &lt;reg16&gt;, &lt;reg16&gt;/&lt;mem16&gt;		#机器码为89H
mov &lt;reg8&gt;&lt;mem18&gt;, &lt;reg8&gt;			#机器码为8AH
mov &lt;reg16&gt;/&lt;mem16&gt;, &lt;reg16&gt;		#机器码为8BH
</code></pre>
<h5 id="shu-ju-chuan-song-zhi-ling">数据传送指令</h5>
<h6 id="mov-zhi-ling">mov 指令</h6>
<p>将第二个操作数(寄存器的内容,内存中的内容或常数值)复制到第一个操作数(寄存器或内存)。但<strong>不能直接用于从内存复制到内存</strong></p>
<p>其语法如下:</p>
<pre><code class="language-x86asm">mov &lt;reg&gt;, &lt;reg&gt;
mov &lt;reg&gt;, &lt;mem&gt;
mov &lt;mem&gt;, &lt;reg&gt;
mov &lt;reg&gt;, &lt;con&gt;
mov &lt;mem&gt;, &lt;com&gt;

#例子:
mov eax, ebx 				#将ebx值复制到eax
mov byte ptr [var], 5		#将5保存到var指示的内存地址的一字节中
</code></pre>
<h6 id="push-zhi-ling">push 指令</h6>
<p>将操作数压入内存的栈,常用于函数调用。ESP 时栈顶,压栈前先将 ESP 值减 4(栈增长方向与内存地址增长方向相反),然后将操作数压入 ESP 指示的地址</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/1251900-20171222111105318-578935555.png" alt="img"></p>
<p>语法如下:</p>
<pre><code class="language-x86asm">push &lt;reg32&gt;
push &lt;mem&gt;
push &lt;con32&gt;

#例子:
push eax		#将eax值压栈
push [var]		#将var值指示的内存地址的4字节值压栈
</code></pre>
<h6 id="pop-zhi-ling">pop 指令</h6>
<p>与 push 指令相反,pop 指令执行的是出栈操作,出栈前先将 ESP 指示的地址中的内容出栈,然后将 ESP 的值加 4</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/1251900-20171222111908896-493635123.png" alt="img"></p>
<p>语法格式如下:</p>
<pre><code class="language-x86asm">pop edi			#弹出栈顶元素送到edi
pop [ebx] 		#弹出栈顶元素送到ebx值指示的内存地址的4字节中
</code></pre>
<h5 id="suan-shu-he-luo-ji-yun-suan-zhi-ling">算数和逻辑运算指令</h5>
<h6 id="add-sub-zhi-ling">add/sub 指令</h6>
<p><code>add</code>指令将两个操作数相加,相加的结果保存到第一个操作数中。<code>sub</code>指令用于两个操作数相减,相减的结果保存到第一个操作数中</p>
<pre><code class="language-x86asm">add &lt;reg&gt;,&lt;reg&gt; / sub &lt;reg&gt;,&lt;reg&gt;
add &lt;reg&gt;,&lt;mem&gt; / sub &lt;reg&gt;,&lt;mem&gt;
add &lt;mem&gt;,&lt;reg&gt; / sub &lt;mem&gt;,&lt;reg&gt;
add &lt;reg&gt;,&lt;con&gt; / sub &lt;reg&gt;,&lt;con&gt;
add &lt;mem&gt;,&lt;con&gt; / sub &lt;mem&gt;,&lt;con&gt;

#例子:
sub eax, 10		#eax ← eax-10
add byte ptr [var], 10 		#10与var值指示的内存地址的1字节的值相加,并将结果保存在var值指示的内存地址的字节中
</code></pre>
<h6 id="inc-dec-zhi-ling">inc/dec 指令</h6>
<p><code>inc</code>指令是表示将操作数自增 1;<code>dec</code>指令是表示将操作数自减 1</p>
<pre><code class="language-x86asm">inc &lt;reg&gt; / dec &lt;reg&gt;
inc &lt;mem&gt; / dec &lt;mem&gt;

#例子:
dec eax			#eax的值自减1
inc dword ptr	#var所指示的啊内存地址的4字节的值自增1(d double,word 16位)
</code></pre>
<h6 id="imul-zhi-ling">imul 指令</h6>
<p>带符号整数乘法指令,有两种格式:</p>
<p>① 两个操作数,将两个操作数相乘,将结果保存在第一个操作数中,<strong>第一个操作数必须为寄存器</strong></p>
<p>②3 个操作数,将第二个和第三个操作数相乘,将结果保存在第一个操作数中,<strong>第一个操作数必须为寄存器</strong></p>
<p>其语法格式如下:</p>
<pre><code class="language-x86asm">imul &lt;reg32&gt;,&lt;reg32&gt;
imul &lt;reg32&gt;,&lt;mem&gt;
imul &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;
imul &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;


#例子:
imul eax, [var]		#eax ← eax * [var]
imul esi, edi, 25	#esi ← edi * 25
</code></pre>
<p>乘法操作结果可能溢出,则编译器设置<code>溢出标志 OF=1</code>,以使 CPU 调出溢出异常处理程序。</p>
<h6 id="idiv-zhi-ling">idiv 指令</h6>
<p>带符号整数除法,他只有一个操作数,即除数,而被除数则为 edx:eax 中的内容(64 位整数),操作结果有两部分:商和余数,商送到 eax,余数送到 edx</p>
<p>其语法如下:</p>
<pre><code class="language-x86asm">idiv &lt;reg32&gt;
idiv &lt;mem&gt;

#例子:
idiv ebx
idiv dword ptr [var]
</code></pre>
<h6 id="and-or-xor-zhi-ling">and/or/xor 指令</h6>
<p>分别是<code>逻辑与</code>、<code>逻辑或</code>、<code>逻辑异或</code>指令操作,用于操作数的位操作,操作结果放在第一个操作数中</p>
<pre><code class="language-x86asm">and &lt;reg&gt;,&lt;reg&gt; / or &lt;reg&gt;,&lt;reg&gt; / xor &lt;reg&gt;,&lt;reg&gt;
and &lt;reg&gt;,&lt;mem&gt; / or &lt;reg&gt;,&lt;mem&gt; / xor &lt;reg&gt;,&lt;mem&gt;
and &lt;mem&gt;,&lt;reg&gt; / or &lt;mem&gt;,&lt;reg&gt; / xor &lt;mem&gt;,&lt;reg&gt;
and &lt;reg&gt;,&lt;con&gt; / or &lt;reg&gt;,&lt;con&gt; / xor &lt;reg&gt;,&lt;con&gt;
and &lt;mem&gt;,&lt;con&gt; / or &lt;mem&gt;,&lt;con&gt; / xor &lt;mem&gt;,&lt;con&gt;

#例子:
and eax, 0fH		#将eax中的前28位全部置为0,最后4位保持不变,0fH(H表示该数为16进制数)
xor edx, edx		#置edx中的内容为0
</code></pre>
<h6 id="not-zhi-ling">not 指令</h6>
<p>位翻转指令,将操作数中的每一位翻转,即 0 → 1、1 → 0</p>
<p>其语法如下:</p>
<pre><code class="language-x86asm">not &lt;reg&gt;
not &lt;mem&gt;

#例子:
not byte ptr [var]	#将var值指示的内存地址的一字节的所有位翻转
</code></pre>
<h6 id="neg-zhi-ling">neg 指令</h6>
<p>取负指令</p>
<pre><code class="language-x86asm">neg &lt;reg&gt;
neg &lt;mem&gt;

#例子:
neg eax				#eax ← eax
</code></pre>
<h6 id="shl-shr-zhi-ling">shl/shr 指令</h6>
<p>逻辑移位指令,shl 为逻辑左移,shr 为逻辑右移,第一个操作数表示被操作数,第二个操作指示移位的位数</p>
<pre><code class="language-x86asm">shl &lt;reg&gt;,&lt;con8&gt; / shr &lt;reg&gt;,&lt;con8&gt;
shl &lt;mem&gt;,&lt;con8&gt; / shr &lt;mem&gt;,&lt;con8&gt;
shl &lt;reg&gt;,&lt;cl&gt; / shr &lt;reg&gt;,&lt;cl&gt;
shl &lt;mem&gt;,&lt;cl&gt; / shr &lt;mem&gt;,&lt;cl&gt;

#例:
shl eax, 1			#将eax值左移一位,相当于乘2
shr ebx, cl 		#将ebx值右移n位(n为cl中的值),相当于除2
</code></pre>
<h5 id="kong-zhi-liu-zhi-ling">控制流指令</h5>
<p>x86 处理器维持一个指示当前执行指令的指令指针(IP),当一条指令执行后,此指针自动指向下一条指令。IP 寄存器不能直接操作,但可以用控制流指令更新。通常用标签(label)指示程序中的指令地址,在 x86 的汇编代码中,可在任何指令前加入标签。例如:</p>
<pre><code class="language-x86asm">		mov esi, [ebp+8]
 begin: xor ecx, ecx
		mov eax, [esi]
</code></pre>
<p>这样 begin 指示了第二条指令,控制流指令通过标签就可以实现程序指令的跳转</p>
<h6 id="jmp-zhi-ling">jmp 指令</h6>
<p>控制 IP 转移到 label 所指示的地址(从 label 中取出指令执行)</p>
<pre><code class="language-x86asm">jmp &lt;label&gt;

#例子:
jmp begin			#跳转到begin标记的指令执行
</code></pre>
<h6 id="jcondition-zhi-ling">jcondition 指令</h6>
<p>条件转移指令,依据 CPU 状态字中的一系列条件状态转移。CPU 状态字中包括指示最后一个算数运算结果是否为 0,运算结果是否为负数等</p>
<pre><code class="language-x86asm">je &lt;label&gt;	(jump when equal)
jne &lt;label&gt;	(jump when not equal)
jz &lt;label&gt;	(jump when last result was zero)
jnz &lt;label&gt;	(jump when result was not zero)
jg &lt;label&gt;	(jump when greather than)
jge &lt;label&gt;	(jump when greather than or equal to)
jl &lt;label&gt;	(jump when less than)
jle &lt;label&gt;	(jump when less than or equal to)

#例子:
cmp eax, ebx
jle done 			#如果eax的值小于等于ebx的值,跳转到done指示的指令执行,否则执行下一条指令
</code></pre>
<h6 id="cmp-test-zhi-ling">cmp/test 指令</h6>
<p>cmp 指令用于比较两个操作数的值(compare),test 指令对两个操作数进行逐位与运算,<strong>这两类指令都不保存操作结果,仅根据运算结果设置 CPU 状态字中的条件码</strong></p>
<pre><code class="language-x86asm">cmp &lt;reg&gt;,&lt;reg&gt; / test &lt;reg&gt;,&lt;reg&gt;
cmp &lt;mem&gt;,&lt;reg&gt; / test &lt;mem&gt;,&lt;reg&gt;
cmp &lt;reg&gt;,&lt;mem&gt; / test &lt;reg&gt;,&lt;mem&gt;
cmp &lt;reg&gt;,&lt;con&gt; / test &lt;reg&gt;,&lt;con&gt;

#cmp和test通常和jcondition指令搭配使用,举例:
cmp dword ptr [var], 10		#将var指示的主存地址为4字节的内容,与10进行比较
jne loop					#如果相等则顺序执行,如果不相等则跳转到loop处执行
test eax, eax				#测试eax是否为0
jz xxxx						#为零则置标志ZF为1,跳转到xxxx处执行
</code></pre>
<h6 id="call-ret-zhi-ling">call/ret 指令</h6>
<p>分别用于实现子程序(过程、函数等)的调用及返回</p>
<pre><code class="language-x86asm">call &lt;label&gt;
ret
</code></pre>
<p>call 指令首先将当前执行指令地址入栈,然后无条件转移到由标签指示的命令。与其他简单的跳转指令不同,call 指令保存调用前的地址信息(当 call 命令结束后,返回调用之前的地址)。</p>
<p>ret 指令实现子程序的返回机制,ret 指令弹出栈中保存的指令地址,然后无条件转移到保存的指令地址执行。</p>
<h3 id="guo-cheng-diao-yong-de-ji-qi-ji-biao-shi">过程调用的机器级表示</h3>
<p>上面说 call/ret 指令主要用于过程调用,他们都属于一种无条件转移指令。</p>
<p>假定过程 P(调用者)调用过程 Q(被调用者),过程调用的执行步骤如下:</p>
<ol>
<li class="lvl-3">
<p>P 将入口参数(实参)放在 Q 能够访问到的地方</p>
</li>
<li class="lvl-3">
<p>P 将返回地址存到特定的地方,然后控制转移到 Q(call 实现)</p>
</li>
<li class="lvl-3">
<p>Q 保存 P 的现场(通用寄存器的内容),并为自己的非静态局部变量分配空间</p>
</li>
<li class="lvl-3">
<p>执行过程 Q</p>
</li>
<li class="lvl-3">
<p>Q 恢复 P 的现场,将返回结果放到 P 能够访问到的地方,并释放局部变量所占空间</p>
</li>
<li class="lvl-3">
<p>Q 取出返回地址,将控制转移到 P(ret 实现)</p>
</li>
</ol>
<p>其中寄存器 EAX、ECX 和 EDX 是<code>调用者保存寄存器</code>,其保存和恢复的任务由过程 P 负责,P 调用 Q 时,Q 就可以直接使用这 3 个寄存器</p>
<p>寄存器 ESI、EDI、EBX 是<code>被调用者保存寄存器</code>,Q 必须先将他们的值保存在栈中才能使用它们,并在返回 P 之前先恢复它们的值</p>
<p>每个过程都有自己的栈区,称为<code>栈帧</code>,因此,一个栈由若干帧栈帧组成。帧指针寄存器 EBP 指示当前栈帧的起止位置(栈底),栈指针寄存器 ESP 指示栈顶,栈从高地址向低地址增长,因此当前栈帧的范围在帧指针 EBP 和 ESP 指向的区域之间</p>
<h3 id="xuan-ze-yu-ju-de-ji-qi-ji-biao-shi">选择语句的机器级表示</h3>
<p>常见的选择结构语句有<code>if-then</code>、<code>if-then-else</code>、<code>case(或switch)</code>等。编译器通过条件码(标志位)设置指令和各类转移指令来实现程序中的选择结构语句。</p>
<p><strong>条件码(标志位)</strong></p>
<p>除了整数寄存器,CPU 还维护一组<code>条件码(标志位)寄存器</code>,他们描述了<strong>最近</strong>的算数或逻辑运算操作的属性。可以检测这些寄存器来执行条件分支指令,最常用的条件码如下:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>CF</strong>:进(借)位标志,最近无符号整数加(减)运算后的进(借)位情况。有进(借)位时,CF = 1;否则 CF = 0</p>
</li>
<li class="lvl-2">
<p><strong>ZF</strong>:零标志。最近的操作的运算结果是否为 0。若结果为 0,ZF = 1;否则 ZF = 0</p>
</li>
<li class="lvl-2">
<p><strong>SF</strong>:符号标志。最近的带符号数运算结果的符号。若为负,SF = 1;否则 SF = 0</p>
</li>
<li class="lvl-2">
<p><strong>OF</strong>:溢出标志。最近的带符号数运算结果是否溢出,若溢出,OF =1;否则 OF = 0</p>
</li>
</ul>
<p>可见,OF 和 SF 对无符号数运算来说没有意义,而 CF 对带符号数运算来说没有意义</p>
<h2 id="cisc-he-risc-de-ji-ben-gai-nian">CISC 和 RISC 的基本概念</h2>
<p>CISC 复杂指令系统计算机，功能更强大，指令更复杂；RISC 精简指令系统计算机，指令简单，执行速度快。</p>
<p>RISC 精简指令系统计算机，要求指令系统简化，尽量使用<strong>寄存器-寄存器</strong>操作指令。指令格式一致，指令长度固定、种类少，寻址方式种类少，<strong>指令功能没那么强</strong>。</p>
<p>RISC 采用指令流水线技术，使大部分指令在一个时钟周期内完成。适合流水线的指令系统的特征有 ∶</p>
<p>① 指令长度应尽量一致;</p>
<p>② 指令格式应尽量规整;</p>
<p>③ 保证除 Load/Store 指令外的其他指令都不访问存储器;</p>
<p>④<strong>数据和指令在存储器中&quot;对齐&quot;存放</strong>。</p>
<h1 id="zhong-yang-chu-li-qi">中央处理器</h1>
<h2 id="cpu-de-gong-neng-he-ji-ben-jie-gou">CPU 的功能和基本结构</h2>
<h3 id="cpu-de-gong-neng">CPU 的功能</h3>
<p><strong>指令控制</strong> 程序的顺序控制，称为指令控制。由于程序是一个指令序列，这些指令的 相互顺序不能任意颠倒，必须严格按程序规定的顺序进行，因此，保证机器按顺序执行程 序是 CPU 的首要任务。</p>
<p><strong>操作控制</strong> 一条指令的功能往往是由若干个操作信号的组合来实现的，因此，CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制 这些部件按指令的要求进行动作。</p>
<p><strong>时间控制</strong> 对各种操作实施时间上的定时，称为时间控制。因为在计算机中，各种指令的操作信号均受到时间的严格定时。另外，一条指令的整个执行过程也受到时间的严格 定时。只有这样，计算机才能有条不紊地自动工作。</p>
<p><strong>数据加工</strong> 所谓数据加工，就是对数据进行算术运算和逻辑运算处理。完成数据的加工处理，是 CPU 的根本任务。因为，原始信息只有经过加工处理后才能对人们有用</p>
<p><strong>中断处理</strong> 对计算机运行过程中出现的异常情况和特殊请求进行处理</p>
<h3 id="cpu-de-ji-ben-jie-gou">CPU 的基本结构</h3>
<p><strong>控制器</strong></p>
<p>由<code>程序计数器(PC)</code>、<code>指令寄存器(IR)</code>、<code>指令译码器(ID)</code>、<code>时序产生器和操作控制器(OC)</code>组成， 它是发布命令的“决策机构”，即完成协调和指挥整个计算机系统的操作。</p>
<p>控制器的主要功能有：</p>
<ol>
<li class="lvl-3">
<p>从指令 cache 中取出一条指令，并指出下一条指令在指令 cache 中的位置。</p>
</li>
<li class="lvl-3">
<p>对指令进行译码或测试，并产生相应的操作控制信号，以便启动规定的动作。比如， 一次数据 cache 的读/写操作，一个算术逻辑运算操作，或一个输入/输出操作。</p>
</li>
<li class="lvl-3">
<p>指挥并控制 CPU、数据 cache 和输入/输出设备之间数据流动的方向。</p>
</li>
</ol>
<p>下面详细介绍一下控制器的组成:</p>
<ol>
<li class="lvl-3">
<p><strong>指令寄存器(IR)</strong> <span style="color:red">指令寄存器用来保存当前正在执行的一条指令。</span>当执行一条指令 时，先把它从指令存储器(简称指存)读出，然后再传送至指令寄存器。指令划分为操作码 和地址码字段，由二进制数字组成。为了执行任何给定的指令，必须对操作码进行测试， 以便识别所要求的操作。一个叫做指令译码器的部件就是做这项工作的。指令寄存器中操 作码字段 OP 的输出就是指令译码器的输入。操作码一经译码后，即可向操作控制器发出具 体操作的特定信号。</p>
</li>
<li class="lvl-3">
<p><strong>程序计数器(PC)</strong> <span style="color:red">用来指出下一条指令在主存中存放给的地址。</span>在程序开始执行前，必须将它的起始地址，即程序的第一条指令所在的指存单元地址送入 PC，因此 PC 的内容即是从指存提取的第一条指令的地址。当执行指令时，CPU 将自动修改 PC 的内容，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按 顺序来执行的，所以修改的过程通常只是简单的对 PC 加 1。 但是，当遇到转移指令如 JMP 指令时，那么后继指令的地址(即 PC 的内容)必须从指令寄存器中的地址字段取得。在这种情况下，下一条从指存取出的指令将由转移指令来规定，而不是像通常一样按顺序来取得。因此程序计数器的结构应当是具有寄存器和计数两种功能的结构。<code>汇编程序员可见</code></p>
</li>
<li class="lvl-3">
<p><strong>存储器地址寄存器(MAR)</strong> 用于存放要访问的主存单元的地址</p>
</li>
<li class="lvl-3">
<p><strong>存储数据寄存器(MDR)</strong> 用于存放向主存写入的信息或从主存读出的信息</p>
</li>
<li class="lvl-3">
<p><strong>时序系统</strong> 用于产生各种时序信号,他们都由统一时钟(CLOCK)分频得到</p>
</li>
<li class="lvl-3">
<p><strong>微操作信号信号发生器</strong> 根据 IR 的内容(指令)、PSW 的内容(状态信息)及时序信号,产生控制计算机各个部件所要用到的控制信号</p>
</li>
</ol>
<p><strong>运算器</strong></p>
<p>由<code>算术逻辑运算单元(ALU)</code>、<a href="####%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8"><code>通用寄存器</code></a>、<code>数据缓冲寄存器(DR)</code>和<code>程序状态字寄存器(状态条件寄存器，PSWR)</code>组成，它是数据加工处理部件。相对控制器而言，运算器接受控制器的命令而进行动作，即运算器所进行的全部操作都是由控制器发出的控制信号来指挥的，所以它是执行部件。</p>
<p>运算器有两个主要功能：</p>
<ol>
<li class="lvl-3">
<p>执行所有的算术运算。</p>
</li>
<li class="lvl-3">
<p>执行所有的逻辑运算，并进行逻辑测试，如零值测试或两个值的比较。 通常，一个算术操作产生一个运算结果，而一个逻辑操作则产生一个判决。</p>
</li>
</ol>
<p>下面详细介绍一下运算器的组成:</p>
<ol>
<li class="lvl-3">
<p><strong>算数逻辑单元(ALU)</strong>: 进行算数/逻辑运算</p>
</li>
<li class="lvl-3">
<p><strong>暂存寄存器</strong>: 用于暂存从主存读来的数据,该数据不能存放在通用寄存器中,某则会破坏其原有的内容。<code>暂存寄存器对应用程序员来说是透明的</code></p>
</li>
<li class="lvl-3">
<p><strong>累加寄存器(ACC)</strong>:一个通用寄存器,用于暂时存放 ALU 的运算结果,可做加法运算的一个输入端</p>
</li>
<li class="lvl-3">
<p><strong>通用寄存器</strong> 在我们的模型中，通用寄存器有 4 个(R0 ～ R3)，其功能是：当算术逻 辑单元(ALU)执行算术或逻辑运算时，为 ALU 提供一个工作区。例如，在执行一次加法运 算时，选择两个操作数(分别放在两个寄存器)相加，所得的结果送回其中一个寄存器(如 R2)中，而 R2 中原有的内容随即被替换。</p>
<p>目前 CPU 中的通用寄存器，可多达 64 个，甚至更多。其中任何一个可存放源操作数， 也可存放结果操作数。在这种情况下，需要在指令格式中对寄存器号加以编址。从硬件结 构来讲，需要使用通用寄存器堆结构，以便选择输入信息源。通用寄存器还用作地址指示 器、变址寄存器、堆栈指示器等。</p>
</li>
<li class="lvl-3">
<p><strong>程序状态字寄存器(PSWR)</strong> 程序状态字寄存器又称为状态条件寄存器，<span style="color:red">保存由算术运算指令和逻辑运算指令运算或测试结果建立的各种条件代码</span>，如运算结果<code>进位标志C)</code>，<code>运算结果溢出标志(V)</code>，<code>运算结果为零标志(Z)</code>，<code>运算结果为负标志(N)</code>，等等。这些 标志位通常分别由 1 位触发器保存。 除此之外，状态条件寄存器还保存中断和系统工作状态等信息，以便使 CPU 和系统能 及时了解机器运行状态和程序运行状态。因此，状态条件寄存器是一个由各种状态条件标 志拼凑而成的寄存器。<code>对所有用户可见</code></p>
</li>
<li class="lvl-3">
<p><strong>移位器</strong> 对操作数或运算记过进行移位操作</p>
</li>
<li class="lvl-3">
<p><strong>计数器</strong> 控制乘除运算的操作步骤</p>
</li>
</ol>
<blockquote>
<p>虚拟存储器对系统程序员可见</p>
</blockquote>
<p>以下是哈弗结构的 CPU 模型简略图(数据 cache 和指令 cache 分离)👇:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230712163507973.png" alt="image-20230712163507973"></p>
<p>`</p>
<p><strong>寄存器和存储器的可见性总结</strong>:</p>
<table>
<thead>
<tr>
<th style="text-align:left">寄存器</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">汇编程序员可见</th>
<th style="text-align:left">应用程序员可见</th>
<th style="text-align:left">系统程序员可见</th>
<th style="text-align:left">用户是否可见(可编程)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">PSW</td>
<td style="text-align:left">在条件转移指令中使用，以及在程序员使用 CMP 指令时需要用到</td>
<td style="text-align:left"><strong>是</strong></td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><strong>是</strong></td>
</tr>
<tr>
<td style="text-align:left">PC</td>
<td style="text-align:left">跳转指令需要使用 PC+n 来实现</td>
<td style="text-align:left"><strong>是</strong></td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><strong>是</strong></td>
</tr>
<tr>
<td style="text-align:left">通用寄存器</td>
<td style="text-align:left">程序员可以使用通用寄存器 R 写指令</td>
<td style="text-align:left"><strong>是</strong></td>
<td style="text-align:left"><strong>是</strong></td>
<td style="text-align:left">否</td>
<td style="text-align:left"><strong>是</strong></td>
</tr>
<tr>
<td style="text-align:left">MAR</td>
<td style="text-align:left">内存地址寄存器，用于存储要访问的内存地址</td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><strong>是</strong></td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">MDR</td>
<td style="text-align:left">内存数据寄存器，用于存储从内存读取或将数据写入内存的数据</td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">累加器 ACC</td>
<td style="text-align:left">用于存储运算结果和进行算术逻辑操作</td>
<td style="text-align:left"><strong>是</strong></td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><strong>是</strong></td>
</tr>
<tr>
<td style="text-align:left">IR</td>
<td style="text-align:left">指令寄存器，用于存储当前正在执行的指令</td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">Cache</td>
<td style="text-align:left">高速缓存，用于临时存储内存中的数据，以提高访问速度</td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><strong>是</strong></td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">微程序结构和功能</td>
<td style="text-align:left">CPU 内部的微指令，用于控制 CPU 的操作流程</td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><strong>是</strong></td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">暂存寄存器</td>
<td style="text-align:left">CPU 内部用于完成某些操作的寄存器</td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><strong>是</strong></td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">虚拟寄存器</td>
<td style="text-align:left">虚拟机中的寄存器</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><strong>是</strong></td>
<td style="text-align:left"><strong>是</strong></td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">虚拟存储器</td>
<td style="text-align:left">系统程序员通过虚拟存储器来管理内存的使用，以及进行进程之间的隔离和保护。</td>
<td style="text-align:left">否</td>
<td style="text-align:left">否</td>
<td style="text-align:left"><strong>是</strong></td>
<td style="text-align:left">否</td>
</tr>
</tbody>
</table>
<h2 id="zhi-ling-de-guo-cheng">指令的过程</h2>
<h3 id="zhi-ling-zhou-qi">指令周期</h3>
<p>CPU 从主存中取出并执行一条指令的时间称为指令周期,不同指令的指令周期可能不同。</p>
<p>指令周期常用若干机器周期来表示,一个机器周期又包含若干个时钟周期(也称节拍或 T 周期,它是 CPU 操作的最基本的单位)。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230712224618774.png" alt="image-20230712224618774"></p>
<p>完整的指令周期：</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20201019215210426.png" alt="img"></p>
<p>上述 4 个工作周期都有 CPU 访存操作，只是访存的目的不同。</p>
<p><strong>取指周期是为了取指令(控制器自动进行，不需要得到相应的指令)</strong></p>
<p><strong>间址周期是为了取操作数有效地址</strong></p>
<p><strong>执行周期是为了取操作数并执行运算</strong></p>
<p><strong>中断周期是为了保存程序断点</strong></p>
<blockquote>
<p>为了区分不同的工作周期,在 CPU 内设置了 4 个标志触发器 FE、IND、EX 和 INT,他们分别对应<code>取指</code>、<code>间址</code>、<code>执行</code>和<code>中断</code>周期,并以&quot;1&quot;状态表示有效</p>
</blockquote>
<h3 id="zhi-ling-zhou-qi-de-shu-ju-liu">指令周期的数据流</h3>
<h4 id="qu-zhi-zhou-qi">取指周期</h4>
<p>根据 PC 中的内容从主存中取出指令代码并存放在 IR 中</p>
<p>取指周期的数据流向如下图 👇:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230713092234989.png" alt="image-20230713092234989"></p>
<blockquote>
<p><strong><em>在取指令开始的时候，PC 存放的是当前指令的地址；取指完成后，PC 中存放的是下一条指令的地址。</em></strong><br>
区别在于 是取指令开始的阶段还是取指令结束的阶段。</p>
</blockquote>
<h4 id="jian-zhi-zhou-qi">间址周期</h4>
<p>取操作数的有效地址</p>
<p>间址周期的数据流向如下图 👇:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230713092728467.png" alt="image-20230713092728467"></p>
<p>为什么有个或？ 因为在取指周期阶段是先把指令放在 MDR 里面，再传到 IR；进入到间址周期， MDR 中内容是暂时还没有改的，里面存的也还是之前的内容。所以 “有个或” 。</p>
<blockquote>
<p>Ad(IR)表示取出 IR 中存放指令字的地址字段</p>
</blockquote>
<h4 id="zhi-xing-zhou-qi">执行周期</h4>
<p>根据 IR 中的指令的操作码和 MDR 中地址对应的主存的操作数，通过 ALU 操作产生执行结果。不同的指令执行周期操作不同，因此数据流无法统一。</p>
<h4 id="zhong-duan-zhou-qi">中断周期</h4>
<p>处理中断请求。假设程序断点存入堆栈中,并用 SP 指示栈顶地址,并且进栈操作是先修改栈顶指针,后存入数据</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230713091644918.png" alt="image-20230713091644918"></p>
<p><span style="color:rgb(246, 132, 43);font-weight:600">只是先暂停任务，去完成其它任务。为了恢复当前任务，需要保存断点。</span><span style="color:rgb( 142, 205, 109);font-weight:600">【断点：本来要执行的下一条指令，即 PC 的内容】</span>一般使用 堆栈结构来保存断点，SP 表示栈顶地址。假设 SP 指向栈顶元素，进栈操作是先修改指针后存入数据。【如果是栈顶元素上一个位置，则是先存入数据，再移动指针】</p>
<p>调整指针是通过 <span style="color:red;font-weight:600">减 1</span> 实现，和平时的方向是相反的，<span style="color:rgb( 142, 205, 109);font-weight:600">因为在主存中选一片区域做堆栈的时候，是从高地址码向低地址去扩增的。</span>所以进栈用减法，出栈用加法。</p>
<p><span style="color:rgb(51, 153, 234);font-weight:600">到第 3 步，将 PC 的内容送到 MDR 之后，配合之前写的命令，PC 的内容就会通过数据总线放到存储器中。<br>
(MDR)  → M(MAR)</span></p>
<p>第 3 步完成后，就完成了中断操作的第一个任务：保存断点（即暂停当前任务）；<span style="color:rgb(246, 132, 43);font-weight:600">下一步是要去完成其它任务，怎么开始完成其它任务？</span><br>
<span style="color:rgb( 142, 205, 109);font-weight:600">把任务要执行的第一条指令地址（即中断服务程序的入口地址）放到 PC 中。</span>这个地址是由向量形成部件产生的（中断章节具体介绍），故该地址又被称为 向量地址。 这样下一步， CPU 还是根据 PC 中的内容去寻找下一条指令，所以就切入到了一个新的程序的运行。</p>
<h3 id="zhi-ling-zhi-xing-fang-an">指令执行方案</h3>
<p><strong>单指令周期</strong>：具体来说，就是不分取指阶段、执行阶段等，而是将指令周期作为一个阶段，就相当于每个指令周期都是一个机器周期。这种模式下，指令和指令之间是串行执行的。因为所有的指令需要统一 一个时间，所以指令周期 取决于执行时间最长的指令的执行时间。</p>
<p><strong>多指令周期</strong>:对不同类型的指令选用不同的执行步骤。指令之间串行执行。</p>
<p><strong>流水线方案</strong>：间隔一定时间启动就启动一条指令，原理是：在不同的机器周期（不同的小步骤下），一条指令所需要的硬件资源是不同的，所以这样的安排相当于多条指令在并行执行，只不过在不同的阶段在使用不同的硬件。</p>
<h2 id="shu-ju-tong-lu-de-gong-neng-he-ji-ben-jie-gou">数据通路的功能和基本结构</h2>
<h3 id="shu-ju-tong-lu-de-gong-neng">数据通路的功能</h3>
<p>数据通路就是数据在功能部件之间传送的路径；</p>
<p>数据通路描述了信息从哪里开始、中间经过哪些部件、最终传送到哪个寄存器；</p>
<p>数据通路由 <mark>控制部件</mark> 控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号；</p>
<p>数据通路的功能是<mark>实现 CPU 内部的 运算器与寄存器 及 寄存器之间 的数据交换</mark> ；</p>
<h3 id="shu-ju-tong-lu-de-ji-ben-jie-gou">数据通路的基本结构</h3>
<p>数据通路的基本结构包括以下三种：</p>
<p>① <strong>CPU 内部单总线结构</strong></p>
<p>所有寄存器的输入端和输出端都连接连接到一条公共通路上；</p>
<p>特点：结构简单、易数据冲突、性能低；</p>
<p>② <strong>CPU 内部三总线结构</strong></p>
<p>所有寄存的输入输出端链接到多条公共通路上</p>
<p>③ <strong>专用数据通路方式</strong></p>
<p>根据指令执行过程中的数据和地址的流动方向安排连接线路；</p>
<p>特点：避免使用共享的总线，性能高、硬件量大；</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210715141630.png" alt="找不到图片(Image not found)"></p>
<blockquote>
<p>字母加&quot;<code>in</code>&quot;表示该部件允许输入控制信号</p>
<p>字母加&quot;<code>out</code>&quot;表示该部件允许输出控制信号</p>
<p>注意: <code>内部总线</code>是指同一部件，如 CPU 内部连接各寄存器及运算部件之间的总线; <code>系统总线</code>是指同一台计算机系统的各部件，如 CPU、内存、通道和各类 IO 接口间互相连接的总线。</p>
</blockquote>
<h4 id="ji-cun-qi-zhi-jian-de-shu-chuan-song">寄存器之间的数传送</h4>
<p>寄存器之间的数据传送可通过 CPU 内部总线完成。在图 5.7 中，某寄存器 AX 的输出和输入分别由 AXout 和 AXin 控制。这里以 PC 寄存器为例，把 PC 内容送至 MAR，实现传送操作的流程及控制信号为</p>
<pre><code class="language-css">PC→Bus PCout有效，PC内容送总线
Bus→MAR MARin有效，总线内容送MAR
</code></pre>
<h4 id="zhu-cun-yu-cpu-zhi-jian-de-shu-ju-chuan-song">主存与 CPU 之间的数据传送</h4>
<p>主存与 CPU 之间的数据传送也要借助 CPU 内部总线完成。现以 CPU 从主存读取指令为例说明数据在数据通路中的传送过程。实现传送操作的流程及控制信号为</p>
<pre><code class="language-css">PC→Bus→MAR PCout 和 MARin有效，现行指令地址→MAR
1→R CU发读命令
MEM(MAR)→MDR MDRin有效
MDR→BuS→IR MDRout和 IRin有效，现行指令→IR
</code></pre>
<h5 id="zhi-xing-suan-zhu-huo-luo-ji-yun-suan">执行算术或逻辑运算</h5>
<p>执行算术或逻辑操作时，由于 ALU 本身是没有内部存储功能的组合电路，因此如要执行加法运算，相加的两个数必须在 ALU 的两个输入端同时有效。图 5.7 中的暂存器 Y 即用于该目的。先将一个操作数经 CPU 内部总线送入暂存器 Y 保存，Y 的内容在 ALU 的左输入端始终有效，再将另一个操作数经总线直接送到 ALU 的右输入端。这样两个操作数都送入了 ALU，运算结果暂存在暂存器 Z 中。</p>
<pre><code class="language-css">Ad(IR)→Bus→MAR MDRout和 MARin有效
1→R CU发读命令
MEM→数据线→MDR 操作数从存储器→数据线→MDR
MDR→Bus→Y MDRout 和 Yin有效，操作数→Y
(ACC)+(Y)→Z ACCout 和 ALUin有效，CU向ALU发加命令，结果→Z
Z→ACC Zout和 ACCin有效，结果→ACC
</code></pre>
<h2 id="kong-zhi-qi-de-gong-neng-he-gong-zuo-yuan-li">控制器的功能和工作原理</h2>
<h3 id="kong-zhi-qi-de-jie-gou-he-gong-neng">控制器的结构和功能</h3>
<p>从图 5.8 可以看到计算机硬件系统的五大功能部件及其连接关系。它们通过数据总线、地址总线和控制总线连接在一起，其中点画线框内的是控制器部件。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210715150655.png" alt="找不到图片(Image not found)"></p>
<p>控制器的主要功能有:</p>
<ol>
<li class="lvl-3">
<p>从主存中取出一条指令，并指出下一条指令在主存中的位置。</p>
</li>
<li class="lvl-3">
<p>对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。</p>
</li>
<li class="lvl-3">
<p>指挥并控制 CPU、主存、输入和输出设备之间的数据流动方向。</p>
</li>
</ol>
<p>根据控制器产生微操作控制信号的方式的不同，控制器可分为<code>硬布线控制器</code>和<code>微程序控制器</code>，两类控制器中的 PC 和 IR 是相同的，但确定和表示指令执行步骤的办法以及给出控制各部件运行所需要的控制信号的方案是不同的。</p>
<h3 id="ying-bu-xian-kong-zhi-qi">硬布线控制器</h3>
<p>基本原理是根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号。它由复杂的组合逻辑门电路和一些触发器构成，因此又称<code>组合逻辑控制器</code>。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/d9481fa2bf02472bbcfb7d9af2838d29.png" alt="在这里插入图片描述"></p>
<h4 id="ying-bu-xian-kong-zhi-qi-de-shi-xu-xi-tong-ji-wei-cao-zuo">硬布线控制器的时序系统及微操作</h4>
<p>1）时钟周期。用时钟信号控制节拍发生器，可以产生节拍，每个节拍的宽度正好对应一个时钟周期。在每个节拍内机器可完成一个或几个需同时执行的操作。</p>
<p>2）机器周期。机器周期可视为所有指令执行过程中的一个基准时间。不同指令的操作不同，指令周期也不同。访问一次存储器的时间是固定的，因此通常以存取周期作为基准时间，即内存中读取一个指令字的最短时间作为机器周期。在存储字长等于指令字长的前提下，取指周期也可视为机器周期。</p>
<p>在一个机器周期里可完成若干微操作，每个微操作都需一定的时间，可用时钟信号来控制产生每个微操作命令。</p>
<p>3）指令周期。</p>
<p>4）微操作命令分析。控制单元具有发出各种操作命令（控制信号）序列的功能。这些命令与指令有关，而且必须按一定次序发出，才能使机器有序地工作。</p>
<p>执行程序的过程中，对于不同的指令，控制单元需发出各种不同的微操作命令。一条指令分为 3 个工作周期:取指周期、间址周期和执行周期。下面分析各个子周期的微操作命令。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210930183346.png" alt="找不到图片(Image not found)"></p>
<h5 id="cpu-de-kong-zhi-fang-shi">CPU 的控制方式</h5>
<p>控制单元控制一条指令执行的过程，实质上是依次执行一个确定的微操作序列的过程。由于不同指令所对应的微操作数及复杂程度不同，因此每条指令和每个微操作所需的执行时间也不同。主要有以下 3 种控制方式。</p>
<ol>
<li class="lvl-3">
<p><code>同步控制方式</code> 。所谓同步控制方式，是指系统有一个统一的时钟，所有的控制信号均来自这个统一的时钟信号。通常以最长的微操作序列和最烦琐的微操作作为标准，采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令。同步控制方式的优点是控制电路简单，缺点是运行速度慢。</p>
</li>
<li class="lvl-3">
<p><code>异步控制方式</code>。异步控制方式不存在基准时标信号，各部件按自身固有的速度工作，通过应答方式进行联络。异步控制方式的优点是运行速度快，缺点是控制电路比较复杂。</p>
</li>
<li class="lvl-3">
<p><code>联合控制方式</code>。联合控制方式是介于同步、异步之间的一种折中。这种方式对各种不同的指令的微操作实行大部分采用同步控制、小部分采用异步控制的办法。</p>
</li>
</ol>
<h5 id="ying-bu-xian-kong-zhi-dan-yuan-she-ji-bu-zou">硬布线控制单元设计步骤</h5>
<p>硬布线控制单元设计步骤包括:</p>
<ol>
<li class="lvl-3">
<p><strong>列出微操作命令的操作时间表</strong>。先根据微操作节拍安排，列出微操作命令的操作时间表。操作时间表中包括各个机器周期、节拍下的每条指令完成的微操作控制信号。表 5.1 列出了 CLA、COM、SHR 等 10 条机器指令微操作命令的操作时间表。表中 FE、IND 和 EX 为 CPU 工作周期标志，T<sub>0</sub>～ T<sub>2</sub>,为节拍，Ⅰ 为间址标志，在取指周期的 T<sub>2</sub>时刻，若测得 I=1，则 IND 触发器置“1”，标志进入间址周期;若 I=0，则 EX 触发器置“1”，标志进入执行周期。同理，在间址周期的 T<sub>2</sub>时刻，若测得 IND=0(表示一次间接寻址)，则 EX 触发器置“1”，进入执行周期;若测得 IND= 1(表示多次间接寻址)，则继续间接寻址。在执行周期的 T<sub>2</sub>时刻，CPU 要向所有中断源发中断查询信号，若检测到有中断请求并满足响应条件，则 INT 触发器置“1”，标志进入中断周期。表中未列出 INT 触发器置“1”的操作和中断周期的微操作。表中第一行对应 10 条指令的操作码，代表不同的指令。若某指令有表中所列出的微操作命令，其对应的单元格内为 1。</p>
</li>
<li class="lvl-3">
<p><strong>进行微操作信号综合</strong>。在列出微操作时间表后，即可对它们进行综合分析、归类，根据微操作时间表可写出各微操作控制信号的逻辑表达式并进行适当的简化。表达式一般包括下列因素:</p>
</li>
</ol>
<p>微操作控制信号=机器周期 ∧ 节拍 ∧ 脉冲 ∧ 操作码 ∧ 机器状态条件</p>
<p>根据表 5.1 便可列出每个微操作命令的初始逻辑表达式，经化简、整理可获得能用现有门电路实现的微操作命令逻辑表达式。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716142423.png" alt="找不到图片(Image not found)"></p>
<p>例如，根据表 5.1 可写出 M(MAR)–MDR 微操作命令的逻辑表达式:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mrow><mi mathvariant="normal">M</mi></mrow><mo>(</mo><mrow><mi mathvariant="normal">M</mi><mi mathvariant="normal">A</mi><mi mathvariant="normal">R</mi></mrow><mo>)</mo><mo>→</mo><mrow><mi mathvariant="normal">M</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">R</mi></mrow></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mspace width="1em"></mspace><mo>=</mo><mrow><mi mathvariant="normal">F</mi><mi mathvariant="normal">E</mi></mrow><mo>⋅</mo><msub><mi>T</mi><mn>1</mn></msub><mo>+</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">N</mi><mi mathvariant="normal">D</mi></mrow><mo>⋅</mo><msub><mrow><mi mathvariant="normal">T</mi></mrow><mn>1</mn></msub><mo>(</mo><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">D</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">T</mi><mi mathvariant="normal">A</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">A</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">J</mi><mi mathvariant="normal">M</mi><mi mathvariant="normal">P</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">B</mi><mi mathvariant="normal">A</mi><mi mathvariant="normal">N</mi></mrow><mo>)</mo><mo>+</mo><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">X</mi></mrow><mo>⋅</mo><msub><mi>T</mi><mn>1</mn></msub><mo>(</mo><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">D</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">A</mi></mrow><mo>)</mo></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mspace width="1em"></mspace><mo>=</mo><msub><mi>T</mi><mn>1</mn></msub><mo>{</mo><mrow><mi mathvariant="normal">F</mi><mi mathvariant="normal">E</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">N</mi><mi mathvariant="normal">D</mi></mrow><mo>(</mo><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">D</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">T</mi><mi mathvariant="normal">A</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">A</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">J</mi><mi mathvariant="normal">M</mi><mi mathvariant="normal">P</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">B</mi><mi mathvariant="normal">A</mi><mi mathvariant="normal">N</mi></mrow><mo>)</mo><mo>+</mo><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">X</mi></mrow><mo>(</mo><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">D</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">A</mi></mrow><mo>)</mo><mo>}</mo></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned} &amp; \mathrm{M}(\mathrm{MAR}) \rightarrow \mathrm{MDR} \\ &amp; \quad=\mathrm{FE} \cdot T_1+\mathrm{IND} \cdot \mathrm{T}_1(\mathrm{ADD}+\mathrm{STA}+\mathrm{LDA}+\mathrm{JMP}+\mathrm{BAN})+\mathrm{EX} \cdot T_1(\mathrm{ADD}+\mathrm{LDA}) \\ &amp; \quad=T_1\{\mathrm{FE}+\mathrm{IND}(\mathrm{ADD}+\mathrm{STA}+\mathrm{LDA}+\mathrm{JMP}+\mathrm{BAN})+\mathrm{EX}(\mathrm{ADD}+\mathrm{LDA})\}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:2.05em;"></span><span class="strut bottom" style="height:3.6000000000000005em;vertical-align:-1.5500000000000007em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-1.2099999999999997em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span style="top:-0.00999999999999951em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span style="top:1.1900000000000006em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="col-align-l"><span class="vlist"><span style="top:-1.2099999999999997em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mord textstyle uncramped"><span class="mord mathrm">M</span></span><span class="mopen">(</span><span class="mord textstyle uncramped"><span class="mord mathrm">M</span><span class="mord mathrm">A</span><span class="mord mathrm">R</span></span><span class="mclose">)</span><span class="mrel">→</span><span class="mord textstyle uncramped"><span class="mord mathrm">M</span><span class="mord mathrm">D</span><span class="mord mathrm">R</span></span></span></span><span style="top:-0.00999999999999951em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mord mspace quad"></span><span class="mrel">=</span><span class="mord textstyle uncramped"><span class="mord mathrm">F</span><span class="mord mathrm">E</span></span><span class="mbin">⋅</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">I</span><span class="mord mathrm">N</span><span class="mord mathrm">D</span></span><span class="mbin">⋅</span><span class><span class="mord textstyle uncramped"><span class="mord mathrm">T</span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord textstyle uncramped"><span class="mord mathrm">A</span><span class="mord mathrm">D</span><span class="mord mathrm">D</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">S</span><span class="mord mathrm">T</span><span class="mord mathrm">A</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">L</span><span class="mord mathrm">D</span><span class="mord mathrm">A</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">J</span><span class="mord mathrm">M</span><span class="mord mathrm">P</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">B</span><span class="mord mathrm">A</span><span class="mord mathrm">N</span></span><span class="mclose">)</span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">E</span><span class="mord mathrm">X</span></span><span class="mbin">⋅</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord textstyle uncramped"><span class="mord mathrm">A</span><span class="mord mathrm">D</span><span class="mord mathrm">D</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">L</span><span class="mord mathrm">D</span><span class="mord mathrm">A</span></span><span class="mclose">)</span></span></span><span style="top:1.1900000000000006em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mord mspace quad"></span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">{</span><span class="mord textstyle uncramped"><span class="mord mathrm">F</span><span class="mord mathrm">E</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">I</span><span class="mord mathrm">N</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord textstyle uncramped"><span class="mord mathrm">A</span><span class="mord mathrm">D</span><span class="mord mathrm">D</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">S</span><span class="mord mathrm">T</span><span class="mord mathrm">A</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">L</span><span class="mord mathrm">D</span><span class="mord mathrm">A</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">J</span><span class="mord mathrm">M</span><span class="mord mathrm">P</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">B</span><span class="mord mathrm">A</span><span class="mord mathrm">N</span></span><span class="mclose">)</span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">E</span><span class="mord mathrm">X</span></span><span class="mopen">(</span><span class="mord textstyle uncramped"><span class="mord mathrm">A</span><span class="mord mathrm">D</span><span class="mord mathrm">D</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">L</span><span class="mord mathrm">D</span><span class="mord mathrm">A</span></span><span class="mclose">)</span><span class="mclose">}</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></p>
<p>式中，ADD、STA、LDA、JMP、BAN 均来自操作码译码器的输出。</p>
<ol start="3">
<li class="lvl-3">
<p><strong>画出微操作命令的逻辑图</strong>。根据逻辑表达式可画出对应每个微操作信号的逻辑电路图，并用逻辑门电路实现。</p>
</li>
</ol>
<p>例如，M(MAR)-MDR 的逻辑表达式所对应的逻辑图如图 5.10 所示，图中未考虑门的扇入系数。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716142756.png" alt="找不到图片(Image not found)"></p>
<blockquote>
<p>🤔<strong>扇入系数是什么?</strong></p>
<p>在数字电路设计中，“门的扇入系数”（Fan-in）是指一个逻辑门所能接受的输入数量。每个逻辑门都有一个特定的扇入限制，表示它能够连接的输入信号线的数量。</p>
<p>逻辑门的扇入系数取决于特定的逻辑门类型。例如，一个 2 输入的 AND 门具有扇入系数 2，意味着它可以连接两个输入信号线。如果连接了超过 2 个输入信号线，可能会导致电路设计上的问题。</p>
</blockquote>
<h3 id="wei-cheng-xu-kong-zhi-qi">微程序控制器</h3>
<p>微程序控制器采用存储逻辑实现，也就是把微操作信号代码化，使每条机器指令转化成为一段微程序并存入一个专门的存储器（控制存储器）中，微操作控制信号由微指令产生。</p>
<h4 id="wei-cheng-xu-kong-zhi-de-ji-ben-gai-nian">微程序控制的基本概念</h4>
<p>微程序设计思想就是将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令。这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。目前，大多数计算机都采用微程序设计技术。</p>
<p>微程序设计技术涉及的基本术语如下:</p>
<ol>
<li class="lvl-3">
<p><strong>微命令</strong>与<strong>微操作</strong> 。一条机器指令可以分解成一个微操作序列，这些微操作是计算机中最基本的、不可再分解的操作。在微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为 微命令微命令 ，它是构成控制序列的最小单位。例如，打开或关闭某个控制门的电位信号、某个寄存器的打入脉冲等。微命令和微操作是一一对应的。微命令是微操作的控制信号，微操作是微命令的执行过程。微命令有相容性和互斥性之分。相容性微命令是指那些可以同时产生、共同完成某一些微操作的微命令;而互斥性微命令是指在机器中不允许同时出现的微命令。相容和互斥都是相对的，一个微命令可以和一些微命令相容，和另一些微命令互斥。</p>
</li>
</ol>
<blockquote>
<p>注意:在组合逻辑控制器中也存在微命令与微操作这两个概念，它们并非只是微程序控制器的专有概念。</p>
</blockquote>
<ol start="2">
<li class="lvl-3">
<p><strong>微指令</strong>与<strong>微周期</strong>。微指令是若干微命令的集合。存放微指令的控制存储器的单元地址称为微地址。一条微指令通常至少包含两大部分信息:</p>
</li>
</ol>
<p>① 操作控制字段操作控制字段 ，又称微操作码字段，用于产生某一步操作所需的各种操作控制信号。</p>
<p>② 顺序控制字段顺序控制字段 ，又称微地址码字段，用于控制产生下一条要执行的微指令地址。微周期通常指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。</p>
<ol start="3">
<li class="lvl-3">
<p><strong>主存储器</strong>与<strong>控制存储器</strong>。主存储器用于存放程序和数据，在 CPU 外部，用 RAM 实现;<code>控制存储器（CM）</code>用于存放微程序，在 CPU 内部，用 ROM 实现。</p>
</li>
<li class="lvl-3">
<p><strong>程序</strong>与<strong>微程序</strong>。 <code>程序是指令的有序集合指令的有序集合</code> ，用于完成特定的功能; <code>微程序微程序是微指令的有序集合微指令的有序集合 </code>，<strong>一条指令的功能由一段微程序来实现</strong>。</p>
</li>
</ol>
<p>微程序和程序是两个不同的概念。微程序是由微指令组成的，用于描述机器指令。微程序实际上是机器指令的实时解释器，是由计算机设计者事先编制好并存放在控制存储器中的，一般不提供给用户。对于程序员来说，计算机系统中微程序的结构和功能是透明的，无须知道。而程序最终由机器指令组成，是由软件设计人员事先编制好并存放在主存或辅存中的。</p>
<p>读者应注意区分以下寄存器:</p>
<p>①<code>地址寄存器(MAR)</code>。用于存放主存的读/写地址。</p>
<p>②<code>微地址寄存器(CMAR或μPC)</code>。用于存放控制存储器的读/写微指令的地址。</p>
<p>③<code>指令寄存器（IR)</code>。用于存放从主存中读出的指令。</p>
<p>④<code>微指令寄存器（CMDR或μIR)</code>。用于存放从控制存储器中读出的微指令。</p>
<h4 id="wei-cheng-xu-kong-zhi-qi-zu-cheng-he-gong-zuo-guo-cheng">微程序控制器组成和工作过程</h4>
<h5 id="wei-cheng-xu-kong-zhi-qi-de-ji-ben-zu-cheng">微程序控制器的基本组成</h5>
<p>图 5.11 所示为一个微程序控制器的基本结构，主要画出了微程序控制器比组合逻辑控制器多出的部件，包括:</p>
<p>①<strong>控制存储器</strong>。它是微程序控制器的核心部件，用于存放各指令对应的微程序，控制存储器可用只读存储器 ROM 构成。</p>
<p>②<strong>微指令寄存器</strong>。用于存放从 CM 中取出的微指令，它的位数同微指令字长相等。</p>
<p>③<strong>微地址形成部件</strong>。用于产生初始微地址和后继微地址,以保证微指令的连续执行。</p>
<p>④<strong>微地址寄存器</strong>。接收微地址形成部件送来的微地址，为在 CM 中读取微指令作准备。</p>
<p><strong>微程序控制器</strong>在结构上通常位于<code>指令译码器</code>和<code>操作控制器</code>之间</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210930184630.png" alt="找不到图片(Image not found)"></p>
<blockquote>
<p>图中的控制存储器就是 CM</p>
</blockquote>
<h5 id="wei-cheng-xu-kong-zhi-qi-de-gong-zuo-guo-cheng">微程序控制器的工作过程</h5>
<p>微程序控制器的工作过程实际上就是在微程序控制器的控制下计算机执行机器指令的过程，这个过程可以描述如下:</p>
<p>① 执行取微指令公共操作。具体的执行是:在机器开始运行时，自动将取指微程序的入口地址送入 CMAR，并从 CM 中读出相应的微指令送入 CMDR。取指微程序的入口地址一般为 CM 的 0 号单元，当取指微程序执行完后，从主存中取出的机器指令就已存入指令寄存器中。</p>
<p>② 由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入 CMAR。</p>
<p>③ 从 CM 中逐条取出对应的微指令并执行。</p>
<p>④ 执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第 ①<br>
步，以完成取下一条机器指令的公共操作。</p>
<p>以上是一条机器指令的执行过程，如此周而复始，直到整个程序执行完毕。</p>
<h4 id="wei-cheng-xu-he-ji-qi-zhi-ling">微程序和机器指令</h4>
<p>通常，一条机器指令对应一个微程序。由于任何一条机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编成一个微程序，这个微程序只负责将指令从主存单元中取出并送至指令寄存器。</p>
<p>此外，也可编出对应间址周期的微程序和中断周期的微程序。这样，控制存储器中的微程序个数应为机器指令数再加上对应取指、间址和中断周期等共用的微程序数。</p>
<blockquote>
<p>注意:若指令系统中具有 n 种机器指令，则控制存储器中的微程序数至少是 n+1(1 为公共的取指微程序)。</p>
</blockquote>
<h5 id="wei-zhi-ling-de-bian-ma-fang-shi">微指令的编码方式</h5>
<p>微指令的编码方式又称微指令的控制方式，是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。</p>
<h6 id="zhi-jie-bian-ma-zhi-jie-kong-zhi-fang-shi">直接编码（直接控制）方式</h6>
<p>微指令的直接编码方式如图 5.12 所示。直接编码法无须进行译码，微指令的微命令字段中每位都代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置成 1 或 0 即可。每个微命令对应并控制数据通路中的一个微操作。</p>
<p>这种编码的优点是简单、直观，执行速度快，操作并行性好;缺点是微指令字长过长，n 个微命令就要求微指令的操作字段有 n 位，造成控制存储器容量极大。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716143824.png" alt="找不到图片(Image not found)"></p>
<p>以下是一个具体的直接编码样例 👇：</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230713200142941.png" alt="image-20230713200142941"></p>
<blockquote>
<p>遵循<code>互斥性微命令</code>分在同一段内，<code>相容性微命令</code>分在不同段内。</p>
</blockquote>
<h6 id="zi-duan-zhi-jie-bian-ma-fang-shi">字段直接编码方式</h6>
<p>将微指令的微命令字段分成若干小字段，把互斥性微命令组合在同一字段中，把相容性微命令组合在不同字段中，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关，这就是字段直接编码方式，如图 5.13 所示。</p>
<p>这种方式可以缩短微指令字长，但因为要通过译码电路后再发出微命令，因此比直接编码方式慢。</p>
<p>微命令字段分段的原则:</p>
<p>① 互斥性微命令分在同一段内，相容性微命令分在不同段内。</p>
<blockquote>
<p>所谓<code>相容性</code>的微操作，是指在同时或同一个 CPU 周期内可以并行执行的 微操作。</p>
<p>所谓<code>相斥性</code>的微操作，是指不能在同时或不能在同一个 CPU 周期内并行执行的微操作。</p>
</blockquote>
<p>② 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。</p>
<p>③ 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为 3 位时，最多只能表示 7 个互斥的微命令，通常用 000 表示不操作。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210930185025.png" alt="找不到图片(Image not found)"></p>
<p>图 5.21 示出了一个简单运算器模型，其中 ALU 为算术逻辑单元，R1、R2、R3 为三个寄存器。三个寄存器的内容都可以通过多路开关从 ALU 的 X 输入端或 Y 输入端送至 ALU，而 ALU 的输出可以送往任何一个寄存器 或同时送往 R1，R2，R3 三个寄存器。在 我们给定的数据通路中，多路开关的每 个控制门仅是一个常闭的开关，它的一个输入端代表来自寄存器的信息，而另一个输入端则作为操作控制端。一旦两 个输入端都有输入信号时，它才产生一个输出信号，从而在控制线能起作用的 一个时间宽度中来控制信息在部件中流 动。图中每个开关门由控制器中相应的 微命令来控制，例如，开关门 4 由控制 器中编号为 4 的微命令控制，开关门 6 由编号为 6 的微命令控制，如此等等。 三个寄存器 R1、R2、R3 的时钟输入端 1、 2、3 也需要加以控制，以便在 ALU 运算 完毕而输出公共总线上电平稳定时，将结果打入到某一寄存器。另外，我们假定 ALU 只有 +，–，M(传送)三种操作。Cy 为最高进位触发器，有进位时该触发器状态为“1”。</p>
<p>ALU 的操作(加、减、传送)在同一个 CPU 周期中只能选择一种，不能并行，所以+，–， M(传送)三个微操作是相斥性的微操作。类似地，4、6、8 三个微操作是相斥性的，5、7、 9 三个微操作也是相斥性的。ALU 的 X 输入微操作 4、6、8 与 Y 输入的 5、7、9 这两组信号中，任意两个微操作也都是相容性的。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230713195734514.png" alt="image-20230713195734514"></p>
<blockquote>
<p>其直接编码格式如上上上图 5.22</p>
</blockquote>
<h6 id="zi-duan-jian-jie-bian-ma-fang-shi">字段间接编码方式</h6>
<p>一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，因此称为字段间接编码，又称隐式编码。这种方式可进一步缩短微指令字长，但因削弱了微指令的并行控制能力，因此通常作为字段直接编码方式的一种辅助手段。</p>
<h5 id="wei-zhi-ling-de-di-zhi-xing-cheng-fang-shi">微指令的地址形成方式</h5>
<p>后继微地址的形成主要有以下两大基本类型:</p>
<ol>
<li class="lvl-3">
<p><strong>直接由微指令的下地址字段指出</strong>。微指令格式中设置一个下地址字段，<strong>由微指令的下地址字段直接指出后继微指令的地址，这种方式又称</strong><mark>断定方式</mark>。</p>
</li>
<li class="lvl-3">
<p><strong>根据机器指令的操作码形成</strong>。机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。</p>
</li>
</ol>
<p>实际上，微指令序列地址的形成方式还有以下几种:</p>
<p>① 增量计数器法，即(CMAR)+1→CMAR，适用于后继微指令的地址连续的情况。</p>
<p>② 根据各种标志决定微指令分支转移的地址。</p>
<p>③ 通过网络测试形成。</p>
<p>④ 由硬件直接产生微程序入口地址。</p>
<p>电源加电后，第一条微指令的地址可由专门的硬件电路产生，也可由外部直接向 CMAR 输入微指令的地址，这个地址即为取指周期微程序的入口地址。</p>
<h5 id="wei-zhi-ling-de-ge-shi">微指令的格式</h5>
<p>微指令格式与微指令的编码方式有关，通常分水平型微指令和垂直型微指令两种。</p>
<p><strong>水平型微指令</strong></p>
<p>从编码方式看，<code>直接编码</code>、<code>字段直接编码</code>、<code>字段间接编码</code>和<code>混合编码</code>都属于水平型微指令。水平型微指令的基本指令格式如图 5.14 所示，指令字中的一位对应一个控制信号，有输出时为 1，否则为 0。一条水平型微指令定义并执行几种并行的基本操作。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716144416.png" alt="找不到图片(Image not found)"></p>
<p>水平型微指令的优点是微程序短，执行速度快;缺点是微指令长，编写微程序较麻烦。</p>
<p><strong>垂直型微指令</strong></p>
<p>垂直型微指令的特点是采用类似机器指令操作码的方式，在微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能，其基本的指令格式如图 5.15 所示。一条垂直型微指令只能定义并执行一种基本操作。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716144502.png" alt="找不到图片(Image not found)"></p>
<p>垂直型微指令格式的优点是微指令短、简单、规整，便于编写微程序;缺点是微程序长，执行速度慢，工作效率低。</p>
<p><strong>混合型微指令</strong></p>
<p>在垂直型的基础上增加一些不太复杂的并行操作。微指令较短，仍便于编写;微程序也不长，执行速度加快。</p>
<p><strong>水平型微指令和垂直型微指令的对比</strong>👇：</p>
<table>
<thead>
<tr>
<th style="text-align:left">特点</th>
<th style="text-align:left">水平型微指令</th>
<th style="text-align:left">垂直型微指令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">并行操作能力</td>
<td style="text-align:left">强</td>
<td style="text-align:left">较差</td>
</tr>
<tr>
<td style="text-align:left">效率</td>
<td style="text-align:left">高</td>
<td style="text-align:left">低</td>
</tr>
<tr>
<td style="text-align:left">灵活性</td>
<td style="text-align:left">强</td>
<td style="text-align:left">较差</td>
</tr>
<tr>
<td style="text-align:left">执行时间</td>
<td style="text-align:left">短</td>
<td style="text-align:left">长</td>
</tr>
<tr>
<td style="text-align:left">微指令字长度</td>
<td style="text-align:left">较长</td>
<td style="text-align:left">较短</td>
</tr>
<tr>
<td style="text-align:left">微程序长度</td>
<td style="text-align:left">短</td>
<td style="text-align:left">长</td>
</tr>
<tr>
<td style="text-align:left">用户掌握难度</td>
<td style="text-align:left">高</td>
<td style="text-align:left">相对容易</td>
</tr>
</tbody>
</table>
<h5 id="wei-cheng-xu-kong-zhi-dan-yuan-de-she-ji-bu-zou">微程序控制单元的设计步骤</h5>
<p>微程序控制单元设计的主要任务是编写各条机器指令所对应的微程序。具体的设计步骤如下:</p>
<ol>
<li class="lvl-3">
<p>写出对应机器指令的微操作命令及节拍安排。无论是组合逻辑设计还是微程序设计，对应相同的 CPU 结构，两种控制单元的微操作命令和节拍安排都是极相似的。如微程序控制单元在取指阶段发出的微操作命令及节拍安排如下:</p>
</li>
</ol>
\begin{aligned}T_{0}&:\quad \text{PC}\to\text{MAR},\ 1\to\text{R}\\T_{1}&:\quad \text{M(MAR)}\to\text{MDR},\ (\text{PC})+1\to\text{PC}\\T_{2}&:\quad \text{MDR}\to\text{IR},\ \text{OP(IR)}\to\text{微地址形成部件}\end{aligned}

<p>与硬布线控制单元相比，只在 T<sub>2</sub>节拍内的微操作命令不同。微程序控制单元在 T<sub>2</sub>节拍内要将指令的操作码送至微地址形成部件，即 OP(IR)→ 微地址形成部件，以形成该条机器指令的微程序首地址。而硬布线控制单元在 T<sub>2</sub>,节拍内要将指令的操作码送至指令译码器，以控制 CU 发出相应的微命令，即 OP(IR)→ID。</p>
<p>若把一个节拍 T 内的微操作安排在一条微指令中完成，上述微操作对应 3 条微指令。但由于微程序控制的所有控制信号都来自微指令，而微指令又存在控制存储器中，因此欲完成上述这些微操作，必须先将微指令从控制存储器中读出，即必须先给出这些微指令的地址。在取指微程序中，除第一条微指令外，其余微指令的地址均由上一条微指令的下地址字段直接给出，因此上述每条微指令都需增加一个将微指令下地址字段送至 CMAR 的微操作，记为 Ad(CMDR)→CMAR。取指微程序的最后一条微指令，其后继微指令的地址是由微地址形成部件形成的，即微地址形成部件 →CMAR。为了反映该地址与操作码有关，因此记为 OP(IR)→ 微地址形成部件 →CMAR。</p>
<p>综上所述，考虑到需要形成后继微指令地址，上述分析的取指操作共需 6 条微指令完成:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/80450e5a13714efc8bf44aaac9496007.png" alt="在这里插入图片描述"></p>
<p>执行阶段的微操作命令及节拍安排，分配原则类似。与硬布线控制 单元微操作命令的节拍安排相比，多了将下一条微指令地址送至 CMAR 的微操作命令，即 Ad(CMDR)→CMAR。其余的微操作命令与硬布线控制单元相同。</p>
<blockquote>
<p>注意:这里为了理解，应将微指令和机器指令相联系，因为每执行完一条微指令后要得到下一条微指令的地址。</p>
</blockquote>
<ol start="2">
<li class="lvl-3">
<p>确定微指令格式。微指令格式包括微指令的编码方式、后继微指令地址的形成方式和微指令字长等。</p>
</li>
</ol>
<p>根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数。由微指令数确定微指令的顺序控制字段的位数。最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长。</p>
<ol start="3">
<li class="lvl-3">
<p>编写微指令码点。根据操作控制字段每位代表的微操作命令，编写每条微指令的码点。</p>
</li>
</ol>
<h5 id="dong-tai-wei-cheng-xu-she-ji-he-hao-wei-cheng-xu-she-ji">动态微程序设计和毫微程序设计</h5>
<ol>
<li class="lvl-3">
<p><strong>动态微程序设计</strong>。在一台微程序控制的计算机中，假如能根据用户的要求改变微程序，则这台机器就具有动态微程序设计功能。</p>
</li>
</ol>
<p>动态微程序的设计需要可写控制寄存器的支持，否则难以改变微程序的内容。实现动态微程序设计可采用可擦除可编程只读存储器（EPROM)。</p>
<ol start="2">
<li class="lvl-3">
<p><strong>毫微程序设计</strong>。在普通的微程序计算机中，从主存取出的每条指令是由放在控制存储器中的微程序来解释执行的，通过控制线对硬件进行直接控制。</p>
</li>
</ol>
<p>若硬件不由微程序直接控制，而是通过存放在第二级控制存储器中的毫微程序来解释的，这个第二级控制存储器就称为毫微存储器，直接控制硬件的是毫微微 指令。</p>
<h3 id="ying-bu-xian-kong-zhi-qi-he-wei-cheng-xu-kong-zhi-qi-de-bi-jiao">硬布线控制器和微程序控制器的比较</h3>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716150404.png" alt="找不到图片(Image not found)"></p>
<h2 id="zhi-ling-liu-shui-xian">指令流水线</h2>
<p>一条指令的执行过程可分解为若干阶段，每个阶段由相应的功能部件完成。如果将各阶段视为相应的流水段，则指令的执行过程就构成了一条指令流水线。采用流水线技术只需增加少量硬件就能把计算机的运算速度提高几倍，因此成为计算机中普遍使用的一种并行处理技术。</p>
<h3 id="zhi-ling-liu-shui-de-ding-yi">指令流水的定义</h3>
<p>根据计算机的不同，具体的分法也不同。例如，图 5.16 把一条指令的执行过程分为如下 <code>三个</code>阶段（或过程)。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716181707.png" alt="找不到图片(Image not found)"></p>
<p><code>取指</code> :根据 PC 内容访问主存储器，取出一条指令送到 IR 中。</p>
<p><code>分析</code> :对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址 EA，并从有效地址 EA 中取出操作数。</p>
<p><code>执行</code> :根据操作码字段，完成指令规定的功能，即把运算结果写到通用寄存器或主存中。</p>
<p>当多条指令在处理器中执行时,可以采用以下两种方式。</p>
<ol>
<li class="lvl-3">
<p>顺序执行方式。前一条指令执行完后，才启动下一条指令，如图 5.17(a)所示。假设取指、分析、执行三个阶段的时间都相等，用 t 表示，顺序执行 n 条指令所用时间 T 为</p>
</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mn>3</mn><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">T = 3nt
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mrel">=</span><span class="mord mathrm">3</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span></p>
<p>传统冯·诺依曼机采用顺序执行方式，又称串行执行方式。其优点是控制简单，硬件代价小;缺点是执行指令的速度较慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低。例如取指时内存是忙碌的，而指令执行部件是空闲的。</p>
<ol start="2">
<li class="lvl-3">
<p>流水线执行方式。为了提高指令的执行速度，可以把取 k ＋ 1 条指令提前到分析第 k 条指令的期间完成，而将分析第 k ＋ 1 条指令与执行第 k 条指令同时进行，如图 5.17(b)所示。采用此种方式时，执行 n 条指令所用的时间为</p>
</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mo>(</mo><mn>2</mn><mo>+</mo><mi>n</mi><mo>)</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">T = (2+n)t
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mord mathit">t</span></span></span></span></span></p>
<p>与顺序执行方式相比，采用流水线执行方式能使指令的执行时间缩短近 2/3，各功能部件的利用率明显提高。但为此需要付出硬件上较大开销的代价，控制过程也更复杂。在理想情况下，每个时钟周期都有一条指令进入流水线，处理机中同时有 3 条指令在执行，每个时钟周期都有一条指令完成，每条指令的时钟周期数（即 CPI）都为 1。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716182135.png" alt="找不到图片(Image not found)"></p>
<p>为了进一步获得更高的执行速度，还可以将流水段进一步细分。如将一条指令的执行过程分为 <code>取指令</code> 、 <code>指令译码</code> 、 <code>执行</code> 和 <code>写回</code> 四个阶段，就形成了 <code>四级流水</code> ;还可进一步分为 <code>取指令(IF)</code> 、 <code>指令译码(ID)</code> 、 <code>执行(EX)</code> 、<code>访存(M)</code> 和 <code>写回(WB)</code> ，就形成了 <code>五级流水 </code>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>各缩写的全称</p>
</li>
<li class="lvl-2">
<p>IF：instruction fetch</p>
</li>
<li class="lvl-2">
<p>ID：instruction decode</p>
</li>
<li class="lvl-2">
<p>EX：execute</p>
</li>
<li class="lvl-2">
<p>M：memory</p>
</li>
<li class="lvl-2">
<p>WB：write back</p>
</li>
</ul>
<p>流水线设计的原则是如下:指令流水段个数以最复杂指令所用的功能段个数为准;流水段的长度以最复杂的操作所花的时间为准。假设某条指令的 5 个阶段所花的时间分别如下。① 取指:200ps;译码:100ps;③ 执行: 150ps;④ 访存 200ps;⑤ 写回 100ps。不考虑数据通路中的各种延迟，该指令的总执行时间为 750ps。按照流水线设计原则，每个流水段的长度为 200ps，所以每条指令的执行时间为 1ns，反正比串行执行时增加了 250ps。假设某程序中有 N 条指令，单周期处理机所用时间为 N×750ns。而流水处理机所用时间为 750ps + (N-1)×200。因此，<code>流水线方式并不能缩短一条指令的执行时间</code>，但是，对于整个程序来说，可以大大增加指令执行的吞吐率。</p>
<p>为了利于实现指令流水线，指令集应具有如下特征:</p>
<ol>
<li class="lvl-3">
<p>指令长度应尽量一致，有利于简化取指令和指令译码操作。否则，取指令所花时间长短不易，使取指部件极其复杂，且也不利于指令译码。</p>
</li>
<li class="lvl-3">
<p>指令格式应尽量规整，尽量保证源寄存器的位置相同，有利于在指令未知时就可取寄存器操作数，否则须译码后才能确定指令中各寄存器编号的位置。</p>
</li>
<li class="lvl-3">
<p>采用 Load/Store 指令，其他指令（如运算指令）都不能访问存储器，这样可把 Load/Store 指令的地址计算和运算指令的执行步骤规整在同一个周期中，有利于减少操作步骤。</p>
</li>
<li class="lvl-3">
<p>数据和指令在存储器中“<code>对齐</code>”存放。这样，有利于减少访存次数，使所需数据在一个流水段内就能从存储器中得到。</p>
</li>
</ol>
<h3 id="liu-shui-xian-de-biao-shi-fang-fa">流水线的表示方法</h3>
<p>通常用时空图来直观地描述流水线的工作过程，如图 5.18 所示。</p>
<p>在时空图中，横坐标表示时间，即输入流水线中的各个任务在流水线中所经过的时间。流水线中各个流水段的执行时间都相等时，横坐标就被分割成相等长度的时间段。纵坐标表示空间，即流水线的每个流水段（对应各执行部件)。</p>
<p>在图 5.18 中，第一条指令 I1 在时刻 T<sub>0</sub>进入流水线，在时刻 T<sub>4</sub>流出流水线。第二条指令 I——2 在时刻 T<sub>1</sub>进入流水线，在时刻 T<sub>5</sub>流出流水线。以此类推，每经过一个 Δt 时间，便有一条指令进入流水线，从时刻 t4 开始有一条指令流出流水线。</p>
<p>从图 5.18 中可以看出，当 t<sub>8</sub> =8Δt 时，流水线上便有 5 条指令流出。若采用串行方式执行指令，当 t8 =8Δt 时，只能执行 2 条指令，可见使用流水线方式成倍地提高了计算机的速度。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716182718.png" alt="找不到图片(Image not found)"></p>
<h3 id="liu-shui-xian-fang-shi-de-te-dian">流水线方式的特点</h3>
<p>与传统的串行执行方式相比，采用流水线方式具有如下特点:</p>
<ol>
<li class="lvl-3">
<p>把一个任务（一条指令或一个操作）分解为几个有联系的子任务，每个子任务由一个专门的功能部件来执行，并依靠多个功能部件并行工作来缩短程序的执行时间。</p>
</li>
<li class="lvl-3">
<p>流水线每个功能段部件后面都要有一个缓冲寄存器，或称锁存器，其作用是保存本流水段的执行结果，供给下一流水段使用。</p>
</li>
<li class="lvl-3">
<p>流水线中各功能段的时间应尽量相等，否则将引起堵塞、断流。</p>
</li>
<li class="lvl-3">
<p>只有连续不断地提供同一种任务时才能发挥流水线的效率，所以在流水线中处理的必须是连续任务。在采用流水线方式工作的处理机中，要在软件和硬件设计等多方面尽量为流水线提供连续的任务。</p>
</li>
<li class="lvl-3">
<p>流水线需要有<code>装入时间</code>和<code>排空时间</code>。装入时间是指第一个任务进入流水线到输出流水线的时间。排空时间是指最后一个任务进入流水线到输出流水线的时间。</p>
</li>
</ol>
<h3 id="liu-shui-xian-de-fen-lei">流水线的分类</h3>
<p>按照不同的分类标准，可以把流水线分成多种不同的种类。下面从几个不同的角度介绍流水线的基本分类方法。</p>
<h5 id="bu-jian-gong-neng-ji-chu-li-ji-ji-he-chu-li-ji-jian-ji-liu-shui-xian">部件功能级、处理机级和处理机间级流水线</h5>
<p>根据流水线使用级别的不同，流水线可分为部件功能级流水线、处理机级流水线和处理机间流水线。</p>
<p><code>部件功能级流水</code> 将复杂的算术逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差、对阶、尾数相加及结果规格化等 4 个子过程。</p>
<p><code>处理机级流水</code> 把一条指令解释过程分成多个子过程，如前面提到的取指、译码、执行、访存和写回 5 个子过程。</p>
<p>处理机间流水是一种宏流水，其中每个处理机完成某一专门任务，各个处理机得到的结果需存放在与下一个处理机共享的存储器中。</p>
<h5 id="dan-gong-neng-liu-shui-xian-he-duo-gong-neng-liu-shui-xian">单功能流水线和多功能流水线</h5>
<p>按可以完成的功能，流水线可分为单功能流水线和多功能流水线。</p>
<p><code>单功能流水线</code>是指只能实现一种固定的专门功能的流水线; <code>多功能流水线</code> 是指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线。</p>
<h5 id="dong-tai-liu-shui-xian-he-jing-tai-liu-shui-xian">动态流水线和静态流水线</h5>
<p>按同一时间内各段之间的连接方式，流水线可分为静态流水线和动态流水线。</p>
<p><code>静态流水线</code> 指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。</p>
<p><code>动态流水线</code> 指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。</p>
<h5 id="xian-xing-liu-shui-xian-he-fei-xian-xing-liu-shui-xian">线性流水线和非线性流水线</h5>
<p>按流水线的各个功能段之间是否有反馈信号，流水线可分为线性流水线与非线性流水线。</p>
<p><code>线性流水线</code> 中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。 <code>非线性流水线</code> 存在反馈回路，从输入到输出的过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。</p>
<p>流水线的每个子过程由专用的功能段实现，各功能段所需的时间应尽量相等。否则，时间长的功能段将成为流水线的瓶颈。</p>
<h4 id="mark-ying-xiang-liu-shui-xian-de-yin-su-mark"><mark>影响流水线的因素</mark></h4>
<p>在指令流水线中，可能会遇到一些情况使得流水线无法正确执行后续指令而引起流水线阻塞或停顿，这种现象称为流水线冲突（冒险)。导致流水线冲突的原因主要有 3 种: <code>结构冒险(资源冲突)</code>、 <code>数据冒险(数据冲突)</code>和 <code>控制冒险(控制冲突)</code>。</p>
<blockquote>
<p>以下还是使用<code>冒险</code>,因为描述的是两个指令之间的关系和隐藏风险，而不是事实上的发生了冲突</p>
</blockquote>
<h5 id="zi-yuan-mou-xian">资源冒险</h5>
<p>由于多条指令在同一时刻争用同一资源而形成的冲突称为资源冲突，即由硬件资源竞争造成的冲突，有以下两种解决办法:</p>
<p>1）前一指令访存时，使后一条相关指令（以及其后续指令）暂停一个时钟周期。</p>
<p>2）单独设置数据存储器和指令存储器，使取数和取指令操作各自在不同的存储器中进行。</p>
<p>事实上，现代计算机都引入了 Cache 机制，而 L1 Cache 通常采用数据 Cache 和指令 Cache 分离的方式，因而也就避免了资源冲突的发生。</p>
<h5 id="shu-ju-mou-xian">数据冒险</h5>
<p>在一个程序中，下一条指令会用到当前指令计算出的结果，此时这两条指令即为数据冲突。当多条指令重叠处理时就会发生冲突，数据冲突可分为三类（结合综合题 3 理解):</p>
<ol>
<li class="lvl-3">
<p><strong>写后读(Read After Write，RAW)相关</strong>:表示当前指令将数据写入寄存器后，下一条指令才能从该寄存器读取数据。否则，先读后写，读到的就是错误（旧）数据。</p>
</li>
<li class="lvl-3">
<p><strong>读后写(Write After Read，WAR）相关</strong>:表示当前指令读出数据后，下一条指令才能写该寄存器。否则，先写后读，读到的就是错误（新）数据。</p>
</li>
<li class="lvl-3">
<p><strong>写后写(Write After Write，WAW)相关</strong>:表示当前指令写入寄存器后，下一条指令才能写该寄存器。否则，下一条指令在当前指令之前写，将使寄存器的值不是最新值。</p>
</li>
</ol>
<p><em>解决的办法有以下几种</em>:</p>
<ol>
<li class="lvl-3">
<p>把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行(流水线气泡)，可分为硬件阻塞(stall)和软件插入“NOP”指令(空指令,即不执行任何有用的操作，只是占据了一个时钟周期，以使后续指令延迟进入流水线)两种方法。</p>
</li>
<li class="lvl-3">
<p>设置相关专用通路，即不等前一条指令把计算结果写回寄存器组，下一条指令也不再读寄存器组，而直接把前一条指令的 ALU 的计算结果作为自己的输入数据开始计算过程，使本来需要暂停的操作变得可以继续执行，这称为<code>数据旁路技术</code>(流水线定向)。</p>
</li>
<li class="lvl-3">
<p>通过编译器对数据相关的指令编译优化的方法，调整指令顺序来解决数据相关。</p>
</li>
</ol>
<h5 id="kong-zhi-chong-tu">控制冲突</h5>
<p>一条指令要确定下一条指令的位置，例如在执行转移、调用或返回等指令时会改变 PC 值，而造成断流,会引起控制冒险。解决的办法有以下几种:</p>
<ol>
<li class="lvl-3">
<p><strong>对转移指令进行分支预测</strong>，尽早生成转移目标地址。分支预测分为简单（静态）预测和动态预测。静态预测总是预测条件不满足，即继续执行分支指令的后续指令。动态预测根据程序执行的历史情况，进行动态预测调整，有较高的预测准确率。</p>
</li>
<li class="lvl-3">
<p><strong>预取转移成功和不成功两个控制流方向上的目标指令</strong>。</p>
</li>
<li class="lvl-3">
<p>加快和提前形成条件码。</p>
</li>
<li class="lvl-3">
<p>提高转移方向的猜准率。</p>
</li>
</ol>
<blockquote>
<p>注意:Cache 缺失的处理过程也会引起流水线阻塞。在不过多增加硬件成本的情况下，如何尽可能地提高指令流水线的运行效率是选用指令流水线技术必须解决的关键问题。</p>
</blockquote>
<h3 id="mark-liu-shui-xian-de-xing-neng-zhi-biao-mark"><mark>流水线的性能指标</mark></h3>
<p>衡量流水线性能的主要指标有<code>吞吐率</code>、<code>加速比</code>和<code>效率</code>。下面以<a href="#####%E7%BA%BF%E6%80%A7%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%B5%81%E6%B0%B4%E7%BA%BF">线性流水线</a>为例分析流水线的主要性能指标，其分析方法和有关公式也适用于非线性流水线。</p>
<h4 id="tun-tu-lu">吞吐率</h4>
<p>流水线的吞吐率 TP(Through Put)是指<strong>单位时间内流水线所完成的任务数量或输出结果的数量</strong></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>P</mi><mo>=</mo><mfrac><mi>n</mi><mrow><msub><mi>T</mi><mi>k</mi></msub></mrow></mfrac><mspace width="2em"></mspace><mspace width="2em"></mspace><mtext><mi mathvariant="normal">(</mi><mn>3</mn><mi mathvariant="normal">.</mi><mn>1</mn><mi mathvariant="normal">)</mi></mtext></mrow><annotation encoding="application/x-tex">TP=\frac n{T_k}\qquad\qquad\text{(3.1)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.10756em;"></span><span class="strut bottom" style="height:1.9435600000000002em;vertical-align:-0.8360000000000001em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mord mspace qquad"></span><span class="mord mspace qquad"></span><span class="text mord displaystyle textstyle uncramped"><span class="mord mathrm">(</span><span class="mord mathrm">3</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">)</span></span></span></span></span></span></p>
<p>其中,n 为任务数,T<sub>k</sub>是处理完 n 个任务所用的时间,这是计算流水线吞吐率的最基本的公式</p>
<p><strong>各段时间均相等的流水线</strong></p>
<p>以下为个段时间均相等(都是 Δt)的线性流水的时空图。这里假设段数为 k,连续输入 n 个任务第一个任务输入后,经过 kΔt 的时间从输出端流出(完成)。此后的 n-1 个 Δt 中,每个 Δt 时间完成一个任务。在这种情况下,流水线完成 n 个连续任务所需要的总时间为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>k</mi></msub><mo>=</mo><mi>k</mi><mi mathvariant="normal">Δ</mi><mi>t</mi><mo>+</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi><mo>=</mo><mo>(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi><mspace width="2em"></mspace><mspace width="2em"></mspace><mtext><mi mathvariant="normal">(</mi><mn>3</mn><mi mathvariant="normal">.</mi><mn>2</mn><mi mathvariant="normal">)</mi></mtext></mrow><annotation encoding="application/x-tex">T_k = k\Delta t + (n-1)\Delta t = (k+n-1)\Delta t \qquad\qquad \text{(3.2)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span><span class="mord mspace qquad"></span><span class="mord mspace qquad"></span><span class="text mord displaystyle textstyle uncramped"><span class="mord mathrm">(</span><span class="mord mathrm">3</span><span class="mord mathrm">.</span><span class="mord mathrm">2</span><span class="mord mathrm">)</span></span></span></span></span></span></p>
<p>将式 3.2 带入式 3.1 中得<strong>流水线实际吞吐率</strong>为:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>P</mi><mo>=</mo><mfrac><mi>n</mi><mrow><mo>(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">TP = \frac n{(k+n-1)\Delta t}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.10756em;"></span><span class="strut bottom" style="height:2.0435600000000003em;vertical-align:-0.936em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span><span style="top:-0.2300000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p>
<p>这种情况下的<strong>最大吞吐率</strong>为:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><msub><mi>P</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><msub><mi>lim</mi><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mfrac><mi>n</mi><mrow><mo>(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">TP_{max}=\lim\limits_{x \to \infty} \frac n{(k+n-1)\Delta t} = \frac 1{\Delta t}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.32144em;"></span><span class="strut bottom" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mop op-limits"><span class="vlist"><span style="top:0.6em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">x</span><span class="mrel">→</span><span class="mord mathrm">∞</span></span></span></span><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span><span class="mop">lim</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span><span style="top:-0.2300000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716183823.png" alt="找不到图片(Image not found)"></p>
<p>由以上式子可知流水线的实际吞吐率总是小于最大吞吐率</p>
<p><strong>各段不完全相等的流水线</strong></p>
<p>在下图(a)所示的流水线中，各段时间不完全相等。其中 S<sub>1</sub>S<sub>2</sub>S<sub>3</sub>,S<sub>5</sub>各段的时间都是 Δt,S<sub>4</sub>的时间是 3Δt ,是其他各段时间的 3 倍。S<sub>4</sub>是该<strong>流水线的瓶颈段</strong>。除了第一个任务外,其余(n-1)个任务必须按瓶颈段的时间间隔 max(Δt<sub>1</sub> ,Δt<sub>2</sub>,…,Δt<sub>k</sub>)连续流入流水线。图(b)是该流水线的时空图，图中的灰色方格表示相应流水段在这一段时间内是空闲的。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230714171756533.png" alt="image-20230714171756533"></p>
<p><em>实际吞吐率为</em>:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">P</mi></mrow><mo>=</mo><mfrac><mrow><mi>n</mi></mrow><mrow><msup><mo>∑</mo><mi>k</mi></msup><mi mathvariant="normal">Δ</mi><msub><mi>t</mi><mi>i</mi></msub><mo>+</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi>max</mi><mo>(</mo><mi mathvariant="normal">Δ</mi><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋅</mo><mo>⋅</mo><mo>⋅</mo><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><msub><mi>t</mi><mi>k</mi></msub><mo>)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\mathrm{TP}=\frac{n}{\sum\limits^k\Delta t_i+(n-1)\max(\Delta t_1,\Delta t_2,\cdot\cdot\cdot,\Delta t_k)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.10756em;"></span><span class="strut bottom" style="height:2.783678em;vertical-align:-1.676118em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord displaystyle textstyle uncramped"><span class="mord mathrm">T</span><span class="mord mathrm">P</span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:1.426113em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mop op-limits"><span class="vlist"><span style="top:-0.000004999999999977245em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span><span class="op-symbol small-op mop">∑</span></span></span><span style="top:-0.950005em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">Δ</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathrm">Δ</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">Δ</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord">⋅</span><span class="mbin">⋅</span><span class="mord">⋅</span><span class="mpunct">,</span><span class="mord mathrm">Δ</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p>
<blockquote>
<p>max(Δt<sub>1</sub> ,Δt<sub>2</sub>,…,Δt<sub>k</sub>)为得出 Δt<sub>1</sub> ,Δt<sub>2</sub>,…,Δt<sub>k</sub>之间的最大值带入计算</p>
</blockquote>
<p>其中 Δt<sub>i</sub>为第 i 段的时间，共有 k 个段。分母中的第一部分是流水线完成第一个任务所用的时间;第二部分是完成其余 n-1 个任务所用的时间。</p>
<p><em>流水线最大吞吐率为</em>:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><msub><mi>P</mi><mrow><mi>max</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>max</mi><mo>(</mo><mi mathvariant="normal">Δ</mi><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mi mathvariant="normal">Δ</mi><msub><mi>t</mi><mi>k</mi></msub><mo>)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">TP_{\max}=\frac1{\max(\Delta t_1,\Delta t_2,\cdotp\cdotp\cdotp\Delta t_k)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.32144em;"></span><span class="strut bottom" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mop">max</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mop">max</span><span class="mopen">(</span><span class="mord mathrm">Δ</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">Δ</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mpunct">⋅</span><span class="mpunct">⋅</span><span class="mpunct">⋅</span><span class="mord mathrm">Δ</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span><span style="top:-0.2300000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p>
<p>对于上图的例子.最大吞吐率为:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><msub><mi>P</mi><mrow><mi>max</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>3</mn><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">TP_{\max}=\frac1{3\Delta t}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.32144em;"></span><span class="strut bottom" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mop">max</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">3</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p>
<p>从上式可以看出，当流水线各段的时间不完全相等时，流水线的最大吞吐率和实际吞吐率由时间最长的那个段决定,这个段就成了整条流水线的瓶颈。这时，瓶颈段一直处于忙碌状态，而其余各段则在许多时间内都是空闲的，硬件使用效率低。</p>
<p>可以用下面两种方法来消除瓶颈段(将其转换为各段时间相等的流水线)。</p>
<p><strong>细分瓶颈法</strong></p>
<p>把流水线中的瓶颈段切分为几个独立的功能段,从而使流水线各段的处理时间都相等。把瓶颈段 S<sub>4</sub>细分为 3 个子流水线段：S<sub>4-1</sub>，S<sub>4-2</sub>，S<sub>4-3</sub>。这样所产生的流水线各段时间均为 Δt,即每隔 Δt 流出一个结果</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230714175113790.png" alt="image-20230714175113790"></p>
<p><strong>重复设置瓶颈段</strong></p>
<p>如果无法把瓶颈段再细分，就可以采用重复设置瓶颈段的方法来解决问题。重复设置的段并行工作，在时间上依次错开处理任务。这种方法的缺点是控制逻辑比较复杂，所需要的硬件也增加了。​ 下图给出了把 S<sub>4</sub>,重复设置后的流水线及时空图。这里，从 S<sub>3</sub>到并列的 S<sub>4a</sub>,S<sub>4b</sub>,S<sub>4c</sub>之间需要设置一个数据分配器，它把从 S<sub>3</sub>输出的第一个任务分配给 S<sub>4a</sub>,第二个任务分配给 S<sub>4b</sub>,第三个任务分配给 S<sub>4c</sub>之后按此重复。而在 S<sub>4a</sub>,S<sub>4b</sub>,S<sub>4c</sub>到 S<sub>5</sub>之间需要设置一个数据收集器、依次分时将数据收集到 S<sub>5</sub>中。改进后的流水线能做到每隔 Δt 流出一个结果。</p>
<p>重复设置瓶颈段示意图 👇：</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230714180014032.png" alt="image-20230714180014032"></p>
<p>对应的流水时空图 👇：</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230714180056753.png" alt="image-20230714180056753"></p>
<p>上述两种方法都能使改进后的流水线最大吞吐率达到</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><msub><mi>P</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">TP_{max} = \frac 1{\Delta t}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.32144em;"></span><span class="strut bottom" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p>
<h4 id="jia-su-bi">加速比</h4>
<p>完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比，称为流水线的<code>加速比 </code>。</p>
<p>不使用流水线（即顺序执行）所用的时间为 T<sub>s</sub>，使用流水线后所用的时间为 T<sub>k</sub>，则该流水线的加速比为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mfrac><mrow><msub><mi>T</mi><mi>s</mi></msub></mrow><mrow><msub><mi>T</mi><mi>k</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">S=\frac{T_s}{T_k}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.36033em;"></span><span class="strut bottom" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p>
<p>若流水线各段执行的时间都相等，则一条 k 段流水线完成 n 个任务所需的时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>k</mi></msub><mo>=</mo><mo>(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">T_k=(k+n-1)\Delta t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span>。而不使用流水线，即顺序执行 n 个任务时，所需的时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>k</mi></msub><mo>=</mo><mi>k</mi><mi>n</mi><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">T_k=kn\Delta t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit">n</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span>。将和值代入上式，得实际加速比为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mfrac><mrow><mi>k</mi><mi>n</mi><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow><mrow><mo>(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>k</mi><mi>n</mi></mrow><mrow><mo>(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">S=\frac{kn\Delta t}{(k+n-1)\Delta t}=\frac{kn}{(k+n-1)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.37144em;"></span><span class="strut bottom" style="height:2.30744em;vertical-align:-0.936em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span><span style="top:-0.2300000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit">n</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span><span style="top:-0.2300000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p>
<p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">n\to \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mrel">→</span><span class="mord mathrm">∞</span></span></span></span>时，最大加速比为 S<sub>max</sub> = k</p>
<h4 id="xiao-lu">效率</h4>
<p>流水线的设备利用率称为流水线的<code>效率</code>。在时空图上，流水线的效率定义为完成 n 个任务占用的时空区有效面积，与 n 个任务所用的时间及 k 个流水段所围成的时空区总面积之比。因此，流水线的效率包含了时间和空间两个因素。</p>
<p>n 个任务占用的时空区有效面积就是顺序执行 n 个任务所使用的总时间 T<sub>0</sub>，而 n 个任务所用的时间与 k 个流水段所围成的时空区总面积为 kT<sub>k</sub>，其中 T<sub>k</sub>是流水线完成 n 个任务所使用的总时间，因此计算流水线效率（E)的一般公式为</p>
E=\frac {n个任务占用的时空区有效面积}{n个任务所用时间与k个流水段所围成的时空区总面积} = \frac {T_0}{kT_k}

<p>若流水线的各段执行时间相等，上式中的分子部分是 n 个任务实际占用的有效面积，分母部分是完成 n 个任务所用的时间与 k 个流水段所围成的总面积。因此，通过时空图来计算流水线的效率非常方便。</p>
<p>流水线的各段执行时间均相等，当连续输入的任务数 n→∞ 时，最高效率为 E=1。</p>
<h3 id="mark-wu-duan-shi-zhi-ling-liu-shui-xian-mark"><mark>五段式指令流水线</mark></h3>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/e344585772fa4a45a228018db89afbfc.png" alt="在这里插入图片描述"></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/be46112aa19441c693c6055ca302d0b0.png" alt="在这里插入图片描述"></p>
<h4 id="yun-suan-lei-zhi-ling">运算类指令</h4>
<p>重点关注 运算类指令 各阶段的操作；</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/fb1878e37d2743b49542cee416a6beca.png" alt="在这里插入图片描述"></p>
<h4 id="load-zhi-ling">LOAD 指令</h4>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/1e9acc5bcacd44a2adfe4c37240198c2.png" alt="在这里插入图片描述"></p>
<h4 id="store-zhi-ling">STORE 指令</h4>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/47b21adcbcbb40b2b6753e95de074209.png" alt="在这里插入图片描述"></p>
<h4 id="tiao-jian-zhuan-yi-zhi-ling">条件转移指令</h4>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/2c2025c254754b94bf97e88d45f388de.png" alt="在这里插入图片描述"></p>
<h4 id="wu-tiao-jian-zhuan-yi-zhi-ling">无条件转移指令</h4>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/d416f4cd1a914a61b3f62ee2675cdf5a.png" alt="在这里插入图片描述"></p>
<h3 id="gao-ji-liu-shui-ji-zhu">高级流水技术</h3>
<p>有两种增加指令级并行的策略：</p>
<p>一种是多发射技术，它通过采用多个内部功能部件，使流水线功能段能同时处理多条指令，处理及一次可以发射多条指令进入流水线执行</p>
<p>另一种是超流水线技术，它通过增加流水线级数来使更多的指令同时在流水线中重叠执行</p>
<h4 id="chao-biao-liang-liu-shui-xian-ji-zhu">超标量流水线技术</h4>
<p>每个时钟周期内可并发多条独立指令，即以并行操作方式将两条或多条指令编译并执行，为此需配置多个功能部件。</p>
<p>超标量计算机不能调整指令的执行顺序，因此通过编译优化技术，把可并行执行的指令搭配起来，挖掘更多的指令并行性，如图 5.20 所示。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716184812.png" alt="找不到图片(Image not found)"></p>
<h4 id="chao-chang-zhi-ling-zi">超长指令字</h4>
<p>又称<code>静态发射技术</code>，由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字（可达几百位)，为此需要采用多个处理部件。</p>
<h4 id="chao-liu-shui-xian-ji-zhu">超流水线技术</h4>
<p>流水线功能划分得越多,时钟周期就越短，指令吞吐率也就越高,因此<strong>超流水线技术是通过提高流水线主频得方式来提升流水线的性能</strong>。但是流水线级数越多，用于流水线寄存器的开销也就越大，因而流水线级数是有限制的，并不是越多越好</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716184857.png" alt="找不到图片(Image not found)"></p>
<p>超流水线 CPU 在流水线充满后，每个时钟周期还是执行一条指令，CPI=1，但其主频更高</p>
<p>多发射流水线 CPU 每个时钟周期可以处理多条指令，CPI&lt;1，相对而言，多发射里露水线成本更高，控制更复杂</p>
<pre><code class="language-css">下列给出的处理器类型中理想情况下 CPI 为 1 的是:()
I、单周期 CPU；II、多周期 CPU ；III、基本流水线 CPU； IV 超标量流水线 CPU
A、I，II； B、I,III; C、II,IV; D、III,IV；

解析：
理想情况下 CPI（Cycle Per Instruction）为 1 表示每个指令在理想情况下只需要一个时钟周期来执行。根据给出的处理器类型，我们来分析每种类型的 CPU 是否满足 CPI 为 1。

I. 单周期 CPU：在单周期 CPU 中，每条指令都需要相同数量的时钟周期来执行，因此 CPI 可能为 1。因此，I 是一个可能满足 CPI 为 1 的选项。

II. 多周期 CPU：在多周期 CPU 中，不同类型的指令可能需要不同数量的时钟周期来执行，因此 CPI 不一定为 1。因此，II 不满足 CPI 为 1。

III. 基本流水线 CPU：在基本流水线 CPU 中，指令被划分为多个阶段，并且多个指令可以同时执行。在理想情况下，每个阶段只需要一个时钟周期，因此 CPI 可能为 1。因此，III 是一个可能满足 CPI 为 1 的选项。

IV. 超标量流水线 CPU：在超标量流水线 CPU 中，多个指令可以同时执行，但每个指令可能需要多个时钟周期来执行完整的流水线流程。因此，CPI 不一定为 1。因此，IV 不满足 CPI 为 1。

综上所述，满足 CPI 为 1 的选项是 B、I,III。因此，答案是 B。其中，单周期 CPU (I) 和基本流水线 CPU (III) 是理想情况下 CPI 为 1 的处理器类型。
</code></pre>
<h2 id="duo-chu-li-qi-de-ji-ben-gai-nian">多处理器的基本概念</h2>
<h3 id="sisd-simd-mimd">SISD、SIMD、MIMD</h3>
<p>基于指令流的数量和数据流的数量，计算机体系结构的分类。</p>
<h4 id="dan-zhi-ling-liu-dan-shu-ju-liu-jie-gou-sisd">单指令流单数据流结构(SISD)</h4>
<p><code>(Single Instruction Single Data,SISD)</code></p>
<p>传统的串行计算机结构，通常只包含一个处理器和一个存储器。有些使用流水线的方式，所以有时会设置多个功能部件，并采用多模块交叉方式组织存储器。（之前介绍的大多都是 SISD 结构）</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/aae30ec640a345f6b2ed7d39bacd049b.png" alt="在这里插入图片描述"></p>
<h4 id="dan-zhi-ling-liu-duo-shu-ju-liu-jie-gou-simd">单指令流多数据流结构（SIMD）</h4>
<p><code>(Single Instruction Multiple Data,SIMD)</code></p>
<p>一个指令流同时对多个数据流进行处理，一般称为数据级并行技术。通常是由一个指令控制部件、多个处理单元组成。每个处理单元虽然执行的都是同一条指令，但每个单元都有自己的地址寄存器，就有了不同的数据地址。一个顺序应用程序被编译之后，可能按照 SISD 组织并运行与串行硬件上，也可能按 SIMD 组织并运行于并行硬件上。</p>
<p>for 循环效率高，但 switch 或 case 时效率低。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/a698d9454c6748fd955f7cde99d7b28f.png" alt="在这里插入图片描述"></p>
<p>向量处理器也是 SIMD 的变体，是一种实现了直接操作一维数组（向量）指令集的 CPU。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/80bf2635f10b443996352f52aa008128.png" alt="在这里插入图片描述"></p>
<h4 id="duo-zhi-ling-liu-dan-shu-ju-liu-jie-gou-misd">多指令流单数据流结构（MISD）</h4>
<p>同时执行多条指令，处理同一个数据，实际上不存在这样的计算机。</p>
<h4 id="duo-zhi-ling-liu-duo-shu-ju-liu-jie-gou-mimd">多指令流多数据流结构（MIMD）</h4>
<p><code>(Multiple Instruction Multiple Data,MIMD)</code></p>
<p>同时执行多条指令，处理多个不同的数据。分为多计算机系统和多处理器系统。<code>多计算机系统</code>：每个计算机节点都具有各自的私有存储器，并且具有独立的主存地址空间，不能通过存取指令来访问不同节点的私有存储器，而要通过消息传递进行数据传送，也称为消息传递 MIMD。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/3b2815de8c7b45fd92480579ae993519.png" alt="在这里插入图片描述"></p>
<p><code>多处理器系统</code>：共享存储多处理器（SMP）系统的简称，它具有共享的单一地址空间，通过访存指令来访问系统中的所有存储器，也称共享存储 MIMD</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/1c0220e29fdd4af883fbd1823642bdd5.png" alt="在这里插入图片描述"></p>
<p>SIMD 和 MIMD 是两种并行计算模式，其中<strong>SIMD 是一种数据级并行模式</strong>，而<strong>MIMD 是一种并行程度更高的线程级并行或线程级以上并行计算模式</strong>。</p>
<h3 id="ying-jian-duo-xian-cheng-de-ji-ben-gai-nian">硬件多线程的基本概念</h3>
<p>在传统的 CPU 中，线程的切换包含了一系列开销，频繁切换回极大影响系统性能，为了减少这些开销，便诞生了硬件多线程。</p>
<p>硬件多线程中必须为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程的激活只需要激活选中的寄存器，从而省略了与存储器数据交换的环节，节省了开销。</p>
<p>三种实现方式：</p>
<ol>
<li class="lvl-3">
<p><strong>细粒度多线程</strong></p>
</li>
</ol>
<p>多个线程之间轮流交叉执行指令，多个线程之间的指令是互不相关的，可以乱序并行执行。该方式下，处理器能在每个时钟周期切换线程。</p>
<ol start="2">
<li class="lvl-3">
<p><strong>粗粒度多线程</strong></p>
</li>
</ol>
<p>仅在一个线程出现较大开销的阻塞时，才切换线程，如 Cache 缺失。当发生流水线阻塞的时候，必须清除被阻塞的流水线，新线程的指令开始执行前需要重载流水线，开销较上一种较大。</p>
<ol start="3">
<li class="lvl-3">
<p><strong>同时多线程（SMT）</strong></p>
</li>
</ol>
<p>SMT 是上述两种多线程技术的变体。它是实现指令级并行的同时，实现线程级的并行，即在同一时钟周期内，发射不同线程中的多条指令执行。</p>
<p>Intel 处理器中的超线程即使 SMT，在一个单处理器或的那个核中设置了两套线程状态部件，共享高速缓存和功能部件。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/1f193862d63442a9a475cf98a07586fa.png" alt="在这里插入图片描述"></p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/f45ea43a584f4654aa368ce0be701017.png" alt="在这里插入图片描述"></p>
<h3 id="duo-he-chu-li-qi-de-ji-ben-gai-nian">多核处理器的基本概念</h3>
<p>**将多个处理单元集成到单个 CPU 中，每个处理单元称为一个核（core）。**每个核可以有自己的 Cache，也可以共享一个 Cache。所有核一般都是对称的，并且共享主存，因此<code>多核属于共享存储的对称多处理器</code>。</p>
<p>在多核计算机系统中，若要充分发挥硬件的性能，必须采用多线程执行，使每个核在同一时刻都有线程在执行，这是真正的并行执行。</p>
<h3 id="gong-xiang-nei-cun-duo-chu-li-qi-de-ji-ben-gai-nian">共享内存多处理器的基本概念</h3>
<p><strong>具有共享的单一物理地址空间的多处理器被称为共享内存多处理器（SMP）</strong>。处理器通过存储器中的共享变量相互通信，所有处理器都能通过存取指令访存任何存储器的位置。（即使这些系统共享同一个物理地址空间，它们仍然可以在自己的虚拟地址空间中单独地运行程序）</p>
<p>单一地址空间的多处理器分类：</p>
<ol>
<li class="lvl-3">
<p><code>统一存储访问（UMA）多处理器</code>：根据处理器与共享存储器之间的连接方式，分为基于总线、基于交叉开关网络和基于多级交换网络连接等几种处理器。（每个处理器对所有存储单元的访问时间都是大致相同的）</p>
</li>
<li class="lvl-3">
<p><code>非统一存储访问（NUMA）多处理器</code>：处理器中不带高速缓存时，被称为 NC-NUMA；处理器中带有一致性高速缓存时，被称为 CC-NUMA，（某些访问请求要比其他的快）</p>
</li>
</ol>
<h1 id="zong-xian">总线</h1>
<h2 id="zong-xian-gai-shu">总线概述</h2>
<p>随着计算机的发展和应用领域的不断扩大，IO 设备的种类和数量也越来越多。为了更好地解决 IO 设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为总线连接。为了进一步简化设计，又提出了各类总线标准。</p>
<h3 id="zong-xian-ji-ben-gai-nian">总线基本概念</h3>
<h4 id="zong-xian-de-ding-yi">总线的定义</h4>
<p>总线是一组能为多个部件分时共享的公共信息传送线路。<code>分时</code>和<code>共享</code>是总线的两个特点。</p>
<p><code>分时 </code>是指同一时刻只允许有一个部件向总线发送信息，若系统中有多个部件，则它们只能分时地向总线发送信息。</p>
<p><code>共享 </code>是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可通过这组线路分时共享。在某一时刻只允许有一个部件向总线发送信息，但多个部件可同时从总线上接收相同的信息。</p>
<h4 id="zong-xian-she-bei">总线设备</h4>
<p>总线上所连接的设备，按其对总线有无控制功能可分为<code>主设备</code>和<code>从设备</code>两种。</p>
<p><code>主设备</code> ：总线的主设备是指获得总线控制权的设备。</p>
<p><code>从设备</code> ：总线的从设备是指被主设备访问的设备，它只能响应从主设备发来的各种总线命令。</p>
<h4 id="zong-xian-te-xing">总线特性</h4>
<p>总线特性是指<code>机械特性</code>（尺寸、形状)、 <code>电气特性</code>（传输方向和有效的电平范围)、 <code>功能特性</code>（每根传输线的功能）和 <code>时间特性</code> （信号和时序的关系)。</p>
<h4 id="mark-zong-xian-de-cu-fa-chuan-shu-fang-shi-mark"><mark>总线的猝发传输方式</mark></h4>
<p>在一个总线周期内传输存储地址连续的多个数据字的总线传输方式，称为<code>猝发传送</code> 。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>又称<code>突发传输</code></p>
</li>
<li class="lvl-2">
<p>传送一个起始地址之后，可以连续读取连续的地址的内容</p>
</li>
<li class="lvl-2">
<p>没有突发传输的话，后面的内容每一次都要传送地址</p>
</li>
</ul>
<pre><code class="language-css">【2012统考真题】某同步总线的时钟频率为100MHz，宽度为32位，地址/数据线复用，每传输一个地址或数据占用一个时钟周期。若该总线支持突发（猝发）传输方式，则一次“主存写”总线事务传输128位数据所需要的时间至少是（）.
A. 20ns	B.40ns	C.50ns	D. 80ns

解析
3.C

由于总线频率为100MHz，因此时钟周期为 10ns。总线位宽与存储字长都是32位，因此每个时钟周期可传送一个32位存储字。猝发式发送可以连续传送地址连续的数据，因此总传送时间为:传送地址10ns，传送128位数据40ns，共需50ns。
</code></pre>
<h3 id="zong-xian-de-fen-lei">总线的分类</h3>
<p>计算机系统中的总线，按功能划分为以下 3 类。</p>
<h4 id="pian-nei-zong-xian">片内总线</h4>
<p>片内总线是芯片内部的总线，它是 CPU 芯片内部寄存器与寄存器之间、寄存器与 ALU 之间的公共连接线。</p>
<h4 id="xi-tong-zong-xian">系统总线</h4>
<p>系统总线是计算机系统内各功能部件(CPU、主存、I/O 接口)之间相互连接的总线。按系统总线传输信息内容的不同，又可分为 3 类：<code>数据总线</code>、<code>地址总线</code>和<code>控制总线</code>。</p>
<ol>
<li class="lvl-3">
<p><code>数据总线</code> 用来传输各功能部件之间的数据信息，它是<code>双向传输总线</code>，其位数与<code>机器字长 </code>、<code> 存储字长</code>有关。</p>
</li>
<li class="lvl-3">
<p><code>地址总线</code> 用来指出数据总线上的源数据或目的数据所在的 <code>主存单元</code> 或 <code>I/O端口的地址</code> ，它是<code>单向传输总线</code>，地址总线的位数与主存地址空间的大小有关。</p>
</li>
<li class="lvl-3">
<p><code>控制总线</code> 传输的是控制信息，包括 CPU 送出的控制命令和主存（或外设）返回 CPU 的反馈信号。</p>
</li>
</ol>
<blockquote>
<p>注意区分数据通路和数据总线:各个功能部件通过数据总线连接形成的数据传输路径称为数据通路。数据通路表示的是数据流经的路径，而 <code>数据总线</code>是承载的媒介。</p>
</blockquote>
<h4 id="tong-xin-zong-xian">通信总线</h4>
<p>通信总线是在计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间传送信息的总线，通信总线也称外部总线。</p>
<p>此外，按时序控制方式可将总线划分为 <code>同步总线</code> 和 <code>异步总线</code> ，还可按数据传输格式将总线划分为 <code>并行总线</code> 和 <code>串行总线</code> 。</p>
<h3 id="xi-tong-zong-xian-de-jie-gou">系统总线的结构</h3>
<p>总线结构通常分为<code>单总线结构</code>、<code>双总线结构</code>和<code>三总线结构</code>等。</p>
<h4 id="dan-zong-xian-jie-gou">单总线结构</h4>
<p>单总线结构将 CPU、主存、IO 设备（通过 IO 接口）都挂在<code>一组</code>总线上，允许 IO 设备之间、IO 设备与主存之间直接交换信息，如图 6.1 所示。CPU 与主存、CPU 与外设之间可直接进行信息交换，而无须经过中间设备的干预。</p>
<blockquote>
<p>注意，单总线并不是指只有一根信号线，系统总线按传送信息的不同可细分为地址总线、数据总线和控制总线。</p>
</blockquote>
<p>优点:结构简单，成本低，易于接入新的设备;缺点:带宽低、负载重，多个部件只能争用唯一的总线，且不支持并发传送操作。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20211002141738.png" alt="找不到图片(Image not found)"></p>
<h4 id="shuang-zong-xian-jie-gou">双总线结构</h4>
<p>双总线结构有两条总线:一条是 <code>主存总线 </code>，用于在 CPU、主存和通道之间传送数据;另一条是<code>IO总线</code> ，用于在多个外部设备与通道之间传送数据，如图 6.2 所示。</p>
<p>优点:将低速 IO 设备从单总线上分离出来，实现了存储器总线和 IO 总线分离。缺点:需要增加通道等硬件设备。</p>
<h4 id="san-zong-xian-jie-gou">三总线结构</h4>
<p>三总线结构是在计算机系统各部件之间采用 3 条各自独立的总线来构成信息通路，这 3 条总线分别为<code>主存总线 </code>、 <code>IO总线</code> 和 <code>直接内存访问(Direct Memory Access,DMA)总线 </code>，如图 6.3 所示。</p>
<p>主存总线用于在 CPU 和内存之间传送地址、数据和控制信息。IO 总线用于在 CPU 和各类外设之间通信。DMA 总线用于在内存和高速外设之间直接传送数据。</p>
<p>优点:提高了 IO 设备的性能，使其更快地响应命令，提高系统吞吐量。缺点:系统工作效率较低。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716190047.png" alt="找不到图片(Image not found)"></p>
<h3 id="mark-zong-xian-de-xing-neng-zhi-biao-mark"><mark>总线的性能指标</mark></h3>
<ol>
<li class="lvl-3">
<p>总线的<strong>传输周期</strong> 。指一次总线操作所需的时间（包括申请阶段、寻址阶段、传输阶段和结束阶段)，简称<code>总线周期</code>。总线传输周期通常由若干总线时钟周期构成。</p>
</li>
<li class="lvl-3">
<p>总线<strong>时钟周期</strong> 。即机器的时钟周期。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。</p>
</li>
<li class="lvl-3">
<p>总线的<strong>工作频率</strong> 。总线上各种操作的频率，为<code>总线周期的倒数</code>。实际上指<strong>1 秒内传送几次数据</strong>。若总线周期=N 个时钟周期，则总线的工作频率=时钟频率/N。</p>
</li>
<li class="lvl-3">
<p>总线的<strong>时钟频率</strong> 。即机器的时钟频率，它为时钟周期的倒数。</p>
</li>
<li class="lvl-3">
<p>总线<strong>宽度</strong> 。又称总线位宽，它是总线上同时能够传输的数据位数，通常指<code> 数据总线的根数</code>，如 32 根称为 32 位总线。</p>
</li>
<li class="lvl-3">
<p>总线<strong>带宽</strong> 。可理解为总线的 数据传输率数据传输率 ，即单位时间内总线上可传输数据的位数，通常用每秒传送信息的字节数来衡量，单位可用字节/秒（B/s）表示。总线带宽=总线工作频率 ×(总线宽度/8)。</p>
</li>
</ol>
<blockquote>
<p>注意:总线带宽和总线宽度应加以区别。</p>
</blockquote>
<ol start="7">
<li class="lvl-3">
<p>总线<strong>复用</strong> 。总线复用是指一种信号线在不同的时间传输不同的信息，因此可以使用较少的线传输更多的信息，从而节省空间和成本。</p>
</li>
<li class="lvl-3">
<p>信号<strong>线数</strong> 。 <code>地址总线</code> 、 <code>数据总线</code> 和 <code>控制总线</code> 3 种总线数的总和称为信号线数。其中，总线的最主要性能指标为总线宽度、总线（工作）频率、总线带宽，总线带宽是指总线本身所能达到的最高传输速率，它是衡量总线性能的重要指标。</p>
</li>
</ol>
<p>三者关系:总线带宽=总线宽度 × 总线频率。</p>
<p>例如，总线工作频率为 22MHz，总线宽度为 16 位，则总线带宽=22×(16/8)=44MB/s。</p>
<h3 id="zong-xian-zhong-cai">*总线仲裁</h3>
<p>为解决多个主设备同时竞争总线控制权的问题，应当采用总线仲裁部件，以某种方式选择一个主设备优先获得总线控制权。只有获得了总线控制权的设备，才能开始传送数据。</p>
<p>总线仲裁方式按其仲裁控制机构的设置可分为<code>集中仲裁方式</code>和<code>分布仲裁方式</code>两种。</p>
<h4 id="ji-zhong-zhong-cai-fang-shi">集中仲裁方式</h4>
<p>总线控制逻辑基本上集中于一个设备（如 CPU)中。将所有的总线请求集中起来，利用一个特定的裁决算法进行裁决，称为集中仲裁方式。集中仲裁方式有链式查询方式、计数器定时查询方式和独立请求方式三种。</p>
<h5 id="lian-shi-cha-xun-fang-shi">链式查询方式</h5>
<p>链式查询方式如图 6.4 所示。总线上所有的部件共用一根总线请求线，当有部件请求使用总线时，需经此线发总线请求信号到总线控制器。由总线控制器检查总线是否忙，若总线不忙，则立即发总线响应信号，经总线响应线 BG 串行地从一个部件传送到下一个部件，依次查询。若响应信号到达的部件无总线请求，则该信号立即传送到下一个部件;若响应信号到达的部件有总线请求，则信号被截住，不再传下去。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716190533.png" alt="找不到图片(Image not found)"></p>
<p>在链式查询中，部件离总线控制器越近，其优先级越高;部件离总线控制器越远，其优先级越低。</p>
<p>优点:链式查询方式优先级固定。此外，只需很少几根控制线就能按一定优先次序实现总线控制，结构简单，扩充容易。</p>
<p>缺点:对硬件电路的故障敏感，且优先级不能改变。当优先级高的部件频繁请求使用总线时，会使优先级较低的部件长期不能使用总线。</p>
<h5 id="ji-shu-qi-ding-shi-cha-xun-fang-shi">计数器定时查询方式</h5>
<p>计数器定时查询方式如图 6.5 所示。它采用一个计数器控制总线使用权，相对链式查询方式多了一组设备地址线，少了一根总线响应线 BG。它仍共用一根总线请求线，当总线控制器收到总线请求信号并判断总线空闲时，计数器开始计数，计数值通过设备地址线发向各个部件。当地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线控制权，同时中止计数器的计数及查询。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716190741.png" alt="找不到图片(Image not found)"></p>
<p>优点:计数可从“0”开始，此时一旦设备的优先次序被固定，设备的优先级就按 0,1,⋯,n 的顺序降序排列，而且固定不变;计数也可从上一次的终点开始，即采用一种循环方法，此时设备使用总线的优先级相等;计数器的初值还可由程序设置，因此优先次序可以改变，且这种方式对电路的故障没有链式查询方式敏感。</p>
<p>缺点:增加了控制线数（若设备有 n 个，则大致需要 ⌈log<sub>2</sub>n⌉+2 条控制线)，控制也比相对链式查询要复杂。</p>
<h5 id="du-li-qing-qiu-fang-shi">独立请求方式</h5>
<p>独立请求方式如图 6.6 所示。每个设备均有一对总线请求线 BR,和总线允许线 BG;。当总线上的部件需要使用总线时，经各自的总线请求线发送总线请求信号，在总线控制器中排队，当总线控制器按一定的优先次序决定批准某个部件的请求时，给该部件发送总线响应信号，该部件接到此信号后就获得了总线使用权，开始传送数据。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716191554.png" alt="找不到图片(Image not found)"></p>
<p>优点:响应速度快，总线允许信号 BG 直接从控制器发送到有关设备，而不必在设备间传递或查询,而且对优先次序的控制相当灵活。</p>
<p>缺点:控制线数量多（设备有 n 个，需要 2n+1 条控制线，其中加的那条控制线为 BS 线，基作用是让设备向总线控制部件反馈已使用完总线)，总线控制逻辑更复杂。为方便记忆，下面归纳了 3 种集中仲裁方式的区别与联系（假设设备有 n 个)，如表 6.1 所示。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716191643.png" alt="找不到图片(Image not found)"></p>
<h4 id="fen-bu-zhong-cai-fang-shi">分布仲裁方式</h4>
<p>分布仲裁方式不需要中央仲裁器，每个潜在的主模块都有自己的仲裁号和仲裁器。当它们有总线请求时，就会把它们各自唯一的仲裁号发送到共享的仲裁总线上，每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较。若仲裁总线上的仲裁号优先级高，则它的总线请求不予响应，并撤销它的仲裁号。最后，获胜者的仲裁号保留在仲裁总线上。</p>
<h3 id="chang-jian-de-zong-xian-biao-zhun">常见的总线标准</h3>
<p>目前，典型的总线标准有<code>ISA</code>、<code>EISA</code>、<code>VESA</code>、<code>PCI</code>、<code>PCI-Express</code>、<code>AGP</code>、<code>RS-232C</code>、<code>USB</code>等。它们的主要区别是总线宽度、带宽、时钟频率、寻址能力、是否支持突发传送等。</p>
<ol>
<li class="lvl-3">
<p><code>ISA</code>。ISA (Industry Standard Architecture，工业标准体系结构）总线是最早出现的微型计算机的系统总线，应用在 IBM 的 AT 机上。</p>
</li>
<li class="lvl-3">
<p><code>EISA</code>。EISA (Extended Industry Standard Architecture，扩展的 ISA）总线是为配合 32 位 CPU 而设计的扩展总线，EISA 对 ISA 完全兼容。</p>
</li>
<li class="lvl-3">
<p><code>VESA</code>。VESA (Video Electronics Standards Association，视频电子标准协会）总线是一个 32 位标准的计算机局部总线，是针对多媒体 PC 要求高速传送活动图像的大量数据应运而生的。</p>
</li>
<li class="lvl-3">
<p><code>PCI</code>。PCI (Peripheral Component Interconnect，外部设备互连）总线是高性能的 32 位或 64 位总线，是专为高度集成的外围部件、扩充插板和处理器/存储器系统设计的互连机制。目前常用的 PCI 适配器有显卡、声卡、网卡等。PCI 总线支持即插即用。PCI 总线是一个与处理器时钟频率无关的高速外围总线，属于局部总线。PCI 总线可通过桥连接实现多层 PCI 总线。</p>
</li>
<li class="lvl-3">
<p><code>PCI-Express (PCI-E)</code>。PCI-Express 是最新的总线和接口标准，它将全面取代现行的 PCI 和 AGP，最终统一总线标准。</p>
</li>
<li class="lvl-3">
<p><code>AGP</code>。AGP (Accelerated Graphics Port，加速图形接口）是一种视频接口标准，专用于连接主存和图形存储器，属于局部总线。AGP 技术为传输视频和三维图形数据提供了切实可行的解决方案。</p>
</li>
<li class="lvl-3">
<p><code>RS-232C</code>。RS-232C (Recommended Standard，RS）是由美国电子工业协会（EIA）推荐的一种串行通信总线，是应用于串行二进制交换的数据终端设备（DTE）和数据通信设备(DCE）之间的标准接口。</p>
</li>
<li class="lvl-3">
<p><code>USB</code>。USB (Universal Serial Bus，通用串行总线）是一种连接外部设备的 IO 总线，属于<code>设备总线</code>。具有即插即用、热插拔等优点，有很强的连接能力。</p>
</li>
<li class="lvl-3">
<p><code>PCMCIA</code>。PCMCIA (Personal Computer Memory Card International Association）是广泛应用于笔记本电脑的一种接口标准，是一个用于扩展功能的小型插槽。PCMCIA 具有即插即用功能。</p>
</li>
<li class="lvl-4">
<p><code>IDE</code>。IDE (Integrated Drive Electronics，集成设备电路)，更准确地称为 ATA，是一种 IDE 接口磁盘驱动器接口类型，硬盘和光驱通过 IDE 接口与主板连接。</p>
</li>
<li class="lvl-4">
<p><code>SCSI</code>。SCSI (Small Computer System Interface，小型计算机系统接口）是一种用于计算机和智能设备之间（硬盘、软驱、光驱、打印机等）系统级接口的独立处理器标准。SCSI 是一种智能的通用接口标准。</p>
</li>
<li class="lvl-4">
<p><code>SATA</code>。SATA (Serial Advanced Technology Attachment，串行高级技术附件）是一种基于行业标准的串行硬件驱动器接口，是由 Intel、IBM、Dell、APT、Maxtor 和 Seagate 公司共同提出的硬盘接口规范。</p>
</li>
</ol>
<h2 id="zong-xian-shi-wu-he-ding-shi">总线事务和定时</h2>
<h3 id="zong-xian-shi-wu">总线事务</h3>
<p>从请求总线到完成总线使用的操作序列称为总线事务,它是在一个总线周期中发生的一系列活动。典型的总线事务包括<code>请求操作</code>、<code>仲裁操作</code>、<code>地址传输</code>、<code>数据传输</code>和<code>总线释放</code></p>
<ol>
<li class="lvl-3">
<p><code>请求阶段</code>。 主设备(CPU 或 DMA)发出总线传输请求,并且获得总线控制权</p>
</li>
<li class="lvl-3">
<p><code>仲裁阶段</code>。 总线冲裁机构决定将下一个传输周期的总线使用权授予某个申请者</p>
</li>
<li class="lvl-3">
<p><code>寻址阶段</code> 。取得使用权的主模块通过总线发出本次要访问的从模块（或从设备）的地址及有关命令，启动参与本次传输的从模块。</p>
</li>
<li class="lvl-3">
<p><code>传输阶段</code> 。主模块和从模块进行数据交换，可单向或双向进行数据传送。</p>
</li>
<li class="lvl-3">
<p><code>结束阶段 </code>。主模块的有关信息均从系统总线上撤除，让出总线使用权。</p>
</li>
</ol>
<blockquote>
<p><strong>突发(猝发)传送方式</strong>能够进行连续成组数据的传送,其寻址阶段发送的是连续数据单元的首地址,在传输阶段传送多个连续单元的数据,每个时钟周期可以传送一个字长的信息,但是不释放总线,直到一组数据全部传送完毕后,再释放总线</p>
</blockquote>
<h3 id="tong-bu-ding-shi-fang-shi">同步定时方式</h3>
<p>所谓同步定时方式，是指系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。时钟产生相等的时间间隔，每个间隔构成一个总线周期。在一个总线周期中，发送方和接收方可以进行一次数据传送。因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线的传送周期开始。</p>
<p>优点:传送速度快，具有较高的传输速率;总线控制逻辑简单。</p>
<p>缺点:主从设备属于强制性同步;不能及时进行数据通信的有效性检验，可靠性较差。</p>
<p>同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统。</p>
<h3 id="yi-bu-ding-shi-fang-shi">异步定时方式</h3>
<p>在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。通常，把交换信息的两个部件或设备分为主设备和从设备，主设备提出交换信息的“请求”信号，经接口传送到从设备;从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。</p>
<p>优点:总线周期长度可变，能保证<strong>两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合</strong>。</p>
<p>缺点:比同步控制方式稍复杂一些，速度比同步定时方式慢。</p>
<p>根据“请求”和“回答”信号的撤销是否互锁，异步定时方式又分为以下 3 种类型。</p>
<ol>
<li class="lvl-3">
<p><code>不互锁方式</code> 。主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间便撤销“请求”信号。而从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间后自动撤销“回答”信号。双方不存在互锁关系，如图 6.7(a)所示。</p>
</li>
</ol>
<ol start="2">
<li class="lvl-3">
<p><code>半互锁方式 </code>。主设备发出“请求”信号后，必须在接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动撤销“回答”信号，不存在互锁关系。半互锁方式如图 6.7(b)所示。</p>
</li>
<li class="lvl-3">
<p><code>全互锁方式</code> 。主设备发出“请求”信号后，必须在从设备“回答”后才撤销“请求”信号;从设备发出“回答”信号后，必须在获知主设备“请求”信号已撤销后，再撤销其“回答”信号。双方存在互锁关系，如图 6.7©所示。</p>
</li>
</ol>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716191950.png" alt="找不到图片(Image not found)"></p>
<p><strong>思考</strong></p>
<blockquote>
<p>🤔<strong>引入总线结构有什么好处?</strong></p>
<p>① 简化了系统结构，便于系统设计制造。</p>
<p>② 大大减少了连线数目，便于布线，减小体积，提高系统的可靠性。</p>
<p>③ 便于接口设计，所有与总线连接的设备均采用类似的接口。</p>
<p>④ 便于系统的扩充、更新与灵活配置，易于实现系统的模块化。</p>
<p>⑤ 便于设备的软件设计，所有接口的软件对不同的接口地址进行操作。</p>
<p>⑥ 便于故障诊断和维修，同时也能降低成本。</p>
</blockquote>
<h1 id="shu-ru-shu-chu-xi-tong">输入输出系统</h1>
<h2 id="i-o-xi-tong-ji-ben-gai-nian">*I/O 系统基本概念</h2>
<h3 id="shu-ru-shu-chu-xi-tong-1">输入/输出系统</h3>
<p>输入/输出是以主机为中心而言的，将信息从外部设备传送到主机称为输入，反之称为输出。输入/输出系统解决的主要问题是对各种形式的信息进行输入和输出的控制。</p>
<p>I/O 系统中的几个基本概念如下:</p>
<ol>
<li class="lvl-3">
<p><code>外部设备</code> 。包括输入/输出设备及通过输入/输出接口才能访问的外存储设备。</p>
</li>
<li class="lvl-3">
<p><code>接口接口 </code>。在各个外设与主机之间传输数据时进行各种协调工作的逻辑部件。协调包括传输过程中速度的匹配、电平和格式转换等。</p>
</li>
<li class="lvl-3">
<p><code>输入设备</code> 。用于向计算机系统输入命令和文本、数据等信息的部件。键盘和鼠标是最基本的输入设备。</p>
</li>
<li class="lvl-3">
<p><code>输出设备</code> 。用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。显示器和打印机是最基本的输出设备。</p>
</li>
<li class="lvl-3">
<p><code>外存设备 </code>。指除计算机内存及 CPU 缓存等外的存储器。硬磁盘、光盘等是最基本的外存设备。</p>
</li>
</ol>
<p>一般来说，I/O 系统由 I/O 软件和 I/O 硬件两部分构成:</p>
<ol>
<li class="lvl-3">
<p><code>I/O 软件</code> 。包括驱动程序、用户程序、管理程序、升级补丁等。通常采用 I/O 指令和通道指令实现 CPU 与 I/O 设备的信息交换。</p>
</li>
<li class="lvl-3">
<p><code>I/O 硬件 </code>。包括外部设备、设备控制器和接口、I/O 总线等。通过设备控制器来控制 I/O 设备的具体动作;通过 I/O 接口与主机（总线）相连。</p>
</li>
</ol>
<h3 id="i-o-kong-zhi-fang-shi">I/O 控制方式</h3>
<p>在输入/输出系统中，经常需要进行大量的数据传输，而传输过程中有各种不同的 I/O 控制方式，基本的控制方式主要有以下 4 种:</p>
<ol>
<li class="lvl-3">
<p><code>程序查询方式 </code>。由 CPU 通过程序不断查询 I/O 设备是否已做好准备，从而控制 I/O 设备与主机交换信息。</p>
</li>
<li class="lvl-3">
<p><code>程序中断方式</code> 。只在 I/O 设备准备就绪并向 CPU 发出中断请求时才予以响应。</p>
</li>
<li class="lvl-3">
<p><code>DMA方式</code> 。主存和 I/O 设备之间有一条直接数据通路，当主存和 I/O 设备交换信息时，无须调用中断服务程序。</p>
</li>
<li class="lvl-3">
<p><code> 通道方式</code> 。在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行 I/O 命令时，只需启动有关通道，通道将执行通道程序，从而完成 I/O 操作。</p>
</li>
</ol>
<p>其中，方式 1 和方式 2 主要用于数据传输率较低的外部设备，方式 3 和方式 4 主要用于数据传输率较高的设备。</p>
<h3 id="wai-bu-she-bei">外部设备</h3>
<p>外部设备也称外围设备，是除主机外的能直接或间接与计算机交换信息的装置。最基本的外部设备主要有键盘、鼠标、显示器、打印机、磁盘存储器和光盘存储器等。</p>
<h4 id="shu-ru-she-bei">输入设备</h4>
<h5 id="jian-pan">键盘</h5>
<p>键盘是最常用的输入设备，通过它可发出命令或输入数据。</p>
<p>键盘通常以矩阵的形式排列按键，每个键用符号标明其含义和作用。每个键相当于一个开关，按下键时，电信号连通;松开键时，弹簧弹起键，电信号断开。</p>
<p>键盘输入信息可分为 3 个步骤:① 查出按下的是哪个键;② 将该键翻译成能被主机接收的编码，如 ASCII 码;③ 将编码传送给主机。</p>
<h5 id="shu-biao">鼠标</h5>
<p>鼠标是常用的定位输入设备，它把用户的操作与计算机屏幕上的位置信息相联系。常用的鼠标有 机械式机械式 和 光电式光电式 两种。</p>
<p>工作原理:鼠标在平面上移动时，其底部传感器把运动的方向和距离检测出来，从而控制光标做相应的运动。</p>
<h4 id="shu-chu-she-bei">输出设备</h4>
<h5 id="xian-shi-qi">显示器</h5>
<p>显示设备种类繁多，按显示设备所用的显示器件分类，有阴极射线管（CRT）显示器、液晶显示器（LCD）、发光二极管（LED）显示器等。按所显示的信息内容分类，有字符显示器、图形显示器和图像显示器 3 大类。显示器属于用点阵方式运行的设备，有以下主要参数。</p>
<ol>
<li class="lvl-3">
<p><code>屏幕大小</code> :以对角线长度表示，常用的有 12 ～ 29 英寸等。</p>
</li>
<li class="lvl-3">
<p><code>分辨率</code> :所能表示的像素个数，屏幕上的每个光点就是一个像素，以宽和高的像素数的乘积表示，如 800×600、1024×768 和 1280×1024 等。</p>
</li>
<li class="lvl-3">
<p><code>灰度级</code> :灰度级是指黑白显示器中所显示的像素点的亮暗差别，在彩色显示器中则表现为颜色的不同，灰度级越多，图像层次越清楚、逼真，典型的有 8 位（256 级）、16 位等。</p>
</li>
<li class="lvl-3">
<p><code>刷新</code> :光点只能保持极短的时间便会消失，为此必须在光点消失之前再重新扫描显示一遍，这个过程称为刷新。</p>
</li>
<li class="lvl-3">
<p><code>刷新频率</code> :指单位时间内扫描整个屏幕内容的次数。按照人的视觉生理，刷新频率大于 30Hz 时才不会感到闪烁，通常显示器的刷新频率为 60 ～ 120Hz。</p>
</li>
<li class="lvl-3">
<p><code>显示存储器(VRAM)</code>:也称刷新存储器，为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中。其存储容量由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大。</p>
</li>
</ol>
VRAM容量=分辨率×灰度级位数

<p>(1) <strong>阴极射线管（CRT）显示器</strong></p>
<p>CRT 显示器主要由电子枪、偏转线圈、荫罩、高压石墨电极、荧光粉涂层和玻璃外壳 5 部分组成，具有可视角度大、无坏点、色彩还原度高、色度均匀、可调节的多分辨率模式、响应时间极短等目前 LCD 难以超过的优点。</p>
<p><strong>按显示信息内容不同</strong>，可分为<code>字符显示器</code>、<code>图形显示器</code>和<code>图像显示器</code>;<strong>按扫描方式不同</strong>，可分为<code>光栅扫描</code>和<code>随机扫描</code>两种显示器。下面简要介绍字符显示器和图形显示器。</p>
<p>①<code>字符显示器</code>。显示字符的方法以点阵为基础。点阵是指由 m×n 个点组成的阵列。点阵的多少取决于显示字符的质量和字符窗口的大小。字符窗口是指每个字符在屏幕上所占的点数，它包括字符显示点阵和字符间隔。</p>
<p>将点阵存入由 ROM 构成的字符发生器中，在 CRT 进行光栅扫描的过程中，从字符发生器中依次读出某个字符的点阵，按照点阵中 О 和 1 代码的不同控制扫描电子束的开或关，从而在屏幕上显示字符。对应于每个字符窗口，所需显示字符的 ASCII 代码被存放在视频存储器 VRAM 中，以备刷新。</p>
<p>②<code>图形显示器</code>。将所显示图形的一组坐标点和绘图命令组成显示文件存放在缓冲存储器中，缓存中的显示文件传送给矢量（线段）产生器，产生相应的模拟电压，直接控制电子束在屏幕上的移动。为在屏幕上保留持久稳定的图像，需按一定的频率对屏幕反复刷新。这种显示器的优点是分辨率高且显示的曲线平滑。目前高质量的图形显示器采用这种随机扫描方式。缺点是当显示复杂图形时，会有闪烁感。</p>
<p>(2)<strong>液晶显示器（LCD）</strong></p>
<p>原理:利用液晶的电光效应，由图像信号电压直接控制薄膜晶体管，再间接控制液晶分子的光学特性来实现图像的显示。</p>
<p>特点:体积小、重量轻、省电、无辐射、绿色环保、画面柔和、不伤眼等。</p>
<p>(3)<strong>LED（发光二极管）显示器</strong></p>
<p>原理:通过控制半导体发光二极管来显示文字、图形、图像等各种信息。</p>
<p>LCD 与 LED 是两种不同的显示技术。LCD 是由液态晶体组成的显示屏，而 LED 则是由发光二极管组成的显示屏。与 LCD 相比，LED 显示器在亮度、功耗、可视角度和刷新速率等方面都更具优势。</p>
<h5 id="da-yin-ji">打印机</h5>
<p>打印机是计算机的输出设备之一，用于将计算机的处理结果打印在相关介质上。</p>
<p>按工作原理，打印机分为击打式和非击打式两大类;按工作方式，打印机分为点阵打印机、针式打印机、喷墨式打印机、激光打印机等。</p>
<p>（1）针式打印机</p>
<p>原理:在联机状态下，主机发出打印命令，经接口、检测和控制电路，间歇驱动纵向送纸和打印头横向移动，同时驱动打印机间歇冲击色带，在纸上打印出所需的内容。</p>
<p>特点:针式打印机擅长“多层复写打印”，实现各种票据或蜡纸等的打印。其工作原理简单，造价低廉，耗材（色带）便宜，但打印分辨率和打印速度不够高。</p>
<p>（2）喷墨式打印机</p>
<p>原理:带电的喷墨雾点经过电极偏转后，直接在纸上形成所需字形。彩色喷墨打印机基于三基色原理，即分别喷射 3 种颜色的墨滴，按一定的比例混合出所要求的颜色。</p>
<p>特点:打印噪声小，可实现高质量彩色打印，通常打印速度比针式打印机快;但防水性差，高质量打印需要专用打印纸。</p>
<p>（3）激光打印机</p>
<p>原理:计算机输出的二进制信息，经过调制后的激光束扫描，在感光鼓上形成潜像，再经过显影、转印和定影，在纸上得到所需的字符或图像。</p>
<p>特点:打印质量高、速度快、噪声小、处理能力强;但耗材多、价格较贵、不能复写打印多份，且对纸张的要求高。</p>
<p>激光打印机是将激光技术和电子显像技术相结合的产物。感光鼓（也称硒鼓）是激光打印机的核心部件。</p>
<h2 id="i-o-jie-kou">I/O 接口</h2>
<p>I/O 接口（I/O 控制器）是主机和外设之间的交接界面，通过接口可以实现主机和外设之间的信息交换。主机和外设具有各自的工作特点，它们在信息形式和工作速度上具有很大的差异，接口正是为了解决这些差异而设置的。</p>
<h3 id="i-o-jie-kou-de-gong-neng">I/O 接口的功能</h3>
<p>I/O 接口的主要功能如下:</p>
<ol>
<li class="lvl-3">
<p><code>实现主机和外设的通信联络控制</code>。解决主机与外设时序配合问题，协调不同工作速度的外设和主机之间交换信息，以保证整个计算机系统能统一、协调地工作。</p>
</li>
<li class="lvl-3">
<p>进行 <code>地址译码</code>和<code>设备选择</code> 。CPU 送来选择外设的地址码后，接口必须对地址进行译码以产生设备选择信息，使主机能和指定外设交换信息。</p>
</li>
<li class="lvl-3">
<p>实现<code>数据缓冲</code> 。<strong>CPU 与外设之间的速度往往不匹配，为消除速度差异，接口必须设置数据缓冲寄存器，用于数据的暂存，以避免因速度不一致而丢失数据。</strong></p>
</li>
<li class="lvl-3">
<p><code>信号格式的转换</code> 。外设与主机两者的电平、数据格式都可能存在差异，接口应提供计算机与外设的信号格式的转换功能，如电平转换、并/串或串/并转换、模/数或数/模转换等。</p>
</li>
<li class="lvl-3">
<p>传送<code>控制命令</code>和<code>状态信息</code> 。CPU 要启动某一外设时，通过接口中的命令寄存器向外设发出启动命令;外设准备就绪时，则将“准备好”状态信息送回接口中的状态寄存器，并反馈给 CPU。外设向 CPU 提出中断请求时，CPU 也应有相应的响应信号反馈给外设。</p>
</li>
</ol>
<h3 id="i-o-jie-kou-de-ji-ben-jie-gou">I/O 接口的基本结构</h3>
<p>如图 7.3 所示，I/O 接口在主机侧通过 I/O 总线与内存、CPU 相连。通过<code>数据总线 </code>，在 <code>数据缓冲寄存器</code>与内存或 CPU 的寄存器之间进行数据传送。同时接口和设备的状态信息被记录在<code>状态寄存器</code>中，通过数据线将状态信息送到 CPU。CPU 对外设的控制命令也通过数据线传送，一般将其送到 I/O 接口的控制寄存器。状态寄存器和控制寄存器在传送方向上是相反的。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716195002.png" alt="找不到图片（Image not found）"></p>
<p>接口中的地址线用于给出要访问的 I/O 接口中的寄存器的地址，它和读/写控制信号一起被送到 I/O 接口的控制逻辑部件，其中地址信息用以选择和主机交换信息的寄存器，通过控制线传送来的读/写信号确认是读寄存器还是写寄存器，此外控制线还会传送一些仲裁信号和握手信号。</p>
<p>接口中的 I/O 控制逻辑还要能对控制寄存器中的命令字进行译码，并将译码得到的控制信号通过外设界面控制逻辑送到外设，同时将数据缓冲寄存器的数据发送到外设或从外设接收数据到数据缓冲寄存器。另外，它还要具有收集外设状态到状态寄存器的功能。</p>
<p>对数据缓冲寄存器、状态/控制寄存器的访问操作是通过相应的指令来完成的，通常称这类指令为 I/O 指令，I/O 指令只能在操作系统内核的底层 I/O 软件中使用，它们是一种<code>特权指令 </code>。</p>
<blockquote>
<p>注意:接口和端口是两个不同的概念。端口是指接口电路中可以进行读/写的寄存器，若干端口加上相应的控制逻辑才可以组成接口。</p>
</blockquote>
<h3 id="i-o-jie-kou-de-lei-xing">I/O 接口的类型</h3>
<p>从不同的角度看，I/O 接口可以分为不同的类型。</p>
<p>1）按数据传送方式可分为 <code>并行接口 </code>（一字节或一个字的所有位同时传送）和<code>串行接口 </code>（一位一位地传送），接口要完成数据格式的转换。</p>
<blockquote>
<p>注意:这里所说的数据传送方式指的是外设和接口一侧的传送方式，而在主机和接口一侧，数据总是并行传送的。</p>
</blockquote>
<p>2）按主机访问 I/O 设备的控制方式可分为 <code>程序查询接口 </code>、 <code>中断接口</code> 和 <code>DMA接口</code> 等。</p>
<p>3）按功能选择的灵活性可分为<code>可编程接口</code> 和 <code>不可编程接口</code> 。</p>
<h3 id="i-o-duan-kou-ji-qi-bian-zhi">I/O 端口及其编址</h3>
<p>I/O 端口是指接口电路中可被 CPU 直接访问的寄存器，主要有<code>数据端口 </code>、 <code>状态端口</code> 和 <code>控制端口</code> ，若干端口加上相应的控制逻辑电路组成接口。通常，CPU 能对数据端口执行读写操作，但对状态端口只能执行读操作，对控制端口只能执行写操作。</p>
<p>I/O 端口要想能够被 CPU 访问，就必须要对各个端口进行编号，每个端口对应一个端口地址。而对 I/O 端口的编址方式有与存储器统一编址和独立编址两种。</p>
<ol>
<li class="lvl-3">
<p><code>统一编址</code> ，又称存储器映射方式，是指把 I/O 端口当作存储器的单元进行地址分配，这种方式 CPU 不需要设置专门的 I/O 指令，用统一的 访存指令访存指令 就可以访问 I/O 端口。</p>
<p>优点:不需要专门的输入/输出指令，可使 CPU 访问 I/O 的操作更灵活、更方便，还可使端口有较大的编址空间。</p>
<p>缺点:端口占用存储器地址，使内存容量变小，而且利用存储器编址的 I/O 设备进行数据输入/输出操作，执行速度较慢。</p>
</li>
<li class="lvl-3">
<p><code>独立编址</code> ，又称 I/O 映射方式，I/O 端口的地址空间与主存地址空间是两个独立的地址空间，因而无法从地址码的形式上区分，需要设置专门的/O 指令来访问 I/O 端口。</p>
<p>优点:输入/输出指令与存储器指令有明显区别，程序编制清晰，便于理解。</p>
<p>缺点:输入/输出指令少，一般只能对端口进行传送操作，尤其需要 CPU 提供存储器读/写、I/O 设备读/写两组控制信号，增加了控制的复杂性。</p>
</li>
</ol>
<h2 id="i-o-fang-shi">I/O 方式</h2>
<p>输入/输出系统实现主机与 I/O 设备之间的数据传送，可以采用不同的控制方式，各种方式在代价、性能、解决问题的着重点等方面各不相同，常用的 I/O 方式有<code>程序查询</code> 、 <code>程序中断</code>、 <code>DMA</code> 和<code>通道 </code>等，其中前两种方式更依赖于 CPU 中程序指令的执行。</p>
<h3 id="cheng-xu-cha-xun-fang-shi">程序查询方式</h3>
<p>信息交换的控制完全由主机执行程序实现，程序查询方式接口中设置一个数据缓冲寄存器（数据端口）和一个设备状态寄存器（状态端口）。主机进行 I/O 操作时，先发出询问信号，读取设备的状态并根据设备状态决定下一步操作究竟是进行数据传送还是等待。</p>
<p>程序查询方式的工作流程如下（见图 7.4）</p>
<p>① CPU 执行初始化程序，并预置传送参数。</p>
<p>② 向 I/O 接口发出命令字，启动 I/O 设备。</p>
<p>③ 从外设接口读取其状态信息。</p>
<p>④ CPU 不断查询 I/O 设备状态，直到外设准备就绪。</p>
<p>⑤ 传送一次数据。</p>
<p>⑥ 修改地址和计数器参数。</p>
<p>⑦ 判断传送是否结束，若未结束转第 ③ 步，直到计数器为 0。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716195423.png" alt="找不到图片（Image not found）"></p>
<p>在这种控制方式下，CPU 一旦启动 I/O，就必须停止现行程序的运行，并在现行程序中插入一段程序。程序查询方式的主要特点是 CPU 有<code>“踏步”等待现象</code>，CPU 与 I/O 串行工作。这种方式的接口设计简单、设备量少，但 CPU 在信息传送过程中要花费很多时间来查询和等待，而且在<code> 一段时间</code>内只能和<code>一台</code>外设交换信息，效率大大降低。</p>
<h3 id="mark-cheng-xu-zhong-duan-fang-shi-mark"><mark>程序中断方式</mark></h3>
<p>现代计算机系统中都配有完善的异常和中断处理系统，CPU 的数据通路中有相应的异常和中断的检测和响应逻辑，在外设接口中有相应的中断请求和控制逻辑，操作系统中有相应的中断服务程序。这些中断硬件线路和中断服务程序有机结合，共同完成异常和中断的处理过程。</p>
<h4 id="yi-chang-he-zhong-duan">异常和中断</h4>
<h5 id="yi-chang">异常</h5>
<p><strong>异常</strong>是指由<code>CPU内部异常</code>引起的意外事件，分为<code>硬故障中断</code> 和<code>程序性异常</code>。<code>硬故障中断 </code>是由硬连线出现异常引起的，如<code>电源掉电</code> 、<code> 存储器线路错</code>等。 <code>程序性异常</code>也称 <code>软中断</code> ，是指在 CPU 内部因执行指令而引起的异常事件。如<code>整除0 </code>、<code>溢出 </code>、<code>断点</code> 、<code>单步跟踪 </code>、<code>非法指令</code> 、 <code>栈溢出</code> 、 <code>地址越界</code> 、<code>缺页</code> 、分时系统中的 <code>时间片中断</code> 及用户态到核心态的<code>切换 </code>等。按发生异常的报告方式和返回方式不同， <code>内部异常</code> 可分为<code>故障 </code>（Fault）、 <code>自陷 </code>（Trap）和 <code>终止</code> （Abort）三类。</p>
<p>① <strong>故障</strong>（Fault）</p>
<p>指在引起故障等指令启动后、执行结束前被检测到的异常事件。例如，指令译码时，出现“非法操作码”;取数据时，发生“缺段”或“缺页”;执行整数除法指令时，发现“除数为 0”等。对于“缺段”“缺页”等异常处理后，已将所需的段或页面从磁盘调入主存，可回到发生故障的指令继续执行，断点为当前发生故障的指令;对于“非法操作码”“除数为 0”等， 因为无法通过异常处理程序恢复故障 ，因此不能回到原断点执行，必须终止进程的执行。</p>
<p>② <strong>自陷</strong>（Trap）</p>
<p>自陷也称陷阱或陷入，它是预先安排的一种“异常”事件，就像预先设定的“陷阱”一样。通常的做法是:事先在程序中用一条特殊指令或通过某种方式设定特殊控制标志来人为设置一个“陷阱”，当执行到被设置了“陷阱”的指令时，CPU 在执行完自陷指令后，自动根据不同“陷阱”类型进行相应的处理，然后返回到自陷指令的下一条指令执行。注意，当自陷指令是转移指令时，并不是返回到下一条指令执行，而是返回到转移目标指令执行。</p>
<p>在 80x86 中，用于程序调试的<code>“ 断点设置 ”</code>功能就是通过<code>自陷</code>方式实现的。此外，系统调用指令、条件自陷指令（如 MIPS 中 teq、teqi、tne、tnei 等一组按条件进入陷阱的指令）等都属于陷阱指令，执行到这些指令时，无条件或有条件地自动调出操作系统内核程序进行执行。</p>
<p>③ <strong>终止</strong>（Abort）</p>
<p>如果在执行指令的过程中发生了使计算机无法继续执行的硬件故障，如电源掉电、线路故障等，那么程序将无法继续执行，只能终止，此时，调出中断服务程序来重启系统。这种异常与故障和自陷不同，不是由特定指令产生的，而是<code>随机</code>发生的。</p>
<h5 id="wai-bu-zhong-duan">外部中断</h5>
<p><code>外中断</code>是指来自 CPU 外部、与 CPU 执行指令无关的事件引起的中断，包括<code>I/O设备</code>发出的 I/O 中断（如键盘输入、打印机缺纸等）、<code>外部信号中断</code>（如用户按 Esc 键），以及各种定时器引起的时钟中断等。<strong>外中断在狭义上一般称为中断（书中若未说明，一般是指外中断）</strong>。</p>
<p>外中断和内部异常在本质上是一样的，但它们之间有以下两个重要的不同点:</p>
<ol>
<li class="lvl-3">
<p>“缺页”或“溢出”等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不阻止任何指令的完成。</p>
</li>
<li class="lvl-3">
<p>异常的检测是由 CPU 自身完成的，不必通过外部的某个信号通知 CPU。对于中断，CPU 必须通过总线获取中断源的标识信息，才能获知哪个设备发生了何种中断。</p>
</li>
</ol>
<blockquote>
<p>有些教材也将异常和中断统称为中断，将由 CPU 内部产生的异常称为内中断，将通过中断请求线 INTR 和 NMI 从 CPU 外部发出的中断请求称为外中断。</p>
</blockquote>
<h4 id="zhong-duan-de-ji-ben-gai-nian">中断的基本概念</h4>
<p>程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU 暂时中止现行程序，而转去对这些异常情况或特殊请求进行处理，在处理完毕后 CPU 又自动返回到现行程序的断点处，继续执行原程序。</p>
<p>程序中断的作用如下:</p>
<p>① 实现 CPU 与 I/O 设备的并行工作。</p>
<p>② <code>处理</code>硬件故障和软件错误。</p>
<p>③ 实现人机交互，用户<code>干预</code>机器需要用到中断系统。</p>
<p>④ 实现<code>多道程序</code>、<code>分时操作</code>，多道程序的切换需借助于中断系统。</p>
<p>⑤ 实时处理需要借助中断系统来实现<code>快速响应</code>。</p>
<p>⑥ 实现应用程序和操作系统（管态程序）的切换，称为<code>“软中断”</code>。</p>
<p>⑦ 多处理器系统中各处理器之间的 信息交流信息交流 和 任务切换任务切换 。</p>
<p>程序中断方式的思想:CPU 在程序中安排好于某个时刻启动某台外设，然后 CPU 继续执行原来的程序，不需要像查询方式那样一直等待外设准备就绪。一旦外设完成数据传送的准备工作，就主动向 CPU 发出中断请求，请求 CPU 为自己服务。在可以响应中断的条件下，CPU 暂时中止正在执行的程序，转去执行中断服务程序为外设服务，在中断服务程序中完成一次主机与外设之间的数据传送，传送完成后，CPU 返回原来的程序，如图 7.5 所示。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716210133.png" alt="找不到图片（Image not found）"></p>
<h4 id="cheng-xu-zhong-duan-fang-shi-gong-zuo-liu-cheng">程序中断方式工作流程</h4>
<h6 id="zhong-duan-qing-qiu">中断请求</h6>
<p>中断源是请求 CPU 中断的设备或事件，一台计算机允许有多个中断源。每个中断源向 CPU 发出中断请求的时间是随机的。为记录中断事件并区分不同的中断源，中断系统需对每个中断源设置中断请求标记触发器 INTR，当其状态为“1”时，表示中断源有请求。这些触发器可组成中断请求标记寄存器，该寄存器可集中在 CPU 中，也可分散在各个中断源中。</p>
<p><code>内中断</code>皆为<code>不可屏蔽中断</code> 。通过 INTR 信号线发出的<code>外中断</code>是<code>可屏蔽中断</code> ，在关中断（IF =1）的情况下不会被响应;而通过 NMI 信号发出的是不可屏蔽中断，即使在关中断（IF=0）的情况下也会被响应。不可屏蔽中断的处理优先级最高，任何时候只要发生不可屏蔽中断，都要中止现行程序的执行，转到不可屏蔽中断处理程序执行。</p>
<h6 id="zhong-duan-pan-you">中断判优</h6>
<p>中断系统在任一瞬间只能响应一个中断源的请求。由于许多中断源提出中断请求的时间都是随机的，因此当多个中断源同时提出请求时，需通过中断判优逻辑确定响应哪个中断源的请求，例如故障中断的优先级别较高，然后是 I/O 中断。</p>
<p>中断判优既可以用硬件实现，又可用软件实现。硬件实现是通过<code>硬件排队器</code>实现的，它既可以设置在 CPU 中，又可以分散在各个中断源中，软件实现是通过<code>查询程序</code>实现的。</p>
<p><strong>一般来说，硬件故障中断属于最高级，其次是软件中断，不可屏蔽中断优于可屏蔽中断，DMA 请求优于 I/O 设备传送的中断请求，高速设备优于低速设备，输入设备优于输出设备，实时设备优于普通设备等。</strong></p>
<h6 id="cpu-xiang-ying-zhong-duan-de-tiao-jian">CPU 响应中断的条件</h6>
<p>CPU 在满足一定的条件下响应中断源发出的中断请求，并经过一些特定的操作，转去执行中断服务程序。CPU 响应中断必须满足以下 3 个条件:</p>
<p>① 中断源有中断请求。</p>
<p>② CPU 允许中断及开中断。</p>
<p>③ 一条指令执行完毕，且没有更紧迫的任务。</p>
<blockquote>
<p>注意:I/O 设备的就绪时间是随机的，而 CPU 在统一的时刻即每条指令执行阶段结束前向接口发出中断查询信号，以获取 I/O 的中断请求，也就是说，<strong>CPU 响应中断的时间是在每条指令执行阶段的结束时刻。这里说的中断仅指外中断，内中断不属于此类情况。</strong></p>
</blockquote>
<h6 id="zhong-duan-xiang-ying">中断响应</h6>
<p>CPU 响应中断后，经过某些操作，转去执行中断服务程序。这些操作是由硬件直接实现的，我们将它称为<code>中断隐指令</code> 。中断隐指令并不是指令系统中的一条真正的指令，它没有操作码，所以中断隐指令是一种不允许也不可能为用户使用的特殊指令。它所完成的操作如下:</p>
<p>① <code>关中断</code> 。CPU 响应中断后，首先要保护程序的断点和现场信息，在保护断点和现场的过程中，CPU 不能响应更高级中断源的中断请求。</p>
<p>② <code>保存断点</code> 。为保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断点（指令无法直接读取的 PC 和 PSWR 等的内容）保存起来。</p>
<p>③ <code>引出中断服务程序</code> 。实质是取出中断服务程序的入口地址并传送给程序计数器（PC）。</p>
<h6 id="zhong-duan-xiang-liang">中断向量</h6>
<p>每个中断都有一个类型号，每个中断类型号都对应一个中断服务程序，每个中断服务程序都有一个入口地址，CPU 必须找到入口地址，即中断向量，把系统中的全部中断向量集中存放到存储器的某个区域内，这个存放中断向量的存储区就称为<code>中断向量表</code>。</p>
<p><strong>CPU 响应中断后，中断硬件会自动将中断向量地址传送到 CPU，由 CPU 实现程序的切换，这种方法称为中断向量法，采用中断向量法的中断称为向量中断</strong>。</p>
<blockquote>
<p>注意: <code>中断向量</code>是<code>中断服务程序的入口地址 </code>，<code>中断向量地址</code>是指 <code>中断服务程序的入口地址的地址</code> 。</p>
</blockquote>
<h6 id="zhong-duan-chu-li-guo-cheng">中断处理过程</h6>
<p>不同计算机的中断处理过程各具特色，就其多数而论，中断处理流程如图 7.6 所示。</p>
<p>中断处理流程如下:</p>
<p>① <code>关中断</code> 。在保护断点和现场期间不能被新的中断所打断，必须关中断。否则，若断点或现场保存不完整，在中断服务程序结束后，就不能正确地恢复并继续执行现行程序。</p>
<p>② <code>保存断点</code> 。断点可以压入堆栈，也可以存入主存的特定单元中。</p>
<p>③ <code>引出中断服务程序</code> 。通常有两种方法寻址中断服务程序的入口地址: <code>硬件向量法</code> 和 <code>软件查询法</code> 。硬件向量法通过硬件产生中断向量地址，再由中断向量地址找到中断服务程序的入口地址。软件查询法用软件编程的办法寻找入口地址。</p>
<blockquote>
<p>注意:硬件产生的实际上是中断类型号，而中断类型号指出了中断向量存放的地址，因此能产生中断向量地址。</p>
</blockquote>
<p>④<code> 保存现场和屏蔽字</code> 。进入中断服务程序后首先要保存现场和中断屏蔽字，现场信息是指用户可见的工作寄存器的内容，它存放着程序执行到断点处的现行值。</p>
<blockquote>
<p>注意:现场和断点，这两类信息都不能被中断服务程序破坏。现场信息因为用指令可直接访问，所以通常在中断服务程序中通过指令把它们保存到栈中，即由软件实现;而断点信息由 CPU 在中断响应开始时自动保存到栈或专门的寄存器中，即由硬件实现。</p>
</blockquote>
<p>⑤ <code>开中断</code> 。允许更高级中断请求得到响应，实现中断嵌套。</p>
<p>⑥ <code>执行中断服务程序</code> 。这是中断请求的目的。</p>
<p>⑦ <code>关中断</code> 。保证在恢复现场和屏蔽字时不被中断。</p>
<p>⑧ <code>恢复现场和屏蔽字</code> 。将现场和屏蔽字恢复到原来的状态。</p>
<p>⑨ <code>开中断、中断返回</code> 。中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序。</p>
<p>其中，①③ 在 CPU 进入中断周期后，由中断隐指令（硬件自动）完成;④⑨ 由中断服务程序完成。</p>
<blockquote>
<p>注意: 恢复现场是指在中断返回之前，中断服务程序必须将寄存器的内容恢复到中断处理之前的状态。这一步骤由中断服务程序完成。而中断返回则由中断服务程序的最后一条中断返回指令来完成。</p>
</blockquote>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716210821.png" alt="找不到图片（Image not found）"></p>
<h4 id="duo-zhong-zhong-duan-he-zhong-duan-ping-bi-ji-zhu">多重中断和中断屏蔽技术</h4>
<p>若 CPU 在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求，而 CPU 对新的中断请求不予响应，则这种中断称为<code>单重中断 </code>，如图 7.7（a）所示。若 CPU 暂停现行的中断服务程序，转去处理新的中断请求，则这种中断称为<code>多重中断</code>，又称<code>中断嵌套 </code>，如图 7.7（b）所示。</p>
<p>中断屏蔽技术主要用于多重中断。CPU 要具备多重中断的功能，必须满足下列条件:</p>
<p>① 在中断服务程序中提前设置开中断指令。</p>
<p>② 优先级别高的中断源有权中断优先级别低的中断源。</p>
<p>每个中断源都有一个 <code>屏蔽触发器 </code>， 1 表示<code>屏蔽该中断源</code>的请求， 0 表示可以<code>正常申请</code>，所有屏蔽触发器组合在一起便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。</p>
<p>关于中断屏蔽字的设置及多重中断程序执行的轨迹，下面通过实例说明。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716211109.png" alt="找不到图片（Image not found）"></p>
<p>例题:</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716211251.png" alt="找不到图片（Image not found）"></p>
<h3 id="dma-fang-shi">DMA 方式</h3>
<p><strong>DMA(Direct Memory Access)方式</strong>是一种<code>完全由硬件</code>进行成组信息传送的控制方式，它具有程序中断方式的优点，即在数据准备阶段，CPU 与外设并行工作。DMA 方式在外设与内存之间开辟一条“直接数据通道”，信息传送不再经过 CPU，降低了 CPU 在传送数据时的开销，因此称为<code>直接存储器存取</code>方式。由于数据传送不经过 CPU，也就不需要保护、恢复 CPU 现场等烦琐操作。</p>
<p>这种方式适用于磁盘机、磁带机等高速设备大批量数据的传送，它的硬件开销比较大。在 DMA 方式中，中断的作用仅限于<code>故障</code>和<code>正常传送结束时的处理</code> 。</p>
<h4 id="dma-fang-shi-de-te-dian">DMA 方式的特点</h4>
<p>主存和 DMA 接口之间有一条直接数据通路。由于 DMA 方式传送数据不需要经过 CPU,因此不必中断现行程序，I/O 与主机并行工作，程序和传送并行工作。</p>
<p>DMA 方式具有下列特点:</p>
<p>① 它使主存与 CPU 的固定联系脱钩，主存既可被 CPU 访问，又可被外设访问。</p>
<p>② 在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。</p>
<p>③ 主存中要开辟专用缓冲区，及时供给和接收外设的数据。</p>
<p>④ DMA 传送速度快，CPU 和外设并行工作，提高了系统效率。</p>
<p>⑤ DMA 在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</p>
<h4 id="dma-kong-zhi-qi-de-zu-cheng">DMA 控制器的组成</h4>
<p>在 DMA 方式中，对数据传送过程进行控制的硬件称为 DMA 控制器（DMA 接口）。当 I/O 设备需要进行数据传送时，通过 DMA 控制器向 CPU 提出 DMA 传送请求，CPU 响应之后将让出系统总线，由 DMA 控制器接管总线进行数据传送。其主要功能如下:</p>
<ol>
<li class="lvl-3">
<p>接受外设发出的 DMA 请求，并向 CPU 发出总线请求。</p>
</li>
<li class="lvl-3">
<p>CPU 响应此总线请求，发出总线响应信号，接管总线控制权，进入 DMA 操作周期。</p>
</li>
<li class="lvl-3">
<p>确定传送数据的主存单元地址及长度，并自动修改主存地址计数和传送长度计数。</p>
</li>
<li class="lvl-3">
<p>规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作。</p>
</li>
<li class="lvl-3">
<p>向 CPU 报告 DMA 操作的结束。</p>
</li>
</ol>
<p>图 7.10 给出了一个简单的 DMA 控制器。</p>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716211543.png" alt="找不到图片（Image not found）"></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>主存地址计数器</code>:存放要交换数据的主存地址。</p>
</li>
<li class="lvl-2">
<p><code>传送长度计数器</code>:记录传送数据的长度，计数溢出时，数据即传送完毕，自动发中断请求信号。</p>
</li>
<li class="lvl-2">
<p><code>数据缓冲寄存器</code>:暂存每次传送的数据。</p>
</li>
<li class="lvl-2">
<p><code>DMA请求触发器</code>:每当 I/O 设备准备好数据后，给出一个控制信号，使 DMA 请求触发器置位。</p>
</li>
<li class="lvl-2">
<p><code>“控制/状态”逻辑</code>:由控制和时序电路及状态标志组成，用于指定传送方向，修改传送参数，并对 DMA 请求信号和 CPU 响应信号进行协调和同步。</p>
</li>
<li class="lvl-2">
<p><code>中断机构</code>:当一个数据块传送完毕后触发中断机构，向 CPU 提出中断请求。</p>
</li>
</ul>
<p>在 DMA 传送过程中，DMA 控制器将接管 CPU 的地址总线、数据总线和控制总线，CPU 的主存控制信号被禁止使用。而当 DMA 传送结束后，将恢复 CPU 的一切权利并开始执行其操作。由此可见，DMA 控制器必须具有控制系统总线的能力。</p>
<h4 id="dma-de-chuan-song-fang-shi">DMA 的传送方式</h4>
<p>主存和 I/O 设备之间交换信息时，不通过 CPU。但当 I/O 设备和 CPU 同时访问主存时，可能发生冲突，为了有效地使用主存，DMA 控制器与 CPU 通常采用以下 3 种方式使用主存:</p>
<ol>
<li class="lvl-3">
<p>停止 CPU 访存。当 I/O 设备有 DMA 请求时，由 DMA 控制器向 CPU 发送一个停止信号，使 CPU 脱离总线，停止访问主存，直到 DMA 传送一块数据结束。数据传送结束后，DMA 控制器通知 CPU 可以使用主存，并把总线控制权交还给 CPU。</p>
</li>
<li class="lvl-3">
<p>周期挪用（或周期窃取）。当 I/O 设备有 DMA 请求时，会遇到 3 种情况:</p>
<ol>
<li class="lvl-6">此时 CPU 不在访存（如 CPU 正在执行乘法指令），因此 I/O 的访存请求与 CPU 未发生冲突;</li>
<li class="lvl-6">CPU 正在访存，此时必须待存取周期结束后，CPU 再将总线占有权让出;</li>
<li class="lvl-6">I/O 和 CPU 同时请求访存，出现访存冲突，此时 CPU 要暂时放弃总线占有权。I/O 访存优先级高于 CPU 访存，因为 I/O 不立即访存就可能丢失数据，此时由 I/O 设备挪用一个或几个存取周期，传送完一个数据后立即释放总线，是一种单字传送方式。</li>
</ol>
</li>
<li class="lvl-3">
<p>DMA 与 CPU 交替访存。这种方式适用于 CPU 的工作周期比主存存取周期长的情况。例如，若 CPU 的工作周期是 1.2μs，主存的存取周期小于 0.6μs，则可将一个 CPU 周期分为 C<sub>1</sub>和 C<sub>2</sub>,两个周期，其中 C<sub>1</sub>专供 DMA 访存，C<sub>2</sub>专供 CPU 访存。这种方式不需要总线使用权的申请、建立和归还过程，总线使用权是通过 C<sub>1</sub>和 C<sub>2</sub>分时控制的。</p>
</li>
</ol>
<h5 id="dma-de-chuan-song-guo-cheng">DMA 的传送过程</h5>
<p>DMA 的数据传送过程分为预处理、数据传送和后处理 3 个阶段:</p>
<ol>
<li class="lvl-3">
<p><code>预处理 </code>。由 CPU 完成一些必要的准备工作。首先，CPU 执行几条 I/O 指令，用以测试 I/O 设备状态，向 DMA 控制器的有关寄存器置初值、设置传送方向、启动该设备等。然后，CPU 继续执行原来的程序，直到 I/O 设备准备好发送的数据（输入情况）或接收的数据（输出情况）时，I/O 设备向 DMA 控制器发送 DMA 请求，再由 DMA 控制器向 CPU 发送总线请求（有时将这两个过程统称为 DMA 请求），用以传输数据。</p>
</li>
<li class="lvl-3">
<p><code>数据传送</code> 。DMA 的数据传输可以以单字节（或字）为基本单位，也可以以数据块为基本单位。对于以数据块为单位的传送（如硬盘），DMA 占用总线后的数据输入和输出操作都是通过循环来实现的。需要指出的是，这一循环也是由 DMA 控制器（而非通过 CPU 执行程序）实现的，即数据传送阶段完全由 DMA（硬件）控制。</p>
</li>
<li class="lvl-3">
<p><code>后处理 </code>。DMA 控制器向 CPU 发送中断请求，CPU 执行中断服务程序做 DMA 结束处理，包括校验送入主存的数据是否正确、测试传送过程中是否出错（错误则转入诊断程序）及决定是否继续使用 DMA 传送其他数据块等。DMA 的传送流程如图 7.11 所示。</p>
</li>
</ol>
<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716211945.png" alt="找不到图片（Image not found）"></p>
<h4 id="dma-fang-shi-he-zhong-duan-fang-shi-de-qu-bie">DMA 方式和中断方式的区别</h4>
<p>DMA 方式和中断方式的重要区别如下:</p>
<p>① 中断方式是程序的切换，需要保护和恢复现场;而 DMA 方式除了预处理和后处理，其他时候不占用 CPU 的任何资源。</p>
<p>② 对中断请求的响应只能发生在每条指令执行完毕时（即指令的执行周期后）;而对 DMA 请求的响应可以发生在每个机器周期结束时（在取指周期、间址周期、执行周期后均可），只要 CPU 不占用总线就可被响应。</p>
<p>③ 中断传送过程需要 CPU 的干预;而 DMA 传送过程不需要 CPU 的干预，因此数据传输率非常高，适合于高速外设的成组数据传送。</p>
<p>④ DMA 请求的优先级高于中断请求。</p>
<p>⑤ 中断方式具有对异常事件的处理能力，而 DMA 方式仅局限于传送数据块的 I/O 操作。</p>
<p>⑥ 从数据传送来看，中断方式靠程序传送，DMA 方式靠硬件传送。</p>
<h2 id="zong-jie">总结</h2>
<h3 id="cpu-xiang-ying-zhong-duan-ying-ju-bei-na-xie-tiao-jian">CPU 响应中断应具备哪些条件?</h3>
<p>在 CPU 内部设置的中断屏蔽触发器必须是开放的。</p>
<p>① 外设有中断请求时，中断请求触发器必须处于“1”状态，保持中断请求信号。</p>
<p>② 外设（接口）中断允许触发器必须为“1”，这样才能把外设中断请求送至 CPU.</p>
<p>③ 具备上述三个条件时，CPU 在现行指令结束的最后一个状态周期响应中断。</p>
<h3 id="zhong-duan-xiang-ying-you-xian-ji-he-zhong-duan-chu-li-you-xian-ji-fen-bie-zhi-shi-yao">中断响应优先级和中断处理优先级分别指什么?</h3>
<p>中断响应优先级是由硬件排队线路或中断查询程序的查询顺序决定的，不可动态改变;而中断处理优先级可以由中断屏蔽字来改变，反映的是正在处理的中断是否比新发生的中断的处理优先级低（屏蔽位为“0”，对新中断开放），若是，则中止正在处理的中断，转到新中断去处理，处理完后再回到刚才被中止的中断继续处理。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
            <ul id="audio-list" style="display:none">
                
                
                <li title='0' data-url='/statics/chengdu.mp3'></li>
                
                    
            </ul>
            
                        
            
            
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d=''
        data-p='https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    >Comments</div>


            
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="https://s2.ax1x.com/2019/09/19/nLtSiD.png" height=300 width=300></img>
                    <p>ND_LJQ</p>
                    <span>Think like an artist, develop like an artisan</span>
                    <dl>
                        
                            
                            
                            
                        
                        
                    </dl>
                </div>
                <ul>
                    <li><a href="/">4 <p>Articles</p></a></li>
                    <li><a href="/categories">6 <p>Categories</p></a></li>
                    <li><a href="/tags">4 <p>Tags</p></a></li>
                </ul>
            </div>
            
            
            
            <div class="box sticky animated fadeInRight faster">
                <div id="toc" class="subbox">
                    <h4>Contents</h4>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ji-suan-ji-de-xi-tong-gai-shu"><span class="toc-number">1.</span> <span class="toc-text">计算机的系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ji-suan-ji-de-ceng-ci-jie-gou"><span class="toc-number">1.1.</span> <span class="toc-text">计算机的层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ji-suan-ji-xi-tong-de-zu-cheng"><span class="toc-number">1.1.1.</span> <span class="toc-text">计算机系统的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ji-suan-ji-ying-jian"><span class="toc-number">1.1.2.</span> <span class="toc-text">计算机硬件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ji-suan-ji-ruan-jian"><span class="toc-number">1.1.3.</span> <span class="toc-text">计算机软件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ji-suan-ji-de-ceng-ci-jie-gou-1"><span class="toc-number">1.1.4.</span> <span class="toc-text">计算机的层次结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ji-suan-ji-de-xing-neng-zhi-biao"><span class="toc-number">1.2.</span> <span class="toc-text">计算机的性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ji-suan-ji-de-zhu-yao-xi-tong-zhi-biao"><span class="toc-number">1.2.1.</span> <span class="toc-text">计算机的主要系统指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ji-ge-zhuan-ye-zhu-yu"><span class="toc-number">1.2.2.</span> <span class="toc-text">几个专业术语</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#shu-ju-de-biao-shi-he-yun-suan"><span class="toc-number">2.</span> <span class="toc-text">数据的表示和运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mark-shu-zhi-yu-bian-ma-mark"><span class="toc-number">2.1.</span> <span class="toc-text">数制与编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jin-wei-ji-shu-zhi-ji-qi-xiang-hu-zhuan-huan"><span class="toc-number">2.1.1.</span> <span class="toc-text">进位计数制及其相互转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ding-dian-shu-de-bian-ma-biao-shi"><span class="toc-number">2.1.2.</span> <span class="toc-text">定点数的编码表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yun-suan-fang-fa-he-yun-suan-dian-lu"><span class="toc-number">2.2.</span> <span class="toc-text">运算方法和运算电路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ji-ben-yun-suan-bu-jian"><span class="toc-number">2.2.1.</span> <span class="toc-text">基本运算部件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ding-dian-shu-de-yun-suan"><span class="toc-number">2.2.2.</span> <span class="toc-text">定点数的运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-yu-yan-xiang-guan"><span class="toc-number">2.3.</span> <span class="toc-text">c 语言相关</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cun-chu-xi-tong"><span class="toc-number">3.</span> <span class="toc-text">存储系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cun-chu-qi-gai-shu"><span class="toc-number">3.1.</span> <span class="toc-text">存储器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cun-chu-qi-de-fen-lei"><span class="toc-number">3.1.1.</span> <span class="toc-text">存储器的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cun-chu-qi-de-xing-neng-zhi-biao"><span class="toc-number">3.1.2.</span> <span class="toc-text">存储器的性能指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#duo-ceng-ci-de-cun-chu-xi-tong"><span class="toc-number">3.1.3.</span> <span class="toc-text">多层次的存储系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zhu-cun-chu-qi-mm"><span class="toc-number">3.2.</span> <span class="toc-text">主存储器(MM)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sram-he-dram"><span class="toc-number">3.2.1.</span> <span class="toc-text">SRAM 和 DRAM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zhi-du-cun-chu-qi"><span class="toc-number">3.2.2.</span> <span class="toc-text">只读存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#duo-mo-kuai-cun-chu-qi"><span class="toc-number">3.2.3.</span> <span class="toc-text">多模块存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zhu-cun-chu-qi-yu-cpu-de-lian-jie"><span class="toc-number">3.2.4.</span> <span class="toc-text">主存储器与 CPU 的连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wai-bu-cun-chu-qi"><span class="toc-number">3.3.</span> <span class="toc-text">外部存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ci-pan-cun-chu-qi"><span class="toc-number">3.3.1.</span> <span class="toc-text">磁盘存储器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gao-su-huan-chong-chu-cun-qi"><span class="toc-number">3.4.</span> <span class="toc-text">高速缓冲储存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cache-de-ji-ben-gong-zuo-yuan-li"><span class="toc-number">3.4.1.</span> <span class="toc-text">Cache 的基本工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache-he-zhu-cun-de-ying-she-fang-shi"><span class="toc-number">3.4.2.</span> <span class="toc-text">Cache 和主存的映射方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache-zhong-zhu-cun-kuai-de-ti-huan-suan-fa"><span class="toc-number">3.4.3.</span> <span class="toc-text">Cache 中主存块的替换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache-xie-ce-lue"><span class="toc-number">3.4.4.</span> <span class="toc-text">Cache 写策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xu-ni-cun-chu-qi"><span class="toc-number">3.5.</span> <span class="toc-text">虚拟存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ye-shi-xu-ni-cun-chu-qi"><span class="toc-number">3.5.1.</span> <span class="toc-text">页式虚拟存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ye-biao"><span class="toc-number">3.5.2.</span> <span class="toc-text">页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kuai-biao-tlb"><span class="toc-number">3.5.3.</span> <span class="toc-text">快表(TLB)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#duan-shi-xu-ni-cun-chu-qi"><span class="toc-number">3.5.4.</span> <span class="toc-text">段式虚拟存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#duan-ye-shi-xu-ni-cun-chu-qi"><span class="toc-number">3.5.5.</span> <span class="toc-text">段页式虚拟存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xu-ni-cun-chu-qi-yu-cache-de-bi-jiao"><span class="toc-number">3.5.6.</span> <span class="toc-text">虚拟存储器与 Cache 的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#zhi-ling-xi-tong"><span class="toc-number">4.</span> <span class="toc-text">指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#zhi-ling-de-ji-ben-xing-shi"><span class="toc-number">4.1.</span> <span class="toc-text">指令的基本形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zhi-ling-de-cao-zuo-lei-xing"><span class="toc-number">4.2.</span> <span class="toc-text">指令的操作类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zhi-ling-de-xun-zhi-fang-shi"><span class="toc-number">4.3.</span> <span class="toc-text">指令的寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#zhi-ling-xun-zhi"><span class="toc-number">4.3.1.</span> <span class="toc-text">指令寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shu-ju-xun-zhi"><span class="toc-number">4.3.2.</span> <span class="toc-text">数据寻址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cheng-xu-de-ji-qi-ji-dai-ma-biao-shi"><span class="toc-number">4.4.</span> <span class="toc-text">程序的机器级代码表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#chang-yong-hui-bian-zhi-ling-jie-shao"><span class="toc-number">4.4.1.</span> <span class="toc-text">常用汇编指令介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#guo-cheng-diao-yong-de-ji-qi-ji-biao-shi"><span class="toc-number">4.4.2.</span> <span class="toc-text">过程调用的机器级表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xuan-ze-yu-ju-de-ji-qi-ji-biao-shi"><span class="toc-number">4.4.3.</span> <span class="toc-text">选择语句的机器级表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cisc-he-risc-de-ji-ben-gai-nian"><span class="toc-number">4.5.</span> <span class="toc-text">CISC 和 RISC 的基本概念</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#zhong-yang-chu-li-qi"><span class="toc-number">5.</span> <span class="toc-text">中央处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu-de-gong-neng-he-ji-ben-jie-gou"><span class="toc-number">5.1.</span> <span class="toc-text">CPU 的功能和基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu-de-gong-neng"><span class="toc-number">5.1.1.</span> <span class="toc-text">CPU 的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu-de-ji-ben-jie-gou"><span class="toc-number">5.1.2.</span> <span class="toc-text">CPU 的基本结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zhi-ling-de-guo-cheng"><span class="toc-number">5.2.</span> <span class="toc-text">指令的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#zhi-ling-zhou-qi"><span class="toc-number">5.2.1.</span> <span class="toc-text">指令周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zhi-ling-zhou-qi-de-shu-ju-liu"><span class="toc-number">5.2.2.</span> <span class="toc-text">指令周期的数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zhi-ling-zhi-xing-fang-an"><span class="toc-number">5.2.3.</span> <span class="toc-text">指令执行方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shu-ju-tong-lu-de-gong-neng-he-ji-ben-jie-gou"><span class="toc-number">5.3.</span> <span class="toc-text">数据通路的功能和基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shu-ju-tong-lu-de-gong-neng"><span class="toc-number">5.3.1.</span> <span class="toc-text">数据通路的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shu-ju-tong-lu-de-ji-ben-jie-gou"><span class="toc-number">5.3.2.</span> <span class="toc-text">数据通路的基本结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kong-zhi-qi-de-gong-neng-he-gong-zuo-yuan-li"><span class="toc-number">5.4.</span> <span class="toc-text">控制器的功能和工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kong-zhi-qi-de-jie-gou-he-gong-neng"><span class="toc-number">5.4.1.</span> <span class="toc-text">控制器的结构和功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ying-bu-xian-kong-zhi-qi"><span class="toc-number">5.4.2.</span> <span class="toc-text">硬布线控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wei-cheng-xu-kong-zhi-qi"><span class="toc-number">5.4.3.</span> <span class="toc-text">微程序控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ying-bu-xian-kong-zhi-qi-he-wei-cheng-xu-kong-zhi-qi-de-bi-jiao"><span class="toc-number">5.4.4.</span> <span class="toc-text">硬布线控制器和微程序控制器的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zhi-ling-liu-shui-xian"><span class="toc-number">5.5.</span> <span class="toc-text">指令流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#zhi-ling-liu-shui-de-ding-yi"><span class="toc-number">5.5.1.</span> <span class="toc-text">指令流水的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#liu-shui-xian-de-biao-shi-fang-fa"><span class="toc-number">5.5.2.</span> <span class="toc-text">流水线的表示方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#liu-shui-xian-fang-shi-de-te-dian"><span class="toc-number">5.5.3.</span> <span class="toc-text">流水线方式的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#liu-shui-xian-de-fen-lei"><span class="toc-number">5.5.4.</span> <span class="toc-text">流水线的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mark-liu-shui-xian-de-xing-neng-zhi-biao-mark"><span class="toc-number">5.5.5.</span> <span class="toc-text">流水线的性能指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mark-wu-duan-shi-zhi-ling-liu-shui-xian-mark"><span class="toc-number">5.5.6.</span> <span class="toc-text">五段式指令流水线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gao-ji-liu-shui-ji-zhu"><span class="toc-number">5.5.7.</span> <span class="toc-text">高级流水技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#duo-chu-li-qi-de-ji-ben-gai-nian"><span class="toc-number">5.6.</span> <span class="toc-text">多处理器的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sisd-simd-mimd"><span class="toc-number">5.6.1.</span> <span class="toc-text">SISD、SIMD、MIMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ying-jian-duo-xian-cheng-de-ji-ben-gai-nian"><span class="toc-number">5.6.2.</span> <span class="toc-text">硬件多线程的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#duo-he-chu-li-qi-de-ji-ben-gai-nian"><span class="toc-number">5.6.3.</span> <span class="toc-text">多核处理器的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gong-xiang-nei-cun-duo-chu-li-qi-de-ji-ben-gai-nian"><span class="toc-number">5.6.4.</span> <span class="toc-text">共享内存多处理器的基本概念</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#zong-xian"><span class="toc-number">6.</span> <span class="toc-text">总线</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#zong-xian-gai-shu"><span class="toc-number">6.1.</span> <span class="toc-text">总线概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#zong-xian-ji-ben-gai-nian"><span class="toc-number">6.1.1.</span> <span class="toc-text">总线基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zong-xian-de-fen-lei"><span class="toc-number">6.1.2.</span> <span class="toc-text">总线的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xi-tong-zong-xian-de-jie-gou"><span class="toc-number">6.1.3.</span> <span class="toc-text">系统总线的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mark-zong-xian-de-xing-neng-zhi-biao-mark"><span class="toc-number">6.1.4.</span> <span class="toc-text">总线的性能指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zong-xian-zhong-cai"><span class="toc-number">6.1.5.</span> <span class="toc-text">*总线仲裁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chang-jian-de-zong-xian-biao-zhun"><span class="toc-number">6.1.6.</span> <span class="toc-text">常见的总线标准</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zong-xian-shi-wu-he-ding-shi"><span class="toc-number">6.2.</span> <span class="toc-text">总线事务和定时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#zong-xian-shi-wu"><span class="toc-number">6.2.1.</span> <span class="toc-text">总线事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tong-bu-ding-shi-fang-shi"><span class="toc-number">6.2.2.</span> <span class="toc-text">同步定时方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yi-bu-ding-shi-fang-shi"><span class="toc-number">6.2.3.</span> <span class="toc-text">异步定时方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#shu-ru-shu-chu-xi-tong"><span class="toc-number">7.</span> <span class="toc-text">输入输出系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#i-o-xi-tong-ji-ben-gai-nian"><span class="toc-number">7.1.</span> <span class="toc-text">*I&#x2F;O 系统基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shu-ru-shu-chu-xi-tong-1"><span class="toc-number">7.1.1.</span> <span class="toc-text">输入&#x2F;输出系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-o-kong-zhi-fang-shi"><span class="toc-number">7.1.2.</span> <span class="toc-text">I&#x2F;O 控制方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wai-bu-she-bei"><span class="toc-number">7.1.3.</span> <span class="toc-text">外部设备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#i-o-jie-kou"><span class="toc-number">7.2.</span> <span class="toc-text">I&#x2F;O 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#i-o-jie-kou-de-gong-neng"><span class="toc-number">7.2.1.</span> <span class="toc-text">I&#x2F;O 接口的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-o-jie-kou-de-ji-ben-jie-gou"><span class="toc-number">7.2.2.</span> <span class="toc-text">I&#x2F;O 接口的基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-o-jie-kou-de-lei-xing"><span class="toc-number">7.2.3.</span> <span class="toc-text">I&#x2F;O 接口的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-o-duan-kou-ji-qi-bian-zhi"><span class="toc-number">7.2.4.</span> <span class="toc-text">I&#x2F;O 端口及其编址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#i-o-fang-shi"><span class="toc-number">7.3.</span> <span class="toc-text">I&#x2F;O 方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cheng-xu-cha-xun-fang-shi"><span class="toc-number">7.3.1.</span> <span class="toc-text">程序查询方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mark-cheng-xu-zhong-duan-fang-shi-mark"><span class="toc-number">7.3.2.</span> <span class="toc-text">程序中断方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dma-fang-shi"><span class="toc-number">7.3.3.</span> <span class="toc-text">DMA 方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zong-jie"><span class="toc-number">7.4.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu-xiang-ying-zhong-duan-ying-ju-bei-na-xie-tiao-jian"><span class="toc-number">7.4.1.</span> <span class="toc-text">CPU 响应中断应具备哪些条件?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zhong-duan-xiang-ying-you-xian-ji-he-zhong-duan-chu-li-you-xian-ji-fen-bie-zhi-shi-yao"><span class="toc-number">7.4.2.</span> <span class="toc-text">中断响应优先级和中断处理优先级分别指什么?</span></a></li></ol></li></ol></li></ol>
                </div>
            </div>
            
            
        </div>
    </div>
</div>

    </div>
</div>
    <div id="back-to-top" class="animated fadeIn faster">
        <div class="flow"></div>
        <span class="percentage animated fadeIn faster">0%</span>
        <span class="iconfont icon-top02 animated fadeIn faster"></span>
    </div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2023
        <span class="gradient-text">
            ND_LJQ
        </span>.
        Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
        Theme
        <span class="gradient-text">
            <a href="https://github.com/TriDiamond/hexo-theme-obsidian" title="Obsidian" target="_blank" rel="noopener">Obsidian</a>
        </span>
        <small><a href="https://github.com/TriDiamond/hexo-theme-obsidian/blob/master/CHANGELOG.md" title="v1.4.9.3" target="_blank" rel="noopener">v1.4.9.3</a></small>
        
        </br>
        
        <span class="gradient-text">
            <a href="https://beian.miit.gov.cn/" title="beian.miit.gov.cn" target="_blank" rel="noopener">beian.miit.gov.cn</a>
        </span>
        
        
        </br>
        <span style="display: inline-block;"> <img src=/null></span>
        
        <span class="gradient-text">
            <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44010602009049" title="www.beian.gov.cn&#x2F;portal&#x2F;registerSystemInfo?recordcode&#x3D;44010602009049" target="_blank" rel="noopener">www.beian.gov.cn&#x2F;portal&#x2F;registerSystemInfo?recordcode&#x3D;44010602009049</a>
        </span>
        
    </p>
</footer>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX", "TeX"],
      linebreaks: {
        automatic: true
      },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"]
      ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      noUndefined: {
        attributes: {
          mathcolor: "red",
          mathbackground: "#FFEEEE",
          mathsize: "90%"
        }
      },
      Macros: {
        href: "{}"
      }
    },
    messageStyle: "none"
  });
</script>
<script>
  function initialMathJax() {
    MathJax.Hub.Queue(function () {
      var all = MathJax.Hub.getAllJax(),
        i;
      // console.log(all);
      for (i = 0; i < all.length; i += 1) {
        console.log(all[i].SourceElement().parentNode)
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  }

  function reprocessMathJax() {
    if (typeof MathJax !== 'undefined') {
      MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }
</script>


 
<link rel="stylesheet" href="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.css">
 
<script src="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.js"></script>
  
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>
 
<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>
 
<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>
 
<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>
 
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/sql/sql.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/java/java.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/c/c.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/html/html.min.js"></script>
   
<script src="/js/busuanzi.min.js"></script>

<script>
  $(document).ready(function () {
    if ($('span[id^="busuanzi_"]').length) {
      initialBusuanzi();
    }
  });
</script>
 
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
  

<script>
  function initialTyped() {
    var typedTextEl = $('.typed-text');
    if (typedTextEl && typedTextEl.length > 0) {
      var typed = new Typed('.typed-text', {
        strings: ['Think like an artist, develop like an artisan', '艺术家思维去思考问题，工匠创造精神去开发'],
        typeSpeed: 90,
        loop: true,
        loopCount: Infinity,
        backSpeed: 20,
      });
    }
  }

  if ($('.article-header') && $('.article-header').length) {
    $(document).ready(function () {
      initialTyped();
    });
  }
</script>




<!-- 引用依赖 -->
<script>document.write(aplayerconf)</script>




</html>
