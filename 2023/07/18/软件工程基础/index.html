
<!DOCTYPE html>
<html lang="cn" class="loading">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
      name="viewport"
      content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>软件工程基础 - 刘三刀的blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="google" content="notranslate" />
    
    <meta name="keywords" content="刘三刀的blog," />
     
    <meta name="description" content="软件工程软件工程的概念和思想何为软件工程1968年,北大西洋公约组织(NATO)科学委员会在西德召开的研讨会上着重讨论如何应对软件危机,会上人们首次提出&amp;quot;软件工程&amp;quot;概念,进而开启," />
     
    <meta name="author" content="ND_LJQ" />
     
    <link
      rel="alternative"
      href="atom.xml"
      title="刘三刀的blog"
      type="application/atom+xml"
    />
     
    <link rel="icon" href="/img/favicon.png" />
     
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">
 
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">
 
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">
 
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">
 
<link rel="stylesheet" href="/css/obsidian.css">
 
<link rel="stylesheet" href="/css/ball-atom.min.css">
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
 
    <link
      href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css"
      rel="stylesheet"
    />
    <script>
      var musiclist = '';
    </script>
    
<script src="/js/loadaplayer.js"></script>

    <!-- 引用依赖 -->
    
<link rel="stylesheet" href="/aplayer/dist/APlayer.min.css">
 
<script src="/aplayer/dist/APlayer.min.js"></script>
<script src="/js/Meting.min.js"></script>
 
  <meta name="generator" content="Hexo 6.3.0"></head>
</html>


<body class="loading">
    <div class="loader">
        <div class="la-ball-atom la-2x">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
    <span id="config-title" style="display:none">刘三刀的blog</span>
    <div id="loader"></div>
    <div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="/img/favicon.png" alt="" data-url="https://nd-ljq.github.io">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">软件工程基础</h3>
        <div class="social">
            <!--        <div class="like-icon">-->
            <!--            <a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
            <!--        </div>-->
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
            animation-delay: 600ms;
            animation-duration: 1.2s;
            background-image: 
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url('/img/cover.jpg') ">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                <a href="/categories/计算机基础"><b>「
                    </b>计算机基础<b> 」</b></a>
                
                July 18, 2023
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="软件工程基础" class="">软件工程基础</a>
            </h3>
            
            <p class="post-count animated fadeInDown">
                
                <span>
                    <b class="iconfont icon-text2"></b> <i>Words count</i>
                    27k
                </span>
                
                
                <span>
                    <b class="iconfont icon-timer__s"></b> <i>Reading time</i>
                    24 mins.
                </span>
                
                
                
                <span id="busuanzi_container_page_pv">
                    <b class="iconfont icon-read"></b> <i>Read count</i>
                    <span id="busuanzi_value_page_pv">0</span>
                </span>
                
            </p>
            
            
            <ul class="animated fadeInDown post-tags-list" itemprop="keywords"><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" rel="tag">软件工程</a></li></ul>
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s"></span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><h2 id="软件工程的概念和思想"><a href="#软件工程的概念和思想" class="headerlink" title="软件工程的概念和思想"></a>软件工程的概念和思想</h2><h3 id="何为软件工程"><a href="#何为软件工程" class="headerlink" title="何为软件工程"></a>何为软件工程</h3><pre><code class="lang-css">1968年,北大西洋公约组织(NATO)科学委员会在西德召开的研讨会上着重讨论如何应对软件危机,会上人们首次提出&quot;软件工程&quot;概念,进而开启了软件工程的研究与实践

根据IEEE给出的定义,软件工程是指:

①将系统的、规范的、可量化的方法应用于软件开发、运行和维护的过程

②以及以上方法的研究
</code></pre>
<p>这一概念定义给出了软件工程的两个方面的内涵,以是软件工程要提供系统的、规范的、可量化的方法来指导软件的开发、运行和维护,而是软件工程要研究方法本身</p>
<h3 id="软件工程的三要素"><a href="#软件工程的三要素" class="headerlink" title="软件工程的三要素"></a>软件工程的三要素</h3><p>软件工程的三方面的核心要素是:==过程==、==方法学==和==工具==</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>该要素主要是从管理的视角,回答软件开发、运行和维护需要做哪些工作、如何管理好这些工作等问题,关注软件项目的规范化组织和可量化实施</p>
<p>至今,软件工程已提出了诸多软件开发过程模型,包括<code>瀑布模型</code>、<code>增量模型</code>、<code>原型模型</code>、<code>迭代模型</code>、<code>螺旋模型</code>。每一种模型都反映了软件开发的不同理解和认识,进而采用不同的过程。此外,软件工程还提供了一组开发方法,如<code>敏捷方法(agile method)</code>、<code>群体化开发方法(crowd-based development)</code>、<code>DevOps方法</code>等。他们为软件开发过程中的开发和维护活动、软件制品的交付方式、软件开发人员的组织和协同等提供指导思想、原则和策略</p>
<h4 id="方法学"><a href="#方法学" class="headerlink" title="方法学"></a>方法学</h4><pre><code class="lang-css">该要素主要是从技术的视角,回答软件开发、运行和维护如何做的问题。方法学旨在为软件开发过程中的各项开发和维护活动提供系统、规范的技术支持,包括:如何理解和认识软件模型,如何用不同抽象层次的模型描述不同开发活动所产生的软件制品,采用什么样的建模语言描述软件模型,提供什么样的编程语言实现软件模型,提供什么样的策略和原则指导各项活动的开展,如何确保开发活动、维护活动和软件制品的质量等。至今,软件工程已提出诸多人软件开发方法学,如`结构化软件开发方法学`、`面向对象软件开发方法学`、`基于构件的软件开发方法学`、`面向主体的软件开发方法学`。
</code></pre>
<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>该要素主要是从工具辅助的视角,回答如何借助工具来辅助软件开发、运行和维护的问题</p>
<h3 id="软件工程的目标"><a href="#软件工程的目标" class="headerlink" title="软件工程的目标"></a>软件工程的目标</h3><p>软件工程的整体目标是在成本、进度、资源等约束下,帮助软件开发人员开发出满足用户要求的足够好的软件系统。软件开发、运行和维护是一项极为复杂的工作,涉及多方的利益相关者,包括客户、用户、开发者、维护者、管理者等,他们会从各自的角度提出各自的诉求。软件工程就是要站在这些利益相关者的角度实现以下目标:</p>
<p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/image-20230617101440688.png" alt="image-20230617101440688"></p>
<ol>
<li>指导开发、运行和维护</li>
<li>满足工程约束</li>
<li><p>确保软件质量</p>
<pre><code class="lang-css">对软件客户、用户而言,所谓的足够好是指软件具有正确性、友好性、可靠性、易用性等特点;而对于软件开发者、维护者、管理者而言,所谓的足够好是指软件具有可维护性、可理解性、可重用性,互操作性等
</code></pre>
</li>
</ol>
<h3 id="软件工程的原则"><a href="#软件工程的原则" class="headerlink" title="软件工程的原则"></a>软件工程的原则</h3><ol>
<li>抽象和建模</li>
<li>模块化</li>
<li>软件重用</li>
<li>信息隐藏</li>
<li>关注点分离</li>
<li>分治</li>
<li>双向追踪</li>
<li>工具辅助</li>
</ol>
<h2 id="开源软件"><a href="#开源软件" class="headerlink" title="开源软件"></a>开源软件</h2><h3 id="何为开源软件"><a href="#何为开源软件" class="headerlink" title="何为开源软件"></a>何为开源软件</h3><p>开源软件是一种源代码可以自由获取和传播的计算机软件,其拥有者通过开源许可证赋予被许可人对软件进行使用、修改和传播的权利。开源软件采用群体化的思想和理念,代表了一种新的软件开发方法</p>
<h3 id="开源软件实践"><a href="#开源软件实践" class="headerlink" title="开源软件实践"></a>开源软件实践</h3><p>第一次重大变化发生在新闻组出现之后。</p>
<p>第二次重大变化是发生在万维网技术出现之后。许多开源软件分别建立了各自独立的开发社区,如 Linux、Apache、Eclipse 以及 Mozilla 等</p>
<p>第三次变化以 SourceForge 平台上线为标志。它极大的降低了开源软件开发者的参与门槛,使软件开源开发从面向技术精英逐步扩展到所有感兴趣的开发者,极大的激励发了广大软件开发者参与开源实践的创作激情</p>
<p>第四次变化以 GitHub、Stack Overflow 等独立功能平台上线为标志。2008 年 GitHub 开始投入运营,以托管软件开源项目、辅助群体化的分布式协同开发。同年 Stack Overflow 投入运营以支持开发者群体交流和分享软件开发知识,如讨论开发问题,交流开发经验等</p>
<h4 id="政府组织"><a href="#政府组织" class="headerlink" title="政府组织"></a>政府组织</h4><h4 id="开源组织"><a href="#开源组织" class="headerlink" title="开源组织"></a>开源组织</h4><p>①Apache 基金会。该组织成立于 1999 年</p>
<p>②Linux 基金会。该组织成立于 2007 年</p>
<p>③Eclipse 基金会。该组织成立于 2004 年</p>
<p>④Open Source Initiative。该组织成立于 1998 年</p>
<p>⑤ 开放原子开源基金会。该组织与 2020 年 6 月在我国登记注册</p>
<h4 id="企业开发者"><a href="#企业开发者" class="headerlink" title="企业开发者"></a>企业开发者</h4><h4 id="个人开发者"><a href="#个人开发者" class="headerlink" title="个人开发者"></a>个人开发者</h4><h3 id="开源软件的优势"><a href="#开源软件的优势" class="headerlink" title="开源软件的优势"></a>开源软件的优势</h3><ol>
<li>采购和开发成本更低</li>
<li>软件质量更高、更安全</li>
<li>软件研制和交付更快</li>
<li>软件功能更全面,更具创新性</li>
</ol>
<h3 id="开源许可证"><a href="#开源许可证" class="headerlink" title="开源许可证"></a>开源许可证</h3><h4 id="宽松式开源许可证"><a href="#宽松式开源许可证" class="headerlink" title="宽松式开源许可证"></a>宽松式开源许可证</h4><p>特点:代码使用没有任何限制,用户自己承担代码质量的风险,用户使用开源软件时必须披露原作者。BSD、Apache、MIT 等都属于这一类许可证</p>
<h4 id="Copyleft-开源许可证"><a href="#Copyleft-开源许可证" class="headerlink" title="Copyleft 开源许可证"></a>Copyleft 开源许可证</h4><p>指可不经允许随意复制,特点有许多,如分发二进制代码时必须提供源代码,修改后所产生的开源软件须与修改前全检保持一致的许可证,不得在原始许可证以外附加其他限制等。GPL、MPL 等属于这一类许可证。</p>
<p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/59CD530235A02AB899E6562117DD5A55.jpg" alt="img"></p>
<h3 id="开源软件的利用"><a href="#开源软件的利用" class="headerlink" title="开源软件的利用"></a>开源软件的利用</h3><ol>
<li>学习开源软件</li>
<li>参与开源建设,掌握开源技术,理解开源文化</li>
<li>重用开源代码</li>
</ol>
<h2 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h2><h3 id="代表性的软件过程模型"><a href="#代表性的软件过程模型" class="headerlink" title="代表性的软件过程模型"></a>代表性的软件过程模型</h3><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><pre><code class="lang-css">瀑布模型将软件开发过程分为若干步骤和活动,包括`需求分析`、`软件设计`、`编码实现`、`软件测试`和`运行维护`。这些步骤严格按照先后次序和逻辑关系来组织,每个阶段的末尾需要对该阶段产生的软件制品(文档、模型和代码等)进行评审,以发现和纠正软件制品中的问题和缺陷,以防有问题的软件制品进入下一步骤。

该模型适合那些需求易于定义、不易变动的软件系统的开发
</code></pre>
<p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/F38AC7974AC4D5E8ACAFDC9B399FD9F3.jpg" alt="img"></p>
<p>瀑布模型及其改进模型还有一个不足,,软件开发人员要等后期阶段才能产生可运行的软件系统,此时用户才可以接触和使用可运行软件,了解软件的功能和行为,发现软件中存在的质量问题,如果用户界面不太友好,实现功能与需求不太一致,反应速度太慢等如果此时用提出软件改进要求将会对软件开发和管理带来很大的冲击</p>
<h4 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h4><pre><code class="lang-css">在日常生活和工作中,人们经常会构造一些系统的原型,以便为用户直观地展示所关心的内容。所谓原型,是指产品开发前期所产生的产品雏形或仿真产品。相较于实际产品,原型具有可直观展示产品的特性、贴近业务应用、能自然地反映产品需求等特点。

基于原型的上述特点,人们将原型思想引入软件工程领域,在软件开发早期(通常在需求分析阶段)根据用户的初步需求构件软件原型并将其交给用户使用,获得用户的评价和反馈,帮助用户导出软件需求、发现开发人员与用户之间的需求认识偏差,进而有效地支持软件需求分析。这一过程即为原型模型
</code></pre>
<p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/9C3256091F06026626DA6C4DBA12D019-1686982122509-4.jpg" alt="9C3256091F06026626DA6C4DBA12D019"></p>
<p>原型模型适合于那些软件需求难以导出、不易确定且持续变动的软件系统。由于软件原型的修改和完善,需要多次和迭代进行,这一开发模型给软件项目的管理带来了一定的困难</p>
<h4 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h4><pre><code class="lang-css">瀑布模型要等到软件开发后期才能给用户提供可运行的软件系统,这一点往往不利于用户使用。此外,滞后的软件交付和使用必然会导致软件缺陷和问题的滞后发现,加大软件开发的成本和工作量,影响软件质量,出现这一状况的根本原因在于,获取软件需求后瀑布模型要求一次性实现所有软件需求,这势必导致软件设计和实现的工作量大,开发周期长,使软件交付延后

针对这一问题,增量模型做了适当的改进骂他不在要求软件开发人员一次性实现所有的软件需求,而是在软件需求和总体设计确定好后,采用增量开发的模式渐进式地实现软件系统的所有功能

**增量模型的一个显著的优点是允许软件开发人员平行地开发软件、实现软件系统的各个独立模块,从而提高软件开发效率,加快交付目标软件系统的进度**
</code></pre>
<p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/image-20230617142624260.png" alt="image-20230617142624260"></p>
<h4 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h4><p>不要求一次性地开发出完整的软件系统，将软件<br>开发视为一个逐步获取用广需求、完善软件产品的过程</p>
<p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/image-20230617142824216.png" alt="image-20230617142824216"></p>
<p>适用于需求难以确定、不断变更的软件系统</p>
<p><strong>增量模型和迭代模型的区别与联系</strong>：</p>
<p>增量通常和迭代混为一谈，但是其实两者是有区别的。</p>
<p>增量是逐块建造的概念，例如画一幅人物画，我们可以先画 人的头部，再画身体，再画手脚……</p>
<p>迭代是反复求精的概念，同样是画人物画，我们可以采用先画整体轮廓，再勾勒出基本雏形，再细化、着色。</p>
<h4 id="基于构件的过程模型"><a href="#基于构件的过程模型" class="headerlink" title="基于构件的过程模型"></a>基于构件的过程模型</h4><p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/E8074AF44E51A4F22B798D09B08563DA.jpg" alt="img"></p>
<h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/1AA63863052625C5CD6AA7FCAF0B6780.jpg" alt="img"></p>
<h4 id="UP-模型"><a href="#UP-模型" class="headerlink" title="UP 模型"></a>UP 模型</h4><p>UP 模型是一种用例驱动、以体系结构为核心、借助 UML 语言的迭代式软件过程模型</p>
<p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/image-20230617144930654.png" alt="image-20230617144930654"></p>
<p>在 UP 模型中同一个工作流在不同阶段任务强度是不一样的</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模型名称</th>
<th>指导思想</th>
<th>关注点</th>
<th>适用软件</th>
<th>管理难度</th>
</tr>
</thead>
<tbody>
<tr>
<td>瀑布模型</td>
<td>为软件开发提供系统性的指导</td>
<td>与软甲生存周期相一致的软件开发过程</td>
<td>需求变动不大、较为明确、可预先定义的应用</td>
<td>易</td>
</tr>
<tr>
<td>原型模型</td>
<td>以原型为媒介指导用户的需求导出和评价</td>
<td>需求获取、导出和确认</td>
<td>需求难以表述清楚、不易导出和获取的应用</td>
<td>易</td>
</tr>
<tr>
<td>增量模型</td>
<td>快速交付和并行开发软件系统</td>
<td>软件详细设计、编码和测试的增量完成</td>
<td>需求变动不大、较为明确、可预先定义的应用</td>
<td>易</td>
</tr>
<tr>
<td>迭代模型</td>
<td>多次迭代，每次仅针对部分明确的软件需求</td>
<td>分多次迭代来开发软件,每次仅关注部分需求</td>
<td>软件需求变动大,难以一次说清楚的应用</td>
<td>中等</td>
</tr>
<tr>
<td>基于构件的过程模型</td>
<td>基于和构建重用来开发软件</td>
<td>构件的搜索、选择、构件和组装</td>
<td>需求明确,具有丰富构件库的应用</td>
<td>中等</td>
</tr>
<tr>
<td>螺旋模型</td>
<td>集成迭代模型和原型模型，引入风险分析等管理活动</td>
<td>软件计划制定和实施，软件风险管理,基于原型的迭代式开发</td>
<td>开发风险大,需求难以明确的应用</td>
<td>难</td>
</tr>
<tr>
<td>UP 模型</td>
<td>集成迭代过程模型和面向对象最佳实践</td>
<td>参考最佳实践，借助面向对象最佳实践来指导迭代开发</td>
<td>软件需求不明确且经常变化的应用</td>
<td>难</td>
</tr>
</tbody>
</table>
</div>
<h2 id="软件开发方法"><a href="#软件开发方法" class="headerlink" title="软件开发方法"></a>软件开发方法</h2><h3 id="敏捷方法"><a href="#敏捷方法" class="headerlink" title="敏捷方法"></a>敏捷方法</h3><h4 id="何为敏捷方法"><a href="#何为敏捷方法" class="headerlink" title="何为敏捷方法"></a>何为敏捷方法</h4><p>敏捷方法时一类软件开发方法的总称,他们主张软件开发要以代码为中心,快速,轻巧和主动应对需求变化,持续、及时交付可运行的软件系统</p>
<h4 id="敏捷开发的理念和价值观"><a href="#敏捷开发的理念和价值观" class="headerlink" title="敏捷开发的理念和价值观"></a>敏捷开发的理念和价值观</h4><p>① 较之于过程和工具,应更加重视人和交互的价值。</p>
<p>② 较之于面面俱到的文档,应更加重视可运行软件的价值</p>
<p>③ 较之于合同谈判,应更加重视用户合作的价值</p>
<p>④ 较之于遵循计划,应更加重视响应用户需求的变化的价值</p>
<p>概括起来敏捷方法具有以下特点:</p>
<p>① 更加重视可运行软件系统,即代码,弱化软件文档,以可运行软件系统为中心来开展软件开发</p>
<p>② 以适应变化为目的来推进软件开发,鼓励和支持软件需求的变化,针对变化不断优化和调整软件卡法计划,及时交付软件产品</p>
<p>③ 软件开发要以人为本,敏捷软件开发是面向人的而不是面向过程的,让方法、技术、工具、过程等来适应人,而不是让人来适应它们</p>
<h4 id="敏捷方法的实施原则"><a href="#敏捷方法的实施原则" class="headerlink" title="敏捷方法的实施原则"></a>敏捷方法的实施原则</h4><p><strong>12 条敏捷开发原则</strong></p>
<p>① 尽早和持续地交付有价值的软件,以确保客户满意度</p>
<p>② 支持客户需求变化,即使到了软件开发后期</p>
<p>③ 每隔几周或一两个月就须向客户交付可运行软件,交付周期宜短不宜长</p>
<p>④ 在软件开发全过程,业务人员和开发人员须每天在一起工作</p>
<p>⑤ 由积极主动的人来承担项目开发,支持和信任他们并提供所需的环境</p>
<p>⑥ 面对面交谈是团队内部最有效和高效的传递方式</p>
<p>⑦ 交付可运行软件你作为衡量开发进度的首要衡量标准</p>
<p>⑧ 项目负责人、开发方和用户方应保持长期、稳定和可持续的开发速度</p>
<p>⑨ 追求卓越的开发技术和良好的软件设计,增强团队和个体的敏捷能力</p>
<p>⑩ 在保证质量的前提下采用简单的方法来完成开发任务</p>
<p>⑪ 组建自组织的开发团队,以出色地完成软件架构、需求和设计等工作</p>
<p>⑫ 团队应反思如何提高工作效率,并以此调整个体和团队的行为</p>
<h4 id="支持敏捷方法的开发技术和管理手段"><a href="#支持敏捷方法的开发技术和管理手段" class="headerlink" title="支持敏捷方法的开发技术和管理手段"></a>支持敏捷方法的开发技术和管理手段</h4><p>从管理的角度来看,敏捷开发方法的应用对软件项目管理提出以下一组要求:</p>
<p>① 管理软件需求,支持需求的变化和跟踪</p>
<p>② 选择和构件合适的软件开发过程,支持迭代式软件开发和持续性软件交付</p>
<p>③ 管理开发团队,加强开发人员之间、开发人员与用户之间的交流、沟通和反馈</p>
<p>④ 开发人员和用户一起参与项目计划的制定和实施</p>
<p>⑤ 加强跟踪和监督,及时化解软件风险</p>
<h4 id="极限编程"><a href="#极限编程" class="headerlink" title="极限编程"></a>极限编程</h4><p>极限编程是由 Kent Beck 提出的一种特殊的敏捷方法,与敏捷方法相比较,极限编程的核心理念和价值观更为具体明确:</p>
<p>① 交流。交流对于软件开发非常重要,鼓励基于口头、直接和平等的交流</p>
<p>② 反馈。从团队内外获得持续和明确的反馈,获得软件及其开发状态,它对软件项目的成功实施至关重要</p>
<p>③ 简单。用尽可能简单的过程和技术来指导开发、解决开发问题</p>
<p>④ 勇气。勇于制定个体决策、快速开发,并在必要时具有重新开发的信心</p>
<p>在上述价值观和理念的基础上极限编程制定了一组更具体,更易于操作的实施原则,以指导其应用:</p>
<p>① 计划游戏。计划游戏旨在帮助开发团队快速制定下次迭代的软件开发计划</p>
<p>② 隐喻。简单而言,隐喻是指用业务相关的术语来描述和交流软件需求促使软件开发人员和业务人员就软件需求达成共同一致的理解</p>
<p>③ 小型发布。经常给用户发布可运行的软件系统,每次发布的软件仅增加少量的功能</p>
<p>④ 简单设计。所谓的简单设计是指保持软件设计方案的简单性,不添加任何不必要的设计元素。</p>
<p>⑤ 测试驱动开发。采用测试驱动的方法来开发软件和测试程序</p>
<p>⑥ 重构。重构是指在不改变程序代码功能的前提下,改进代码设计和结构,使程序代码具有更高的质量,如更加简单、易于拓展、更加健壮</p>
<p>⑦ 结对编程</p>
<p>⑧ 集体拥有代码。</p>
<p>⑨ 持续集成。新代码一旦经过验证后就可集成到整个软件系统之中,代码集成应经常进行,周期尽可能短</p>
<p>⑩ 每周 40 小时工作日。</p>
<p>⑪ 现场用户。让用户和业务人员成为团队成员参与软件开发的全过程</p>
<p>⑫ 编码标准。依据行业或组织的编码标准来编写程序代码,力求代码遵循编码风格,具有良好的可读性、可理解性和可维护性</p>
<h4 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h4><h2 id="软件需求工程基础"><a href="#软件需求工程基础" class="headerlink" title="软件需求工程基础"></a>软件需求工程基础</h2><h3 id="面相对象的需求分析方法学"><a href="#面相对象的需求分析方法学" class="headerlink" title="面相对象的需求分析方法学"></a>面相对象的需求分析方法学</h3><h4 id="基本概念和思想"><a href="#基本概念和思想" class="headerlink" title="基本概念和思想"></a>基本概念和思想</h4><pre><code class="lang-css">面向对象的软件工程认为,无论是现实世界(应用问题)还是计算机世界(软件系统),他们都是由多样化的对象所构成的,每个对象都有其状态并可提供功能和服务,不同对象之间通过交互来开展协作、展示行为、实现功能和提供服务。

具体地,面向对象的需求分析方法学提供了以下一组的核心概念:
</code></pre>
<h5 id="对象-object"><a href="#对象-object" class="headerlink" title="对象(object)"></a>对象(object)</h5><pre><code class="lang-css">对象既可以表示现实世界中的个体、事物或者实体,也可以表示在计算机软件中的某个运行元素或单元(如运行实例)。每个对象都有其属性和方法,属性表示对象的性质,属性的值定义了对象的状态;方法表示对象所能提供的服务,它定义了对象的行为。对象的方法作用于对象的属性之上,使得属性的取值发生变化,导致对象状态发生变化
</code></pre>
<h5 id="类-class"><a href="#类-class" class="headerlink" title="类(class)"></a>类(class)</h5><p>顾名思义,类是一种分类和组织机制。它是对一组具有相同特征对象的抽象。通俗地将,通过类可以将不同的对象进行分类</p>
<h5 id="消息-message"><a href="#消息-message" class="headerlink" title="消息(message)"></a>消息(message)</h5><p>每个对象都不应是孤立的,他们之间需要进行交互以获得对方的服务,通过相互协作来共同解决问题。对象之间通过消息传递进行交互,消息传递是对象间的唯一通信方式,一个对象通过向另一个对象发送消息,从而请求相应的服务</p>
<h5 id="继承-inheritance"><a href="#继承-inheritance" class="headerlink" title="继承(inheritance)"></a>继承(inheritance)</h5><p>继承描述了类与类之间的一般与特殊关系,它本质上是对现实世界不同实体间遗传关系的一种直观表示,也是对计算机软件中不同类进行层次化组织的一种机制</p>
<h5 id="关联-association"><a href="#关联-association" class="headerlink" title="关联(association)"></a>关联(association)</h5><p>描述了类与类之间的关系,他有多种形式,如聚合、组合等</p>
<h5 id="多态-polymorphism"><a href="#多态-polymorphism" class="headerlink" title="多态(polymorphism)"></a>多态(polymorphism)</h5><p>多态是针对类的方法而言的,它是指同一个方法作用于不同的对象上可以有不同的解释,并产生不同的执行结果。</p>
<h5 id="覆盖-override"><a href="#覆盖-override" class="headerlink" title="覆盖(override)"></a>覆盖(override)</h5><p>一个子类可以通过继承来获得父类的属性和方法。当然子类也可以在自己的类中增加或者重新定义所继承的属性和方法,从而用新定义的属性和方法来覆盖所继承的来自父类的属性或方法</p>
<h5 id="重载-overload"><a href="#重载-overload" class="headerlink" title="重载(overload)"></a>重载(overload)</h5><p>一个类中允许有多个名称相同但是参数不同的方法,由于这些方法在具体的参数数目及类型上有所区别,因而系统将根据收到的消息的实参来引用不同的方法</p>
<h4 id="面相对象建模语言-UML"><a href="#面相对象建模语言-UML" class="headerlink" title="面相对象建模语言 UML"></a>面相对象建模语言 UML</h4><p>本质上 UML 是一种可视化的建模语言,它提供了图形化的语言机制,包括语法、语义和语用</p>
<p>以及相应的规则、约束和拓展机制。</p>
<p>UML 的主要视图</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">视点</th>
<th style="text-align:center">视图</th>
<th>建模内容</th>
<th>支持的开发阶段</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">结构</td>
<td style="text-align:center">包图</td>
<td>系统高层结构</td>
<td>需求分析、软件设计</td>
</tr>
<tr>
<td style="text-align:center">结构</td>
<td style="text-align:center">类图</td>
<td>系统类结构</td>
<td>需求分析、软件设计</td>
</tr>
<tr>
<td style="text-align:center">结构</td>
<td style="text-align:center">对象图</td>
<td>系统在特定时刻的对象结构</td>
<td>需求分析、软件设计</td>
</tr>
<tr>
<td style="text-align:center">结构</td>
<td style="text-align:center">构件图</td>
<td>系统构件组成</td>
<td>软件设计</td>
</tr>
<tr>
<td style="text-align:center">行为</td>
<td style="text-align:center">状态图</td>
<td>对象状态及其变化</td>
<td>需求分析、软件设计</td>
</tr>
<tr>
<td style="text-align:center">行为</td>
<td style="text-align:center">活动图</td>
<td>系统为完成某项功能而事实的操作</td>
<td>需求分析、软件设计</td>
</tr>
<tr>
<td style="text-align:center">行为</td>
<td style="text-align:center">交互图</td>
<td>系统中的对象间如何通过消息传递来实现系统功能</td>
<td>需求分析、软件设计</td>
</tr>
<tr>
<td style="text-align:center">部署</td>
<td style="text-align:center">部署图</td>
<td>软件系统制品及其运行环境</td>
<td>软件设计、部署和运行</td>
</tr>
<tr>
<td style="text-align:center">用例</td>
<td style="text-align:center">用例图</td>
<td>软件系统的功能</td>
<td>需求分析</td>
</tr>
</tbody>
</table>
</div>
<h2 id="软件设计基础"><a href="#软件设计基础" class="headerlink" title="软件设计基础"></a>软件设计基础</h2><h3 id="面向对象的软件设计方法学"><a href="#面向对象的软件设计方法学" class="headerlink" title="面向对象的软件设计方法学"></a>面向对象的软件设计方法学</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p><strong>面向对象的软件设计过程</strong></p>
<pre><code class="lang-css">面向对象的软件设计遵循先整体后局部,先抽象后具体的设计原则,借助模块化软件设计的基本思想和策略,先展开软件体系结构设计,明确软件系统的整体架构,在此基础上开展用户界面设计。上述两项设计完成后,将开展一系列详细设计工作,包括用例设计、构件/子系统设计、数据设计、类设计等,最终将这些设计进行整合,形成完整的软件设计方案
</code></pre>
<p><strong>面向对象的软件设计建模语言</strong></p>
<p>UML</p>
<h4 id="面向对象的软件设计原则"><a href="#面向对象的软件设计原则" class="headerlink" title="面向对象的软件设计原则"></a>面向对象的软件设计原则</h4><pre><code class="lang-css">面向对象的软件设计方法学提供了一组原则以指导软件设计,提高设计水平,产生高质量的软件设计模型
</code></pre>
<h5 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h5><pre><code class="lang-css">单一职责原则要求每个类值承担一项责任,也即类的职责要单一化,它充分体现了软件模块化设计的思想。该原则有助于控制类的粒度大小,提高类设计的模块化程度以及类的内聚性,降低类实现的规模和复杂性,减少类变更的因素和频率
</code></pre>
<h5 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h5><pre><code class="lang-css">开闭原则要求每个类对于扩展是开放的,对于修改时封闭的。所谓的&quot;拓展的开放性&quot;是指类的功能是可拓展的。

该设计原则有助于提高软件设计的灵活性、可重用性和可维护性。但是,该原则的应用也必然会给软件设计带来额外的抽象和设计成本
</code></pre>
<h5 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h5><pre><code class="lang-css">确保父类所拥有的性质在子类中仍成立,或者说,对于父类在软件中出现的所有地方,均可由子类进行替代,反之则不成立。这项原则是面向对象程序设计语言中继承机制的理论基础,也是遵循开闭原则的前提条件。

这一原则要求子类可以拓展父类功能,但不能改变父类原有功能。这就要求子类继承父类时除了添加新的方法完成新增功能外,尽量不要重写父类的方法。
</code></pre>
<h5 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h5><pre><code class="lang-css">基本思想是尽量将臃肿庞大的接口拆分成更小和更具体的接口,让接口中只包含使用者感兴趣的方法,即根据使用者的需要定义接口
</code></pre>
<h5 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h5><pre><code class="lang-css">基本思想是:高层模块不应该依赖底层模块,两者都应该其抽象;抽象不应该依赖细节,细节应该依赖抽象。这里的抽象是指面向对象设计中的接口或抽象类,他们均不能直接实例化,细节是指具体的类。因此,依赖倒置原则更为直接的描述为:高层的类不应该依赖底层的类,接口或抽象类不应该依赖具体的实现类,具体的实现类应依赖接口或抽象类。

该原则有助于降低变化带来的影响,同时该原则提高了高层模块的可重用性、可拓展性,减少了类之间的耦合度,是软件系统的稳定性得到提升,并提高了代码的可理解性和可维护性
</code></pre>
<h5 id="最少知识原则"><a href="#最少知识原则" class="headerlink" title="最少知识原则"></a>最少知识原则</h5><pre><code class="lang-css">基本思想:只与你的直接朋友交谈,不与陌生人说话。也即一个类只对与自己存在耦合关系的类进行狡猾,尽可能少的与其他不相关的类发生交互。这意味着一个类应该为与其发生交互关系的其他类提供最少的知识

最少知识原则有助于实现类间解耦,使每个类与其他类是弱耦合甚至无耦合,从而提高类的可重用性。但这势必会提高软件系统带来的复杂性,给软件维护带来难度
</code></pre>
<h4 id="面向对象的软件设计优势"><a href="#面向对象的软件设计优势" class="headerlink" title="面向对象的软件设计优势"></a>面向对象的软件设计优势</h4><ol>
<li>高层抽象和自然过渡</li>
<li>多种形式和粗粒度的软件重用</li>
<li>系统化的软件设计</li>
<li>支持软件的拓展和变更</li>
</ol>
<h2 id="软件体系结构设计"><a href="#软件体系结构设计" class="headerlink" title="软件体系结构设计"></a>软件体系结构设计</h2><h3 id="软件体系结构模型的表示方法"><a href="#软件体系结构模型的表示方法" class="headerlink" title="软件体系结构模型的表示方法"></a>软件体系结构模型的表示方法</h3><h4 id="包图"><a href="#包图" class="headerlink" title="包图"></a>包图</h4><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><h3 id="软件测试过程"><a href="#软件测试过程" class="headerlink" title="软件测试过程"></a>软件测试过程</h3><p>单元测试</p>
<p>集成测试</p>
<p>确认测试</p>
<p>系统测试</p>
<h3 id="软件测试技术"><a href="#软件测试技术" class="headerlink" title="软件测试技术"></a>软件测试技术</h3><h4 id="黑盒测试技术"><a href="#黑盒测试技术" class="headerlink" title="黑盒测试技术"></a>黑盒测试技术</h4><pre><code class="lang-css">该测试技术的前提是已知软件模块的功能,但是不知道该软件模块的内部实现细节(如其内部的控制流程和实现算法)这种情况下针对该软件模块设计和运行测试用例,测试软件模块的运行是否正常,测试软件模块的运行是否正常,能否满足用户的需求。通常,`集成测试`和`确认测试`大多采用黑盒测试技术,典型的黑盒测试技术包括`等价分类法`和`边界取值法`

软件测试不仅要进行功能测试,如单元测试、集成测试和确认测试等,而且还需要进行非功能测试,如压力测试、兼容性测试、可靠性测试、容量测试。

在软件测试的过程中,为了尽可能发现软件系统中潜在的缺陷和错误,软件测试应应对不同测试目的,遵循以下原则来设计测试用例。

①需求(功能)覆盖。确保软件系统的所有需求或功能都被测试用例覆盖到。某个测试用例覆盖了某项功能,是指该测试数据的输入导致被测试的对象运行了实现某项功能的程序代码

②模块覆盖。确保软件系统的所有程序模块(如过程、函数)都被测试用例覆盖到

③语句覆盖。确保软件系统的所有程序语句都被测试用例覆盖到。

④分支覆盖。程序中的控制结构(如 if语句或者while语句)通常具有多个不同的执行分支,分支覆盖是要确保待测试对象的所有分支都被测试用例覆盖到

⑤条件覆盖。程序中控制结构的逻辑表达式即可取TRUE,也可取FALSE。条件覆盖是要确保控制结构中逻辑表达式的所有取值都被测试到

⑥多条件覆盖。确保程序中所有控制结构的逻辑表达式中,每个子表达式取值的组合都被测试用例覆盖到

⑦条件/分支覆盖。该原则是由条件覆盖和分支覆盖组合而成

⑧路径覆盖。程序模块中的一条路径是指从入口语句(该模块的第一条执行语句)到出口语句(该模块的最后一条语句,如return语句)的语句序列。路径覆盖是要确保模块中的每一天路径都被测试用例覆盖到

⑨基本路径覆盖。基本路径是指至少引入一个新语句或者新判断的路径。基本路径覆盖是要确保模块中的每一条基本路径都被测试用例覆盖到。
</code></pre>
<h4 id="白盒测试技术"><a href="#白盒测试技术" class="headerlink" title="白盒测试技术"></a>白盒测试技术</h4><p>白盒测试的前提是已知程序的内部控制结构,以此作为依据来设计软件测试用例下面基本路径测试技术来介绍白盒测试技术</p>
<pre><code class="lang-c">void Func(int nPosX, int nPosY)&#123;
    while(nPosX &gt; 0)&#123;
        int nSum = nPosX + nPosY;
        if(nSum &gt; 1)&#123;
            nPosX--;
            nPosY--;
        &#125;else&#123;
            if(nSum &lt; -1)&#123;
                nPosX -= 2;
            &#125;else&#123;
                nPosX -= 4;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>1.根据模块详细设计绘出模块的流程图</p>
<p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/流程图.svg" alt="流程图"></p>
<p>2.将流程图转换为流图</p>
<pre><code>①增加控制结构,将流程图中的结合点转换为流图中的一个节点。所谓的结合点是指条件语句的汇聚点。如上图中的9号和10号位置就是结合点

②讲流程图中的过程块合并为流图中的一个节点。所谓&quot;过程块&quot;是指一组必然会顺序执行的语句集。例如上图中的2号和3号,4号和5号分别构成了一个过程块
</code></pre><p>经过上述转换,可得以下流图</p>
<p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/流图-1687067591618-5.svg" alt="流图"></p>
<p>3.确定基本路径集合</p>
<p>针对转换得到的流图,计算该图的复杂度为</p>
<pre><code>复杂度 = Edge(D) - Node(D) + 2
</code></pre><p>所得的复杂度就是该图所具有的基本路径数量</p>
<p>所以上图中的复杂度为 11 - 9 + 2 = 4</p>
<p>基于上图的理解,该模块基本路径如下:</p>
<p>基本路径 1:1→11</p>
<p>基本路径 2:1→2,3→6→7→9→10→1→11</p>
<p>基本路径 3:1→2,3→6→8→9→10→1→11</p>
<p>基本路径 4:1→2,3→6→4,5→10→11</p>
<p>软件的维护演化</p>
<h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><p><strong>1.软件工程的”工程”指的是什么含义?他反映了软件工程具有什么样的基本理念和思想?</strong></p>
<pre><code>①将系统的、规范的、可量化的方法应用于软件开发、运行和维护的过程

②以及上述方法的研究
</code></pre><p>基本理念和思想:一是软件工程要提供系统的、规范的可量化的的方法来指导软件的开发、运行和维护,二是研究方法本身</p>
<p><strong>2.软件工程要为软件开发和运维提供系统的可量化的、规范的方法。请诠释”系统的可量化的、规范的”有何含义</strong></p>
<pre><code>系统的。是指软件工程关心的是软件全声明周期的开发问题
</code></pre><p>规范的。是指软件工程所提供的方法可为软件开发活动及其所产生的软件制品提供可准确描述的、标准化的指南</p>
<p>可量化的。软件工程采用可量化的手段,基于定量的数据来支持软件的开发</p>
<p><strong>3.软件工程三要素存在什么样的关系?说明面向对象工程的三个构成要素的具体内涵</strong></p>
<pre><code>这些要素从不同的工程视角关注软件的开发、运行和维护的问题,为软件质量保证提供了不同的支持,构成了&quot;系统、规范和可量化&quot;的方法



*过程*:

    从管理的视角,回答软件开发、运行和维护需要做哪些工作、如何管理好这些工作,关注软件的规范化组织和可量化实施

*方法学*:

    从技术的视角,回答软件开发、运行和维护如何做的问题。

*工具*:

    从工具辅助的视角,回答如何借助工具来辅助软件开发、运行和维护的问题
</code></pre><p><strong>4.面向对象程序设计体现了哪些软件工程的基本原则?请举例说明</strong></p>
<pre><code>抽象和建模：面向对象程序设计通过抽象和建模来描述和解决问题。它将现实世界的事物抽象为类和对象，并定义它们之间的关系和行为。这样可以更好地理解问题领域，使设计更符合实际需求。

模块化：面向对象的程序设计鼓励将代码组织成模块化的、可重用的单元，即类。每个类都封装了相关的数据和方法，提供了一种结构化的方式来组织代码。这符合软件工程中的模块化原则，将系统划分为相互独立且可测试的模块，提高代码的可维护性和可重用性。

软件重用：面向对象程序设计通过继承、组合和接口等机制来实现代码的重用。通过定义通用的类和接口，可以在不同的项目中重用已有的代码，提高开发效率和代码质量。

信息隐藏：面向对象程序设计通过封装来隐藏类的内部实现细节，仅暴露必要的接口给其他模块使用。这样的信息隐藏有助于提高系统的可维护性和可扩展性，同时保护了数据的完整性。
</code></pre><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><p><strong>1.软件过程模型和软件生存周期这两个概念有何区别和联系？</strong></p>
<pre><code>软件生存周期是针对软件而言的，它是指软件从提出开发开始到最终退役所经历的阶段

软件过程模型是针对软件开发而言的，他关注的是指导软件开法的相关步骤和活动
</code></pre><p><strong>2.对比分析迭代模型、增量模型、螺旋模型、UP 模型之间的差异性</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模型名称</th>
<th>指导思想</th>
<th>关注点</th>
<th>适用软件</th>
<th>管理难度</th>
</tr>
</thead>
<tbody>
<tr>
<td>瀑布模型</td>
<td>为软件开发提供系统性的指导</td>
<td>与软件生存周期相一致的软件开发过程</td>
<td>需求变动不大、较为明确、可预先定义的应用</td>
<td>易</td>
</tr>
<tr>
<td>原型模型</td>
<td>以原型为媒介指导用户的需求导出和评价</td>
<td>需求获取、导出和确认</td>
<td>需求难以表述清楚、不易导出和获取的应用</td>
<td>易</td>
</tr>
<tr>
<td>增量模型</td>
<td>快速交付和并行开发软件系统</td>
<td>软件详细设计、编码和测试的增量完成</td>
<td>需求变动不大、较为明确、可预先定义的应用</td>
<td>易</td>
</tr>
<tr>
<td>迭代模型</td>
<td>多次迭代，每次仅针对部分明确的软件需求</td>
<td>分多次迭代来开发软件,每次仅关注部分需求</td>
<td>软件需求变动大,难以一次说清楚的应用</td>
<td>中等</td>
</tr>
<tr>
<td>基于构件的过程模型</td>
<td>基于和构建重用来开发软件</td>
<td>构件的搜索、选择、构件和组装</td>
<td>需求明确,具有丰富构件库的应用</td>
<td>中等</td>
</tr>
<tr>
<td>螺旋模型</td>
<td>集成迭代模型和原型模型，引入风险分析等管理活动</td>
<td>软件计划制定和实施，软件风险管理,基于原型的迭代式开发</td>
<td>开发风险大,需求难以明确的应用</td>
<td>难</td>
</tr>
<tr>
<td>UP 模型</td>
<td>集成迭代过程模型和面向对象最佳实践</td>
<td>参考最佳实践，借助面向对象最佳实践来指导迭代开发</td>
<td>软件需求不明确且经常变化的应用</td>
<td>难</td>
</tr>
</tbody>
</table>
</div>
<p><strong>3.开发一个软件项目为什么需要软件过程模型？如果没有过程模型的指导，会产生什么样的情况？</strong></p>
<pre><code>软件过程定义了软件开发和维护的一组有序活动集合，它为相关人员参与软件开发、完成开发任务提供了规范化路线
</code></pre><p>没有过程模型的指导，会产生</p>
<p>1）不可预测的开发过程</p>
<p>2）风险无法控制</p>
<p>3）低质量的交付</p>
<p><strong>4.当开发一个软件项目时，应考虑哪些方面的因素来选择或指定合适的软件过程模型</strong></p>
<p>考虑软件项目的特点</p>
<p>考虑软件项目开发的风险</p>
<p>考虑团队的经验水平</p>
<p><strong>5.如果要开发一个军用软件项目，用户方有明确的需求，对软件质量提出非常高的要求，请问采用哪种开发过程模型和方法较为适合？为什么？</strong></p>
<ol>
<li>瀑布模型：瀑布模型是一种线性顺序的开发过程模型，包括需求定义、系统设计、编码、测试和部署等阶段。对于军用软件项目，明确的需求和高软件质量要求可以与瀑布模型的严格阶段性和文档化要求相匹配。瀑布模型有助于详尽地定义和分析需求，进行全面的系统设计和严格的软件测试，从而提供高质量和可靠的软件交付。</li>
</ol>
<p>2) 增量模型：增量模型强调在迭代和增量的基础上进行软件开发。每个增量都是一个完整的软件版本，包括设计、编码、测试和部署等活动。这种模型可以快速交付部分功能，以便用户方早期验证和反馈。对于军用软件项目，采用增量模型可以确保及时响应用户需求、减少风险和提供高质量的软件交付。</p>
<p>任选其一</p>
<p><strong>6.如果要开发一个业务信息系统项目，系统的需求来自一线业务工作人员，需要不断进行及交流和反馈，请问采用哪种开发过程模型和方法较为适合？为什么？</strong></p>
<ol>
<li>敏捷方法（如 Scrum）：敏捷方法适合需要灵活性、快速反馈和持续交付的项目。由于业务信息系统项目的需求可能会频繁变化和调整，采用敏捷方法可以通过短期迭代和增量交付的方式，不断进行交流和反馈。敏捷方法强调与业务工作人员的紧密合作，他们可以参与到项目开发中，提供及时的需求反馈和验证，从而确保系统符合业务需求。</li>
<li>增量模型：增量模型适合需要快速交付可用功能的项目。对于业务信息系统项目，用户对系统功能的反馈和验证非常重要。采用增量模型可以在每个增量中交付一部分功能，使业务工作人员能够及时使用并提供反馈。这样可以确保系统开发的正确性和符合业务需求，同时减少开发过程中的风险。</li>
<li>迭代模型：迭代模型强调通过反复迭代的方式逐步完善系统。业务信息系统项目通常具有复杂的需求和较长的生命周期，通过采用迭代模型，可以在每个迭代中集中精力开发和验证一部分功能。业务工作人员可以参与每个迭代的需求讨论和验证过程，确保系统开发与业务需求保持一致。</li>
<li>原型模型：原型模型适合在项目初期需要进行需求探索和验证的情况。通过快速构建原型，与业务工作人员进行交流和演示，可以及时捕捉需求细节和调整。原型模型有助于提高业务工作人员对系统的理解和参与度，从而确保系统满足其实际需求。</li>
</ol>
<p>任选其一</p>
<p><strong>7.软件开发方法与软件过程模型二者有何差别?请结合迭代模型和敏捷方法,说明他们之间的区别的和联系</strong></p>
<p><strong>8.为什么说传统的软件过程模型是重型的,体现在哪里?为什么说敏捷方法是轻型的,体现在哪里?</strong></p>
<p>传统的软件过程模型他们都以文档为中心指导软件开发</p>
<p>体现在:软件开发和运维的大量工作用于撰写和评审文档而非编写程序代码</p>
<pre><code>软件需要变化是常态,一旦需求发生变化,开发人员不得不首先去修改软件需求文档,并据此来调整其它文档,最后再根据修改后的文档来修改程序代码
</code></pre><p>敏捷方法以代码为中心,快速、轻巧和主动应对需求变化,持续、及时交付可运行的软件系统,体现在:</p>
<p>① 较之于过程和工具,应更加重视人和交互的价值。</p>
<p>② 较之于面面俱到的文档,应更加重视可运行软件的价值</p>
<p>③ 较之于合同谈判,应更加重视用户合作的价值</p>
<p>④ 较之于遵循计划,应更加重视响应用户需求的变化的价值</p>
<h3 id="第十五章"><a href="#第十五章" class="headerlink" title="第十五章"></a>第十五章</h3><p><strong>1.何为软件维护,何为软件演化?这两个概念有何区别和联系?</strong></p>
<pre><code>软件维护是指软件交付给用户使用后修改软件系统及其他部件的过程,以修复缺陷,提高性能或者其他属性,增强软件功能以及适应变化的环境。

软件演化是指针对软件的大规模功能增强和结构调整,以实现变化的软件需求或者提高软件系统的质量。





交付后的软件依然还会经历变更,而其中仅有少数变更属于真正意义上的&quot;软件维护&quot;范畴,更多的变更则属于&quot;软件演化&quot;的范畴
</code></pre><p><strong>2.软件维护有哪几种形式</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th>起因</th>
<th>目的</th>
<th>维护行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>纠正性维护</td>
<td>软件存在缺陷</td>
<td>诊断、纠正和修复软件缺陷</td>
<td>修改代码和调整文档</td>
</tr>
<tr>
<td>改善性维护</td>
<td>增强软件的功能和服务</td>
<td>满足用户增长和变化的软件需求</td>
<td>编写代码和撰写文档</td>
</tr>
<tr>
<td>适应性维护</td>
<td>软件运行所依赖的环境发生了变化</td>
<td>适应软件运行的变化和发展</td>
<td>编写代码和撰写文档</td>
</tr>
<tr>
<td>预防性维护</td>
<td>软件质量出现了下降</td>
<td>提高软件系统的质量,尤其是内部质量</td>
<td>重组代码和撰写文档</td>
</tr>
</tbody>
</table>
</div>
<p><strong>3.软件维护通常会面临哪些困难和挑战</strong></p>
<p>同步性</p>
<p>周期长</p>
<p>费用高</p>
<p>难度大</p>
<p><strong>4.为什么软件不会有物理层面的老化现象,但会出现逻辑层面的老化现象?请举例说明</strong></p>
<p>软件部署在某个计算环境下运行,运行次数和运行持续时间不会对软件系统的物理特性产生影响,所以不会产生物理层面的老化现象,而随着软件在维护和演化的过程中出现用户满意度降低、质量逐渐下降、变更成本不断上升等现象,这种现象发生在逻辑层面而不在物理层面</p>
<p><strong>5.为什么说软件逻辑老化不可避免,只要有维护就必然会导致软件逻辑老化?能否通过软件维护来解决软件逻辑老化的问题?</strong></p>
<p>软件维护虽然可以解决软件中潜藏的某些缺陷,但也会引入新的缺陷,在对软件进行改善性维护的同时,尽管增加了新的功能,但也会破坏软件架构,引入新的软件问题,使得整个软件不易于维护.软件架构变得脆弱。因此,随着对软件的不断维护,必然会导致整个软件逻辑老化</p>
<p>能,基于软件系统的可维护性以及软件系统的价值,采取以下 4 种方式和策略来应对</p>
<pre><code>维护。如果软件系统的价值较低,但是软件系统的可维护性较好,软件维护团队可以对软件系统进行有限的维护工作

抛弃。如果软件系统的价值较低,且软件系统的可维护性低,软件团队可以逐步抛弃对软件系统的维护

再工程。如果软件系统的价值较高,但软件系统的可维护性低,此时软件维护团队可以主动采取再工程的为胡策略。如对软件系统进行重组

演化。如果软件系统的价值较高,可维护性好,软件维护团队可以采取积极和主动的演化策略
</code></pre><p><strong>6.软件重构、重组、逆向工程和再工程有何区别?请举例说明</strong></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
            <ul id="audio-list" style="display:none">
                
                
                <li title='0' data-url='/statics/chengdu.mp3'></li>
                
                    
            </ul>
            
                        
            
            
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci='7bbd114371cb2cd73dc2'
        data-cs='fd7cda0eb23cbb69b65e291c5b607b196613a6b1'
        data-r='nd-ljq.github.io'
        data-o='ND-LJQ'
        data-a='ND-LJQ'
        data-d=''
        data-p='https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    >Comments</div>


            
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="/img/head.jpg" height=300 width=300></img>
                    <p>ND_LJQ</p>
                    <span>Think like an artist, develop like an artisan</span>
                    <dl>
                        
                            
                                <dd><a href="https://github.com/ND-LJQ'" target="_blank"><span
                                    class=" iconfont icon-github"></span></a></dd>
                            
                            
                            
                        
                        
                    </dl>
                </div>
                <ul>
                    <li><a href="/">8 <p>Articles</p></a></li>
                    <li><a href="/categories">9 <p>Categories</p></a></li>
                    <li><a href="/tags">8 <p>Tags</p></a></li>
                </ul>
            </div>
            
            
            
            <div class="box sticky animated fadeInRight faster">
                <div id="toc" class="subbox">
                    <h4>Contents</h4>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">软件工程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E6%80%9D%E6%83%B3"><span class="toc-number">1.1.</span> <span class="toc-text">软件工程的概念和思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">何为软件工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">1.1.2.</span> <span class="toc-text">软件工程的三要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.3.</span> <span class="toc-text">软件工程的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.4.</span> <span class="toc-text">软件工程的原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">开源软件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">何为开源软件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.2.2.</span> <span class="toc-text">开源软件实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.2.3.</span> <span class="toc-text">开源软件的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81"><span class="toc-number">1.2.4.</span> <span class="toc-text">开源许可证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">1.2.5.</span> <span class="toc-text">开源软件的利用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">软件过程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E8%A1%A8%E6%80%A7%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">代表性的软件过程模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">软件开发方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">敏捷方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.5.</span> <span class="toc-text">软件需求工程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E5%AD%A6"><span class="toc-number">1.5.1.</span> <span class="toc-text">面相对象的需求分析方法学</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80"><span class="toc-number">1.6.</span> <span class="toc-text">软件设计基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E5%AD%A6"><span class="toc-number">1.6.1.</span> <span class="toc-text">面向对象的软件设计方法学</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.7.</span> <span class="toc-text">软件体系结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.1.</span> <span class="toc-text">软件体系结构模型的表示方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">1.8.</span> <span class="toc-text">软件测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B"><span class="toc-number">1.8.1.</span> <span class="toc-text">软件测试过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF"><span class="toc-number">1.8.2.</span> <span class="toc-text">软件测试技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98"><span class="toc-number">1.9.</span> <span class="toc-text">课后习题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0"><span class="toc-number">1.9.1.</span> <span class="toc-text">第二章</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0"><span class="toc-number">1.9.2.</span> <span class="toc-text">第三章</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0"><span class="toc-number">1.9.3.</span> <span class="toc-text">第十五章</span></a></li></ol></li></ol></li></ol>
                </div>
            </div>
            
            
        </div>
    </div>
</div>

    </div>
</div>
    <div id="back-to-top" class="animated fadeIn faster">
        <div class="flow"></div>
        <span class="percentage animated fadeIn faster">0%</span>
        <span class="iconfont icon-top02 animated fadeIn faster"></span>
    </div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2023
        <span class="gradient-text">
            ND_LJQ
        </span>.
        Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
        Theme
        <span class="gradient-text">
            <a href="https://github.com/TriDiamond/hexo-theme-obsidian" title="Obsidian" target="_blank" rel="noopener">Obsidian</a>
        </span>
        <small><a href="https://github.com/TriDiamond/hexo-theme-obsidian/blob/master/CHANGELOG.md" title="v1.4.9.3" target="_blank" rel="noopener">v1.4.9.3</a></small>
        
        
    </p>
</footer>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX", "TeX"],
      linebreaks: {
        automatic: true
      },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"]
      ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      noUndefined: {
        attributes: {
          mathcolor: "red",
          mathbackground: "#FFEEEE",
          mathsize: "90%"
        }
      },
      Macros: {
        href: "{}"
      }
    },
    messageStyle: "none"
  });
</script>
<script>
  function initialMathJax() {
    MathJax.Hub.Queue(function () {
      var all = MathJax.Hub.getAllJax(),
        i;
      // console.log(all);
      for (i = 0; i < all.length; i += 1) {
        console.log(all[i].SourceElement().parentNode)
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  }

  function reprocessMathJax() {
    if (typeof MathJax !== 'undefined') {
      MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }
</script>


 
<link rel="stylesheet" href="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.css">
 
<script src="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.js"></script>
  
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>
 
<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>
 
<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>
 
<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>
 
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/sql/sql.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/java/java.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/c/c.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/html/html.min.js"></script>
   
<script src="/js/busuanzi.min.js"></script>

<script>
  $(document).ready(function () {
    if ($('span[id^="busuanzi_"]').length) {
      initialBusuanzi();
    }
  });
</script>
 
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
  

<script>
  function initialTyped() {
    var typedTextEl = $('.typed-text');
    if (typedTextEl && typedTextEl.length > 0) {
      var typed = new Typed('.typed-text', {
        strings: ['Think like an artist, develop like an artisan', '艺术家思维去思考问题，工匠创造精神去开发'],
        typeSpeed: 90,
        loop: true,
        loopCount: Infinity,
        backSpeed: 20,
      });
    }
  }

  if ($('.article-header') && $('.article-header').length) {
    $(document).ready(function () {
      initialTyped();
    });
  }
</script>




<!-- 引用依赖 -->
<script>document.write(aplayerconf)</script>




</html>
