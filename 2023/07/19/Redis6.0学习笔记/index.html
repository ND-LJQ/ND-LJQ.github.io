
<!DOCTYPE html>
<html lang="cn" class="loading">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
      name="viewport"
      content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Redis6.0学习笔记 - 刘三刀的blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="google" content="notranslate" />
    
    <meta name="keywords" content="刘三刀的blog," />
     
    <meta name="description" content="Redis  是典型的  NoSQL  数据库，支持多种数据结构类型。设计思想是：单线程+多路 IO 复用技术

redis 官方介绍

Redis  是一个开源的  key-value  存储系统," />
     
    <meta name="author" content="ND_LJQ" />
     
    <link
      rel="alternative"
      href="atom.xml"
      title="刘三刀的blog"
      type="application/atom+xml"
    />
     
    <link rel="icon" href="/img/favicon.png" />
     
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">
 
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">
 
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">
 
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">
 
<link rel="stylesheet" href="/css/obsidian.css">
 
<link rel="stylesheet" href="/css/ball-atom.min.css">
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
 
    <link
      href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css"
      rel="stylesheet"
    />
    <script>
      var musiclist = '';
    </script>
    
<script src="/js/loadaplayer.js"></script>

    <!-- 引用依赖 -->
    
<link rel="stylesheet" href="/aplayer/dist/APlayer.min.css">
 
<script src="/aplayer/dist/APlayer.min.js"></script>
<script src="/js/Meting.min.js"></script>
 
  <meta name="generator" content="Hexo 6.3.0"></head>
</html>


<body class="loading">
    <div class="loader">
        <div class="la-ball-atom la-2x">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
    <span id="config-title" style="display:none">刘三刀的blog</span>
    <div id="loader"></div>
    <div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="/img/favicon.png" alt="" data-url="https://nd-ljq.github.io">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">Redis6.0学习笔记</h3>
        <div class="social">
            <!--        <div class="like-icon">-->
            <!--            <a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
            <!--        </div>-->
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
            animation-delay: 600ms;
            animation-duration: 1.2s;
            background-image: 
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url('/img/cover.jpg') ">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                <a href="/categories/NoSQL"><b>「
                    </b>NOSQL<b> 」</b></a>
                
                July 19, 2023
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Redis6.0学习笔记" class="">Redis6.0学习笔记</a>
            </h3>
            
            <p class="post-count animated fadeInDown">
                
                <span>
                    <b class="iconfont icon-text2"></b> <i>Words count</i>
                    104k
                </span>
                
                
                <span>
                    <b class="iconfont icon-timer__s"></b> <i>Reading time</i>
                    1:35
                </span>
                
                
                
                <span id="busuanzi_container_page_pv">
                    <b class="iconfont icon-read"></b> <i>Read count</i>
                    <span id="busuanzi_value_page_pv">0</span>
                </span>
                
            </p>
            
            
            <ul class="animated fadeInDown post-tags-list" itemprop="keywords"><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s"></span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <p><strong><em>Redis</em></strong>  是典型的  <strong><em>NoSQL</em></strong>  数据库，支持多种数据结构类型。设计思想是：<strong>单线程+多路 IO 复用技术</strong></p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/说明.png" alt></p>
<p><a target="_blank" rel="noopener" href="https://redis.io/download">redis 官方介绍</a></p>
<blockquote>
<p><strong><em>Redis</em></strong>  是一个开源的  <strong><em>key-value</em></strong>  存储系统。<br>和  <strong><em>Memcached</em></strong>  类似，它支持存储的  <strong><em>value</em></strong>  类型相对更多，包括  <strong><em>string、list、set、zset、sorted set、hash</em></strong>。</p>
<p>这些数据类型都支持  <strong><em>push/pop、add/remove</em></strong>  及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的</p>
<p>这些数据类型都支持  <strong><em>push/pop、add/remove</em></strong>  及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p>
<p>在此基础上，<strong><em>Redis</em></strong>  支持各种不同方式的排序。</p>
<p>与  <strong><em>memcached</em></strong>一样，为了保证效率，数据都是缓存在内存中。<br>区别的是  <strong><em>Redis</em></strong>  会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p>
<p>并且在此基础上实现了<strong><em>master-slave</em></strong> （主从）同步。<br>单线程 + <strong><em>IO</em></strong>  多路复用。</p>
</blockquote>
<h1 id="Redis-中的-key-操作"><a href="#Redis-中的-key-操作" class="headerlink" title="Redis 中的 key 操作"></a>Redis 中的 key 操作</h1><h2 id="查看当前库中所有的-key-值"><a href="#查看当前库中所有的-key-值" class="headerlink" title="查看当前库中所有的 key 值"></a>查看当前库中所有的 key 值</h2><pre><code class="lang-sql">keys  *
</code></pre>
<h2 id="设置-key-value-值"><a href="#设置-key-value-值" class="headerlink" title="设置 key-value 值"></a>设置 key-value 值</h2><pre><code class="lang-sql">set key_name value //返回ok代表成功
</code></pre>
<h2 id="查看-key-是否存在"><a href="#查看-key-是否存在" class="headerlink" title="查看 key 是否存在"></a>查看 key 是否存在</h2><pre><code class="lang-sql">exists key_name //返回值为1表示存在,0则不存在
</code></pre>
<h2 id="查看-key-的-type"><a href="#查看-key-的-type" class="headerlink" title="查看 key 的 type"></a>查看 key 的 type</h2><pre><code class="lang-sql">type key_name
</code></pre>
<p>redis 的操作是原子操作，即不会被线程调度机制打断的操作</p>
<h2 id="同时设置一个或多个-key-value-对"><a href="#同时设置一个或多个-key-value-对" class="headerlink" title="同时设置一个或多个 key-value 对"></a>同时设置一个或多个 key-value 对</h2><pre><code class="lang-sql">mset key1_name value1 key2_name value2.....
</code></pre>
<h2 id="key-值不存在的时候设置-key-的值"><a href="#key-值不存在的时候设置-key-的值" class="headerlink" title="key 值不存在的时候设置 key 的值"></a>key 值不存在的时候设置 key 的值</h2><pre><code class="lang-sql">setnx key_name value
</code></pre>
<h2 id="key-值不存在的时候设置一个或多个-key-的值"><a href="#key-值不存在的时候设置一个或多个-key-的值" class="headerlink" title="key 值不存在的时候设置一个或多个 key 的值"></a>key 值不存在的时候设置一个或多个 key 的值</h2><pre><code class="lang-sql">msetnx key1_name value1 key2_name value2 key3_name value3.... // 原子性，有一个失败则都失败
</code></pre>
<h2 id="设置键值的同时，设置过期时间"><a href="#设置键值的同时，设置过期时间" class="headerlink" title="设置键值的同时，设置过期时间"></a>设置键值的同时，设置过期时间</h2><pre><code class="lang-sql">setex key_name time value
</code></pre>
<h2 id="设置旧值的同时设置新值"><a href="#设置旧值的同时设置新值" class="headerlink" title="设置旧值的同时设置新值"></a>设置旧值的同时设置新值</h2><pre><code class="lang-sql">getset key_name value
</code></pre>
<h2 id="获取-key-的-value-值"><a href="#获取-key-的-value-值" class="headerlink" title="获取 key 的 value 值"></a>获取 key 的 value 值</h2><pre><code class="lang-sql">get key_name
</code></pre>
<h2 id="获取一个或多个-key-value-对"><a href="#获取一个或多个-key-value-对" class="headerlink" title="获取一个或多个 key-value 对"></a>获取一个或多个 key-value 对</h2><pre><code class="lang-sql">mget key1_name key2_name key3_name...
</code></pre>
<h2 id="将给定的值追加到目标-key-的末尾"><a href="#将给定的值追加到目标-key-的末尾" class="headerlink" title="将给定的值追加到目标 key 的末尾"></a>将给定的值追加到目标 key 的末尾</h2><pre><code class="lang-sql">append key_name value
</code></pre>
<h2 id="获得-key-值长度"><a href="#获得-key-值长度" class="headerlink" title="获得 key 值长度"></a>获得 key 值长度</h2><pre><code class="lang-sql">strlen key_name
</code></pre>
<h2 id="将-key-中存储的数字增长-1"><a href="#将-key-中存储的数字增长-1" class="headerlink" title="将 key 中存储的数字增长 1"></a>将 key 中存储的数字增长 1</h2><pre><code class="lang-sql">incr key_name  //只能对数字值操作，如果为空，新增值为1
</code></pre>
<h2 id="将-key-中存储的数字增长任意值"><a href="#将-key-中存储的数字增长任意值" class="headerlink" title="将 key 中存储的数字增长任意值"></a>将 key 中存储的数字增长任意值</h2><pre><code class="lang-sql">incrby key_name value
</code></pre>
<h2 id="将-key-中存储的数字减一"><a href="#将-key-中存储的数字减一" class="headerlink" title="将 key 中存储的数字减一"></a>将 key 中存储的数字减一</h2><pre><code class="lang-sql">decr key_name
</code></pre>
<h2 id="将-key-中存储的数字减去任意值"><a href="#将-key-中存储的数字减去任意值" class="headerlink" title="将 key 中存储的数字减去任意值"></a>将 key 中存储的数字减去任意值</h2><pre><code class="lang-sql">decrby key_name value
</code></pre>
<h2 id="删除指定-key"><a href="#删除指定-key" class="headerlink" title="删除指定 key"></a>删除指定 key</h2><pre><code class="lang-sql">del key_name //返回值为1表示成功
</code></pre>
<h2 id="非阻塞删除"><a href="#非阻塞删除" class="headerlink" title="非阻塞删除"></a>非阻塞删除</h2><pre><code class="lang-sql">unlink key_name  //仅将keys从keyspace元数据中删除，真正的删除会在后续一步操作
</code></pre>
<h2 id="设置-key-过期时间"><a href="#设置-key-过期时间" class="headerlink" title="设置 key 过期时间"></a>设置 key 过期时间</h2><pre><code class="lang-sql">expire key_name time //以s为单位
</code></pre>
<h2 id="查看-key-的过期时间"><a href="#查看-key-的过期时间" class="headerlink" title="查看 key 的过期时间"></a>查看 key 的过期时间</h2><pre><code class="lang-sql">ttl key_name  // -1代表永不过期 -2代表已经过期
</code></pre>
<h2 id="查看当前库的-key-的数量"><a href="#查看当前库的-key-的数量" class="headerlink" title="查看当前库的 key 的数量"></a>查看当前库的 key 的数量</h2><pre><code class="lang-sql">dbsize
</code></pre>
<h2 id="清空当前库"><a href="#清空当前库" class="headerlink" title="清空当前库"></a>清空当前库</h2><pre><code class="lang-sql">flushdb
</code></pre>
<h2 id="清空所有库"><a href="#清空所有库" class="headerlink" title="清空所有库"></a>清空所有库</h2><pre><code class="lang-sql">flushall
</code></pre>
<h1 id="Redis-的基本数据类型"><a href="#Redis-的基本数据类型" class="headerlink" title="Redis 的基本数据类型"></a>Redis 的基本数据类型</h1><p>Redis 是使用了一个「哈希表」保存所有键值对，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。</p>
<p>Redis 的哈希桶是怎么保存键值对数据的呢？</p>
<p>哈希桶存放的是指向键值对数据的指针（dictEntry<em>），这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身，而是保存了 void </em> key 和 void <em> value 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 void </em> value 指针找到。</p>
<p>这里有一张 Redis 保存键值对所涉及到的数据结构。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis全景图.png" alt="redis基本数据结构一览"></p>
<ul>
<li>redisDb 结构，表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针；</li>
<li>dict 结构，结构体里存放了 2 个哈希表，正常情况下都是用「哈希表 1」，「哈希表 2」只有在 rehash 的时候才用，具体什么是 rehash，在哈希表数据结构会讲；</li>
<li>ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；</li>
<li>dictEntry 结构，表示哈希表节点的结构，结构里存放了  <strong>void <em> key 和 void </em> value 指针， <em>key 指向的是 String 对象，而 </em>value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象</strong>。</li>
</ul>
<p>特别说明下，void <em> key 和 void </em> value 指针指向的是  <strong>Redis 对象</strong>，Redis 中的每个对象都由 redisObject 结构表示，如下图：</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/对象结构.png" alt><br>对象结构里包含的成员变量：</p>
<ul>
<li>type，标识该对象是什么类型的对象（String 对象、 List 对象、Hash 对象、Set 对象和 Zset 对象）；</li>
<li>encoding，标识该对象使用了哪种底层的数据结构；</li>
<li><strong>ptr，指向底层数据结构的指针</strong>。</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h3><p>字符串在 Redis 中是很常用的，键值对中的键是字符串类型，值有时也是字符串类型。</p>
<p>Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS。</p>
<p>既然 Redis 设计了 SDS 结构来表示字符串，肯定是 C 语言的 char* 字符数组存在一些缺陷。</p>
<p>要了解这一点，得先来看看 char* 字符数组的结构。</p>
<h3 id="C-语言字符串的缺陷"><a href="#C-语言字符串的缺陷" class="headerlink" title="C 语言字符串的缺陷"></a>C 语言字符串的缺陷</h3><p>C 语言的字符串其实就是一个字符数组，即数组中每个元素是字符串中的一个字符。</p>
<p>比如，下图就是字符串“xiaolin”的 char* 字符数组的结构：</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/38e4949cc380698609129c20459ae0c3_MD5.png" alt></p>
<p>没学过 C 语言的同学，可能会好奇为什么最后一个字符是“\0”？</p>
<p>在 C 语言里，对字符串操作时，char * 指针只是指向字符数组的起始位置，而<strong>字符数组的结尾位置就用“\0”表示，意思是指字符串的结束</strong>。</p>
<p>因此，C 语言标准库中的字符串操作函数就通过判断字符是不是 “\0” 来决定要不要停止操作，如果当前字符不是 “\0” ，说明字符串还没结束，可以继续操作，如果当前字符是 “\0” 是则说明字符串结束了，就要停止操作。</p>
<p>举个例子，C 语言获取字符串长度的函数  <code>strlen</code>，就是通过字符数组中的每一个字符，并进行计数，等遇到字符为 “\0” 后，就会停止遍历，然后返回已经统计到的字符个数，即为字符串长度。下图显示了 strlen 函数的执行流程：</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3d93bb27b72acda3c4387834c43909a5_MD5.png" alt></p>
<p>很明显，<strong>C 语言获取字符串长度的时间复杂度是 O（N）（<em>这是一个可以改进的地方</em></strong>）</p>
<p>C 语言字符串用 “\0” 字符作为结尾标记有个缺陷。假设有个字符串中有个 “\0” 字符，这时在操作这个字符串时就会<strong>提早结束</strong>，比如 “xiao\0lin” 字符串，计算字符串长度的时候则会是 4，如下图：</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1f49b3b41356a712d2b6fb2dee533f0a_MD5.png" alt></p>
<p>因此，除了字符串的末尾之外，<strong>字符串里面不能含有 “\0” 字符</strong>，否则最先被程序读入的 “\0” 字符将被误认为是字符串结尾，这个限制使得 C 语言的字符串只能保存文本数据，<strong>不能保存像图片、音频、视频文化这样的二进制数据（<em>这也是一个可以改进的地方</em>）</strong></p>
<p>另外， C 语言标准库中字符串的操作函数是很不安全的，对程序员很不友好，稍微一不注意，就会导致缓冲区溢出。</p>
<p>举个例子，strcat 函数是可以将两个字符串拼接在一起。</p>
<p><code>c //将 src 字符串拼接到 dest 字符串后面 char *strcat(char *dest, const char* src);</code></p>
<p><strong>C 语言的字符串是不会记录自身的缓冲区大小的</strong>，所以 strcat 函数假定程序员在执行这个函数时，已经为 dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而<strong>一旦这个假定不成立，就会发生缓冲区溢出将可能会造成程序运行终止，（<em>这是一个可以改进的地方</em></strong>）。</p>
<p>而且，strcat 函数和 strlen 函数类似，时间复杂度也很高，也都需要先通过遍历字符串才能得到目标字符串的末尾。然后对于 strcat 函数来说，还要再遍历源字符串才能完成追加，<strong>对字符串的操作效率不高</strong>。</p>
<p>好了， 通过以上的分析，我们可以得知 C 语言的字符串不足之处以及可以改进的地方：</p>
<ul>
<li>获取字符串长度的时间复杂度为 O（N）；</li>
<li>字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据；</li>
<li>字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；</li>
</ul>
<p>Redis 实现的 SDS 的结构就把上面这些问题解决了，接下来我们一起看看 Redis 是如何解决的。</p>
<h3 id="SDS-结构设计"><a href="#SDS-结构设计" class="headerlink" title="SDS 结构设计"></a>SDS 结构设计</h3><p>下图就是 Redis 5.0 的 SDS 的数据结构：</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/acd89e40ca2c7821459850c7524f62f3_MD5.png" alt></p>
<p>结构中的每个成员变量分别介绍下：</p>
<ul>
<li><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。</li>
<li><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过  <code>alloc - len</code>  计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。</li>
<li><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面再说明区别之处。</li>
<li><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。</li>
</ul>
<p>总的来说，Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据：len、alloc、flags，用来解决 C 语言字符串的缺陷。</p>
<h3 id="O（1）复杂度获取字符串长度"><a href="#O（1）复杂度获取字符串长度" class="headerlink" title="O（1）复杂度获取字符串长度"></a>O（1）复杂度获取字符串长度</h3><p>C 语言的字符串长度获取 strlen 函数，需要通过遍历的方式来统计字符串长度，时间复杂度是 O（N）。</p>
<p>而 Redis 的 SDS 结构因为加入了 len 成员变量，那么<strong>获取字符串长度的时候，直接返回这个成员变量的值就行，所以复杂度只有 O（1）</strong>。</p>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>因为 SDS 不需要用 “\0” 字符来标识字符串结尾了，而是<strong>有个专门的 len 成员变量来记录长度，所以可存储包含 “\0” 的数据</strong>。但是 SDS 为了兼容部分 C 语言标准库的函数， SDS 字符串结尾还是会加上 “\0” 字符。</p>
<p>因此， SDS 的 API 都是以处理二进制的方式来处理 SDS 存放在 buf[] 里的数据，程序不会对其中的数据做任何限制，数据写入的时候时什么样的，它被读取时就是什么样的。</p>
<p>通过使用二进制安全的 SDS，而不是 C 字符串，使得 Redis 不仅可以保存文本数据，也可以保存任意格式的二进制数据。</p>
<h3 id="不会发生缓冲区溢出"><a href="#不会发生缓冲区溢出" class="headerlink" title="不会发生缓冲区溢出"></a>不会发生缓冲区溢出</h3><p>C 语言的字符串标准库提供的字符串操作函数，大多数（比如 strcat 追加字符串函数）都是不安全的，因为这些函数把缓冲区大小是否满足操作需求的工作交由开发者来保证，程序内部并不会判断缓冲区大小是否足够用，当发生了缓冲区溢出就有可能造成程序异常结束。</p>
<p>所以，Redis 的 SDS 结构里引入了 alloc 和 len 成员变量，这样 SDS API 通过  <code>alloc - len</code>  计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。</p>
<p>而且，<strong>当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小（小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容）</strong>，以满足修改所需的大小。</p>
<p>在扩展 SDS 空间之前，SDS API 会优先检查未使用空间是否足够，如果不够的话，API 不仅会为 SDS 分配修改所必须要的空间，还会给 SDS 分配额外的「未使用空间」。</p>
<p>这样的好处是，下次在操作 SDS 时，如果 SDS 空间够的话，API 就会直接使用「未使用空间」，而无须执行内存分配，<strong>有效的减少内存分配次数</strong>。</p>
<p>所以，使用 SDS 即不需要手动修改 SDS 的空间大小，也不会出现缓冲区溢出的问题。</p>
<h3 id="节省内存空间"><a href="#节省内存空间" class="headerlink" title="节省内存空间"></a>节省内存空间</h3><p>SDS 结构中有个 flags 成员变量，表示的是 SDS 类型。</p>
<p>Redos 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。</p>
<p>这 5 种类型的主要<strong>区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同</strong>。</p>
<p>比如 sdshdr16 和 sdshdr32 这两个类型，它们的定义分别如下：</p>
<pre><code class="lang-c">struct __attribute__ ((__packed__)) sdshdr16 &#123;
    uint16_t len;
    uint16_t alloc; 
    unsigned char flags; 
    char buf[];
&#125;;


struct __attribute__ ((__packed__)) sdshdr32 &#123;
    uint32_t len;
    uint32_t alloc; 
    unsigned char flags;
    char buf[];
&#125;;
</code></pre>
<p>可以看到：</p>
<ul>
<li>sdshdr16 类型的 len 和 alloc 的数据类型都是 uint16_t，表示字符数组长度和分配空间大小不能超过 2 的 16 次方。</li>
<li>sdshdr32 则都是 uint32_t，表示表示字符数组长度和分配空间大小不能超过 2 的 32 次方。</li>
</ul>
<p><strong>之所以 SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间</strong>。比如，在保存小字符串时，结构头占用空间也比较少。</p>
<p>除了设计不同类型的结构体，Redis 在编程上还<strong>使用了专门的编译优化来节省内存空间</strong>，即在 struct 声明了  <code>__attribute__ ((packed))</code> ，它的作用是：<strong>告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐</strong>。</p>
<p>比如，sdshdr16 类型的 SDS，默认情况下，编译器会按照 16 字节对齐的方式给变量分配内存，这意味着，即使一个变量的大小不到 16 个字节，编译器也会给它分配 16 个字节。</p>
<p>举个例子，假设下面这个结构体，它有两个成员变量，类型分别是 char 和 int，如下所示：</p>
<pre><code class="lang-c">#include &lt;stdio.h&gt;

 struct test1 &#123;
    char a;
    int b;
 &#125; test1;

int main() &#123;
     printf(&quot;%lu\n&quot;, sizeof(test1));
     return 0;
&#125;
</code></pre>
<p>猜猜这个结构体大小是多少？我先直接说答案，这个结构体大小计算出来是 8。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/f146749f3864d3731b9ffae675c9ce8e_MD5.png" alt></p>
<p>这是因为默认情况下，编译器是使用「字节对齐」的方式分配内存，虽然 char 类型只占一个字节，但是由于成员变量里有 int 类型，它占用了 4 个字节，所以在成员变量为 char 类型分配内存时，会分配 4 个字节，其中这多余的 3 个字节是为了字节对齐而分配的，相当于有 3 个字节被浪费掉了。</p>
<p>如果不想编译器使用字节对齐的方式进行分配内存，可以采用了  <code>__attribute__ ((packed))</code>  属性定义结构体，这样一来，结构体实际占用多少内存空间，编译器就分配多少空间。</p>
<p>比如，我用  <code>__attribute__ ((packed))</code>  属性定义下面的结构体 ，同样包含 char 和 int 两个类型的成员变量，代码如下所示：</p>
<pre><code class="lang-c">#include &lt;stdio.h&gt;

struct __attribute__((packed)) test2  &#123;
    char a;
    int b;
 &#125; test2;

int main() &#123;
     printf(&quot;%lu\n&quot;, sizeof(test2));
     return 0;
&#125;
</code></pre>
<p>这时打印的结果是 5（1 个字节 char + 4 字节 int）。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/35d85b3f8a490fa1502107879d9ff1f3_MD5.png" alt></p>
<p>可以看得出，这是按照实际占用字节数进行分配内存的，这样可以节省内存空间。</p>
<h3 id="部分操作指令"><a href="#部分操作指令" class="headerlink" title="部分操作指令"></a>部分操作指令</h3><p><strong><em>获取 key 的指定范围的值</em></strong></p>
<pre><code class="lang-sql">getrange key_name start_number end_number
</code></pre>
<p><strong><em>在 key 的指定位置插入值</em></strong></p>
<pre><code class="lang-sql">setrange key_name start_number value
</code></pre>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>允许重复值</p>
<p>单键多值<br>底层：双向链表 对两端的操作性能高，中间的操作性能低</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>qickList:链表+ziplist</p>
<ul>
<li>首先在<strong>列表元素较少的情况下会使用一块连续的内存存储</strong>，这个结构是  <strong><em>ziplist</em></strong>，也即是<strong>压缩列表</strong><ul>
<li>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</li>
</ul>
</li>
<li>当<strong>数据量比较多</strong>的时候才会改成  <strong><em>quicklist</em></strong>。<ul>
<li>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是  <strong><em>int</em></strong>  类型的数据，结构上还需要两个额外的指针  <strong><em>prev</em></strong>  和  <strong><em>next</em></strong></li>
</ul>
</li>
</ul>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1751903-20220127114010280-898156568.png" alt></p>
<ul>
<li><strong><em>Redis</em></strong>  将<strong>链表</strong>和  <strong><em>ziplist</em></strong>  结合起来组成了  <strong><em>quicklist</em></strong>。也就是将多个  <strong><em>ziplist</em></strong>  使<strong>用双向指针串起来使用</strong>。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。<strong><em>quicklist</em></strong>结构图如下：<br><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211022122514593.png" alt></li>
</ul>
<h2 id="链表节点结构设计"><a href="#链表节点结构设计" class="headerlink" title="链表节点结构设计"></a>链表节点结构设计</h2><p>先来看看「链表节点」结构的样子：</p>
<pre><code class="lang-c">typedef struct listNode &#123;
    //前置节点
    struct listNode *prev;
    //后置节点
    struct listNode *next;
    //节点的值
    void *value;
&#125; listNode;
</code></pre>
<p>有前置节点和后置节点，可以看的出，这个是一个双向链表。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2809989f806dc74957bb01f308aafd61_MD5.png" alt></p>
<h3 id="链表结构设计"><a href="#链表结构设计" class="headerlink" title="链表结构设计"></a>链表结构设计</h3><p>不过，Redis 在 listNode 结构体基础上又封装了 list 这个数据结构，这样操作起来会更方便，链表结构如下：</p>
<pre><code class="lang-c">typedef struct list &#123;
    //链表头节点
    listNode *head;
    //链表尾节点
    listNode *tail;
    //节点值复制函数
    void *(*dup)(void *ptr);
    //节点值释放函数
    void (*free)(void *ptr);
    //节点值比较函数
    int (*match)(void *ptr, void *key);
    //链表节点数量
    unsigned long len;
&#125; list;
</code></pre>
<p>list 结构为链表提供了链表头指针 head、链表尾节点 tail、链表节点数量 len、以及可以自定义实现的 dup、free、match 函数。</p>
<p>举个例子，下面是由 list 结构和 3 个 listNode 结构组成的链表。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/a1419c63bed3a88896609b20f1d614cc_MD5.png" alt></p>
<h3 id="链表的优势与缺陷"><a href="#链表的优势与缺陷" class="headerlink" title="链表的优势与缺陷"></a>链表的优势与缺陷</h3><p>Redis 的链表实现优点如下：</p>
<ul>
<li>listNode 链表节点的结构里带有 prev 和 next 指针，<strong>获取某个节点的前置节点或后置节点的时间复杂度只需 O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表</strong>；</li>
<li>list 结构因为提供了表头指针 head 和表尾节点 tail，所以<strong>获取链表的表头节点和表尾节点的时间复杂度只需 O(1)</strong>；</li>
<li>list 结构因为提供了链表节点数量 len，所以<strong>获取链表中的节点数量的时间复杂度只需 O(1)</strong>；</li>
<li>listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此<strong>链表节点可以保存各种不同类型的值</strong>；</li>
</ul>
<p>链表的缺陷也是有的：</p>
<ul>
<li><p>链表每个节点之间的内存都是不连续的，意味着<strong>无法很好利用 CPU 缓存</strong>。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。</p>
</li>
<li><p>还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，<strong>内存开销较大</strong>。</p>
</li>
</ul>
<p>因此，Redis 3.0 的 List 对象在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。</p>
<p>不过，压缩列表存在性能问题（具体什么问题，下面会说），所以 Redis 在 3.2 版本设计了新的数据结构 quicklist，并将 List 对象的底层数据结构改由 quicklist 实现。</p>
<p>然后在 Redis 5.0 设计了新的数据结构 listpack，沿用了压缩列表紧凑型的内存布局，最终在最新的 Redis 版本，将 Hash 对象和 Zset 对象的底层数据结构实现之一的压缩列表，替换成由 listpack 实现。</p>
<hr>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。</p>
<p>但是，压缩列表的缺陷也是有的：</p>
<ul>
<li>不能保存过多的元素，否则查询效率就会降低；</li>
<li>新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。</li>
</ul>
<p>因此，Redis 对象（List 对象、Hash 对象、Zset 对象）包含的元素数量较少，或者元素值不大的情况才会使用压缩列表作为底层数据结构。</p>
<p>接下来，就跟大家详细聊下压缩列表。</p>
<h3 id="压缩列表结构设计"><a href="#压缩列表结构设计" class="headerlink" title="压缩列表结构设计"></a>压缩列表结构设计</h3><p>压缩列表是 Redis 为了节约内存而开发的，它是<strong>由连续内存块组成的顺序型数据结构</strong>，有点类似于数组。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/d21c4278d9d71f4938b76d2328189630_MD5.png" alt></p>
<p>压缩列表在表头有三个字段：</p>
<ul>
<li><strong><em>zlbytes</em></strong>，记录整个压缩列表占用对内存字节数；</li>
<li><strong><em>zltail</em></strong>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li>
<li><strong><em>zllen</em></strong>，记录压缩列表包含的节点数量；</li>
<li><strong><em>zlend</em></strong>，标记压缩列表的结束点，固定值 0xFF（十进制 255）。</li>
</ul>
<p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</strong>。</p>
<p>另外，压缩列表节点（entry）的构成如下：</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/985302f3e0228d5e55c5474bcfb7e0d3_MD5.png" alt></p>
<p>压缩列表节点包含三部分内容：</p>
<ul>
<li><strong><em>prevlen</em></strong>，记录了「前一个节点」的长度；</li>
<li><strong><em>encoding</em></strong>，记录了当前节点实际数据的类型以及长度；</li>
<li><strong><em>data</em></strong>，记录了当前节点的实际数据；</li>
</ul>
<p>当我们往压缩列表中插入数据时，压缩列表就会根据数据是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，<strong>这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的</strong>。</p>
<p>分别说下，prevlen 和 encoding 是如何根据数据的大小和类型来进行不同的空间大小分配。</p>
<p>压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度」，而且 prevlen 属性的空间大小跟前一个节点长度值有关，比如：</p>
<ul>
<li>如果<strong>前一个节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用  <strong>1 字节的空间</strong>来保存这个长度值；</li>
<li>如果<strong>前一个节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用  <strong>5 字节的空间</strong>来保存这个长度值；</li>
</ul>
<p>encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关：</p>
<ul>
<li>如果<strong>当前节点的数据是整数</strong>，则 encoding 会使用  <strong>1 字节的空间</strong>进行编码。</li>
<li>如果<strong>当前节点的数据是字符串，根据字符串的长度大小</strong>，encoding 会使用  <strong>1 字节/2 字节/5 字节的空间</strong>进行编码。</li>
</ul>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>压缩列表除了查找复杂度高的问题，还有一个问题。</p>
<p><strong>压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降</strong>。</p>
<p>前面提到，压缩列表节点的 prevlen 属性会根据前一个节点的长度进行不同的空间大小分配：</p>
<ul>
<li>如果前一个<strong>节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用  <strong>1 字节的空间</strong>来保存这个长度值；</li>
<li>如果前一个<strong>节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用  <strong>5 字节的空间</strong>来保存这个长度值；</li>
</ul>
<p>现在假设一个压缩列表中有多个连续的、长度在 250 ～ 253 之间的节点，如下图：</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/08968fccc8baa1f596b85c872f3c843c_MD5.png" alt></p>
<p>因为这些节点长度值小于 254 字节，所以 prevlen 属性需要用 1 字节的空间来保存这个长度值。</p>
<p>这时，如果将一个长度大于等于 254 字节的新节点加入到压缩列表的表头节点，即新节点将成为 e1 的前置节点，如下图：</p>
<p><img src="images/Redis6.0学习笔记/96ebc09237508ab25190a507c9978fde_MD5.png" alt></p>
<p>因为 e1 节点的 prevlen 属性只有 1 个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重分配操作，并将 e1 节点的 prevlen 属性从原来的 1 字节大小扩展为 5 字节大小。</p>
<p>多米诺牌的效应就此开始。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6cbf966e531d613a4d3050f5e5235dd2_MD5.png" alt></p>
<p>e1 原本的长度在 250 ～ 253 之间，因为刚才的扩展空间，此时 e1 的长度就大于等于 254 了，因此原本 e2 保存 e1 的 prevlen 属性也必须从 1 字节扩展至 5 字节大小。</p>
<p>正如扩展 e1 引发了对 e2 扩展一样，扩展 e2 也会引发对 e3 的扩展，而扩展 e3 又会引发对 e4 的扩展…. 一直持续到结尾。</p>
<p><strong>这种在特殊情况下产生的连续多次空间扩展操作就叫做「连锁更新」</strong>，就像多米诺牌的效应一样，第一张牌倒下了，推动了第二张牌倒下；第二张牌倒下，又推动了第三张牌倒下….，</p>
<h3 id="压缩列表的缺陷"><a href="#压缩列表的缺陷" class="headerlink" title="压缩列表的缺陷"></a>压缩列表的缺陷</h3><p>空间扩展操作也就是重新分配内存，因此<strong>连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能</strong>。</p>
<p>所以说，<strong>虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题</strong>。</p>
<p>因此，<strong>压缩列表只会用于保存的节点数量不多的场景</strong>，只要节点数量足够小，即使发生连锁更新，也是能接受的。</p>
<p>虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题。</p>
<h2 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h2><p>在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。</p>
<p>其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。</p>
<p>在前面讲压缩列表的时候，我也提到了压缩列表的不足，虽然压缩列表是通过紧凑型的内存布局节省了内存开销，但是因为它的结构设计，如果保存的元素数量增加，或者元素变大了，压缩列表会有「连锁更新」的风险，一旦发生，会造成性能下降。</p>
<p>quicklist 解决办法，<strong>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</strong></p>
<h3 id="quicklist-结构设计"><a href="#quicklist-结构设计" class="headerlink" title="quicklist 结构设计"></a>quicklist 结构设计</h3><p>quicklist 的结构体跟链表的结构体类似，都包含了表头和表尾，区别在于 quicklist 的节点是 quicklistNode。</p>
<pre><code class="lang-c">typedef struct quicklist &#123;
    //quicklist的链表头
    quicklistNode *head;      //quicklist的链表头
    //quicklist的链表头
    quicklistNode *tail; 
    //所有压缩列表中的总元素个数
    unsigned long count;
    //quicklistNodes的个数
    unsigned long len;       
    ...
&#125; quicklist;
</code></pre>
<p>接下来看看，quicklistNode 的结构定义：</p>
<pre><code class="lang-c">typedef struct quicklistNode &#123;
    //前一个quicklistNode
    struct quicklistNode *prev;     //前一个quicklistNode
    //下一个quicklistNode
    struct quicklistNode *next;     //后一个quicklistNode
    //quicklistNode指向的压缩列表
    unsigned char *zl;              
    //压缩列表的的字节大小
    unsigned int sz;                
    //压缩列表的元素个数
    unsigned int count : 16;        //ziplist中的元素个数 
    ....
&#125; quicklistNode;
</code></pre>
<p>可以看到，quicklistNode 结构体里包含了前一个节点和下一个节点指针，这样每个 quicklistNode 形成了一个双向链表。但是链表节点的元素不再是单纯保存元素值，而是保存了一个压缩列表，所以 quicklistNode 结构体里有个指向压缩列表的指针 *zl。</p>
<p>我画了一张图，方便你理解 quicklist 数据结构。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/47fff23194a56091d71d0c6c9c07059b_MD5.png" alt></p>
<p>在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。</p>
<p>quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。</p>
<h2 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h2><p>quicklist 虽然通过控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是并没有完全解决连锁更新的问题。</p>
<p>因为 quicklistNode 还是用了压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，所以要想彻底解决这个问题，需要设计一个新的数据结构。</p>
<p>于是，Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p>
<h3 id="listpack-结构设计"><a href="#listpack-结构设计" class="headerlink" title="listpack 结构设计"></a>listpack 结构设计</h3><p>listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。</p>
<p>我们先看看 listpack 结构：</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cbd68ba65eb3ade3bf61f6c68acaacac_MD5.png" alt></p>
<p>listpack 头包含两个属性，分别记录了 listpack 总字节数和元素数量，然后 listpack 末尾也有个结尾标识。图中的 listpack entry 就是 listpack 的节点了。</p>
<p>每个 listpack 节点结构如下：</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6014f7281be6c8f9b0b5aa14a9351e91_MD5.png" alt></p>
<p>主要包含三个方面内容：</p>
<ul>
<li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li>
<li>data，实际存放的数据；</li>
<li>len，encoding+data 的总长度；</li>
</ul>
<p>可以看到，<strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong>。</p>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><pre><code class="lang-sql">从左边插入一个或多个数据
lpush key_name value1 value2 value3...

例子: lpush k1 v1 v2 v3
     lrange k1 0 -1  //代表取所有
     (1)v3
     (2)v2
     (3)v1

从右边插入一个或多个数据
rpush key_name value1 value2 value3...

在list的某一值前或后插入数据
linsert key_name target_value new_value
</code></pre>
<p>lpush 原理(推箱子):</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>v1</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>v2</th>
<th>v1</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>v3</th>
<th>v2</th>
<th>v1</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>rpush 原理(同理):</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>v1</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>v1</th>
<th>v2</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>v1</th>
<th>v2</th>
<th>v3</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="获取范围内的数据"><a href="#获取范围内的数据" class="headerlink" title="获取范围内的数据"></a>获取范围内的数据</h2><pre><code class="lang-sql">从左边取
lrange key_name start_number end_number  // lrange k1 0 -1 代表list中的全部value

lindex key_name index //取list中的某一索引的值

llen key_name  //获取list长度
</code></pre>
<h2 id="弹出数据"><a href="#弹出数据" class="headerlink" title="弹出数据"></a>弹出数据</h2><pre><code class="lang-sql">rpop/lpop key_name //字面意思从左边或者右边弹出值

rpoppush key1_name key2_name //从key1列表右边吐出一个值,插到key2左边
</code></pre>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><pre><code class="lang-sql">lrem key_name n value // 从左边删除n个value
</code></pre>
<h2 id="数据的替换"><a href="#数据的替换" class="headerlink" title="数据的替换"></a>数据的替换</h2><pre><code class="lang-sql">lset key_name index value //将列表下标为index的值替换为value
</code></pre>
<h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合 )"></a>Set(集合 )</h2><p>Set 是 string 类型的无序集合.底层是一个 value 为 null 的 hash 表,所以添加,删除,查找的复杂度都是 o(0),单位是 menmber(成员)</p>
<p>集合中的值具有唯一性</p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>Set 的数据结构是 dict 字典,字典是用哈希表实现的</p>
<p>在<code>Redis7.2</code>之前，当一个集合满足以下两个条件时，Redis 会选择使用<code>intset</code>编码：</p>
<ul>
<li>集合对象保存的所有元素都是整数值</li>
<li>集合对象保存的元素数量小于等于 512 个（默认）</li>
<li>intset 最大元素数量可在 redis.conf 配置</li>
</ul>
<pre><code class="lang-sql">set-max-intset-entries 512
</code></pre>
<p>为什么加入了<a href="#####listpack">listpack</a><br>在<code>redis7.2</code>之前，<a href="######SDS">sds</a>类型的数据会直接放入到编码结构式为<a href="#####Hash(哈希">hashtable</a>&gt;) 的 set 中。其中，<a href="######SDS">sds</a>其实就是 redis 中的 string 类型。</p>
<p>而在<code>redis7.2</code>之后，<a href="######SDS">sds</a>类型的数据，首先会使用<a href="#####listpack">listpack</a>结构当 set 达到一定的阈值时，才会自动转换为<a href="#####Hash(哈希">hashtable</a>&gt;)。</p>
<p>添加<a href="#####listpack">listpack</a>结构是为了提高内存利用率和操作效率，因为 <a href="#####Hash(哈希">hashtable</a>&gt;) 的空间开销和碰撞概率都比较高。</p>
<h3 id="整数集合-intset"><a href="#整数集合-intset" class="headerlink" title="整数集合(intset)"></a>整数集合(intset)</h3><p>整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不时，就会使用整数集这个数据结构作为底层实现。</p>
<h3 id="整数集合结构设计"><a href="#整数集合结构设计" class="headerlink" title="整数集合结构设计"></a>整数集合结构设计</h3><p>整数集合本质上是一块连续内存空间，它的结构定义如下：</p>
<pre><code class="lang-c">typedef struct intset &#123;
    //编码方式
    uint32_t encoding;
    //集合包含的元素数量
    uint32_t length;
    //保存元素的数组
    int8_t contents[];
&#125; intset;
</code></pre>
<p>可以看到，保存元素的容器是一个 contents 数组，虽然 contents 被声明为 int8_t 类型的数组，但是实际上 contents 数组并不保存任何 int8_t 类型的元素，contents 数组的真正类型取决于 intset 结构体里的 encoding 属性的值。比如：</p>
<ul>
<li>如果 encoding 属性值为 INTSET_ENC_INT16，那么 contents 就是一个 int16_t 类型的数组，数组中每一个元素的类型都是 int16_t；</li>
<li>如果 encoding 属性值为 INTSET_ENC_INT32，那么 contents 就是一个 int32_t 类型的数组，数组中每一个元素的类型都是 int32_t；</li>
<li>如果 encoding 属性值为 INTSET_ENC_INT64，那么 contents 就是一个 int64_t 类型的数组，数组中每一个元素的类型都是 int64_t；</li>
</ul>
<p>不同类型的 contents 数组，意味着数组的大小也会不同。</p>
<h3 id="整数集合的升级操作"><a href="#整数集合的升级操作" class="headerlink" title="整数集合的升级操作"></a>整数集合的升级操作</h3><p>整数集合会有一个升级规则，就是当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，也就是按新元素的类型（int32_t）扩展 contents 数组的空间大小，然后才能将新元素加入到整数集合里，当然升级的过程中，也要维持整数集合的有序性。</p>
<p>整数集合升级的过程不会重新分配一个新类型的数组，而是在原本的数组上扩展空间，然后在将每个元素按间隔类型大小分割，如果 encoding 属性值为 INTSET_ENC_INT16，则每个元素的间隔就是 16 位。</p>
<p>举个例子，假设有一个整数集合里有 3 个类型为 int16_t 的元素。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2a14433f719e4b889e4e56e88ad20a8c_MD5.png" alt></p>
<p>现在，往这个整数集合中加入一个新元素 65535，这个新元素需要用 int32_t 类型来保存，所以整数集合要进行升级操作，首先需要为 contents 数组扩容，<strong>在原本空间的大小之上再扩容多 80 位（4x32-3x16=80），这样就能保存下 4 个类型为 int32_t 的元素</strong>。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/d7bcbee3cd9694a0f73b4186c4aea753_MD5.png" alt></p>
<p>扩容完 contents 数组空间大小后，需要将之前的三个元素转换为 int32_t 类型，并将转换后的元素放置到正确的位上面，并且需要维持底层数组的有序性不变，整个转换过程如下：</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5c956d0733797e86a5f3b4d397d3248a_MD5.png" alt></p>
<blockquote>
<p>整数集合升级有什么好处呢？</p>
</blockquote>
<p>如果要让一个数组同时保存 int16_t、int32_t、int64_t 类型的元素，最简单做法就是直接使用 int64_t 类型的数组。不过这样的话，当如果元素都是 int16_t 类型的，就会造成内存浪费的情况。</p>
<p>整数集合升级就能避免这种情况，如果一直向整数集合添加 int16_t 类型的元素，那么整数集合的底层实现就一直是用 int16_t 类型的数组，只有在我们要将 int32_t 类型或 int64_t 类型的元素添加到集合时，才会对数组进行升级操作。</p>
<p>因此，整数集合升级的好处是<strong>节省内存资源</strong>。</p>
<blockquote>
<p>整数集合支持降级操作吗？</p>
</blockquote>
<p><strong>不支持降级操作</strong>，一旦对数组进行了升级，就会一直保持升级后的状态。比如前面的升级操作的例子，如果删除了 65535 元素，整数集合的数组还是 int32_t 类型的，并不会因此降级为 int16_t 类型。</p>
<h3 id="添加一个或多个数据"><a href="#添加一个或多个数据" class="headerlink" title="添加一个或多个数据"></a>添加一个或多个数据</h3><pre><code class="lang-sql">sadd key_name value1 value2 value3....
</code></pre>
<h3 id="查看集合中所有的数据"><a href="#查看集合中所有的数据" class="headerlink" title="查看集合中所有的数据"></a>查看集合中所有的数据</h3><pre><code class="lang-sql">smembers key_name
</code></pre>
<h3 id="判断集合中是否有某一个值"><a href="#判断集合中是否有某一个值" class="headerlink" title="判断集合中是否有某一个值"></a>判断集合中是否有某一个值</h3><pre><code class="lang-sql">sismember key_name value
</code></pre>
<h3 id="查询集合元素个数"><a href="#查询集合元素个数" class="headerlink" title="查询集合元素个数"></a>查询集合元素个数</h3><pre><code class="lang-sql">scard key_name
</code></pre>
<h3 id="删除集合中的某一元素"><a href="#删除集合中的某一元素" class="headerlink" title="删除集合中的某一元素"></a>删除集合中的某一元素</h3><pre><code class="lang-sql">srem key_name value1 value2 value3...
</code></pre>
<h3 id="在集合中随机弹值"><a href="#在集合中随机弹值" class="headerlink" title="在集合中随机弹值"></a>在集合中随机弹值</h3><pre><code class="lang-sql">spop key_name
</code></pre>
<h3 id="集合中随机取-n-个值"><a href="#集合中随机取-n-个值" class="headerlink" title="集合中随机取 n 个值"></a>集合中随机取 n 个值</h3><pre><code class="lang-sql">srandmember key_name n
</code></pre>
<h3 id="集合间传值"><a href="#集合间传值" class="headerlink" title="集合间传值"></a>集合间传值</h3><pre><code class="lang-sql">smove key1_name key2_name key1_value //相同的值会忽略,但是还是会删除
</code></pre>
<h3 id="集合间取交集"><a href="#集合间取交集" class="headerlink" title="集合间取交集"></a>集合间取交集</h3><pre><code class="lang-sql">sinter key1_name key2_name
</code></pre>
<h3 id="集合间取并集"><a href="#集合间取并集" class="headerlink" title="集合间取并集"></a>集合间取并集</h3><pre><code class="lang-sql">sunion key1_name key2_name
</code></pre>
<h3 id="集合间取差集"><a href="#集合间取差集" class="headerlink" title="集合间取差集"></a>集合间取差集</h3><pre><code class="lang-sql">sdiif key1_name key2_name //key1中有的,不包含key2中的
</code></pre>
<h2 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h2><p>哈希表是一种保存键值对（key-value）的数据结构。</p>
<p>哈希表中的每一个 key 都是独一无二的，程序可以根据 key 查找到与之关联的 value，或者通过 key 来更新 value，又或者根据 key 来删除整个 key-value 等等。</p>
<p>在讲压缩列表的时候，提到过 Redis 的 Hash 对象的底层实现之一是压缩列表（最新 Redis 代码已将压缩列表替换成 listpack）。Hash 对象的另外一个底层实现就是哈希表。</p>
<p>哈希表优点在于，它<strong>能以 O(1) 的复杂度快速查询数据</strong>。怎么做到的呢？将 key 通过 Hash 函数的计算，就能定位数据在表中的位置，因为哈希表实际上是数组，所以可以通过索引值快速查询到数据。</p>
<p>但是存在的风险也是有，在哈希表大小固定的情况下，随着数据不断增多，那么<strong>哈希冲突</strong>的可能性也会越高。</p>
<p>解决哈希冲突的方式，有很多种。</p>
<p><strong>Redis 采用了「链式哈希」来解决哈希冲突</strong>，在不扩容哈希表的前提下，将具有相同哈希值的数据串起来，形成链接起，以便这些数据在表中仍然可以被查询到。</p>
<p>接下来，详细说说哈希表。</p>
<p><strong><em>Hash</em></strong>  类型对应的数据结构是两种：<em><strong>ziplist</strong></em>（压缩列表），<em><strong>hashtable</strong></em>（哈希表）。</p>
<p>当  <strong><em>field-value</em></strong>  长度较短且个数较少时，使用  <strong><em>ziplist</em></strong>，否则使用  <strong><em>hashtable</em></strong>。</p>
<p>hash 是一个 string 类型的 field 和 value 的映射表,hash 特别适合用来储存对象如:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>user</td>
<td><em>field</em></td>
<td><em>value</em></td>
</tr>
<tr>
<td></td>
<td>id</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>name</td>
<td>张三</td>
</tr>
<tr>
<td></td>
<td>age</td>
<td>20</td>
</tr>
</tbody>
</table>
</div>
<p>存储格式</p>
<p>第一种</p>
<p> key value</p>
<p> user: {id:1,name:jack,age:20} 修改太麻烦(不推荐)</p>
<p>第二种</p>
<p> key value</p>
<p> user :id 1</p>
<p> user :name jack</p>
<p> user :age 20</p>
<p>第三种 hash</p>
<p> key value</p>
<p> field value</p>
<p> user id 1</p>
<p>name jack</p>
<p> age 20</p>
<h3 id="哈希表结构设计"><a href="#哈希表结构设计" class="headerlink" title="哈希表结构设计"></a>哈希表结构设计</h3><p>Redis 的哈希表结构如下：</p>
<pre><code class="lang-c">typedef struct dictht &#123;
    //哈希表数组
    dictEntry **table;
    //哈希表大小
    unsigned long size;  
    //哈希表大小掩码，用于计算索引值
    unsigned long sizemask;
    //该哈希表已有的节点数量
    unsigned long used;
&#125; dictht;
</code></pre>
<p>可以看到，哈希表是一个数组（dictEntry **table），数组的每个元素是一个指向「哈希表节点（dictEntry）」的指针。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/b4f2f799a8f80d0c6902ce03ecba5e28_MD5.png" alt></p>
<p>哈希表节点的结构如下：</p>
<pre><code class="lang-c">typedef struct dictEntry &#123;
    //键值对中的键
    void *key;

    //键值对中的值
    union &#123;
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    &#125; v;
    //指向下一个哈希表节点，形成链表
    struct dictEntry *next;
&#125; dictEntry;
</code></pre>
<p>dictEntry 结构里不仅包含指向键和值的指针，还包含了指向下一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对链接起来，以此来解决哈希冲突的问题，这就是链式哈希。</p>
<p>另外，这里还跟你提一下，dictEntry 结构里键值对中的值是一个「联合体 v」定义的，因此，键值对中的值可以是一个指向实际值的指针，或者是一个无符号的 64 位整数或有符号的 64 位整数或 double 类的值。这么做的好处是可以节省内存空间，因为当「值」是整数或浮点数时，就可以将值的数据内嵌在 dictEntry 结构里，无需再用一个指针指向实际的值，从而节省了内存空间。</p>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>哈希表实际上是一个数组，数组里多每一个元素就是一个哈希桶。</p>
<p>当一个键值对的键经过 Hash 函数计算后得到哈希值，再将(哈希值 % 哈希表大小)取模计算，得到的结果值就是该 key-value 对应的数组元素位置，也就是第几个哈希桶。</p>
<blockquote>
<p>什么是哈希冲突呢？</p>
</blockquote>
<p>举个例子，有一个可以存放 8 个哈希桶的哈希表。key1 经过哈希函数计算后，再将「哈希值 % 8 」进行取模计算，结果值为 1，那么就对应哈希桶 1，类似的，key9 和 key10 分别对应哈希桶 1 和桶 6。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/c3755f6a86db3144ddb22682041a6d5a_MD5.png" alt></p>
<p>此时，key1 和 key9 对应到了相同的哈希桶中，这就发生了哈希冲突。</p>
<p>因此，<strong>当有两个以上数量的 kay 被分配到了哈希表中同一个哈希桶上时，此时称这些 key 发生了冲突。</strong></p>
<h3 id="链式哈希"><a href="#链式哈希" class="headerlink" title="链式哈希"></a>链式哈希</h3><p>Redis 采用了「<strong>链式哈希</strong>」的方法来解决哈希冲突。</p>
<blockquote>
<p>链式哈希是怎么实现的？</p>
</blockquote>
<p>实现的方式就是每个哈希表节点都有一个 next 指针，用于指向下一个哈希表节点，因此多个哈希表节点可以用 next 指针构成一个单项链表，<strong>被分配到同一个哈希桶上的多个节点可以用这个单项链表连接起来</strong>，这样就解决了哈希冲突。</p>
<p>还是用前面的哈希冲突例子，key1 和 key9 经过哈希计算后，都落在同一个哈希桶，链式哈希的话，key1 就会通过 next 指针指向 key9，形成一个单向链表。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5cacb138848230dad58b68d7db25a3a0_MD5.png" alt></p>
<p>不过，链式哈希局限性也很明显，随着链表长度的增加，在查询这一位置上的数据的耗时就会增加，毕竟链表的查询的时间复杂度是 O(n)。</p>
<p>要想解决这一问题，就需要进行 rehash，也就是对哈希表的大小进行扩展。</p>
<p>接下来，看看 Redis 是如何实现的 rehash 的。</p>
<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>哈希表结构设计的这一小节，介绍了 Redis 使用 dictht 结构体表示哈希表。不过，在实际使用哈希表时，Redis 定义一个 dict 结构体，这个结构体里定义了<strong>两个哈希表（ht[2]）</strong>。</p>
<pre><code class="lang-c">typedef struct dict &#123;
    …
    //两个Hash表，交替使用，用于rehash操作
    dictht ht[2]; 
    …
&#125; dict;
</code></pre>
<p>之所以定义了 2 个哈希表，是因为进行 rehash 的时候，需要用上 2 个哈希表了。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/c31a25bdb9c38097ef3105cc6203953e_MD5.png" alt></p>
<p>在正常服务请求阶段，插入的数据，都会写入到「哈希表 1」，此时的「哈希表 2 」 并没有被分配空间。</p>
<p>随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：</p>
<ul>
<li>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；</li>
<li>将「哈希表 1 」的数据迁移到「哈希表 2」 中；</li>
<li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。</li>
</ul>
<p>为了方便你理解，我把 rehash 这三个过程画在了下面这张图：</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/103eb10e1f3be076c67f652fc629ed1a_MD5.png" alt></p>
<p>这个过程看起来简单，但是其实第二步很有问题，<strong>如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求</strong>。</p>
<h3 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h3><p>为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了<strong>渐进式 rehash</strong>，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。</p>
<p>渐进式 rehash 步骤如下：</p>
<ul>
<li>给「哈希表 2」 分配空间；</li>
<li><strong>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上</strong>；</li>
<li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间嗲呢，会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。</li>
</ul>
<p>这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作。</p>
<p>在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。</p>
<p>比如，查找一个 key 的值的话，先会在「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。</p>
<p>另外，在渐进式 rehash 进行期间，新增一个 key-value 时，会被保存到「哈希表 2 」里面，而「哈希表 1」 则不再进行任何添加操作，这样保证了「哈希表 1 」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表 1 」就会变成空表。</p>
<h3 id="rehash-触发条件"><a href="#rehash-触发条件" class="headerlink" title="rehash 触发条件"></a>rehash 触发条件</h3><p>介绍了 rehash 那么多，还没说什么时情况下会触发 rehash 操作呢？</p>
<p>rehash 的触发条件跟<strong>负载因子（load factor）</strong>有关系。</p>
<p>负载因子可以通过下面这个公式计算：</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/c61457275db3f8e54e114594d90fcb37_MD5.png" alt></p>
<p>触发 rehash 操作的条件，主要有两个：</p>
<ul>
<li><strong>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。</strong></li>
<li><strong>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</strong></li>
</ul>
<h3 id="存储数据-单个"><a href="#存储数据-单个" class="headerlink" title="存储数据(单个)"></a>存储数据(单个)</h3><pre><code class="lang-sql">hset key_name field_name field_value //给key_name集合中的 field键赋值
</code></pre>
<h3 id="存储数据-多个"><a href="#存储数据-多个" class="headerlink" title="存储数据(多个)"></a>存储数据(多个)</h3><pre><code class="lang-sql">hmset key_name field1_name value1 field2_name value2
</code></pre>
<h3 id="取出数据"><a href="#取出数据" class="headerlink" title="取出数据"></a>取出数据</h3><pre><code class="lang-sql">hget key_name field_name
</code></pre>
<h3 id="取出-key-hash-集合内所有的-field-值"><a href="#取出-key-hash-集合内所有的-field-值" class="headerlink" title="取出 key hash 集合内所有的 field 值"></a>取出 key hash 集合内所有的 field 值</h3><pre><code class="lang-sql">hkeys key_name
</code></pre>
<h3 id="取出-key-hash-集合内所有的-value-值"><a href="#取出-key-hash-集合内所有的-value-值" class="headerlink" title="取出 key hash 集合内所有的 value 值"></a>取出 key hash 集合内所有的 value 值</h3><pre><code class="lang-sql">hvals key_name
</code></pre>
<h3 id="查看-key-中的-field-是否存在"><a href="#查看-key-中的-field-是否存在" class="headerlink" title="查看 key 中的 field 是否存在"></a>查看 key 中的 field 是否存在</h3><pre><code class="lang-sql">hexists key_name field_name
</code></pre>
<h3 id="key-中的-hash-集合中-field-加值"><a href="#key-中的-hash-集合中-field-加值" class="headerlink" title="key 中的 hash 集合中 field 加值"></a>key 中的 hash 集合中 field 加值</h3><pre><code class="lang-sql">hincrby key_name field_name n
</code></pre>
<h3 id="key-中-hash-集合中的-field-值不存在的时候设置一个-field-值"><a href="#key-中-hash-集合中的-field-值不存在的时候设置一个-field-值" class="headerlink" title="key 中 hash 集合中的 field 值不存在的时候设置一个 field 值"></a>key 中 hash 集合中的 field 值不存在的时候设置一个 field 值</h3><pre><code class="lang-sql">hsetnx key_name field_name value
</code></pre>
<h2 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset(有序集合)"></a>Zset(有序集合)</h2><p>Redis 有序集合 zset 与普通合集 set 非常相似,是一个<strong>没有重复元素</strong>的字符串集合</p>
<p>不同之处在于有序集合中的每一个成员都关联了一个评分,这个评分(score)被用来按照从低到高的方式</p>
<p>排序集合中的成员,集合的成员是唯一的,但是评分可以是重复的</p>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>数据结构</strong></p>
<p><strong><em>SortedSet</em></strong>（<strong><em>zset</em></strong>是  <strong><em>Redis</em></strong>  提供的一个非常特别的数据结构，一方面它等价于  <strong><em>Java</em></strong>  的数据结构  <strong><em>Map<String, double></String,></em></strong>，可以给每一个元素  <strong><em>value</em></strong>  赋予一个权重  <strong><em>score</em></strong>，另一方面它又类似于  <strong><em>TreeSet</em></strong>，内部的元素会按照权重  <strong><em>score</em></strong>  进行排序，可以得到每个元素的名次，还可以通过  <strong><em>score</em></strong>  的范围来获取元素的列表。</p>
<p><strong><em>zset</em></strong>  底层使用了两个数据结构</p>
<p>(1) hash(存储成员) field value</p>
<p> member_name score</p>
<p>(2)跳跃表(可以快速找到成员),跳跃表的目的<strong>在于给元素  <em>value</em>  排序，根据  <em>score</em>  的范围获取元素列表</strong><br><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1751903-20220127231807136-1683727598.png" alt></p>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>Redis 只有在 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。</p>
<p>Zset 对象是唯一一个同时使用了两个数据结构来实现的 Redis 对象，这两个数据结构一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。</p>
<pre><code class="lang-c">typedef struct zset &#123;
    dict *dict;
    zskiplist *zsl;
&#125; zset;
</code></pre>
<p>Zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了哈希表进行索引。</p>
<p>接下来，详细的说下跳表。</p>
<h3 id="跳表结构设计"><a href="#跳表结构设计" class="headerlink" title="跳表结构设计"></a>跳表结构设计</h3><p>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是 O(N)，于是就出现了跳表。<strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>，这样的好处是能快读定位数据。</p>
<p>那跳表长什么样呢？我这里举个例子，下图展示了一个层级为 3 的跳表。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/f8033bbd89b988d3588c4567089c0ac2_MD5.png" alt></p>
<p>图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：</p>
<ul>
<li>L0 层级共有 5 个节点，分别是节点 1、2、3、4、5；</li>
<li>L1 层级共有 3 个节点，分别是节点 2、3、5；</li>
<li>L2 层级只有 1 个节点，也就是节点 3 。</li>
</ul>
<p>如果我们要在链表中查找节点 4 这个元素，只能从头开始遍历链表，需要查找 4 次，而使用了跳表后，只需要查找 2 次就能定位到节点 4，因为可以在头节点直接从 L2 层级跳到节点 3，然后再往前遍历找到节点 4。</p>
<p>可以看到，这个查找过程就是在多个层级上跳来跳去，最后定位到元素。当数据量很大时，跳表的查找复杂度就是 O(logN)。</p>
<p>那跳表节点是怎么实现多层级的呢？这就需要看「跳表节点」的数据结构了，如下：</p>
<pre><code class="lang-c">typedef struct zskiplistNode &#123;
    //Zset 对象的元素值
    sds ele;
    //元素权重值
    double score;
    //后向指针
    struct zskiplistNode *backward;

    //节点的level数组，保存每层上的前向指针和跨度
    struct zskiplistLevel &#123;
        struct zskiplistNode *forward;
        unsigned long span;
    &#125; level[];
&#125; zskiplistNode;
</code></pre>
<p>Zset 对象要同时保存元素和元素的权重，对应到跳表节点结构里就是 sds 类型的 ele 变量和 double 类型的 score 变量。每个跳表节点都有一个后向指针，指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。</p>
<p>跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的<strong>zskiplistLevel 结构体类型的 level 数组</strong>。</p>
<p>level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel 结构体表示，比如 leve[0] 就表示第一层，leve[1] 就表示第二层。zskiplistLevel 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离。</p>
<p>比如，下面这张图，展示了各个节点的跨度。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/198958b60ad0ccafb11e375957f696d0_MD5.png" alt></p>
<p>第一眼看到跨度的时候，以为是遍历操作有关，实际上并没有任何关系，遍历操作只需要用前向指针就可以完成了。</p>
<p><strong>跨度实际上是为了计算这个节点在跳表中的排位</strong>。具体怎么做的呢？因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，从头节点点到该结点的查询路径上，将沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排位。</p>
<p>举个例子，查找图中节点 3 在跳表中的排位，从头节点开始查找节点 3，查找的过程只经过了一个层（L3），并且层的跨度是 3，所以节点 3 在跳表中的排位是 3。</p>
<p>另外，图中的头节点其实也是 zskiplistNode 跳表节点，只不过头节点的后向指针、权重、元素值都会被用到，所以图中省略了这部分。</p>
<p>问题来了，由谁定义哪个跳表节点是头节点呢？这就介绍「跳表」结构体了，如下所示：</p>
<pre><code class="lang-c">typedef struct zskiplist &#123;
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
&#125; zskiplist;
</code></pre>
<p>跳表结构里包含了：</p>
<ul>
<li>跳表的头尾节点，便于在 O(1)时间复杂度内访问跳表的头节点和尾节点；</li>
<li>跳表的长度，便于在 O(1)时间复杂度获取跳表节点的数量；</li>
<li>跳表的最大层数，便于在 O(1)时间复杂度获取跳表中层高最大的那个节点的层数量；</li>
</ul>
<h3 id="跳表节点查询过程"><a href="#跳表节点查询过程" class="headerlink" title="跳表节点查询过程"></a>跳表节点查询过程</h3><p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p>
<ul>
<li>如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</li>
<li>如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li>
</ul>
<p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。</p>
<p>举个例子，下图有个 3 层级的跳表。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/a1a86db7c8e46e0c337748a89751d172_MD5.png" alt></p>
<p>如果要查找「元素：abcd，权重：4」的节点，查找的过程是这样的：</p>
<ul>
<li>先从头节点的最高层开始，L2 指向了「元素：abc，权重：3」节点，这个节点的权重比要查找节点的小，所以要访问该层上的下一个节点；</li>
<li>但是该层上的下一个节点是空节点，于是就会跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[1];</li>
<li>「元素：abc，权重：3」节点的 leve[1] 的下一个指针指向了「元素：abcde，权重：4」的节点，然后将其和要查找的节点比较。虽然「元素：abcde，权重：4」的节点的权重和要查找的权重相同，但是当前节点的 SDS 类型数据「大于」要查找的数据，所以会继续跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[0]；</li>
<li>「元素：abc，权重：3」节点的 leve[0] 的下一个指针指向了「元素：abcd，权重：4」的节点，该节点正是要查找的节点，查询结束。</li>
</ul>
<h3 id="跳表节点层数设置"><a href="#跳表节点层数设置" class="headerlink" title="跳表节点层数设置"></a>跳表节点层数设置</h3><p>跳表的相邻两层的节点数量的比例会影响跳表的查询性能。</p>
<p>举个例子，下图的跳表，第二层的节点数量只有 1 个，而第一层的节点数量有 6 个。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/a5f8dc48cd6085bd9b4347740f823bb0_MD5.png" alt></p>
<p>这时，如果想要查询节点 6，那基本就跟链表的查询复杂度一样，就需要在第一层的节点中依次顺序查找，复杂度就是 O(N) 了。所以，为了降低查询复杂度，我们就需要维持相邻层结点数间的关系。</p>
<p><strong>跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)</strong>。</p>
<p>下图的跳表就是，相邻两层的节点数量的比例是 2 : 1。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/f1e5782db076bdb2322e7d7999a19e1a_MD5.png" alt></p>
<blockquote>
<p>那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？</p>
</blockquote>
<p>如果采用新增节点或者删除节点时，来调整跳表节点以维持比例的方法的话，会带来额外的开销。</p>
<p>Redis 则采用一种巧妙的方法是，<strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。</p>
<p>具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</p>
<p>这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。</p>
<h3 id="添加一个或多个成员"><a href="#添加一个或多个成员" class="headerlink" title="添加一个或多个成员"></a>添加一个或多个成员</h3><pre><code class="lang-sql">zadd key_name score1 value1 score2 value2 score3 value3... //score(评分)
</code></pre>
<h3 id="输出范围中的值"><a href="#输出范围中的值" class="headerlink" title="输出范围中的值"></a>输出范围中的值</h3><pre><code class="lang-sql">zrange key_name start_index end_index [withscores] // 0 -1代表输出所有的值
//输出下标在start_index和end_index之间的元素,添加withscores则会将评分(score)一起输出

zrangebyscore key_name min_score max_score [withscore] [limit offset count]
//返回有序集合key中,所有score值介于min和max之间的(包括min或max)成员
//有序集合按score值从小到大的次序排列

zrevrangescore key_name min_score max_score [withscore] [limit offset count]
//返回有序集合key中,所有score值介于min和max之间的(包括min或max)成员
//有序集合按score值大到小 的次序排列
</code></pre>
<h3 id="增加成员的值"><a href="#增加成员的值" class="headerlink" title="增加成员的值"></a>增加成员的值</h3><pre><code class="lang-sql">zincrby key_name incre_number member_name
</code></pre>
<h3 id="删除成员"><a href="#删除成员" class="headerlink" title="删除成员"></a>删除成员</h3><pre><code class="lang-sql">zrem key_name member_name
</code></pre>
<h3 id="统计评分区间的成员个数"><a href="#统计评分区间的成员个数" class="headerlink" title="统计评分区间的成员个数"></a>统计评分区间的成员个数</h3><pre><code class="lang-sql">zcount key_name min_score max_score
</code></pre>
<h3 id="查看成员在集合中的排名"><a href="#查看成员在集合中的排名" class="headerlink" title="查看成员在集合中的排名"></a>查看成员在集合中的排名</h3><pre><code class="lang-sql">zrank key_name member_name //返回索引(索引从0开始)
</code></pre>
<h1 id="Redis6-新数据类型"><a href="#Redis6-新数据类型" class="headerlink" title="Redis6 新数据类型"></a>Redis6 新数据类型</h1><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1751903-20220130095125761-652530924.png" alt></p>
<ul>
<li>将 Bitmaps 数据类型理解为一个数组，每个单位只存储 0 和 1<br>实例：<br><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1751903-20220130095603624-864852729.png" alt></li>
<li>getbit ：获取 Bitmaps 中某个偏移量的值</li>
<li>bitcount [start end]：统计字符串被设置为 1 的 bit 数，start end 可以指定范围，且可以使用负数值，例如：-1 表示最后一个位，-2 表示倒数第二个位置（从 0 开始….）</li>
<li><p>bitop and(or/not/xor) [key…]：复合操作，可以做多个 Bitmaps 的交集、并集等操作，并将结果保存在 destkey 中</p>
<ul>
<li>例如：bitop and users:1 users:2 users:3，将 users:2 与 users:3 的交集结果存放到 key 为 users:1 的值中</li>
</ul>
</li>
</ul>
<p><strong>Bitmaps 与 set 对比</strong><br><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1751903-20220130101108367-1370827612.png" alt><br><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1751903-20220130101116294-825337259.png" alt><br><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1751903-20220130101123120-819954855.png" alt></p>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>[<img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5d72247a2259e41f5c7b5000b203df22_MD5.png" alt="2022-01-30_101307"><br><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4665c8c889132a944c9e552419c10c75_MD5.png" alt><br><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3a14c3695b247825efbc61954ae8f048_MD5.png" alt="-01-30_101721"></p>
<ol>
<li><p>pfadd [element…]：添加指定元素到 HyperLogLog 中，执行命令后，若基数发生变化则返回 1，否则返回 0</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ab32d9ad182ae8aa27e1fd95c0070351_MD5.png" alt="2022-01-30_102109"><br>count [key…]：计算基数值</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/526441d1074ee64c61549efeb303ff66_MD5.png" alt="2022-01-30_102558"><br>merge [其中，sourcekey 可以为多个]：将多个 HyperLogLog 数据类型进行合并，例子比如将月活跃用户数与日活跃用户数进行合并，就可以使用 pfcount 进行统计基数</p>
</li>
</ol>
<h2 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h2><p>[<img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/adcda2a55b7d2013053157499944d00a_MD5.png" alt="2022-01-30_102917"><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4e4ffaf733e4c7f4bd3c3e82cb8d8b16_MD5.png" alt="-01-30_103044"><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/c481d01aa47652b799d3c2dc1da63425_MD5.png" alt="-01-30_103806"><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7ceb5d248ae5038da441c97bdc813bcd_MD5.png" alt="-01-30_103854"><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/def9bb17bc13a23053fc5db4544e9aa9_MD5.png" alt="-01-30_104205"></p>
<h1 id="Redis-的配置文件"><a href="#Redis-的配置文件" class="headerlink" title="Redis 的配置文件"></a>Redis 的配置文件</h1><p>只支持 bytes 不支持 bit</p>
<h2 id="NETWORK"><a href="#NETWORK" class="headerlink" title="NETWORK"></a>NETWORK</h2><h3 id="修改配置以网络连接-默认只能本地连接"><a href="#修改配置以网络连接-默认只能本地连接" class="headerlink" title="修改配置以网络连接(默认只能本地连接)"></a>修改配置以网络连接(默认只能本地连接)</h3><pre><code class="lang-sql">bind 127.0.0.1 -::1 (默认本地连接)
// 用#号注释掉即可允许远程连接

protected-mode yes //保护模式(只允许本机连接) 将yes改为no即可支持远程访问
</code></pre>
<h3 id="Port"><a href="#Port" class="headerlink" title="Port"></a>Port</h3><p>默认 6379</p>
<h3 id="tcp-backlog"><a href="#tcp-backlog" class="headerlink" title="tcp-backlog"></a>tcp-backlog</h3><p><em>默认值 511</em></p>
<p><em>backlog 其实是一个连接队列,backlog 队列的总和=未完成三次握手队列+已完成三次握手的队列</em></p>
<p><em>高并发环境下需要一个高 backlog 来避免慢客户端的连接问题</em></p>
<pre><code class="lang-sql">tcp-backlog 511
</code></pre>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><pre><code class="lang-sql">timeout 0 //客户端未操作指定时间后断开连接 默认值为0(永不过期) 单位为秒
</code></pre>
<h3 id="tcp-keepalive"><a href="#tcp-keepalive" class="headerlink" title="tcp-keepalive"></a>tcp-keepalive</h3><p>检测客户端的 tcp 是否活着(操作) 默认每 300 秒检查一次</p>
<pre><code class="lang-sql">tcp-keepalive 300
</code></pre>
<h2 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a>GENERAL</h2><h3 id="允许后台启动-默认为-no"><a href="#允许后台启动-默认为-no" class="headerlink" title="允许后台启动(默认为 no)"></a>允许后台启动(默认为 no)</h3><pre><code class="lang-sql">daemonize yes
</code></pre>
<h2 id="Limits"><a href="#Limits" class="headerlink" title="Limits"></a>Limits</h2><h3 id="设置最大的客户端连接数"><a href="#设置最大的客户端连接数" class="headerlink" title="设置最大的客户端连接数"></a>设置最大的客户端连接数</h3><pre><code class="lang-sql">maxclients 10000 //默认最大连接数10000
</code></pre>
<h3 id="设置最大的内存占用量"><a href="#设置最大的内存占用量" class="headerlink" title="设置最大的内存占用量"></a>设置最大的内存占用量</h3><pre><code class="lang-sql">maxmemory &lt;bytes&gt;   //达到最大的内存占用数后根据maxmemory-policy规则进行操作
</code></pre>
<h3 id="设置最大内存占用规则"><a href="#设置最大内存占用规则" class="headerlink" title="设置最大内存占用规则"></a>设置最大内存占用规则</h3><pre><code class="lang-sql">maxmemory-policy
</code></pre>
<h1 id="Redis-发布和订阅"><a href="#Redis-发布和订阅" class="headerlink" title="Redis 发布和订阅"></a>Redis 发布和订阅</h1><p><strong><em>Redis</em></strong>  发布订阅（ <strong><em>pub/sub</em></strong> ）是一种消息通信模式：发送者（ <strong><em>pub</em></strong> ）发送消息，订阅者（ <strong><em>sub</em></strong> ）接收消息。</p>
<p><strong><em>Redis</em></strong>  客户端可以订阅任意数量的频道。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/24841c0e421a088d18108f59d08b3bb7_MD5.png" alt="2022-01-30_094007"><br>可以建立许多个频道进行消息的发送（如上图频道 1、频道 2、频道 3），供订阅者进行接收和监听消息。</p>
<ol>
<li>客户端可以订阅频道</li>
</ol>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/b194767a5f6cabe32724636d689a1bf8_MD5.png" alt></p>
<ol>
<li>当给这个频道发布消息后，消息就会发送给订阅的客户端</li>
</ol>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/d759a0c1f90b29e573c5e0dd944c37b4_MD5.png" alt></p>
<p><strong>发布订阅命令行实现</strong></p>
<ol>
<li>打开一个客户端订阅 channel1</li>
</ol>
<ul>
<li>subscribe channel1</li>
</ul>
<ol>
<li>打开另一个客户端，给 channel1 发布消息 hello</li>
</ol>
<ul>
<li><p>publish channel1 hello</p>
</li>
<li><p>返回的数字表示：订阅者的数量、</p>
</li>
</ul>
<ol>
<li>打开第一个客户端可以看到发送的信息</li>
</ol>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5a97d7ca234dc4d8392be731113fcd6a_MD5.png" alt="2022-01-30_094743"><br>发布的消息如果没有持久化，那么在订阅的客户端是接收不到消息的，只能收到订阅后发布的消息</p>
<h2 id="订阅频道"><a href="#订阅频道" class="headerlink" title="订阅频道"></a>订阅频道</h2><pre><code class="lang-sql">SUBSCRIBE channel_name //   返回值为订阅人数
</code></pre>
<h2 id="向频道发送信息"><a href="#向频道发送信息" class="headerlink" title="向频道发送信息"></a>向频道发送信息</h2><pre><code class="lang-sql">publish channel_name message
</code></pre>
<h1 id="Redis6-新数据类型-1"><a href="#Redis6-新数据类型-1" class="headerlink" title="Redis6 新数据类型"></a>Redis6 新数据类型</h1><h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>Bitmap 本身不是一种数据类型,它实际上就是字符串(key-value)</p>
<p>但是它可以对字符串进行位操作</p>
<h1 id="通过-jedis-操作-Redis"><a href="#通过-jedis-操作-Redis" class="headerlink" title="通过 jedis 操作 Redis"></a>通过 jedis 操作 Redis</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ol>
<li>依赖</li>
</ol>
<pre><code class="lang-xml">&lt;dependency&gt;
  &lt;groupId&gt;redis.clients&lt;/groupId&gt;
  &lt;artifactId&gt;jedis&lt;/artifactId&gt;
  &lt;version&gt;3.2.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol>
<li>连接 <strong><em>Redis</em></strong></li>
</ol>
<pre><code class="lang-java">public class JedisDemo &#123;
  public static void main(String[] args) &#123;
    // 创建Jedis对象
    Jedis jedis = new Jedis(&quot;192.168.xx.xxx&quot;, 6379);
    // 测试，能够连接上的话，ping通，会返回一个值
    String ping = jedis.ping();
    System.out.println(&quot;连接成功：&quot; + ping);
    jedis.close();
  &#125;
&#125;
</code></pre>
<p>注意：使用 Jedis 进行操作，需要对 Redis 的网络相关配置文件进行修改：</p>
<ul>
<li><strong>bind：</strong>默认是 bind 绑定本机，不进行修改的情况下，只能接受本机的访问请求，<strong>不写的情况下，能够无限制接受任何 ip 地址的访问。</strong></li>
<li><strong>protected-mode：将本机访问保护模式设置为 no</strong></li>
</ul>
<p>如果出现 <strong>connet timed out</strong> 错误，检查两块，第一是否配置文件进行了修改，第二防火墙是否关闭。</p>
<p><strong><em>key</em></strong></p>
<pre><code class="lang-java">jedis.set(&quot;k1&quot;, &quot;v1&quot;);
 jedis.set(&quot;k2&quot;, &quot;v2&quot;);
jedis.set(&quot;k3&quot;, &quot;v3&quot;);
 Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;); // 返回所有key
System.out.println(keys.size());
System.out.println(key);
&#125;
System.out.println(jedis.exists(&quot;k1&quot;)); // 是否存在
System.out.println(jedis.ttl(&quot;k1&quot;)); // 过期时间
System.out.println(jedis.get(&quot;k1&quot;)); // 获取key对应value值
</code></pre>
<p><strong><em>String</em></strong></p>
<pre><code class="lang-java"> jedis.mset(&quot;str1&quot;,&quot;v1&quot;,&quot;str2&quot;,&quot;v2&quot;,&quot;str3&quot;,&quot;v3&quot;);
 System.out.println(jedis.mget(&quot;str1&quot;,&quot;str2&quot;,&quot;str3&quot;));
</code></pre>
<p><strong><em>List</em></strong></p>
<pre><code class="lang-java">// 可以使用lpush或者rpush添加k-v
List&lt;String&gt; list = jedis.lrange(&quot;mylist&quot;,0,-1);
for (String element : list) &#123;
    System.out.println(element);
&#125;
</code></pre>
<p><strong><em>Set</em></strong></p>
<pre><code class="lang-java">jedis.sadd(&quot;orders&quot;, &quot;order01&quot;);
jedis.sadd(&quot;orders&quot;, &quot;order02&quot;);
jedis.sadd(&quot;orders&quot;, &quot;order03&quot;);
jedis.sadd(&quot;orders&quot;, &quot;order04&quot;);
Set&lt;String&gt; smembers = jedis.smembers(&quot;orders&quot;);
for (String order : smembers) &#123;
    System.out.println(order);
&#125;
jedis.srem(&quot;orders&quot;, &quot;order02&quot;);
</code></pre>
<p><strong><em>Hash</em></strong></p>
<pre><code class="lang-java">jedis.hset(&quot;hash1&quot;,&quot;userName&quot;,&quot;lisi&quot;);
System.out.println(jedis.hget(&quot;hash1&quot;,&quot;userName&quot;));
Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();
map.put(&quot;telphone&quot;,&quot;13810169999&quot;);
map.put(&quot;address&quot;,&quot;atguigu&quot;);
map.put(&quot;email&quot;,&quot;abc@163.com&quot;);
jedis.hmset(&quot;hash2&quot;,map);
List&lt;String&gt; result = jedis.hmget(&quot;hash2&quot;, &quot;telphone&quot;,&quot;email&quot;);
for (String element : result) &#123;
    System.out.println(element);
&#125;
</code></pre>
<p><strong><em>zset</em></strong></p>
<pre><code class="lang-java">jedis.zadd(&quot;zset01&quot;, 100d, &quot;z3&quot;);
jedis.zadd(&quot;zset01&quot;, 90d, &quot;l4&quot;);
jedis.zadd(&quot;zset01&quot;, 80d, &quot;w5&quot;);
jedis.zadd(&quot;zset01&quot;, 70d, &quot;z6&quot;);

Set&lt;String&gt; zrange = jedis.zrange(&quot;zset01&quot;, 0, -1);
for (String e : zrange) &#123;
    System.out.println(e);
&#125;
</code></pre>
<h2 id="模拟验证码发送"><a href="#模拟验证码发送" class="headerlink" title="模拟验证码发送"></a>模拟验证码发送</h2><p>[<img src="images/Redis6.0学习笔记/9f8e2266b7c02f2f0d31021d8f7f4d07_MD5.png" alt="2022-01-30_113532"></p>
<pre><code class="lang-java">public class PhoneCode &#123;
    public static void main(String[] args) &#123;
        // 模拟验证码发送
//        verifyCode(&quot;123456789&quot;);
        getRedisCode(&quot;123456789&quot;, &quot;123456&quot;);
    &#125;

    // 1. 生成6位数字验证码
    public static String getCode()&#123;
        Random random = new Random();
        String code = &quot;&quot;;
        for (int i = 0; i &lt; 6; i++) &#123;
            int nextInt = random.nextInt(10);
            code += nextInt;
        &#125;

        return code;
    &#125;

    // 2. 每个手机每天只能发送三次验证码请求，验证码放到redis中，并设置过期时间
    public static void verifyCode(String phone) &#123;
        // 连接redis
        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);

        // 拼接key
        // 手机发送次数的key
        String countKey = &quot;VerifyCode-&quot; + phone + &quot;:count&quot;;
        // 验证码的key
        String phoneKey = &quot;VerifyCode-&quot; + phone + &quot;:code&quot;;

        // 每个手机每天只能发送三次验证码
        String count = jedis.get(countKey);
        if(count == null) &#123;
            // 之前还没发送过，这次是第一次发送，设置发送次数为1
            jedis.setex(countKey, 24*60*60, &quot;1&quot;); // 设置过期时间为一天
        &#125; else if (Integer.parseInt(count) &lt; 3) &#123;
            // 发送次数加1
            jedis.incr(countKey);
        &#125; else if (Integer.parseInt(count) &gt;= 3) &#123;
            // 发送已经有三次了，不能再发送了
            System.out.println(&quot;今天发送验证码的次数已经达到三次，无法再发送！&quot;);
            jedis.close(); // 关闭连接

            return; // 不执行下面的代码
        &#125;

        // 验证码放到redis中
        String code1 = getCode();
        jedis.setex(phoneKey, 120, code1); // 设置验证码的过期时间为两分钟，会进行覆盖
        jedis.close();
    &#125;

    // 3. 验证码校验
    public static void getRedisCode(String phone, String code)&#123;
        // 连接redis
        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);

        // 拼接key
        // 验证码的key
        String phoneKey = &quot;VerifyCode-&quot; + phone + &quot;:code&quot;;
        // 判断
        String codePhone = jedis.get(phoneKey);
        if(codePhone.equals(code)) &#123;
            System.out.println(&quot;成功！&quot;);
        &#125; else &#123;
            System.out.println(&quot;失败！&quot;);
        &#125;
        jedis.close();
    &#125;
&#125;
</code></pre>
<h2 id="Jedis-主从复制"><a href="#Jedis-主从复制" class="headerlink" title="Jedis 主从复制"></a><em>Jedis</em> 主从复制</h2><pre><code class="lang-java">private static JedisSentinelPool jedisSentinelPool=null;

public static  Jedis getJedisFromSentinel()&#123;

  if(jedisSentinelPool==null)&#123;
    Set&lt;String&gt; sentinelSet=new HashSet&lt;&gt;();
    sentinelSet.add(&quot;172.16.88.168:26379&quot;); // 端口为sentinal
    JedisPoolConfig jedisPoolConfig =new JedisPoolConfig();
    jedisPoolConfig.setMaxTotal(10); // 最大可用连接数
    jedisPoolConfig.setMaxIdle(5); // 最大闲置连接数
    jedisPoolConfig.setMinIdle(5); // 最小闲置连接数
    jedisPoolConfig.setBlockWhenExhausted(true); // 连接耗尽是否等待
    jedisPoolConfig.setMaxWaitMillis(2000); // 等待时间
    jedisPoolConfig.setTestOnBorrow(true); // 取连接的时候进行测试

    jedisSentinelPool=new JedisSentinelPool(&quot;mymaster&quot;,sentinelSet,jedisPoolConfig); // 服务主机名
    return jedisSentinelPool.getResource();
  &#125;
  else &#123;
    return jedisSentinelPool.getResource();
  &#125;
&#125;
</code></pre>
<h2 id="集群的-Jedis-开发"><a href="#集群的-Jedis-开发" class="headerlink" title="集群的 Jedis 开发"></a>集群的 <em>Jedis</em> 开发</h2><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。</p>
<p>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p>
<pre><code class="lang-java">public class JedisClusterTest &#123;
  public static void main(String[] args) &#123;
     // 创建对象
     Set&lt;HostAndPort&gt; set = new HashSet&lt;HostAndPort&gt;();
     set.add(new HostAndPort(&quot;172.16.xx.xxx&quot;,6379)); // 任何一个端口
     JedisCluster jedisCluster = new JedisCluster(set);
     // 操作
     jedisCluster.set(&quot;k1&quot;, &quot;v1&quot;);
     System.out.println(jedisCluster.get(&quot;k1&quot;));
     jedisCluster.close();
  &#125;
&#125;
</code></pre>
<h2 id="SpringBoot-整合-Redis"><a href="#SpringBoot-整合-Redis" class="headerlink" title="SpringBoot 整合 Redis"></a>SpringBoot 整合 Redis</h2><ol>
<li>依赖</li>
</ol>
<pre><code class="lang-xml">&lt;!-- redis --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- 连接池：spring2.X集成redis所需common-pool2--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
  &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
  &lt;version&gt;2.6.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol>
<li>配置文件配置 <strong><em>Redis</em></strong></li>
</ol>
<pre><code class="lang-properties">#Redis服务器地址
spring.redis.host= ip地址
#Redis服务器连接端口
spring.redis.port=6379
#Redis数据库索引（默认为0，一共有16个）
spring.redis.database= 0
#连接超时时间（毫秒）
spring.redis.timeout=1800000
#连接池最大连接数（使用负值表示没有限制）
spring.redis.lettuce.pool.max-active=20
#最大阻塞等待时间(负数表示没限制)
spring.redis.lettuce.pool.max-wait=-1
#连接池中的最大空闲连接
spring.redis.lettuce.pool.max-idle=5
#连接池中的最小空闲连接
spring.redis.lettuce.pool.min-idle=0
</code></pre>
<ol>
<li><strong><em>Redis</em></strong> 配置类（需要继承 <strong><em>CachingConfigurerSupport</em></strong>）</li>
</ol>
<pre><code class="lang-java">@EnableCaching
@Configuration
public class RedisConfig extends CachingConfigurerSupport &#123;
    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();
        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        template.setConnectionFactory(factory);
                // key序列化方式
        template.setKeySerializer(redisSerializer);
                // value序列化
        template.setValueSerializer(jackson2JsonRedisSerializer);
                // value hashmap序列化
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        return template;
    &#125;

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) &#123;
        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
                // 解决查询缓存转换异常的问题
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
                // 配置序列化（解决乱码的问题）,过期时间600秒
        RedisCacheConfiguration config =
          RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofSeconds(600))
      .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))
                .disableCachingNullValues();
        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)
                .cacheDefaults(config)
                .build();
        return cacheManager;
    &#125;
&#125;
</code></pre>
<ol>
<li>测试</li>
</ol>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/864a35245816e530fcd957a9a322e1b7_MD5.png" alt="2022-01-30_122709"></p>
<h1 id="Redis-中的事务操作"><a href="#Redis-中的事务操作" class="headerlink" title="Redis 中的事务操作"></a>Redis 中的事务操作</h1><h2 id="Multi、Exec、discard"><a href="#Multi、Exec、discard" class="headerlink" title="Multi、Exec、discard"></a>Multi、Exec、discard</h2><p>从输入 Multi 命令开始,输入的命令一次进入命令队列,但不会执行,知道输入 Exec 后,Redis 会将之前的命令队列中的命令依次执行</p>
<p>组队的时候可以通过 discard 来放弃组队</p>
<pre><code class="lang-sql">--redis客户端
127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379(TX)&gt;set key1 value1
QUEUED
127.0.0.1:6379(TX)&gt;set key2 value2
QUEUED
127.0.0.1:6379(TX)&gt;exec
1) OK
2) OK
127.0.0.1:6379&gt;


127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379(TX)&gt;set key1 value1
QUEUED
127.0.0.1:6379(TX)&gt;set key2 value2
QUEUED
127.0.0.1:6379(TX)&gt;discard
OK
127.0.0.1:6379&gt;
</code></pre>
<h2 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h2><h3 id="提交错误"><a href="#提交错误" class="headerlink" title="提交错误"></a>提交错误</h3><p>使用 exec 语句提交时,命令队列无法执行</p>
<pre><code class="lang-sql">--redis客户端
127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379(TX)&gt;set key1 value1
QUEUED
127.0.0.1:6379(TX)&gt;set key2 //语句有语法错误
(error) ERR wrong number of arguments for &#39;set&#39; command
127.0.0.1:6379(TX)&gt;exec
(error) EXECABORT Transaction discarded because of previous errors.
127.0.0.1:6379&gt;
</code></pre>
<h3 id="执行错误"><a href="#执行错误" class="headerlink" title="执行错误"></a>执行错误</h3><p>能正确执行 exec 提交,但是命令队列中错误的语句报错</p>
<pre><code class="lang-sql">--redis客户端
127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379(TX)&gt;set key1 value1
QUEUED
127.0.0.1:6379(TX)&gt;incr key1 //此时语句语法正确 但是逻辑不正确
QUEUED
127.0.0.1:6379(TX)&gt;set key2 value2
QUEUED
127.0.0.1:6379(TX)&gt;exec
1) OK
2) (erro)ERR value is not an integer or out of range
3) OK
127.0.0.1:6379&gt;
</code></pre>
<h2 id="事务冲突问题"><a href="#事务冲突问题" class="headerlink" title="事务冲突问题"></a>事务冲突问题</h2><h3 id="悲观-🔒"><a href="#悲观-🔒" class="headerlink" title="悲观 🔒"></a>悲观 🔒</h3><p>每次拿数据的时候都认为其他事务会修改数据,所以每次拿数据的时候都会上 🔒</p>
<p>这样别的事务想拿这个数据就会被 block(阻塞)直到它拿到 🔒</p>
<p>乐观 🔒</p>
<p>在数据上添加版本号,当有事务对数据成功进行更新后同步更新版本号,同时间在进行的事务会将开始事务时</p>
<p>获得的版本号与现在的版本号进行对比,若版本号更新则更新数据后再进行事务的操作</p>
<p>在执行 multi 之前,先执行 watch 指令 ,可以监视一个(或多个)key,如果在事务执行之前这个(或这些)key 被其他命令所改动</p>
<p>那么事务将会被打断(返回 nil)</p>
<pre><code class="lang-sql">watch key1 [key2]
</code></pre>
<h2 id="事务的三特性"><a href="#事务的三特性" class="headerlink" title="事务的三特性"></a>事务的三特性</h2><h3 id="单独隔离操作"><a href="#单独隔离操作" class="headerlink" title="单独隔离操作"></a>单独隔离操作</h3><p> 事务中的所有命令都会序列化、按顺序的执行.事务在执行的过程中,不会</p>
<p> 被其他客户端发送来的命令请求所打断</p>
<h3 id="没有隔离级别"><a href="#没有隔离级别" class="headerlink" title="没有隔离级别"></a>没有隔离级别</h3><p> 队列中的命令么有提交之前都不会实际被执行,因为事务提交前任何指令都</p>
<p> 不会被实际执行</p>
<h3 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h3><p> 事务中有一条命令执行失败,其后命令仍然会被执行,没有回滚</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h3><p>ab 模拟测试</p>
<p>安装:</p>
<pre><code class="lang-sql">yum install httpd-tools
</code></pre>
<h3 id="通过浏览器测试"><a href="#通过浏览器测试" class="headerlink" title="通过浏览器测试"></a>通过浏览器测试</h3><pre><code class="lang-sql">ab -n 1000 -c 100 -p ~/postfile -T application/x-www-form-urlencoded http://192.168.137.1:8080/seckill/doseckil
//ab -n 1000 -c 100 代表1000个请求中有100个是并发操作
//-p ~/postfile 代表此目录下的postfile文件
// -p的意思是提交类型为POST ,-T的意思是 content-type的类型
//http://192.168.137.1:8080/seckill 本地的cotroller方法的路径
</code></pre>
<h3 id="并发出现的问题"><a href="#并发出现的问题" class="headerlink" title="并发出现的问题"></a>并发出现的问题</h3><pre><code class="lang-java">出现秒杀后商品存量为负值(超买超卖)
--乐观锁解决
//监视库存
jedis.watch(kcKey)

//使用事务
Transaction multi = jedis.multi();
//组队操作
multi.decr(kcKey) //kcKey 库存key
multi.sadd(userKey,uid) //秒杀成功的用户uid

并发量太大出现连接超时问题
--使用jedis连接池解决


库存遗留问题(秒杀结束,但是商品未被抢完)
LUA脚本
将复杂的或者多步的redis操作,写为一个脚本,一次提交给redis执行,减少反复连接redis的次数,性能
利用LUA脚本淘汰用户,解决超卖问题
(实际上是redis利用其单线程的特性,用任务队列的方式解决多任务并发问题)
</code></pre>
<h1 id="Redis-中的持久化操作"><a href="#Redis-中的持久化操作" class="headerlink" title="Redis 中的持久化操作"></a>Redis 中的持久化操作</h1><p>Redis 会单独创建(fork)一个子进程来进行持久化,会先将数据写入到一个临时文件中</p>
<p>待持久化过程结束了,再用这个临时文件取替换上次持久化好的文件.整个过程中,主进程</p>
<p>是不进行任何 IO 操作的,这就确保了极高的性能,如果需要进行大规模数据的恢复,且对数据恢复</p>
<p>完整性并不是很敏感,那 RDB 方式要比 AOF 方式更加高效.RDB 的缺点是最后一次持久化后</p>
<p>数据可能会丢失</p>
<h2 id="dump-rdb"><a href="#dump-rdb" class="headerlink" title="dump.rdb"></a>dump.rdb</h2><p>在 redis.conf 中的配置文件,默认为 dump.rdb</p>
<pre><code class="lang-properties">dbfilename dump.rdb
</code></pre>
<p>在指定目录生成 rdb 文件(默认在启动目录生成文件)</p>
<pre><code class="lang-properties">dir ./
</code></pre>
<p>save<br>表示写操作的次数。</p>
<pre><code class="lang-properties">save time num //在time时间(秒)内至少有num个key被改变时执行数据持久化操作
</code></pre>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/98baf70787c7bb0cf81b07b0d0ff3859_MD5.png" alt></p>
<p>redis 无法写入硬盘时停止写入(默认 no)</p>
<pre><code class="lang-properties">stop-writes-on-bgsave-error yes
</code></pre>
<p>对存入到磁盘中的快照是否进行压缩</p>
<pre><code class="lang-properties">rdbcompression yes //使用LZF算法进行压缩 但是会消耗CPU性能
</code></pre>
<p>检查快照完整性</p>
<pre><code class="lang-properties">rdbchecksum yes //开启会有大概10%的数据损耗
</code></pre>
<h2 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h2><p>在指定时间间隔内将内存中的数据集快照写入磁盘</p>
<h2 id="AOF-Append-only-File"><a href="#AOF-Append-only-File" class="headerlink" title="AOF(Append only File)"></a>AOF(Append only File)</h2><p><strong>以日志的形式来记录每个写操作（增量保存）</strong>，将  <strong><em>Redis</em></strong>  执行过的<strong>所有写指令记录下来（读操作不记录）</strong>， <strong>只许追加文件但不可以改写文件</strong>（可能是使用的 redo 和 undo 日志恢复？）。<strong><em>Redis</em></strong>  启动之初会读取该文件重新构建数据，换言之，如果  <strong><em>Redis</em></strong>  重启就会<strong>根据日志文件的内容</strong>将写指令从前到后执行一次，以完成数据的恢复工作。</p>
<p><strong>一种使用追加方式记录数据的方法</strong></p>
<p><strong>执行流程</strong></p>
<ul>
<li><p>客户端的请求写命令会被  <strong><em>append</em></strong>  追加到  <strong><em>AOF</em></strong>  缓冲区内；</p>
</li>
<li><p><strong><em>AOF</em></strong>  缓冲区根据  <strong><em>AOF</em></strong>  持久化策略  <code>[always,everysec,no]</code>  将操作  <strong><em>sync</em></strong>  同步到磁盘的  <strong><em>AOF</em></strong>  文件中；</p>
</li>
<li><p><strong><em>AOF</em></strong>  文件大小超过重写策略或手动重写时，会对  <strong><em>AOF</em></strong>  文件  <strong><em>Rewrite</em></strong>  重写，压缩  <strong><em>AOF</em></strong>  文件容量；</p>
</li>
<li><p><strong><em>Redis</em></strong>  服务重启时，会重新  <strong><em>load</em></strong>  加载  <strong><em>AOF</em></strong>  文件中的写操作达到数据恢复的目的。</p>
</li>
</ul>
<p><strong><em>AOF</em></strong>  和  <strong><em>RDB</em></strong>  同时开启时，系统默认读取  <strong><em>AOF</em></strong>  的数据（数据不会存在丢失）</p>
<h3 id="AOF-开启"><a href="#AOF-开启" class="headerlink" title="AOF 开启"></a>AOF 开启</h3><p>AOF 和 RDB 同时开启后,系统默认取 AOF 数据(数据不会存在丢失)</p>
<p>在 redis.conf 中修改</p>
<pre><code class="lang-properties">appendonly no // 默认为no 启动为yes
</code></pre>
<h3 id="生成路径"><a href="#生成路径" class="headerlink" title="生成路径"></a>生成路径</h3><pre><code class="lang-properties">跟RDB生成路径相同
</code></pre>
<h3 id="异常恢复"><a href="#异常恢复" class="headerlink" title="异常恢复"></a>异常恢复</h3><p>如果遇到 AOF 文件损坏,通过/usr/loacl!/bin/redis-check-aof—fix appendonly.aof 来进行修复</p>
<pre><code class="lang-properties">redis-check-aof --fix appendonly.aof
</code></pre>
<h3 id="AOF-配置"><a href="#AOF-配置" class="headerlink" title="AOF 配置"></a>AOF 配置</h3><p><strong>AOF 同步频率设置</strong></p>
<pre><code class="lang-properties">appendfsync always
//始终同步,每次Redis的写入都会立刻记入日志;性能较差但是数据完整性较好

appendfsync everysec
//每秒同步,每秒记入日志一次,如果宕机,本秒的数据可能丢失
appendfsync no
redis不主动进行同步,把同步时机交给操作系统
</code></pre>
<h3 id="Rewrite-压缩"><a href="#Rewrite-压缩" class="headerlink" title="Rewrite 压缩"></a>Rewrite 压缩</h3><p>AOF 采用文件追加方式,文件会越来越大,为避免出现此种情况,新增了重写机制</p>
<p>当 AOF 文件超过所设定的阈值时,Redis 就会采用 AOF 文件压缩,只保留可以恢复</p>
<p>数据的最小指令集.可以使用命令 bgrewriteaof</p>
<pre><code class="lang-properties">auto-aof-rewrite-min-size:设置重写基准值,最小文件为64位.达到这个值后开始重写
重写后达到前一次重写大小的200%后再次重写
</code></pre>
<p>系统载入或者上次重写完毕时,Redis 会记录此时 AOF 大小,设为 base_size</p>
<p>如果 Redis 的 AOF 当前大小&gt;= base_size + base_size*100% 且当前大小&gt;=64mb(默认)的情况下,Redis 会对 AOF 进行重写</p>
<h2 id="持久化操作总结"><a href="#持久化操作总结" class="headerlink" title="持久化操作总结"></a>持久化操作总结</h2><p>官方推荐两个都启用</p>
<p>如果对数据不敏感,可以单独用 RDB</p>
<p>不建议单独用 AOF ,因为会出现 bug</p>
<p>如果只是做纯内存缓存,可以都不用</p>
<h1 id="Redis-的主从复制"><a href="#Redis-的主从复制" class="headerlink" title="Redis 的主从复制"></a>Redis 的主从复制</h1><p>主服务器进行写操作,从服务器只能进行读操作</p>
<ul>
<li>读写分离,性能拓展</li>
<li>容灾的快速恢复</li>
</ul>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/主服务器.png" alt="主服务器"></p>
<ol>
<li><p>当从服务器连接到主服务器后,从服务器向主服务器发送进行数据同步的消息</p>
</li>
<li><p>主服务器收到消息后对数据进行持久化操作,生成 rdb 文件,再将 rdb 文件发送给</p>
<p>从服务器,从服务器拿到 rdb 文件后进行读取</p>
</li>
<li><p>每次主服务器进行写操作之后,就会和服务器进行数据同步</p>
</li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="查看主机信息"><a href="#查看主机信息" class="headerlink" title="查看主机信息"></a>查看主机信息</h3><pre><code class="lang-sql">info replication
</code></pre>
<h3 id="在从机上设置主机"><a href="#在从机上设置主机" class="headerlink" title="在从机上设置主机"></a>在从机上设置主机</h3><pre><code class="lang-sql">slaveof &lt;主机ip&gt; &lt;主机端口号&gt;
//从服务器挂掉后重启并不能自动连接之前的主服务器,而是恢复成默认(将自己认为是主服务器),必须重新设置
//主服务器挂了后重启还是主服务器,他的从服务器仍不会&quot;篡位&quot;
</code></pre>
<h2 id="搭建一主两从"><a href="#搭建一主两从" class="headerlink" title="搭建一主两从"></a>搭建一主两从</h2><ol>
<li>创建文件目录</li>
</ol>
<pre><code class="lang-bash">/opt/etc
</code></pre>
<ol>
<li>将  <strong><em>redis.conf</em></strong>  复制到当前目录</li>
</ol>
<pre><code class="lang-bash">cp /etc/redis.conf /opt/etc/
</code></pre>
<ol>
<li>创建 3 个  <strong><em>redis.conf</em></strong>  配置文件</li>
</ol>
<pre><code class="lang-shell">redis6379.conf
redis6380.conf
redis6381.conf
</code></pre>
<pre><code class="lang-bash"># redis6379.conf
include /opt/etc/redis.conf
pidfile /var/run/redis_6379.pid
port 6379
dbfilename dump6379.rdb

# redis6380.conf
include /opt/etc/redis.conf
pidfile /var/run/redis_6380.pid
port 6380
dbfilename dump6380.rdb

# redis6381.conf
include /opt/etc/redis.conf
pidfile /var/run/redis_6381.pid
port 6381
dbfilename dump6381.rdb
</code></pre>
<ol>
<li>启动 3 台  <strong><em>redis</em></strong>  服务器</li>
</ol>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/a61843c9cff3fc5e37465663f6c04992_MD5.png" alt></p>
<ol>
<li>查看主机运行情况</li>
</ol>
<pre><code class="lang-shell">info replication
</code></pre>
<p>[<img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/e4e37ad7b3359f9503d8f6a5bb6a78ca_MD5.png" alt></p>
<ol>
<li><p>配从不配主</p>
<p>在从机中进行设置，成为谁的从机</p>
</li>
</ol>
<pre><code class="lang-bash">slaveof  &lt;ip&gt; &lt;port&gt;
# 成为某个实例的从服务器
</code></pre>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/f3c836bf84ad1b0e1ca681047a05668c_MD5.png" alt></p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/b194fcedb26744bd8754a127d2965c87_MD5.png" alt="截屏2021-10-30 15.03.40"></p>
<ol>
<li>再次查看主机运行情况</li>
</ol>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7af0b9003c9361386a0d982ffa66a8d1_MD5.png" alt></p>
<p>成功搭建。</p>
<h2 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h2><p><strong>特点：</strong></p>
<blockquote>
<p>主机  <strong><em>6379</em></strong>，从机  <strong><em>6380</em></strong>  和  <strong><em>6381</em></strong>。</p>
<ol>
<li><p>假设从机  <strong><em>6380</em></strong>  挂掉。（从机挂掉）</p>
<ul>
<li>当 6380 重启后，<strong>6380 不再是 6379 的从机，而是作为新的 master</strong>；（<strong>从机重启后，不再是某个主机的从机，其自身就是一个主机）</strong></li>
<li>当再次把 6380 作为 6379 的从机加入后，从机才会把数据从头到尾复制。<strong>（从机重启后，需要再输入成为从机的指令）</strong></li>
</ul>
</li>
<li><p>假设主机  <strong><em>6379</em></strong>  挂掉。（主机挂掉）</p>
<ul>
<li>6380 和 6381 仍然是 6379 的从机，不会做任何事；<strong>（从机不会改变）</strong></li>
<li>当 6379 重启后，既然是主服务器。<strong>（主机重启后，还是主机）</strong></li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p>完整版：</p>
<ul>
<li><p><strong><em>slave</em></strong>  启动成功连接到  <strong><em>master</em></strong>  后会发送一个  <strong><em>sync</em></strong>  命令（同步命令）。</p>
</li>
<li><p><strong><em>master</em></strong>  接到命令启动后台的存盘进程，对数据进行持久化操作，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<strong><em>master</em></strong>  将传送整个数据文件（<em><strong>rdb</strong></em>）到  <strong><em>slave</em></strong>，以完成一次完全同步。</p>
</li>
<li><p>当主服务进行写操作后，和从服务器进行数据同步。</p>
</li>
<li><p><strong>全量复制</strong>：而  <strong><em>slave</em></strong>  服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
</li>
<li><p><strong>增量复制</strong>：<strong><em>master</em></strong>  继续将新的所有收集到的修改命令依次传给  <strong><em>slave</em></strong>，完成同步。</p>
</li>
<li><p>只要是重新连接  <strong><em>master</em></strong>，一次完全同步（全量复制）将被自动执行。</p>
</li>
</ul>
<blockquote>
<p>全量复制：是从机主动去请求主机进行同步操作，是一开始连接的时候</p>
<p>增量复制：主机进行一次写操作之后，就主动同步从机</p>
</blockquote>
<p>简洁版：</p>
<p>[<img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/b262ce0098d5b031b8258015816612d9_MD5.png" alt="2022-01-31_111926"></p>
<h2 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h2><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/薪火相传.png" alt></p>
<p>上一个  <strong><em>slave</em></strong>  可以是下一个  <strong><em>slave</em></strong>  的  <strong><em>master</em></strong>（<strong>从机是另一个从机的主机，并由这个担任主机的从机，进行数据同步</strong>），<strong><em>slave</em></strong>  同样可以接收其他  <strong><em>slave</em></strong>的连接和同步请求，那么该  <strong><em>slave</em></strong>  作为了链条中下一个的  <strong><em>master</em></strong>，可以有效减轻  <strong><em>master</em></strong>  的写压力，去中心化降低风险。</p>
<pre><code class="lang-xml">slaveof &lt;ip&gt; &lt;port&gt;
</code></pre>
<ul>
<li><p>特点与一主二从类似</p>
</li>
<li><p>中途变更转向：会清除之前的数据，重新建立拷贝最新的。</p>
</li>
<li><p>当某个担任主机的  <strong><em>slave</em></strong>  宕机，其挂在后面的  <strong><em>slave</em></strong>  都没法备份。</p>
<ul>
<li>即当主机挂掉，从机还是从机，但是无法继续写数据。</li>
</ul>
</li>
</ul>
<h3 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h3><p>大哥挂了小弟立马上位(主服务器挂了,从服务器变成主服务器)</p>
<pre><code class="lang-sql">slaveof no one  //将从机设置为主机 必须我们在从机手动设置
</code></pre>
<h3 id="哨兵模式-反客为主自动版"><a href="#哨兵模式-反客为主自动版" class="headerlink" title="哨兵模式(反客为主自动版)"></a>哨兵模式(反客为主自动版)</h3><p>反客为主自动版,能够后台监控主机是否故障,如果故障了根据投票数自动将从库转换为主库</p>
<p>规则:</p>
<ol>
<li>优先级:值越小优先级越高</li>
<li>偏移量:获得原主机数据最全的</li>
<li>runid:每个 redis 实例启动后都会生成一个随机的 runid</li>
</ol>
<pre><code class="lang-sql">--在自定义的/myredis目录下新建sentinel.conf文件,名字绝对不能错

--在文件中配置哨兵,填写内容
sentinel monitor mymaster 127.0.0.1 6379 1 //  mymaster是为监控对象起的服务器名称,1为至少有多少个哨兵同意迁移的数量



启动
redis-sentinel /myredis/sentinel.conf

从服务器的优先级在redis.conf中默认
slave-priority 100 --值越小优先度越高
</code></pre>
<p><strong>主机挂掉，哨兵监控到之后，会按照选举规则，从 从机 中选举中产生新的主机，原来挂掉的主机会变成新主机的从机</strong>。</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8eeef98de5e5e1fba8a4ff71871035ae_MD5.png" alt="2022-01-31_120213"></p>
<h3 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h3><p>选择条件依次为：</p>
<ul>
<li><p>根据优先级别，<em><strong>slave-priority/replica-priority</strong></em>，<strong>优先选择优先级靠前</strong>的。（越小优先级越高）</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/f65c3ee1d6b39e4c363bb68be630329c_MD5.png" alt></p>
</li>
<li><p>根据偏移量，<strong>优先选择偏移量大</strong>的。（偏移量是指获得原主机数据最全的）</p>
</li>
<li><p>若前两个条件相同，那么选择  <strong><em>runid</em></strong>  最小的，<strong>优先选择最小的服务</strong></p>
<ul>
<li>每个 redis 实例启动后，都会随机生成一个 40 位的 runid</li>
</ul>
</li>
</ul>
<h3 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h3><p>由于所有的写操作都是先在  <strong><em>master</em></strong>  上操作，然后同步更新到  <strong><em>slave</em></strong>  上，所以从  <strong><em>master</em></strong>  同步到  <strong><em>slave</em></strong>  从机有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，<strong><em>slave</em></strong>  机器数量的增加也会使这个问题更加严重。</p>
<h1 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h1><p>容量不够,redis 如何进行扩容?</p>
<p>并发操作,redis 如何分摊?</p>
<p>解决方法:<strong>无中心化集群</strong></p>
<h2 id="代理服务器模式"><a href="#代理服务器模式" class="headerlink" title="代理服务器模式"></a>代理服务器模式</h2><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/代理服务器.png" alt></p>
<h2 id="无中心化集群模式"><a href="#无中心化集群模式" class="headerlink" title="无中心化集群模式"></a>无中心化集群模式</h2><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/订单服务器.png" alt="订单服务器"></p>
<h2 id="无中心化集群配置"><a href="#无中心化集群配置" class="headerlink" title="无中心化集群配置"></a>无中心化集群配置</h2><pre><code class="lang-properties">//redis.conf中进行配置

cluster-enbled yes --打开集群模式

cluster-config-file nodes-6379.conf --设定节点配置文件名,自定义

cluster-node-timeout 15000 设定节点失联时间,超过该时间(毫秒),集群自动进行主从切换
</code></pre>
<h3 id="合体"><a href="#合体" class="headerlink" title="合体"></a>合体</h3><p>进入 redis 的主目录下的 src 目录</p>
<pre><code class="lang-properties">redis-cli --cluster create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391

--replicacs 1 采用最简单的方式配集群,一台主机,一台从机正好三组
</code></pre>
<p>以集群的方式连接 Redis</p>
<pre><code class="lang-properties">redis-cli -c -p 6379 // -c是以集群的策略连接Redis  -p是连接到6379端口(从服务器)
这时候在从服务器中执行写操作,Redis集群会自动切换到集群中的写服务器(主服务器 )
</code></pre>
<p>查看集群中的服务器信息</p>
<pre><code class="lang-shell">cluster nodes
</code></pre>
<h3 id="集群如何分配系节点"><a href="#集群如何分配系节点" class="headerlink" title="集群如何分配系节点"></a>集群如何分配系节点</h3><p>一个集群至少要有<strong>三个主节点</strong></p>
<p>选项—cluster-reolicas 1 表示我们希望为集群中的每一个主节点创建一个从节点</p>
<p>插槽(slot)</p>
<p>一个 Redis 集群中包含 16384 个插槽,数据库中的每个键都属于这 16384 个插槽的其中一个</p>
<p>集群使用 CRC16(key)%16384 来计算键 key 属于哪个槽,其中 CRC16(key)语句用于计算键</p>
<p>key 的 CRC16 的校验和</p>
<p>集群中的每个节点负责处理一部分插槽.举个例子,如果一个集群可以有主节点,其中:</p>
<p>节点 A 负责处理 0 号至 5460 号插槽</p>
<p>节点 B 负责处理 5461 号至 10922 号插槽</p>
<p>节点 C 负责处理 10923 号至 16384 号插槽</p>
<p>在集群中设置多个值</p>
<pre><code class="lang-sql">&gt; mset name lucy age 20 address china
&gt;(error) CROSSSLOT Keys in request don&#39;t hash to the same slot
&gt; mset name&#123;user&#125; lucy age&#123;user&#125; 20 address(user) china //为这些值设置一个共同的组
</code></pre>
<p>查询集群中的值</p>
<pre><code class="lang-shell">cluster keyslot key_name
返回值为插槽值
</code></pre>
<p>故障恢复</p>
<pre><code class="lang-sql">//redis.conf

cluster-require-full-coverage yes/no --yes(如果某段插槽的主从服务器全部挂掉,那么整个集群都挂掉)
                                     --no(如果某一段插槽的主从都挂掉,那么该插槽数据全部不能使用,也无法存储)
</code></pre>
<h2 id="集群的-Jedis-开发-1"><a href="#集群的-Jedis-开发-1" class="headerlink" title="集群的 Jedis 开发"></a>集群的 Jedis 开发</h2><pre><code class="lang-java">HostAndPort hostAndPort =  new HostAndPort(&quot;集群中任意服务器的IP地址&quot;,集群中任意服务器的端口号)
JedisCluster jediscluster = new Jediscluster(hostAndPort)
jedisCluster.set(&quot;b1&quot;,&quot;value1&quot;) //设置值
String value = jedisCluster.get(&quot;b1&quot;) //取值
jedisCluster.close()
</code></pre>
<h1 id="Redis-应用问题的解决"><a href="#Redis-应用问题的解决" class="headerlink" title="Redis 应用问题的解决"></a>Redis 应用问题的解决</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/f8f1086b9bab7ef3489a4e5281b194b7_MD5.png" alt="img"></p>
<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p><strong><em>key</em></strong> 对应的数据在数据源并不存在，每次针对此 <strong><em>key</em></strong> 的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。</p>
<p>redis 查询不到数据库，出现了很多非正常 url 访问。黑客攻击就是通过查询一个不存在的值，缓存里面没有，那么就会查数据库，大量类似的请求发生后，导致数据库崩溃。若黑客利用此漏洞进行攻击可能压垮数据库。</p>
<p>造成的条件：</p>
<ol>
<li>应用服务器压力变大，访问请求增光</li>
<li><strong>*redis* 命中率下降</strong>（重点）</li>
<li>导致一直访问查询数据库</li>
</ol>
<blockquote>
<p>服务器压力变大，请求太多，导致 redis 缓存命中率开始下降，对数据库的访问越来越多，数据库最终承受不住压力，崩溃了。</p>
</blockquote>
<h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><ul>
<li><p><strong>对空值缓存</strong></p>
<p>如果一个查询返回的数据为空（不管是数据是否不存在），仍然把这个空结果（<strong><em>null</em></strong>）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</p>
</li>
<li><p><strong>设置可访问的名单（白名单）：</strong></p>
<p>使用 <strong><em>bitmaps</em></strong> 类型定义一个可以访问的名单，名单 <strong><em>id</em></strong> 作为 <strong><em>bitmaps</em></strong> 的偏移量，每次访问和 <strong><em>bitmap</em></strong> 里面的 <strong><em>id</em></strong> 进行比较，如果访问 <strong><em>id</em></strong> 不在 <strong><em>bitmaps</em></strong> 里面，进行拦截，则不允许访问。</p>
</li>
<li><p><strong>采用布隆过滤器</strong></p>
<p>布隆过滤器（<strong><em>Bloom Filter</em></strong>）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数）。（跟 bitmaps 类似，不过效率更高）</p>
<p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的<strong>优点是空间效率和查询时间都远远超过一般的算法</strong>，<strong>缺点是有一定的误识别率和删除困难，命中率不一定高</strong>。</p>
<p>将所有可能存在的数据哈希到一个足够大的 <strong><em>bitmaps</em></strong> 中，一个一定不存在的数据会被这个 <strong><em>bitmaps</em></strong> 拦截掉，从而避免了对底层存储系统的查询压力。</p>
</li>
<li><p><strong>进行实时监控</strong></p>
<p>当发现 <strong><em>Redis</em></strong> 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以<strong>设置黑名单限制服务</strong>。</p>
</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/e4a18d9d357bd8a6af6750916a0c43a5_MD5.png" alt="img"></p>
<blockquote>
<p>注意与缓存穿透的区别：</p>
<ul>
<li>缓存穿透<ul>
<li>redis 命中率下降，导致数据库访问量激增</li>
</ul>
</li>
<li>缓存击穿<ul>
<li>redis 正常访问，但某个热点 key 突然失效，导致瞬间数据库的访问量激增</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h3><p><strong><em>key</em></strong> 对应的数据存在，但在 <strong><em>redis</em></strong> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端<strong><em>DB</em></strong> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <strong><em>DB</em></strong> 压垮。</p>
<ol>
<li>数据库访问压力瞬间增大</li>
<li><strong><em>redis</em></strong> 中没有出现大量 <strong><em>key</em></strong> 过期，<strong><em>redis 正常运行</em></strong>（与缓存穿透的区别）</li>
<li><strong>某个经常访问的 *key*，即十分热点的 key，不停地被大量访问，当这个 key 过期的瞬间，持续的高并发就击穿了缓存，大量请求数据库，导致数据库奔溃</strong></li>
</ol>
<h3 id="如何解决-1"><a href="#如何解决-1" class="headerlink" title="如何解决"></a>如何解决</h3><ul>
<li><p><strong>预先设置热门数据</strong></p>
<p>在 <strong><em>redis</em></strong> 高峰访问之前，把一些热门数据提前存入到 <strong><em>redis</em></strong> 里面，<strong>加大这些热门数据 *key* 的时长</strong>。</p>
</li>
<li><p><strong>实时调整</strong></p>
<p>现场监控哪些数据热门，实时调整 <strong><em>key</em></strong> 的过期时长。</p>
</li>
<li><p><strong>使用锁</strong></p>
</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/73e0f4659d0effe60dc6312df76c83ac_MD5.png" alt></p>
<h2 id="现象-2"><a href="#现象-2" class="headerlink" title="现象"></a>现象</h2><p><strong><em>key</em></strong> 对应的数据存在，但在 <strong><em>redis</em></strong> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期后，一般都会从后端 <strong><em>DB</em></strong> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <strong><em>DB</em></strong> 压垮。</p>
<p>缓存雪崩与缓存击穿的区别在于这里针对很多 <strong><em>key</em></strong> 缓存，前者则是某一个 <strong><em>key</em></strong>。</p>
<ol>
<li>数据库压力变大</li>
<li><strong>极少的时间段，查询大量 *key* 的集中过期情况</strong>（大量 key 集中过期，而缓存击穿是热点 key 过期）</li>
</ol>
<h3 id="如何解决-2"><a href="#如何解决-2" class="headerlink" title="如何解决"></a>如何解决</h3><ul>
<li><p><strong>构建多级缓存架构</strong></p>
<p><strong><em>nginx</em></strong> 缓存 + <strong><em>redis</em></strong> 缓存 + 其他缓存（<strong><em>ehcache</em></strong>等）</p>
</li>
<li><p><strong>使用锁或队列：</strong></p>
<p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。<strong>不适用高并发情况</strong>。</p>
</li>
<li><p><strong>设置过期标志更新缓存：</strong></p>
<p><strong>记录缓存数据是否过期（设置提前量）</strong>，快过期的时候，提前进行一个缓存。如果过期会触发通知另外的线程在后台去更新实际 <strong><em>key</em></strong> 的缓存。</p>
</li>
<li><p><strong>将缓存失效时间分散开：</strong></p>
<p>比如我们可以在原有的失效时间基础上增加一个随机值，比如 1 ～ 5 分钟随机，这样<strong>每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件</strong>。</p>
</li>
</ul>
<h1 id="分布式锁-共享锁"><a href="#分布式锁-共享锁" class="headerlink" title="分布式锁(共享锁)"></a>分布式锁(共享锁)</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，<strong>由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效</strong>，单纯的 Java API 并不能提供分布式锁的能力。为了解决这个问题就需要<strong>一种跨 JVM 的互斥机制来控制共享资源的访问</strong>，这就是分布式锁要解决的问题。</p>
<p>分布式锁主流的实现方案：</p>
<ul>
<li>基于数据库实现分布式锁</li>
<li>基于缓存（Redis 等）</li>
<li>基于 Zookeeper</li>
</ul>
<p>每一种分布式锁解决方案都有各自的优缺点：</p>
<ul>
<li>性能：redis 最高</li>
<li>可靠性：zookeeper 最高</li>
</ul>
<h2 id="设置锁以及过期时间"><a href="#设置锁以及过期时间" class="headerlink" title="设置锁以及过期时间"></a>设置锁以及过期时间</h2><ul>
<li>设置锁的命令</li>
</ul>
<pre><code class="lang-java">SETNX KEY VALUE  # 设置锁
del key   # 删除锁
</code></pre>
<ul>
<li>给锁设置过期时间</li>
</ul>
<pre><code class="lang-java">expire users 30 # 给users上锁30s
</code></pre>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/82ff822ff8ec8ca52e620cee68928647_MD5.png" alt="2022-01-31_151329"></p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9c611885258374eb5056e3ae5d4b60ae_MD5.png" alt="-01-31_151536"></p>
<p>上锁的同时设置过期时间</p>
<pre><code class="lang-java">set key value nx ex time # nx 上锁；ex 设置过期时间
</code></pre>
<ul>
<li>Java 实现</li>
</ul>
<pre><code class="lang-java">@GetMapping(&quot;testLock&quot;)
public void testLock()&#123;
    //1获取锁，setne ,顺便设置过期时间
    Boolean lock = redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;111&quot;,3,TimeUnit.SECONDS); // key, value, 过期时间，时间单位
    //2获取锁成功、查询num的值
    if(lock)&#123;
        Object value = redisTemplate.opsForValue().get(&quot;num&quot;);
        //2.1判断num为空return
        if(StringUtils.isEmpty(value))&#123;
            return;
        &#125;
        //2.2有值就转成成int
        int num = Integer.parseInt(value+&quot;&quot;);
        //2.3把redis的num加1
        redisTemplate.opsForValue().set(&quot;num&quot;, ++num);
        //2.4释放锁，del
        redisTemplate.delete(&quot;lock&quot;);

    &#125;else&#123;
        //3获取锁失败、每隔0.1秒再获取
        try &#123;
            Thread.sleep(100); // 休眠，等一会
            testLock(); // 再去尝试获取锁
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="分布式锁产生的问题"><a href="#分布式锁产生的问题" class="headerlink" title="分布式锁产生的问题"></a>分布式锁产生的问题</h2><h3 id="使用-UUID-防止误删锁"><a href="#使用-UUID-防止误删锁" class="headerlink" title="使用 UUID 防止误删锁"></a>使用 UUID 防止误删锁</h3><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022-01-31_152914.png" alt="2022-01-31_152914"></p>
<p><strong>现象</strong></p>
<p>a 先上锁后，在执行操作的过程中，服务器卡顿，而 10 秒过期后，b 抢到锁进行具体操作，然而此时 a 的服务器恢复正常，a 继续执行操作并结束，此时有一个释放锁的操作，那么此时释放的锁是 b 的锁，这就是导致误删除锁的现象发生。</p>
<p><strong>解决方案</strong></p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4fa0c163933ece70106a9d22813c9f91_MD5.png" alt="2022-01-31_153659"></p>
<p>现修改版：</p>
<pre><code class="lang-java">@GetMapping(&quot;testLock&quot;)
public void testLock()&#123;
    // 设置UUID
    String uuid = UUID.randomUUID().toString();
    .....
    if(lock)&#123;
       ...
        // 判断UUID值是否一样
        String lockUuid = (String)redisTemplate.opsForValue().get(&quot;lock&quot;);
        if(uuid.equals(lockUuid))&#123; // UUID一样时，才释放锁
             //2.4释放锁，del
            redisTemplate.delete(&quot;lock&quot;);
        &#125;
    &#125;else&#123;
       ...
    &#125;
&#125;
</code></pre>
<h3 id="Lua-保证删除原子性"><a href="#Lua-保证删除原子性" class="headerlink" title="Lua 保证删除原子性"></a>Lua 保证删除原子性</h3><p>问题：<strong>删除操作缺乏原子性，即 uuid 的比较操作和删除操作不是原子操作</strong></p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9e22048deefb586b50b938f7f46ae9e9_MD5.png" alt="2022-01-31_154515"></p>
<p>现修改：</p>
<pre><code class="lang-java">@GetMapping(&quot;testLockLua&quot;)
public void testLockLua() &#123;
    //1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中
    String uuid = UUID.randomUUID().toString();

    //2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！
    String skuId = &quot;25&quot;; // 访问skuId 为25号的商品 100008348542
    String locKey = &quot;lock:&quot; + skuId; // 锁住的是每个商品的数据

    // 3 获取锁
    Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid, 3, TimeUnit.SECONDS);

    // 第一种： lock 与过期时间中间不写任何的代码。
    // redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);//设置过期时间
    // 如果true
    if (lock) &#123;
        // 执行的业务逻辑开始
        // 获取缓存中的num 数据
        Object value = redisTemplate.opsForValue().get(&quot;num&quot;);
        // 如果是空直接返回
        if (StringUtils.isEmpty(value)) &#123;
            return;
        &#125;
        // 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！
        int num = Integer.parseInt(value + &quot;&quot;);
        // 使num 每次+1 放入缓存
        redisTemplate.opsForValue().set(&quot;num&quot;, String.valueOf(++num));

        /*使用lua脚本来锁*/

        // 定义lua 脚本
        String script = &quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot;;

        // 使用redis执行lua执行
        DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;();
        redisScript.setScriptText(script);
        // 设置一下返回值类型 为Long
        // 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，
        // 那么返回字符串与0 会有发生错误。
        redisScript.setResultType(Long.class);
        // 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。
        redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid);

    &#125; else &#123;
        .....
    &#125;
&#125;
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了确保分布式锁可用，我们<strong>至少要确保锁的实现同时满足以下四个条件</strong>：</p>
<ul>
<li><p>互斥性。<strong>在任意时刻，只有一个客户端能持有锁</strong>。</p>
</li>
<li><p><strong>不会发生死锁</strong>。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</p>
</li>
<li><p>解铃还须系铃人。<strong>加锁和解锁必须是同一个客户端</strong>，客户端自己不能把别人加的锁给解了。</p>
</li>
<li><p><strong>加锁和解锁必须具有原子性</strong>。</p>
</li>
</ul>
<h1 id="Redis6-的新功能"><a href="#Redis6-的新功能" class="headerlink" title="Redis6 的新功能"></a>Redis6 的新功能</h1><h2 id="ACL-访问控制列表"><a href="#ACL-访问控制列表" class="headerlink" title="ACL(访问控制列表)"></a>ACL(访问控制列表)</h2><p>将用户的权限进行更细粒度的权限控制</p>
<p>(1),接入权限:用户名,密码</p>
<p>(2)用户可执行的命令</p>
<p>(3)用户可以操作的 key</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><pre><code>acl list //展现当前所有用户的信息
acl cat  //查看具体操作的指令列表
acl setuser user_name //添加用户以及权限
acl whoami //查看当前用户名
</code></pre><h1 id="模拟秒杀"><a href="#模拟秒杀" class="headerlink" title="模拟秒杀"></a>模拟秒杀</h1><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>核心的逻辑代码：</p>
<pre><code class="lang-java">public class SecKill_redis &#123;

    public static void main(String[] args) &#123;
        Jedis jedis =new Jedis(&quot;192.168.242.110&quot;,6379);
        System.out.println(jedis.ping());
        jedis.close();
    &#125;

    //秒杀过程
    public static boolean doSecKill(String uid,String prodid) throws IOException &#123;
        //1 uid和prodid非空判断
        if(uid == null || prodid == null)&#123;
            return false;
        &#125;

        //2 连接redis
        Jedis jedis =new Jedis(&quot;192.168.xx.xxx&quot;,6379);

        //3 拼接key
        // 3.1 库存key
        String kcKey = &quot;sk:&quot;+prodid+&quot;:qt&quot;;
        // 3.2 秒杀成功用户key
        String userKey = &quot;sk:&quot;+prodid+&quot;:user&quot;;

        //4 获取库存，如果库存null，秒杀还没有开始
        String kc = jedis.get(kcKey);
        if(kc == null)&#123;
            System.out.println(&quot;秒杀还没开始，请稍等&quot;);
            jedis.close();
            return false;
        &#125;

        // 5 判断用户是否重复秒杀操作
        if(jedis.sismember(userKey, uid))&#123;
            System.out.println(&quot;每个用户只能秒杀成功一次，请下次再来&quot;);
            jedis.close();
            return false;
        &#125;

        //6 判断如果商品数量，库存数量小于1，秒杀结束
        if(Integer.parseInt(kc) &lt; 1)&#123;
            System.out.println(&quot;秒杀结束，请下次参与&quot;);
            jedis.close();
            return false;
        &#125;

        //7 秒杀过程
        //7.1库存-1
        jedis.decr(kcKey);
        //7.2 把秒杀成功的用户添加到清单里面
        jedis.sadd(userKey,uid);
        System.out.println(&quot;用户&quot; + uid + &quot;秒杀成功&quot;);
        jedis.close();
        return true;
    &#125;
&#125;
</code></pre>
<h2 id="使用-ab-工具模拟并发以及暴露出的问题"><a href="#使用-ab-工具模拟并发以及暴露出的问题" class="headerlink" title="使用 ab 工具模拟并发以及暴露出的问题"></a>使用 ab 工具模拟并发以及暴露出的问题</h2><blockquote>
<p>CentOS 6 默认安装</p>
<p>CentOS 7 手动安装（yum -y install httpd-tools）</p>
</blockquote>
<ul>
<li><p>通过 ab 命令发送并发操作</p>
<pre><code class="lang-java">ab -n 2000 -c 200 -k -p ~/postfile -T application/x-www-form-urlencoded http://192.168.0.43:8080/Seckill/doseckill
</code></pre>
<p>-n：测试会话中所执行的请求个数</p>
<p>-c：一次产生的请求个数</p>
</li>
<li><p>并发暴露出来的问题</p>
<ul>
<li><p>会出现<strong>超卖问题</strong>：卖完了商品，但还存在继续购买，即库存变为负数</p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/bd88f0c555d2ebca992b86b7140ad08f_MD5.png" alt="2022-01-30_203603"></p>
<ul>
<li><p>解决方案：使用<strong>乐观锁</strong>，进行版本控制<strong>（redis 事务+watch）</strong></p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3b1e161138b4eb786b74ddef177fe9fc_MD5.png" alt="2022-01-30_204947"><br>代码修改：</p>
<pre><code class="lang-java">//秒杀过程
public static boolean doSecKill(String uid,String prodid) throws IOException &#123;
    //1 uid和prodid非空判断
    if(uid == null || prodid == null)&#123;
        return false;
    &#125;

    //2 连接redis
    //Jedis jedis =new Jedis(&quot;192.168.xx.xxx&quot;,6379);

    //通过连接池获取连接redis的对象
    JedisPool jedisPoolInstance = JedisPoolUtil.getJedisPoolInstance();
    Jedis jedis = jedisPoolInstance.getResource();

    //3 拼接key
    // 3.1 库存key
    String kcKey = &quot;sk:&quot;+prodid+&quot;:qt&quot;;
    // 3.2 秒杀成功用户key
    String userKey = &quot;sk:&quot;+prodid+&quot;:user&quot;;

    //监视库存
    jedis.watch(kcKey);

    //4 获取库存，如果库存null，秒杀还没有开始
    String kc = jedis.get(kcKey);
    if(kc == null)&#123;
        System.out.println(&quot;秒杀还没开始，请稍等&quot;);
        jedis.close();
        return false;
    &#125;

    // 5 判断用户是否重复秒杀操作
    if(jedis.sismember(userKey, uid))&#123;
        System.out.println(&quot;每个用户只能秒杀成功一次，请下次再来&quot;);
        jedis.close();
        return false;
    &#125;

    //6 判断如果商品数量，库存数量小于1，秒杀结束
    if(Integer.parseInt(kc) &lt; 1)&#123;
        System.out.println(&quot;秒杀结束，请下次参与&quot;);
        jedis.close();
        return false;
    &#125;

    //7 秒杀过程
    //使用事务
    Transaction multi = jedis.multi();

    //组队操作
    multi.decr(kcKey);
    multi.sadd(userKey,uid);

    //执行
    List&lt;Object&gt; results = multi.exec();

    if(results == null || results.size()==0) &#123;
        System.out.println(&quot;秒杀失败了....&quot;);
        jedis.close();
        return false;
    &#125;

    //        //7.1库存-1
    //        jedis.decr(kcKey);
    //        //7.2 把秒杀成功的用户添加到清单里面
    //        jedis.sadd(userKey,uid);
    System.out.println(&quot;用户&quot; + uid + &quot;秒杀成功&quot;);
    jedis.close();
    return true;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>连接超时问题</strong></p>
<ul>
<li>解决方案：采用连接池</li>
</ul>
<pre><code class="lang-java">// 创建工具类
public class JedisPoolUtil &#123;
    private static volatile JedisPool jedisPool = null;

    private JedisPoolUtil() &#123;
    &#125;

    public static JedisPool getJedisPoolInstance() &#123;
        if (null == jedisPool) &#123;
            synchronized (JedisPoolUtil.class) &#123;
                if (null == jedisPool) &#123;
                    JedisPoolConfig poolConfig = new JedisPoolConfig();
                    poolConfig.setMaxTotal(200);
                    poolConfig.setMaxIdle(32);
                    poolConfig.setMaxWaitMillis(100*1000);
                    poolConfig.setBlockWhenExhausted(true);
                    poolConfig.setTestOnBorrow(true);  // ping  PONG

                    jedisPool = new JedisPool(poolConfig, &quot;192.168.xx.xxx&quot;, 6379, 60000 );
                &#125;
            &#125;
        &#125;
        return jedisPool;
    &#125;

    public static void release(JedisPool jedisPool, Jedis jedis) &#123;
        if (null != jedis) &#123;
            jedisPool.returnResource(jedis);
        &#125;
    &#125;
&#125;
</code></pre>
<p>修改代码，主要是针对前面基本实现中的核心代码，对获取 redis 对象进行修改：</p>
<pre><code class="lang-java">//2 连接redis
//Jedis jedis =new Jedis(&quot;192.168.xx.xxx&quot;,6379);

//通过连接池获取连接redis的对象
JedisPool jedisPoolInstance = JedisPoolUtil.getJedisPoolInstance();
Jedis jedis = jedisPoolInstance.getResource();
</code></pre>
</li>
<li><p><strong>商品遗留问题</strong>，即秒杀已经结束了，却还有商品库存</p>
<ul>
<li>解决方案：使用 Lua 脚本</li>
</ul>
<blockquote>
<p>Lua 是一个小巧的脚本语言，Lua 脚本可以很容易的被 C/C++ 代码调用，也可以反过来调用 C/C++的函数，Lua 并没有提供强大的库，一个完整的 Lua 解释器不过 200k，所以 Lua 不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。很多应用程序、游戏使用 LUA 作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。</p>
</blockquote>
<p><strong>将复杂的或者多步的 redis 操作，写为一个脚本，一次提交给 redis 执行</strong>，减少反复连接 redis 的次数。提升性能。</p>
<p><strong>Lua 脚本是类似 redis 事务，有一定的原子性，不会被其他命令插队</strong>，可以完成一些 redis 事务性的操作。</p>
<p>但是注意 redis 的 lua 脚本功能，只有在 Redis 2.6 以上的版本才可以使用。</p>
<p><strong>利用 Lua 脚本淘汰用户，解决超卖问题</strong>。</p>
<p>redis 2.6 版本以后，通过 lua 脚本解决争抢问题，<strong>实际上是 redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题。</strong></p>
<p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/739bc930419ef903046dfdb5f8653b9f_MD5.png" alt="2022-01-30_205550"></p>
</li>
</ul>
</li>
</ul>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
            <ul id="audio-list" style="display:none">
                
                
                <li title='0' data-url='/statics/chengdu.mp3'></li>
                
                    
            </ul>
            
                        
            
            
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci='7bbd114371cb2cd73dc2'
        data-cs='fd7cda0eb23cbb69b65e291c5b607b196613a6b1'
        data-r='nd-ljq.github.io'
        data-o='ND-LJQ'
        data-a='ND-LJQ'
        data-d=''
        data-p='https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token'
    >Comments</div>


            
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="/img/head.jpg" height=300 width=300></img>
                    <p>ND_LJQ</p>
                    <span>Think like an artist, develop like an artisan</span>
                    <dl>
                        
                            
                                <dd><a href="https://github.com/ND-LJQ'" target="_blank"><span
                                    class=" iconfont icon-github"></span></a></dd>
                            
                            
                            
                        
                        
                    </dl>
                </div>
                <ul>
                    <li><a href="/">20 <p>Articles</p></a></li>
                    <li><a href="/categories">11 <p>Categories</p></a></li>
                    <li><a href="/tags">10 <p>Tags</p></a></li>
                </ul>
            </div>
            
            
            
            <div class="box sticky animated fadeInRight faster">
                <div id="toc" class="subbox">
                    <h4>Contents</h4>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E4%B8%AD%E7%9A%84-key-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">Redis 中的 key 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%BA%93%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84-key-%E5%80%BC"><span class="toc-number">1.1.</span> <span class="toc-text">查看当前库中所有的 key 值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-key-value-%E5%80%BC"><span class="toc-number">1.2.</span> <span class="toc-text">设置 key-value 值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-key-%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">1.3.</span> <span class="toc-text">查看 key 是否存在</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-key-%E7%9A%84-type"><span class="toc-number">1.4.</span> <span class="toc-text">查看 key 的 type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA-key-value-%E5%AF%B9"><span class="toc-number">1.5.</span> <span class="toc-text">同时设置一个或多个 key-value 对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#key-%E5%80%BC%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%AE%BE%E7%BD%AE-key-%E7%9A%84%E5%80%BC"><span class="toc-number">1.6.</span> <span class="toc-text">key 值不存在的时候设置 key 的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#key-%E5%80%BC%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA-key-%E7%9A%84%E5%80%BC"><span class="toc-number">1.7.</span> <span class="toc-text">key 值不存在的时候设置一个或多个 key 的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%94%AE%E5%80%BC%E7%9A%84%E5%90%8C%E6%97%B6%EF%BC%8C%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">1.8.</span> <span class="toc-text">设置键值的同时，设置过期时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%97%A7%E5%80%BC%E7%9A%84%E5%90%8C%E6%97%B6%E8%AE%BE%E7%BD%AE%E6%96%B0%E5%80%BC"><span class="toc-number">1.9.</span> <span class="toc-text">设置旧值的同时设置新值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-key-%E7%9A%84-value-%E5%80%BC"><span class="toc-number">1.10.</span> <span class="toc-text">获取 key 的 value 值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA-key-value-%E5%AF%B9"><span class="toc-number">1.11.</span> <span class="toc-text">获取一个或多个 key-value 对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E7%BB%99%E5%AE%9A%E7%9A%84%E5%80%BC%E8%BF%BD%E5%8A%A0%E5%88%B0%E7%9B%AE%E6%A0%87-key-%E7%9A%84%E6%9C%AB%E5%B0%BE"><span class="toc-number">1.12.</span> <span class="toc-text">将给定的值追加到目标 key 的末尾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97-key-%E5%80%BC%E9%95%BF%E5%BA%A6"><span class="toc-number">1.13.</span> <span class="toc-text">获得 key 值长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86-key-%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E5%AD%97%E5%A2%9E%E9%95%BF-1"><span class="toc-number">1.14.</span> <span class="toc-text">将 key 中存储的数字增长 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86-key-%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E5%AD%97%E5%A2%9E%E9%95%BF%E4%BB%BB%E6%84%8F%E5%80%BC"><span class="toc-number">1.15.</span> <span class="toc-text">将 key 中存储的数字增长任意值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86-key-%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E5%AD%97%E5%87%8F%E4%B8%80"><span class="toc-number">1.16.</span> <span class="toc-text">将 key 中存储的数字减一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86-key-%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E5%AD%97%E5%87%8F%E5%8E%BB%E4%BB%BB%E6%84%8F%E5%80%BC"><span class="toc-number">1.17.</span> <span class="toc-text">将 key 中存储的数字减去任意值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A-key"><span class="toc-number">1.18.</span> <span class="toc-text">删除指定 key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%88%A0%E9%99%A4"><span class="toc-number">1.19.</span> <span class="toc-text">非阻塞删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-key-%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">1.20.</span> <span class="toc-text">设置 key 过期时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-key-%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">1.21.</span> <span class="toc-text">查看 key 的过期时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%BA%93%E7%9A%84-key-%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">1.22.</span> <span class="toc-text">查看当前库的 key 的数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA%E5%BD%93%E5%89%8D%E5%BA%93"><span class="toc-number">1.23.</span> <span class="toc-text">清空当前库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA%E6%89%80%E6%9C%89%E5%BA%93"><span class="toc-number">1.24.</span> <span class="toc-text">清空所有库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">Redis 的基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">2.1.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SDS"><span class="toc-number">2.1.1.</span> <span class="toc-text">SDS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">2.1.2.</span> <span class="toc-text">C 语言字符串的缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDS-%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.1.3.</span> <span class="toc-text">SDS 结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#O%EF%BC%881%EF%BC%89%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="toc-number">2.1.4.</span> <span class="toc-text">O（1）复杂度获取字符串长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8"><span class="toc-number">2.1.5.</span> <span class="toc-text">二进制安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="toc-number">2.1.6.</span> <span class="toc-text">不会发生缓冲区溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%9C%81%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">2.1.7.</span> <span class="toc-text">节省内存空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">2.1.8.</span> <span class="toc-text">部分操作指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">2.2.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.1.</span> <span class="toc-text">数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.3.</span> <span class="toc-text">链表节点结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.3.1.</span> <span class="toc-text">链表结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E7%BC%BA%E9%99%B7"><span class="toc-number">2.3.2.</span> <span class="toc-text">链表的优势与缺陷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="toc-number">2.4.</span> <span class="toc-text">压缩列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.4.1.</span> <span class="toc-text">压缩列表结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0"><span class="toc-number">2.4.2.</span> <span class="toc-text">连锁更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">2.4.3.</span> <span class="toc-text">压缩列表的缺陷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#quicklist"><span class="toc-number">2.5.</span> <span class="toc-text">quicklist</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#quicklist-%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.5.1.</span> <span class="toc-text">quicklist 结构设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#listpack"><span class="toc-number">2.6.</span> <span class="toc-text">listpack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#listpack-%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.6.1.</span> <span class="toc-text">listpack 结构设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">2.7.</span> <span class="toc-text">插入数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">2.8.</span> <span class="toc-text">获取范围内的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B9%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">2.9.</span> <span class="toc-text">弹出数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">2.10.</span> <span class="toc-text">删除数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9B%BF%E6%8D%A2"><span class="toc-number">2.11.</span> <span class="toc-text">数据的替换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set-%E9%9B%86%E5%90%88"><span class="toc-number">2.12.</span> <span class="toc-text">Set(集合 )</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-number">2.12.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88-intset"><span class="toc-number">2.12.2.</span> <span class="toc-text">整数集合(intset)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.12.3.</span> <span class="toc-text">整数集合结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E7%9A%84%E5%8D%87%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="toc-number">2.12.4.</span> <span class="toc-text">整数集合的升级操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE"><span class="toc-number">2.12.5.</span> <span class="toc-text">添加一个或多个数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%9B%86%E5%90%88%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">2.12.6.</span> <span class="toc-text">查看集合中所有的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%9B%86%E5%90%88%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E6%9F%90%E4%B8%80%E4%B8%AA%E5%80%BC"><span class="toc-number">2.12.7.</span> <span class="toc-text">判断集合中是否有某一个值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="toc-number">2.12.8.</span> <span class="toc-text">查询集合元素个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E5%85%83%E7%B4%A0"><span class="toc-number">2.12.9.</span> <span class="toc-text">删除集合中的某一元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E9%9A%8F%E6%9C%BA%E5%BC%B9%E5%80%BC"><span class="toc-number">2.12.10.</span> <span class="toc-text">在集合中随机弹值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%B8%AD%E9%9A%8F%E6%9C%BA%E5%8F%96-n-%E4%B8%AA%E5%80%BC"><span class="toc-number">2.12.11.</span> <span class="toc-text">集合中随机取 n 个值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E9%97%B4%E4%BC%A0%E5%80%BC"><span class="toc-number">2.12.12.</span> <span class="toc-text">集合间传值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E9%97%B4%E5%8F%96%E4%BA%A4%E9%9B%86"><span class="toc-number">2.12.13.</span> <span class="toc-text">集合间取交集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E9%97%B4%E5%8F%96%E5%B9%B6%E9%9B%86"><span class="toc-number">2.12.14.</span> <span class="toc-text">集合间取并集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E9%97%B4%E5%8F%96%E5%B7%AE%E9%9B%86"><span class="toc-number">2.12.15.</span> <span class="toc-text">集合间取差集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash-%E5%93%88%E5%B8%8C"><span class="toc-number">2.13.</span> <span class="toc-text">Hash(哈希)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.13.1.</span> <span class="toc-text">哈希表结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">2.13.2.</span> <span class="toc-text">哈希冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%93%88%E5%B8%8C"><span class="toc-number">2.13.3.</span> <span class="toc-text">链式哈希</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rehash"><span class="toc-number">2.13.4.</span> <span class="toc-text">rehash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8F-rehash"><span class="toc-number">2.13.5.</span> <span class="toc-text">渐进式 rehash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rehash-%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.13.6.</span> <span class="toc-text">rehash 触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE-%E5%8D%95%E4%B8%AA"><span class="toc-number">2.13.7.</span> <span class="toc-text">存储数据(单个)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE-%E5%A4%9A%E4%B8%AA"><span class="toc-number">2.13.8.</span> <span class="toc-text">存储数据(多个)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">2.13.9.</span> <span class="toc-text">取出数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E5%87%BA-key-hash-%E9%9B%86%E5%90%88%E5%86%85%E6%89%80%E6%9C%89%E7%9A%84-field-%E5%80%BC"><span class="toc-number">2.13.10.</span> <span class="toc-text">取出 key hash 集合内所有的 field 值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E5%87%BA-key-hash-%E9%9B%86%E5%90%88%E5%86%85%E6%89%80%E6%9C%89%E7%9A%84-value-%E5%80%BC"><span class="toc-number">2.13.11.</span> <span class="toc-text">取出 key hash 集合内所有的 value 值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-key-%E4%B8%AD%E7%9A%84-field-%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">2.13.12.</span> <span class="toc-text">查看 key 中的 field 是否存在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key-%E4%B8%AD%E7%9A%84-hash-%E9%9B%86%E5%90%88%E4%B8%AD-field-%E5%8A%A0%E5%80%BC"><span class="toc-number">2.13.13.</span> <span class="toc-text">key 中的 hash 集合中 field 加值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key-%E4%B8%AD-hash-%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84-field-%E5%80%BC%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA-field-%E5%80%BC"><span class="toc-number">2.13.14.</span> <span class="toc-text">key 中 hash 集合中的 field 值不存在的时候设置一个 field 值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zset-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">2.14.</span> <span class="toc-text">Zset(有序集合)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2"><span class="toc-number">2.14.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8"><span class="toc-number">2.14.2.</span> <span class="toc-text">跳表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.14.3.</span> <span class="toc-text">跳表结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%E8%8A%82%E7%82%B9%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">2.14.4.</span> <span class="toc-text">跳表节点查询过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%E8%8A%82%E7%82%B9%E5%B1%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.14.5.</span> <span class="toc-text">跳表节点层数设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E6%88%90%E5%91%98"><span class="toc-number">2.14.6.</span> <span class="toc-text">添加一个或多个成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E8%8C%83%E5%9B%B4%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="toc-number">2.14.7.</span> <span class="toc-text">输出范围中的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E6%88%90%E5%91%98%E7%9A%84%E5%80%BC"><span class="toc-number">2.14.8.</span> <span class="toc-text">增加成员的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%88%90%E5%91%98"><span class="toc-number">2.14.9.</span> <span class="toc-text">删除成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E8%AF%84%E5%88%86%E5%8C%BA%E9%97%B4%E7%9A%84%E6%88%90%E5%91%98%E4%B8%AA%E6%95%B0"><span class="toc-number">2.14.10.</span> <span class="toc-text">统计评分区间的成员个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%88%90%E5%91%98%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E6%8E%92%E5%90%8D"><span class="toc-number">2.14.11.</span> <span class="toc-text">查看成员在集合中的排名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis6-%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">Redis6 新数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Bitmaps"><span class="toc-number">3.1.</span> <span class="toc-text">Bitmaps</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">3.2.</span> <span class="toc-text">HyperLogLog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Geospatial"><span class="toc-number">3.3.</span> <span class="toc-text">Geospatial</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">Redis 的配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NETWORK"><span class="toc-number">4.1.</span> <span class="toc-text">NETWORK</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E4%BB%A5%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5-%E9%BB%98%E8%AE%A4%E5%8F%AA%E8%83%BD%E6%9C%AC%E5%9C%B0%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.1.1.</span> <span class="toc-text">修改配置以网络连接(默认只能本地连接)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Port"><span class="toc-number">4.1.2.</span> <span class="toc-text">Port</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-backlog"><span class="toc-number">4.1.3.</span> <span class="toc-text">tcp-backlog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timeout"><span class="toc-number">4.1.4.</span> <span class="toc-text">timeout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-keepalive"><span class="toc-number">4.1.5.</span> <span class="toc-text">tcp-keepalive</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GENERAL"><span class="toc-number">4.2.</span> <span class="toc-text">GENERAL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%81%E8%AE%B8%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8-%E9%BB%98%E8%AE%A4%E4%B8%BA-no"><span class="toc-number">4.2.1.</span> <span class="toc-text">允许后台启动(默认为 no)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Limits"><span class="toc-number">4.3.</span> <span class="toc-text">Limits</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%A4%A7%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E6%95%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">设置最大的客户端连接数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%A4%A7%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E9%87%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text">设置最大的内存占用量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%A4%A7%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">4.3.3.</span> <span class="toc-text">设置最大内存占用规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-number">5.</span> <span class="toc-text">Redis 发布和订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E9%A2%91%E9%81%93"><span class="toc-number">5.1.</span> <span class="toc-text">订阅频道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E9%A2%91%E9%81%93%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF"><span class="toc-number">5.2.</span> <span class="toc-text">向频道发送信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis6-%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">6.</span> <span class="toc-text">Redis6 新数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Bitmap"><span class="toc-number">6.1.</span> <span class="toc-text">Bitmap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-jedis-%E6%93%8D%E4%BD%9C-Redis"><span class="toc-number">7.</span> <span class="toc-text">通过 jedis 操作 Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">7.1.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8F%91%E9%80%81"><span class="toc-number">7.2.</span> <span class="toc-text">模拟验证码发送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jedis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">7.3.</span> <span class="toc-text">Jedis 主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%9A%84-Jedis-%E5%BC%80%E5%8F%91"><span class="toc-number">7.4.</span> <span class="toc-text">集群的 Jedis 开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot-%E6%95%B4%E5%90%88-Redis"><span class="toc-number">7.5.</span> <span class="toc-text">SpringBoot 整合 Redis</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="toc-number">8.</span> <span class="toc-text">Redis 中的事务操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Multi%E3%80%81Exec%E3%80%81discard"><span class="toc-number">8.1.</span> <span class="toc-text">Multi、Exec、discard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">8.2.</span> <span class="toc-text">事务的错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E9%94%99%E8%AF%AF"><span class="toc-number">8.2.1.</span> <span class="toc-text">提交错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF"><span class="toc-number">8.2.2.</span> <span class="toc-text">执行错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="toc-number">8.3.</span> <span class="toc-text">事务冲突问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82-%F0%9F%94%92"><span class="toc-number">8.3.1.</span> <span class="toc-text">悲观 🔒</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%89%E7%89%B9%E6%80%A7"><span class="toc-number">8.4.</span> <span class="toc-text">事务的三特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%8B%AC%E9%9A%94%E7%A6%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">8.4.1.</span> <span class="toc-text">单独隔离操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">8.4.2.</span> <span class="toc-text">没有隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">8.4.3.</span> <span class="toc-text">不保证原子性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">8.5.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">8.5.1.</span> <span class="toc-text">测试工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B5%8B%E8%AF%95"><span class="toc-number">8.5.2.</span> <span class="toc-text">通过浏览器测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.5.3.</span> <span class="toc-text">并发出现的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E4%B8%AD%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">9.</span> <span class="toc-text">Redis 中的持久化操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dump-rdb"><span class="toc-number">9.1.</span> <span class="toc-text">dump.rdb</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB-Redis-DataBase"><span class="toc-number">9.2.</span> <span class="toc-text">RDB(Redis DataBase)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF-Append-only-File"><span class="toc-number">9.3.</span> <span class="toc-text">AOF(Append only File)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF-%E5%BC%80%E5%90%AF"><span class="toc-number">9.3.1.</span> <span class="toc-text">AOF 开启</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E8%B7%AF%E5%BE%84"><span class="toc-number">9.3.2.</span> <span class="toc-text">生成路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%81%A2%E5%A4%8D"><span class="toc-number">9.3.3.</span> <span class="toc-text">异常恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF-%E9%85%8D%E7%BD%AE"><span class="toc-number">9.3.4.</span> <span class="toc-text">AOF 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rewrite-%E5%8E%8B%E7%BC%A9"><span class="toc-number">9.3.5.</span> <span class="toc-text">Rewrite 压缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93"><span class="toc-number">9.4.</span> <span class="toc-text">持久化操作总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">10.</span> <span class="toc-text">Redis 的主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">10.1.</span> <span class="toc-text">配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF"><span class="toc-number">10.1.1.</span> <span class="toc-text">查看主机信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%BB%8E%E6%9C%BA%E4%B8%8A%E8%AE%BE%E7%BD%AE%E4%B8%BB%E6%9C%BA"><span class="toc-number">10.1.2.</span> <span class="toc-text">在从机上设置主机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%BB%E4%B8%A4%E4%BB%8E"><span class="toc-number">10.2.</span> <span class="toc-text">搭建一主两从</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E"><span class="toc-number">10.3.</span> <span class="toc-text">一主二从</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">10.4.</span> <span class="toc-text">主从复制原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="toc-number">10.5.</span> <span class="toc-text">薪火相传</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB"><span class="toc-number">10.5.1.</span> <span class="toc-text">反客为主</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F-%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB%E8%87%AA%E5%8A%A8%E7%89%88"><span class="toc-number">10.5.2.</span> <span class="toc-text">哨兵模式(反客为主自动版)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E8%A7%84%E5%88%99"><span class="toc-number">10.5.3.</span> <span class="toc-text">选举规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%BB%B6%E6%97%B6"><span class="toc-number">10.5.4.</span> <span class="toc-text">复制延时</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E9%9B%86%E7%BE%A4"><span class="toc-number">11.</span> <span class="toc-text">Redis 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.1.</span> <span class="toc-text">代理服务器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E4%B8%AD%E5%BF%83%E5%8C%96%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.2.</span> <span class="toc-text">无中心化集群模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E4%B8%AD%E5%BF%83%E5%8C%96%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE"><span class="toc-number">11.3.</span> <span class="toc-text">无中心化集群配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E4%BD%93"><span class="toc-number">11.3.1.</span> <span class="toc-text">合体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E7%B3%BB%E8%8A%82%E7%82%B9"><span class="toc-number">11.3.2.</span> <span class="toc-text">集群如何分配系节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%9A%84-Jedis-%E5%BC%80%E5%8F%91-1"><span class="toc-number">11.4.</span> <span class="toc-text">集群的 Jedis 开发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">12.</span> <span class="toc-text">Redis 应用问题的解决</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">12.1.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E8%B1%A1"><span class="toc-number">12.1.1.</span> <span class="toc-text">现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">12.1.2.</span> <span class="toc-text">如何解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">12.2.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E8%B1%A1-1"><span class="toc-number">12.2.1.</span> <span class="toc-text">现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-1"><span class="toc-number">12.2.2.</span> <span class="toc-text">如何解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">12.3.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E8%B1%A1-2"><span class="toc-number">12.4.</span> <span class="toc-text">现象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-2"><span class="toc-number">12.4.1.</span> <span class="toc-text">如何解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-number">13.</span> <span class="toc-text">分布式锁(共享锁)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">13.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%94%81%E4%BB%A5%E5%8F%8A%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">13.2.</span> <span class="toc-text">设置锁以及过期时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">13.3.</span> <span class="toc-text">分布式锁产生的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-UUID-%E9%98%B2%E6%AD%A2%E8%AF%AF%E5%88%A0%E9%94%81"><span class="toc-number">13.3.1.</span> <span class="toc-text">使用 UUID 防止误删锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua-%E4%BF%9D%E8%AF%81%E5%88%A0%E9%99%A4%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">13.3.2.</span> <span class="toc-text">Lua 保证删除原子性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">13.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis6-%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">14.</span> <span class="toc-text">Redis6 的新功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ACL-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8"><span class="toc-number">14.1.</span> <span class="toc-text">ACL(访问控制列表)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4"><span class="toc-number">14.1.1.</span> <span class="toc-text">命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E7%A7%92%E6%9D%80"><span class="toc-number">15.</span> <span class="toc-text">模拟秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.1.</span> <span class="toc-text">基本实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-ab-%E5%B7%A5%E5%85%B7%E6%A8%A1%E6%8B%9F%E5%B9%B6%E5%8F%91%E4%BB%A5%E5%8F%8A%E6%9A%B4%E9%9C%B2%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">15.2.</span> <span class="toc-text">使用 ab 工具模拟并发以及暴露出的问题</span></a></li></ol></li></ol>
                </div>
            </div>
            
            
        </div>
    </div>
</div>

    </div>
</div>
    <div id="back-to-top" class="animated fadeIn faster">
        <div class="flow"></div>
        <span class="percentage animated fadeIn faster">0%</span>
        <span class="iconfont icon-top02 animated fadeIn faster"></span>
    </div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2023
        <span class="gradient-text">
            ND_LJQ
        </span>.
        Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
        Theme
        <span class="gradient-text">
            <a href="https://github.com/TriDiamond/hexo-theme-obsidian" title="Obsidian" target="_blank" rel="noopener">Obsidian</a>
        </span>
        <small><a href="https://github.com/TriDiamond/hexo-theme-obsidian/blob/master/CHANGELOG.md" title="v1.4.9.3" target="_blank" rel="noopener">v1.4.9.3</a></small>
        
        
    </p>
</footer>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX", "TeX"],
      linebreaks: {
        automatic: true
      },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"]
      ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      noUndefined: {
        attributes: {
          mathcolor: "red",
          mathbackground: "#FFEEEE",
          mathsize: "90%"
        }
      },
      Macros: {
        href: "{}"
      }
    },
    messageStyle: "none"
  });
</script>
<script>
  function initialMathJax() {
    MathJax.Hub.Queue(function () {
      var all = MathJax.Hub.getAllJax(),
        i;
      // console.log(all);
      for (i = 0; i < all.length; i += 1) {
        console.log(all[i].SourceElement().parentNode)
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  }

  function reprocessMathJax() {
    if (typeof MathJax !== 'undefined') {
      MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }
</script>


 
<link rel="stylesheet" href="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.css">
 
<script src="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.js"></script>
  
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>
 
<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>
 
<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>
 
<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>
 
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/sql/sql.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/java/java.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/c/c.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/html/html.min.js"></script>
   
<script src="/js/busuanzi.min.js"></script>

<script>
  $(document).ready(function () {
    if ($('span[id^="busuanzi_"]').length) {
      initialBusuanzi();
    }
  });
</script>
 
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
  

<script>
  function initialTyped() {
    var typedTextEl = $('.typed-text');
    if (typedTextEl && typedTextEl.length > 0) {
      var typed = new Typed('.typed-text', {
        strings: ['Think like an artist, develop like an artisan', '艺术家思维去思考问题，工匠创造精神去开发'],
        typeSpeed: 90,
        loop: true,
        loopCount: Infinity,
        backSpeed: 20,
      });
    }
  }

  if ($('.article-header') && $('.article-header').length) {
    $(document).ready(function () {
      initialTyped();
    });
  }
</script>




<!-- 引用依赖 -->
<script>document.write(aplayerconf)</script>




</html>
