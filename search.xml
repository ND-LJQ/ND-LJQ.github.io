<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>File&amp;Blob</title>
      <link href="/2023/07/19/File&amp;Blob/"/>
      <url>/2023/07/19/File&amp;Blob/</url>
      
        <content type="html"><![CDATA[<h1 id="shi-yao-shi-wen-jian">什么是文件</h1><p>这是一张纯色图片<br><img src="images/File&amp;Blob/%E7%BA%AF%E8%89%B2%E5%9B%BE%E5%83%8F1683547623115.png" alt></p><h1 id="wen-jian-de-nei-rong">文件的内容</h1><p>这是他的二进制代码格式:<br><img src="images/File&amp;Blob/Snipaste_2023-05-08_20-20-13.png" alt></p><p>以下是一些常见的文件的二进制代码前缀</p><pre><code class="language-shell">.exe的：MZ? + This program cannot be run in DOS mode..jpg的：JFIF Or Exif  .png：NG.zip：PK+文件列表名+This program cannot be run in DOS mode..gif：GIF……。txt：你认识的字.html带有&lt;&gt;的.pdf：%PDF…….rar：Rar!.doc：邢 + 大段空白内容.docxPK+[Content_Types].xml.7z&gt; 7z.aviAVI.chmITSF+/css+/images/+htm  .mp3ID3 Or [uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu x](https://www.zhihu.com/search?q=uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu%20x&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A104662028%7D) n</code></pre><h1 id="file-he-blob-de-jie-shao-yu-qu-bie">File和Blob的介绍与区别</h1><p><code>File</code> 和 <code>Blob</code> 都是在前端开发中经常使用的对象，它们可以用来处理二进制数据。</p><p><code>File</code> 对象是 HTML5 中新增的一个API，它代表着一个文件对象，可以用来读取和处理本地文件。<code>File</code> 对象通常用于通过 <code>&lt;input type=&quot;file&quot;&gt;</code> 元素选择文件后，将选择的文件对象传递到服务器端。</p><p><code>Blob</code> 对象也是 HTML5 中新增的一个API，它代表着一个不可变的、原始数据的类文件对象。可以看做一个包含了二进制数据的容器，一般用于对于文件的处理，例如文件上传、视频播放、音频播放等等。</p><p><strong>它们的区别在于</strong>：</p><ul class="lvl-0"><li class="lvl-4"><p><code>File</code> 对象通常是由用户通过界面选择上传的文件，而 <code>Blob</code> 对象可以通过多种方式来创建，例如从 <code>File</code> 对象中提取出二进制数据，或者手动创建一个包含二进制数据的 <code>Blob</code> 对象。</p></li><li class="lvl-4"><p><code>File</code> 对象有文件名、大小等属性，而 <code>Blob</code> 对象没有这些属性。</p></li><li class="lvl-4"><p><code>File</code> 对象可以在上传文件时传递到服务器端，而 <code>Blob</code> 对象通常用于在客户端中进行处理，例如通过 URL.createObjectURL() 方法将 <code>Blob</code> 对象转换为可用于视频或音频播放的 URL。</p></li></ul><p>总的来说，<code>File</code> 和 <code>Blob</code> 都是用于处理二进制数据的对象，但是它们在使用场景和属性上还是有所区别的。</p><h1 id="js-zhong-de-file-he-blob">JS中的File和Blob</h1><p>这个file和blob不再是文件层次的了,而是代码层次里js的对象</p><h2 id="chuang-jian-flie-he-blob">创建flie和blob</h2><pre><code class="language-js">const blob = new Blob([123]);const file = new File(['123'],&quot;123.txt&quot;);console.log(blob);console.log(file);consloe.log(await blob.arrayBuffer());console.log(await file.arrayBuffer());//打印结果完全一样 至此我们可以姑且认为file和Blob在数据层面基本上就是一回事</code></pre><p><img src="images/File&amp;Blob/Snipaste_2023-05-08_20-39-19.png" alt><br>可以看出file的原型(Prototype)仍然是Blob</p><h2 id="xiu-gai-file-amp-blob-er-jin-zhi-ceng-mian">修改file&amp;blob(二进制层面)</h2><pre><code class="language-js">const dv = new DataView(await blob.arrayBuffer());console.log(dv);console.log(dv.getUint8(1)); //给一个字节的索引来获取该字节的值 dv.setUnit8(1,65); //修改索引为1的字节的值为65</code></pre><h2 id="da-kai-ben-di-wen-jian-huo-qu-yuan-duan-wen-jian">打开本地文件/获取远端文件</h2><h2 id="xuan-ze-wen-jian">选择文件</h2><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;&lt;input type=&quot;file&quot; onChange=onFileChange(event)&gt;&lt;/input&gt;    &lt;script&gt;//同一文件打开两次 fileChange不会被触发   const onFileChange = async (e) =&gt; &#123;   console.log(e.target); //FileList   console.log(e.target.files[0]); //File   console.log(await e.target.files[0].arrayBuffer());      &#125;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="tuo-zhuai-xuan-ze-wen-jian">拖拽选择文件</h3><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;style&gt;    .dragInput &#123;      position: absolute;      top: 50%;      left: 50%;      height: 100px;      width: 100px;      text-align: center;      border: 1px solid black;    &#125;  &lt;/style&gt;  &lt;body&gt;    &lt;div      class=&quot;dragInput&quot;      ondragover=&quot;onDragOver(event)&quot;      ondrop=&quot;onDragFile(event)&quot;    &gt;&lt;/div&gt;    &lt;script&gt;      const onDragOver = (e) =&gt; &#123;        e.preventDefault();  //阻止浏览器默认的拖放行为（例如在拖放文件时防止浏览器打开文件）      &#125;;      const onDragFile = async (e) =&gt; &#123;        e.preventDefault();        console.log('files', e.dataTransfer.files);        console.log(e.dataTransfer.files[0]);        console.log(await e.dataTransfer.files[0].arrayBuffer());      &#125;;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="xian-zhi-xuan-ze-wen-jian-liu-lan-qi-zi-dai-jiao-xin">限制选择文件(浏览器自带-较新)</h2><h3 id="file-picker">file picker</h3><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;style&gt;    .dragInput &#123;      position: absolute;      top: 50%;      left: 50%;      height: 100px;      width: 100px;      text-align: center;      border: 1px solid black;    &#125;  &lt;/style&gt;  &lt;body&gt;    &lt;div class=&quot;dragInput&quot; onclick=&quot;onClick()&quot;&gt;&lt;/div&gt;    &lt;script&gt;      // options是可选参数，支持下面这些属性      // multiple      // 布尔值，默认值是 false ，表示只能选择一个文件。      // excludeAcceptAllOption      // 布尔值，默认值是 false ，表示是否排除下面 types 中的所有的accept文件类型。      // types      // 可选择的文件类型数组，每个数组项也是个对象，支持下面两个参数：      // description：表示文件或者文件夹的描述，字符串，可选。      // accept：接受的文件类型，对象，然后对象的键是文件的MIME匹配，值是数组，表示支持的文件后缀。具体可以下面的示意。      const pickerOpts = &#123;        types: [          &#123;            description: 'Images',            accept: &#123;              'image/*': ['.png', '.gif', '.jpg', '.jpeg'],            &#125;,          &#125;,        ],        excludeAcceptAllOptions: true,        multiple: false, //是否可以多选      &#125;;      const onClick = async (e) =&gt; &#123;  //在window.showOpenFilePicker返回的Promise中，如果用户选择了一个或多个文件，那么Promise将被解释为一个FileHandle对象的数组。因此，如果只需要处理一个文件，可以使用解构赋值将数组中的第一个FileHandle对象提取出来，如下所示：        const [fileHandle] = await window.showOpenFilePicker(pickerOpts);        console.log(fileHandle);        const f = await fileHandle.getFile();        console.log(f);        console.log(await f.arrayBuffer());      &#125;;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>需要注意的是，如果用户取消选择文件，<code>window.showOpenFilePicker</code>返回的<code>Promise</code>将被拒绝，需要使用<code>try-catch</code>块来捕获此类错误并进行处理。</p><h2 id="cao-zuo-wen-jian">操作文件</h2><h3 id="wen-ben-wen-jian-de-chuang-jian-bian-ji-bao-cun-da-kai-ling-cun-wei">文本文件的创建、编辑、保存、打开、另存为</h3><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;style&gt;    .fileInput &#123;      position: absolute;      top: 50%;      left: 50%;      text-align: center;      transform: translate(-50%, -50%);      border: 1px solid black;    &#125;    .btn-box &#123;      width: 100%;      display: flex;    &#125;    .container &gt; textarea &#123;      border: 0;    &#125;    .btn-box &gt; button &#123;      flex-grow: 1;    &#125;  &lt;/style&gt;  &lt;body&gt;    &lt;div class=&quot;fileInput&quot;&gt;      &lt;div class=&quot;container&quot;&gt;        &lt;textarea name=&quot;&quot; id=&quot;userInput&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;        &lt;div class=&quot;btn-box&quot;&gt;          &lt;button onclick=&quot;onCreate()&quot;&gt;create&lt;/button&gt;          &lt;button onclick=&quot;onOpen()&quot;&gt;open&lt;/button&gt;          &lt;button onclick=&quot;onSaveAs(true)&quot;&gt;save&lt;/button&gt;          &lt;button onclick=&quot;onSaveAs(false)&quot;&gt;save as&lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;      const textArea = document.querySelector('#userInput');      let textValue = '';      let nowFile = null;      let nowFileHandler = null;      const options = &#123;        types: [          &#123;            description: 'Text Files',            accept: &#123;              'text/plain': ['.txt'],              'text/html': ['.html', '.htm'],              'application/json': ['.json'],            &#125;,          &#125;,        ],      &#125;;      const onCreate = async () =&gt; &#123;        const fileHandler = await window.showSaveFilePicker(options);        const writable = await fileHandle.createWritable();        await writable.write(textArea.value);        await writable.close();      &#125;;      const onOpen = async () =&gt; &#123;        //如果选择的是多个文件 则用forEach或者map遍历        // try &#123;        //   const fileHandles = await window.showOpenFilePicker(options);        //   fileHandles.forEach(async (fileHandle) =&gt; &#123;        //     const file = await fileHandle.getFile();        //     console.log(file);        //   &#125;);        // &#125; catch (error) &#123;        //   console.error(error);        // &#125;        const [fileHandler] = await window.showOpenFilePicker(options);        nowFileHandler = fileHandler;        nowFile = await fileHandler.getFile();        textArea.value = await nowFile.text();        textValue = textArea.value      &#125;;      const save = async (fileHandle) =&gt; &#123;        if (!fileHandle) &#123;          return;        &#125;        const stream = await fileHandle.createWritable();        console.log(textValue);        await stream.write(textValue);        await stream.close();        console.log('文件已被保存');      &#125;;      const onSaveAs = async (flag) =&gt; &#123;        // e.preventDefault();        const fileHandler =          flag &amp;&amp; !!nowFileHandler ? nowFileHandler : await onCreate();        save(fileHandler);      &#125;;      textArea.addEventListener('input', (e) =&gt; &#123;        // console.log(textArea.value);        textValue = textArea.value;      &#125;);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="wen-jian-jia-de-xuan-ze">文件夹的选择</h2><p><strong>window.showDirectoryPicker()</strong></p><pre><code class="language-html">dirHandle.values  //得到的是一个迭代器数组,你通过遍历数组才能拿到文件的handledirHandle.getFileHandle()</code></pre><h2 id="blob-url-amp-file-url">Blob URL&amp;File URL</h2><pre><code class="language-JS">URL.createObjectURL(blob) //blob url// http://localhost:3000/UUID//需要newFileReader.readAsDataURL(file); //data url// data:text/plain;base64,YW.....//处于安全性考虑,浏览器不允许用a标签的方式打开data url//其实参数中的blob和file都可以相互替换 在数据层面(二进制)二者一样&lt;a&gt;target=&quot;_blank&quot;download=&quot;fileName&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 基本概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基本概念(前端) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页面渲染以及重排</title>
      <link href="/2023/07/19/%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E4%BB%A5%E5%8F%8A%E9%87%8D%E6%8E%92/"/>
      <url>/2023/07/19/%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E4%BB%A5%E5%8F%8A%E9%87%8D%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<p>用户使用浏览器一般会打开多个页面，现代浏览器使用单独的进程 <code>Render Process</code> 渲染每个页面，<strong>以提升页面性能和稳定性</strong></p><p><img src="/2023/07/19/%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E4%BB%A5%E5%8F%8A%E9%87%8D%E6%8E%92/4c64312ae3fe443ba16bf18e51fa005e~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt></p><h1 id="ye-mian-de-xuan-ran">页面的渲染</h1><ul class="lvl-0"><li class="lvl-2"><p>渲染图示</p><p><img src="/2023/07/19/%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E4%BB%A5%E5%8F%8A%E9%87%8D%E6%8E%92/79daae1a55a64877a7ed32bca62f39de~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt></p></li><li class="lvl-2"><p>渲染图解</p><p>根据 <code>HTML 标记</code> 解析出 <code>DOM 树</code></p><p>根据 <code>CSS 样式</code> 解析出 <code>CSS 规则树</code></p><p>根据 <code>DOM 树</code> 和 <code>CSS 规则树</code> 生成 <code>渲染树</code></p><p>根据渲染树计算 DOM 节点的信息（节点的大小、位置等）</p><p>根据计算好的信息绘制页面（颜色、背景、字体等）</p></li></ul><h1 id="zhong-hui-he-hui-liu">重绘和回流</h1><ul class="lvl-0"><li class="lvl-2"><p>重绘（repaint）</p><p>当 <code>DOM</code> 元素的外观属性发生变化时，如：字体颜色或背景颜色</p><p>浏览器会重新绘制受影响的元素到屏幕，这个过程称之为<strong>重绘</strong></p></li><li class="lvl-2"><p>回流（reflow）</p><p>当 <code>DOM</code> 元素的几何属性发生变化时，如：盒子模型相关的属性。其周围元素的位置也会受到影响</p><p>浏览器会重新生成渲染树且重新布局，这个过程称之为<strong>回流</strong></p></li><li class="lvl-2"><p>影响关系</p><p>重绘不一定导致回流，但回流一定会导致重绘</p></li></ul><h1 id="chang-jian-zhong-hui-hui-liu-yi-ji-you-hua-fang-an">常见重绘、回流以及优化方案</h1><ul class="lvl-0"><li class="lvl-2"><p>常见场景</p></li></ul><p>​浏览器的窗口大小改变（resize 事件）</p><p>​添加或删除可见的 <code>DOM</code> 元素（必要的 DOM 操作）</p><p>​页面中的内容发生变化</p><ul class="lvl-0"><li class="lvl-2"><p>优化方案</p></li></ul><p>​使用 <code>document.createDocumentFragement()</code> 优化必要的 DOM 操作</p><p>​使用 <code>opacity</code>、<code>transform</code>、<code>3D转换属性</code> 开启动画的 GPU 加速</p><p>​使用 <code>el.style.cssText</code> 替代 <code>el.style</code> 来集中改变样式</p><p>​使用 <code>textContent</code> 替代 <code>innerText</code> 来动态修改页面中的内容</p><p>​使用 <code>will-change</code> 属性提前通知浏览器元素将要做什么，让浏览器提前准备合适的优化机制，增强页面的动画渲染性能</p><pre><code>  `will-change` 应该被视为最后的应对手段，用于解决现有的性能问题。不应该被用来预测性能问题。</code></pre><h1 id="shi-zhan">实战</h1><p>滑动选项卡</p><ul class="lvl-0"><li class="lvl-2"><p>基本结构</p><pre><code class="language-html">&lt;div class=&quot;tab&quot; id=&quot;tabId&quot;&gt;  &lt;ul class=&quot;tab-nav&quot;&gt;    &lt;li class=&quot;slider&quot; role=&quot;slider&quot;&gt;&lt;/li&gt;    &lt;li data-index=&quot;0&quot;&gt;导航项&lt;/li&gt;  &lt;/ul&gt;  &lt;div class=&quot;tab-content&quot;&gt;    &lt;div&gt;滑动内容&lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre></li><li class="lvl-2"><p>布局技巧</p><pre><code class="language-css">.tab &#123;  overflow: hidden;&#125;.tab-nav &gt; .slider&#123;  transition: left .3s ease;&#125;.tab-nav:hover &#123;  will-change: margin-left;&#125;.tab-content &#123;  display: flex;  width: 100%;  transition: margin-left .3s ease;&#125;.tab-content &gt; div &#123;  flex-shrink: 0;  width: 100%;&#125;</code></pre><p><code>flex-shrink</code> 定义元素占多余空间的缩小比例（子元素的宽度和大于父元素的宽度时起作用），默认值为 <code>1</code> ，即空间不足时，元素都将等比例缩小</p><p>如果 <code>flex-shrink</code> 的属性设为 <code>0</code> 时，则空间不足时不进行缩小</p></li><li class="lvl-2"><p>绑定事件实现滑动</p><pre><code class="language-js">const tabId = document.querySelector('#tabId')const tabNav = tabId.querySelector('.tab-nav')const tabSlideBar = tabId.querySelector('.slider')const tabSlideContent = tabId.querySelector('.tab-content')tabNav.addEventListener('click', event =&gt; &#123;  const index = event.target.dataset.index  tabSlideBar.style = `left: $&#123;event.target.offsetLeft&#125;px;`  tabSlideContent.style = `margin-left: -$&#123;index * 100&#125;%;`&#125;)</code></pre></li></ul><p><strong>场景</strong>:</p><p>列表页会有很多商品图片，自适应没有用css定义图片高度，当图片加载完成后会发生重排。为了避免这样的情况，是需要用css定好图片宽高吗？</p><p>为了避免重排，所以要限定好图片宽高,自适应的图片，建议使用第三方CDN 结合picture标签来处理</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 业务与性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务与性能优化(前端) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络传输优化</title>
      <link href="/2023/07/19/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96/"/>
      <url>/2023/07/19/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><strong>浏览器从输入地址到页面显示的过程中发生了什么？</strong></p><p>1、浏览器对输入的地址进行 <code>URL</code> 解析</p><p>2、缓存解析，如 <code>浏览器缓存、系统缓存、路由器缓存</code> 等</p><p>3、通过 <code>DNS</code> 服务器将主机域名转换为 <code>IP</code> 地址</p><p>4、根据 <code>IP</code> 地址找到对应的服务器，发起 <code>TCP</code> 连接</p><p>5、建立 <code>TCP</code> 连接后，发起 <code>HTTP</code> 请求</p><p>6、服务器响应 <code>HTTP</code> 请求，浏览器获得 <code>HTML</code> 代码</p><p>7、浏览器解析 <code>HTML</code> 代码，再请求代码中的资源，如 <code>CSS、JS、图片</code> 等</p><p>8、浏览器解析渲染视图页面</p><p>9、服务器断开 <code>TCP</code> 连接</p><p><strong>从整个页面渲染的链路中，可以提取关键词：<code>URL解析</code>、<code>DNS解析</code>、<code>HTTP协议</code>、<code>HTTP缓存</code>、<code>TCP连接</code>、<code>服务器</code>、<code>响应体</code>、<code>渲染</code>，根据这些关键词产出性能优化策略</strong></p><h1 id="dns-yu-ming-jie-xi-you-hua">DNS域名解析优化</h1><p><img src="/2023/07/19/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96/858d04149c474044a0b7ca677c08a254~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="dns.png"></p><p><code>递归查询</code> 主机向本地域名服务器的查询</p><p><code>迭代查询</code> 本地域名服务器向根域名服务器的查询</p><p>HTTP页面自动解析</p><p>在页面加载的过程当中，浏览器会自动将超链接 <code>href</code> 属性中的域名解析为 <code>IP</code> 地址，但为了确保安全性，<code>HTTPS</code> 页面中已不再允许自动解析</p><p>HTTPS页面自动解析</p><pre><code>通过HTML标签方式&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;复制代码通过设置响应头的方式ctx.set('X-DNS-Prefetch-Control', 'on')复制代码</code></pre><p><code>on</code> 表示开启解析，<code>off</code> 表示关闭解析</p><p>手动解析</p><pre><code class="language-html">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//file.cdn.com&quot;&gt;复制代码</code></pre><p>开启指定域名的预解析功能，多用于 <strong>优化 CDN 资源</strong>，<strong>推荐在项目中使用</strong>。最佳使用位置如下</p><pre><code class="language-html">&lt;meta charset=&quot;utf-8&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//file.cdn.com&quot;&gt;复制代码</code></pre><p>优化总结</p><p><code>DNS</code> 请求消耗的带宽非常小，但延迟有点高，尤其是在手机网络上尤为明显，通过 <code>DNS</code> 预解析可以明显的减少一些延迟</p><p><strong>可以减少用户点击链接时的等待时间，从而提升页面的响应速度</strong></p><h1 id="xuan-ran-lian-lu-http-1-1-xie-yi">渲染链路：HTTP1.1协议</h1><h2 id="dui-yi-bu-ren-wu-bing-fa-liang-jin-xing-xian-liu">对异步任务并发量进行限流</h2><p>浏览器同域名下对并发请求的数量是有限制的，通常是 <code>4 ~ 8</code> 以内。超出的会被置入队列等待发送，即 <code>待处理 pending</code> 状态</p><p>如果并发请求量达到一定量级的时候，堆积了无数的调用栈就有可能会导致 <strong>内存溢出</strong></p><h3 id="liu-lan-qi-de-bing-fa-xian-zhi">浏览器的并发限制</h3><ul class="lvl-0"><li class="lvl-2"><p>Chrome 浏览器</p><p>同一域名同时最多只能建立 <code>6</code> 个 <code>TCP</code> 连接，也就是说单个域名最大的并发量不超过 <code>6</code> 个</p></li><li class="lvl-2"><p>Safari 浏览器</p><p>同一域名同时最多只能建立 <code>4</code> 个 <code>TCP</code> 连接，也就是说单个域名最大的并发量不超过 <code>4</code> 个</p></li><li class="lvl-2"><p>业务场景</p><p>假设现在有 <code>1000</code> 个异步任务需要执行，但出于性能的考虑，我们必须将执行的数量控制在 <code>3</code> 个以内，同时还要尽可能快的拿到响应结果</p><p>如：大文件的批量上传、大量的图片加载等 <strong>量化异步任务的执行且影响性能</strong> 的场景</p></li></ul><h3 id="you-hua-fang-an">优化方案</h3><ul class="lvl-0"><li class="lvl-2"><p>参数注解</p><pre><code class="language-js">/*** @description 异步任务并发量的控制* @param &#123;Array&#125; list 迭代数组* @param &#123;Number&#125; limit 控制的并发数量* @param &#123;Function&#125; handler 对list每一项的处理函数*/复制代码</code></pre></li><li class="lvl-2"><p>首先，通过 while 循环实现初始并发</p><pre><code class="language-js">while(limit--) &#123;  handler(list.shift())&#125;</code></pre></li><li class="lvl-2"><p>然后，通过递归依次执行下一个，直到全部执行完</p><pre><code class="language-js">const runInSequence = async (list, handler, callback) =&gt; &#123;  const item = list.shift()  if (item) &#123;    const result = await handler(item)    callback(result)    list.length &amp;&amp; runInSequence(list, handler, callback)  &#125;&#125;</code></pre></li><li class="lvl-2"><p>最后，组合以上逻辑</p><pre><code class="language-js">const asyncThrottling = (&#123; list, limit = 3, handler = () =&gt; &#123;&#125; &#125;) =&gt; &#123;  const response = [], len = list.length  return new Promise(resolve =&gt; &#123;    limit = len &gt; limit ? limit : len    while(limit--) &#123;      runInSequence(list, handler, result =&gt; &#123;        response.push(result)        response.length === len &amp;&amp; resolve(response)      &#125;)    &#125;  &#125;)&#125;</code></pre></li></ul><h1 id="xuan-ran-lian-lu-http-2-xie-yi">渲染链路：HTTP2协议</h1>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 业务与性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务与性能优化(前端) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索引擎排名技巧(SEO)</title>
      <link href="/2023/07/19/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8E%92%E5%90%8D%E6%8A%80%E5%B7%A7-SEO/"/>
      <url>/2023/07/19/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8E%92%E5%90%8D%E6%8A%80%E5%B7%A7-SEO/</url>
      
        <content type="html"><![CDATA[<p>应用的性能好坏直接影响到用户的体验，<code>SEO</code> 做的再好，脱离了性能优化一切也都是空谈，所以 <code>SEO</code> 和性能优化是相辅相成的。响应速度也是搜索引擎排序的一个重要指标</p><h1 id="ye-mian-tou-bu-biao-qian">页面头部标签</h1><ul class="lvl-0"><li class="lvl-2"><p>标题（30字以内）</p><pre><code class="language-html">&lt;title&gt;淘宝网 - 淘！我喜欢&lt;/title&gt;</code></pre><p>强调重点即可，重要的关键词出现不要超过 <code>2</code> 次，而且要靠前，不同页面的 <code>title</code> 要有所不同</p></li><li class="lvl-2"><p>描述（150字以内）</p><pre><code class="language-html">&lt;meta name=&quot;description&quot; content=&quot;淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！&quot;&gt;</code></pre><p>对页面内容的高度概括，不可过分堆砌关键词，不同页面的 <code>description</code> 要有所不同</p></li><li class="lvl-2"><p>关键字</p><pre><code class="language-html">&lt;meta name=&quot;keywords&quot; content=&quot;淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺&quot;&gt;</code></pre><p>告诉搜索引擎本页的重点、关键词，用英文逗号分隔</p></li><li class="lvl-2"><p>总结</p><p>代码顺序按照 标题 -&gt; 描述 -&gt; 关键字 依次</p></li></ul><h1 id="yu-yi-hua-de-hao-chu">语义化的好处</h1><ul class="lvl-0"><li class="lvl-4"><p>符合W3C规范</p></li><li class="lvl-4"><p>代码结构清晰，方便阅读，有利于团队合作开发</p></li><li class="lvl-4"><p>语义化代码让搜索引擎容易理解网页，有利于搜索引擎优化（SEO）</p></li></ul><h1 id="yu-yi-hua-nei-rong-biao-qian">语义化内容标签</h1><ul class="lvl-0"><li class="lvl-2"><p>超链接</p><p>内部链接，要加 <code>title</code> 属性加以说明</p><p>外部链接，要加 <code>rel=&quot;nofollow&quot;</code> 属性，告诉蜘蛛无需追踪</p></li><li class="lvl-2"><p>图片</p><p><code>img</code> 要加上 <code>alt</code> 属性加以说明</p></li><li class="lvl-2"><p>表格</p><p>标题使用 <code>caption</code> 标签</p></li><li class="lvl-2"><p>标题</p><p><code>h1</code> 一个页面只可有一个，多用于包含 <code>logo</code></p><p><code>h2</code> 模块标题</p><p><code>h3</code> 段落的小节标题</p><p><code>h4, h5, h6</code> 基本上不使用</p></li><li class="lvl-2"><p>强调内容的重要性</p><pre><code class="language-html">&lt;em&gt;强调文本&lt;/em&gt;&lt;strong&gt;强调文本&lt;/strong&gt;</code></pre><p><code>strong</code> 和 <code>em</code> 都表示强调，strong 显示为粗体，em 显示为斜体，且 strong 的强调程度要比 em 更高</p></li><li class="lvl-2"><p>视觉上突出显示文本</p><pre><code class="language-html">&lt;mark&gt;&lt;/mark&gt;</code></pre><p>如：搜索结果中高亮的关键词</p></li><li class="lvl-2"><p>时间</p><pre><code class="language-html">&lt;p&gt;文章发表于&lt;time datetime=&quot;2019-08-28 20:00&quot;&gt;2019-08-28&lt;/time&gt;&lt;/p&gt;</code></pre></li><li class="lvl-2"><p>定义联系信息</p><pre><code class="language-html">&lt;address&gt;&lt;/address&gt;</code></pre><p>也可定义 <code>article</code> 元素的作者信息，但不适用于嵌套的 <code>article</code> 元素</p></li><li class="lvl-2"><p>代表一段独立的内容，经常与说明配合使用</p><pre><code class="language-html">&lt;figure&gt;  &lt;!-- 图片、图表、表格等 --&gt;  &lt;figcaption&gt;标题/说明&lt;/figcaption&gt;&lt;/figure&gt;</code></pre><p><code>figcaption</code> 元素必须是 <code>figure</code> 元素的第一个或者最后一个子元素</p></li><li class="lvl-2"><p>换行</p><p><code>br</code> 只用于文本内容的换行</p></li><li class="lvl-2"><p>版权符号</p><p>输入法输入 <code>'banquan'</code>，按序号选择版权符号</p></li></ul><h1 id="yu-yi-hua-jie-gou-biao-qian">语义化结构标签</h1><ul class="lvl-0"><li class="lvl-2"><p>section使用场景</p><pre><code class="language-html">&lt;header&gt;&lt;/header&gt;&lt;section&gt;  &lt;h2&gt;标题&lt;/h2&gt;  &lt;p&gt;段落内容&lt;/p&gt;&lt;/section&gt;&lt;section&gt;  &lt;h2&gt;标题&lt;/h2&gt;  &lt;img src=&quot;./img/product.jpg&quot; alt=&quot;图片说明&quot;&gt;&lt;/section&gt;&lt;section&gt;  &lt;h2&gt;标题&lt;/h2&gt;  &lt;p&gt;段落内容&lt;/p&gt;&lt;/section&gt;&lt;footer&gt;&lt;/footer&gt;</code></pre><p>对页面中的内容进行分块，一个 <code>section</code> 元素通常由标题以及内容组成</p><p><strong>不推荐为那些没有标题的内容使用 section 标签</strong></p></li><li class="lvl-2"><p>article使用场景</p><pre><code class="language-html">&lt;article&gt;  &lt;header&gt;    &lt;h2&gt;标题&lt;/h2&gt;    &lt;p&gt;发表日期：&lt;time datetime=&quot;2019-08-28 20:00&quot;&gt;2019-08-28&lt;/time&gt;&lt;/p&gt;  &lt;/header&gt;  &lt;p&gt;文章内容段&lt;/p&gt;  &lt;p&gt;文章内容段&lt;/p&gt;&lt;/article&gt;</code></pre><p>它比 <code>section</code> 具有更明确的语义，代表一个独立的、完整的相关内容块，可以包含一个或多个 <code>section</code></p></li><li class="lvl-2"><p>aside使用场景</p><pre><code class="language-html">&lt;aside&gt;  &lt;h2&gt;&lt;/h2&gt;  &lt;ul&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;  &lt;/ul&gt;&lt;/aside&gt;</code></pre><p>独立于内容的一部分，且可以被单独的拆分出来而不会使整体受影响，常用于定义页面侧边栏</p></li><li class="lvl-2"><p>main使用场景</p><pre><code class="language-html">&lt;main&gt;&lt;/main&gt;</code></pre><p>用来呈现文档或应用的主体部分，一个页面只能有一个 <code>main</code> 标签</p></li><li class="lvl-2"><p>header使用场景</p><p>1、页面中的header</p><pre><code class="language-html">&lt;header&gt;  &lt;h1 role=&quot;logo&quot;&gt;    &lt;a href=&quot;/&quot;&gt;文字Logo&lt;/a&gt;  &lt;/h1&gt;  &lt;nav&gt;    &lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt;    &lt;a href=&quot;/product&quot;&gt;产品介绍&lt;/a&gt;    &lt;a href=&quot;/about&quot;&gt;关于我们&lt;/a&gt;  &lt;/nav&gt;&lt;/header&gt;</code></pre><p>2、分块中的header</p><pre><code class="language-html">&lt;section&gt;  &lt;header&gt;    &lt;h2&gt;标题&lt;/h2&gt;    &lt;p&gt;信息介绍&lt;/p&gt;  &lt;/header&gt;  &lt;p&gt;分块内容段&lt;/p&gt;&lt;/section&gt;</code></pre><p>3、文章中的header</p><pre><code class="language-html">&lt;article&gt;  &lt;header&gt;    &lt;h2&gt;标题&lt;/h2&gt;    &lt;p&gt;发表日期：&lt;time datetime=&quot;2019-08-28 18:00&quot;&gt;2019-08-28&lt;/time&gt;&lt;/p&gt;  &lt;/header&gt;  &lt;p&gt;文章内容段&lt;/p&gt;&lt;/article&gt;</code></pre><p><strong>article、section、aside、nav 都可以拥有自己的 header 和 footer</strong></p></li><li class="lvl-2"><p>role属性的使用场景</p><p>用来增强语义性，当现有的 HTML 标签不能充分表达语义的时候，可以借助 <code>role</code> 属性来说明</p></li></ul><h1 id="zhu-yi-shi-xiang">注意事项</h1><ul class="lvl-0"><li class="lvl-2"><p>重要内容尽量靠前放</p><p>搜索引擎抓取 <code>HTML</code> 的顺序是从上到下的，而有的搜索引擎对抓取的内容长度有一定的限制</p></li><li class="lvl-2"><p>重要内容不要用JS输出</p><p>搜索引擎不会抓取 <code>JS</code> 的生成内容</p></li><li class="lvl-2"><p>其他</p><p>页面结构尽量扁平化，目录结构不宜过深，最好不超过 <code>三级</code>，每级都有 <code>面包屑导航</code>，成树状结构分布。否则不利于搜索引擎抓取</p><p>做 <code>404</code> 页面，不仅提高蜘蛛体验，也提高用户体验</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 业务与性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务与性能优化(前端) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频与推流</title>
      <link href="/2023/07/19/%E8%A7%86%E9%A2%91%E4%B8%8E%E6%8E%A8%E6%B5%81/"/>
      <url>/2023/07/19/%E8%A7%86%E9%A2%91%E4%B8%8E%E6%8E%A8%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="video-biao-qian">Video标签</h1><pre><code class="language-html">&lt;video&gt;&lt;/video&gt;&lt;!-- video 标签属性中的属性:src=&quot;&quot; :资源路径controls : 在视频块中添加视频控件(暂停,倍速...)alt=&quot;&quot;:用于SEO(Search Engine Optimization 搜索引擎优化)autoplay 视频自动播放,因为浏览器的安全机制问题,有的浏览器支持,有的浏览器需要用户手动点击进行播放操作loop=&quot;true/false&quot;:视频播放完是否循环播放poster=&quot;url&quot;: 视频播放前显示预览图（海报图片）----&gt;</code></pre><p>如果浏览器不支持video标签则在其子元素中添加提示语句</p><pre><code class="language-html">&lt;video&gt;    浏览器不支持video&lt;/video&gt;</code></pre><p>也可以通过js创建一个空video元素,进行判断</p><pre><code class="language-js">if(document.createElement('video').canPlayType)&#123;    console.log('支持video');&#125;else&#123;    console.log('不支持video');&#125;</code></pre><p><strong>浏览器video中src出现错误无法进行加载情况:使用video子元素source来进行视频的轮询</strong></p><pre><code class="language-html">&lt;video controls&gt;    &lt;source src=&quot;&quot;&gt;&lt;/source&gt;&lt;source src=&quot;&quot;&gt;&lt;/source&gt;&lt;source src=&quot;&quot;&gt;&lt;/source&gt;&lt;/video&gt;</code></pre><p>source中的地址从上至下依次请求,直到请求成功</p><p><strong>自己实现控件(使用js中创建的video元素对象中的方法)</strong></p><pre><code class="language-html">&lt;video class=&quot;video-test&quot;&gt;    &lt;source src=&quot;&quot;&gt;&lt;/source&gt;&lt;source src=&quot;&quot;&gt;&lt;/source&gt;&lt;source src=&quot;&quot;&gt;&lt;/source&gt;&lt;/video&gt;&lt;button onClick=&quot;videoPlay(e)&quot;&gt;播放&lt;/button&gt;&lt;script&gt;const video = document.querySelector(&quot;.video-test&quot;);        const videoPlay = (e) =&gt;&#123;        video.play();    &#125;    &lt;/script&gt;</code></pre><h2 id="current-time">currentTime</h2><p>由js创建的vidoe的dom对象中的属性,记录了当前视频的相对时间,即当前视频播放进度(刚开始默认为0)</p><pre><code class="language-html">&lt;video class=&quot;video-test&quot;&gt;    &lt;source src=&quot;&quot;&gt;&lt;/source&gt;&lt;source src=&quot;&quot;&gt;&lt;/source&gt;&lt;source src=&quot;&quot;&gt;&lt;/source&gt;&lt;/video&gt;&lt;button onClick=&quot;videoPlay(e)&quot;&gt;播放&lt;/button&gt;&lt;script&gt;const video = document.querySelector(&quot;.video-test&quot;);    video.load();//虽然没有进行播放操作,但是可以从远端拉取流到本地缓冲区            const videoPlay = (e) =&gt;&#123;        video.play();        console.log(video.currentTime)    &#125;    &lt;/script&gt;</code></pre><p>通过对currentTime进行赋值,可以使视频跳转到指定时间帧</p><h2 id="yin-liang-volume">音量(Volume)</h2><p>视频中的音量是相对与系统的音量的逻辑值(0%-100%)</p><p>即假如系统的音量是80,那么视频的最高100%就是系统音量的80</p><pre><code class="language-js">&lt;script&gt;const video = document.querySelector(&quot;.video-test&quot;);    video.load();//虽然没有进行播放操作,但是可以从远端拉取流到本地缓冲区            const videoPlay = (e) =&gt;&#123;        video.play();       video.volume = 0.2    &#125;    &lt;/script&gt;</code></pre><h3 id="muted">muted</h3><p>通过设置创建的video的dom属性的muted可以控制视频是否静音true静音,false有声音</p><pre><code class="language-js">&lt;script&gt;const video = document.querySelector(&quot;.video-test&quot;);    video.load();//虽然没有进行播放操作,但是可以从远端拉取流到本地缓冲区            video.onclick = () =&gt;&#123;        video.play();        video.muted = !video.muted    &#125;    &lt;/script&gt;</code></pre><h2 id="duration">duration</h2><p>返回视频总共的时长,获取失败返回NaN,获取成功返回秒数</p><h2 id="current-src">currentSrc</h2><p>返回当前正在播放资源的地址</p><p>即返回video标签的当前在播放的子标签source的src</p><p><strong>paused:是否为暂停状态,是为true,否为false</strong></p><p><strong>ended:是否为完播状态,是为true,否为false</strong></p><h1 id="shi-pin">视频</h1><h2 id="xiang-guan-gai-nian">相关概念</h2><h3 id="fps-zheng-lu">FPS(帧率)</h3><p>视频内一秒内播放的画面,越高越流畅,越占用系统资源</p><p>Ps:24fps为人眼观看流畅标准,30为正常标准,60为显示器标准</p><h3 id="fen-bian-lu">分辨率</h3><p>水平方向上的包含的像素点×垂直方向上包含的像素点 = 分辨率</p><h3 id="ma-lu">码率</h3><p>视频文件在单位时间内使用的数据流量,通俗来讲就是单位时间画面采集频率</p><p>文件体积=时间X码率/8 (这里时间单位是秒,码率单位为bps即比特每秒)</p><p><strong>三者之间的关系:</strong></p><ul class="lvl-0"><li class="lvl-2"><p>帧率越高,每秒经过的画面越多,需要的码率也越高,体积也越大</p></li><li class="lvl-2"><p>在码率一定的情况下,分辨率与清晰度成反比:分辨率越高,图像越不清晰,分辨率越低图像越清晰</p></li><li class="lvl-2"><p>在分辨率一定的情况下,码率与清晰度成反比:码率越高,图像越不清晰,码率越低图像越清晰</p></li></ul><h3 id="mei-zheng-de-tu-pian-da-xiao">每帧的图片大小</h3><p>1帧 = 分辨率 × 24  -&gt;一个像素点是由rgb组成 rgb为三个字节一个字节8比特,则为3×8 = 24</p><h1 id="zhi-bo-tui-liu">直播推流</h1><p><img src="/2023/07/19/%E8%A7%86%E9%A2%91%E4%B8%8E%E6%8E%A8%E6%B5%81/image-20230601164144459.png" alt="image-20230601164144459"></p><p><strong>整体架构</strong></p><p><img src="/2023/07/19/%E8%A7%86%E9%A2%91%E4%B8%8E%E6%8E%A8%E6%B5%81/image-20230601164944901.png" alt="image-20230601164944901"></p><p><strong>工作流程</strong></p><p><img src="/2023/07/19/%E8%A7%86%E9%A2%91%E4%B8%8E%E6%8E%A8%E6%B5%81/image-20230601165148586.png" alt="image-20230601165148586"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 业务与性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务与性能优化(前端) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件处理程序的相关优化</title>
      <link href="/2023/07/19/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/"/>
      <url>/2023/07/19/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="shi-jian-liu-ji-zhi">事件流机制</h1><p>向水里扔一个西瓜，</p><p>首先它会有一个下降的过程，这个过程可以理解为从最顶层元素向事件发生的具体元素（目标点）的捕获过程</p><p>之后会产生泡泡，会在最低点（具体元素）之后漂浮到水面上，这个过程相当于事件冒泡</p><p><img src="images/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/90c6d0e2180f4ed28f1137c32b955995tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0-1689775169899-1.webp" alt></p><h1 id="shi-jian-chu-li-cheng-xu">事件处理程序</h1><ul class="lvl-0"><li class="lvl-2"><p>事件委托原理</p><p>利用事件冒泡，只使用一个事件处理程序来管理一系列的类型事件</p><p>也就是说给所有目标元素的共同祖先节点添加一个事件处理程序即可</p><p><code>这样可以减少大量的内存消耗，提升性能</code></p></li><li class="lvl-2"><p>性能解析</p><p>页面中事件处理程序的数量与页面的整体性能直接相关</p><p>每个函数都是对象，都占用内存空间，对象越多，性能越差</p><p>事件处理程序所需访问的 <code>DOM</code> 次数会影响整个页面的就绪时间，导致页面响应缓慢</p></li><li class="lvl-2"><p>事件对象</p><pre><code class="language-JS">event.target  // 触发事件的目标元素event.currentTarget  // 绑定事件的元素event.stopPropagation()  // 阻止事件冒泡event.preventDefault()  // 阻止元素的默认事件</code></pre></li></ul><h1 id="hua-ru-hua-chu-shi-jian">划入划出事件</h1><ul class="lvl-0"><li class="lvl-2"><p>mouseover 和 mouseout</p><p>在鼠标指针从父元素移动到子元素时，会先触发父元素的 <code>mouseout</code> 事件，再触发子元素的 <code>mouseover</code> 事件；在鼠标指针从子元素移回父元素时，会先触发子元素的 <code>mouseout</code> 事件，再触发父元素的 <code>mouseover</code> 事件。这种行为被称为事件冒泡或捕获机制。</p><pre><code class="language-html">&lt;div id=&quot;box&quot;&gt;  &lt;button type=&quot;button&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt;</code></pre><pre><code class="language-css">.box &#123;  width: 200px;  height: 80px;  background-color: #0f0;&#125;</code></pre><pre><code class="language-js">const box = document.querySelector('#box')box.addEventListener('mouseover', () =&gt; &#123;  console.log('移动到自身和其子元素身上都会触发事件')&#125;)</code></pre></li><li class="lvl-2"><p>mouseenter 和 mouseleave</p><pre><code class="language-js">box.addEventListener('mouseenter', () =&gt; &#123;  console.log('只移动到自身触发事件')&#125;)</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 业务与性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务与性能优化(前端) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传文件校验</title>
      <link href="/2023/07/19/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%A0%A1%E9%AA%8C/"/>
      <url>/2023/07/19/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>如果把任意的垃圾文件后缀名修改成允许上传的类型，不仅会造成程序崩溃，还有可能会浪费不必要的资源</p><p>这种恶意上传的操作，不仅带来安全隐患，还会造成不必要的性能开销</p><h1 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h1><p>[[File&amp;Blob]]</p><ul><li><p>Blob 对象</p><p>Blob（Binary Large Object）二进制类型的大对象，表示一个不可变、原始数据的类文件对象。可以通过 <code>slice()</code> 方法将它们分割成为非常小的数据块</p><p><code>File</code> 接口基于 <code>Blob</code> 实现，继承了其功能并将其扩展，使其支持用户系统上的文件</p></li><li><p>FileReader 对象</p><p>主要用于将文件内容读入 <strong>内存</strong>，通过一系列 <strong>异步接口</strong> 读取本地文件内容并输出结果</p><p><code>readAsArrayBuffer()</code> 按字节读取文件内容，结果用 ArrayBuffer 对象表示</p><p><code>readAsText()</code> 按字节读取文件内容，结果用字符串表示</p><p><code>readAsDataURL()</code> 读取文件内容，结果用 data:URL 格式的 Base64 字符串表示</p></li><li><p>ArrayBuffer 对象</p><p>表示通用的、固定长度的原始二进制数据缓冲区，它是一个 <code>二进制字节数组</code></p></li><li><p>Uint8Array 数组类型</p><p>表示一个 <code>8</code> 位无符号整型数组，创建时内容被初始化为 <code>0</code>。创建完后，可以以 <code>对象的方式或使用数组下标索引的方式</code> 引用数组中的元素</p></li></ul><h1 id="前置插件配置"><a href="#前置插件配置" class="headerlink" title="前置插件配置"></a>前置插件配置</h1><ul><li><p>安装 VSCode 插件</p><p>在插件商店中搜索并安装 Hex Editor</p></li></ul><ul><li><p>使用插件查看文件的十六进制内容（以 jpg 文件为例）</p><p><img src="images/上传文件校验/Snipaste_2023-05-08_09-06-57-1689774922523-1.png" alt></p></li></ul><h1 id="常规类型校验"><a href="#常规类型校验" class="headerlink" title="常规类型校验"></a>常规类型校验</h1><ul><li><p>使用 HTML 属性</p><pre><code class="lang-html">&lt;input type=&quot;file&quot; accept=&quot;.mp4, .mov&quot;&gt;&lt;input type=&quot;file&quot; accept=&quot;.png, .jpg, .jpeg, .gif&quot;&gt;</code></pre><p>缺点：可通过浏览器控制台删除 <code>accept</code> 属性，绕过限制</p></li><li><p>使用文件 MIME 类型</p><pre><code class="lang-js">const validFileType = Object.assign(Object.create(null), &#123;        video: [&#39;video/mp4&#39;, &#39;video/quicktime&#39;],        image: [&#39;image/png&#39;, &#39;image/jpeg&#39;, &#39;image/gif&#39;],      &#125;);</code></pre><pre><code>const validator = (type, files) =&gt;  files    .map((file) =&gt; (&#123;      filename: file.name,      valid: validFileType[type].includes(file.type),    &#125;))    .filter((f) =&gt; !f.valid);</code></pre><p>  ```</p></li></ul><pre><code>缺点：可通过本地修改文件扩展名，绕过限制</code></pre><h1 id="安全性类型校验"><a href="#安全性类型校验" class="headerlink" title="安全性类型校验"></a>安全性类型校验</h1><ul><li><p>核心思想</p><p>使用 <code>slice()</code> 方法截取文件头部数据，将其转换为 <code>十六进制</code> 字符串，然后进行逻辑判断</p></li><li><p>配置文件类型映射策略</p><pre><code class="lang-js">const typeMapping = new Map([  [&#39;mp4&#39;, &#123; num: 4, hexs: [&#39;00 00 00 18&#39;, &#39;00 00 00 20&#39;, &#39;00 00 00 1C&#39;] &#125;],  [&#39;mov&#39;, &#123; num: 8, hexs: [&#39;00 00 00 14 66 74 79 70&#39;] &#125;],  [&#39;jpg&#39;, &#123; num: 3, hexs: [&#39;FF D8 FF&#39;] &#125;],  [&#39;png&#39;, &#123; num: 8, hexs: [&#39;89 50 4E 47 0D 0A 1A 0A&#39;] &#125;],  [&#39;gif&#39;, &#123; num: 4, hexs: [&#39;47 49 46 38&#39;] &#125;],  [&#39;pdf&#39;, &#123; num: 7, hexs: [&#39;25 50 44 46 2D 31 2E&#39;] &#125;],  [&#39;zip&#39;, &#123; num: 6, hexs: [&#39;50 4B 03 04 14 00&#39;] &#125;],  [&#39;excel&#39;, &#123; num: 4, hexs: [&#39;50 4B 03 04&#39;] &#125;],  [&#39;image&#39;, &#123; num: 8, hexs: [&#39;FF D8 FF&#39;, &#39;89 50 4E 47 0D 0A 1A 0A&#39;, &#39;47 49 46 38&#39;] &#125;],  [&#39;video&#39;, &#123; num: 8, hexs: [&#39;00 00 00 18&#39;, &#39;00 00 00 20&#39;, &#39;00 00 00 1C&#39;, &#39;00 00 00 14 66 74 79 70&#39;] &#125;]])</code></pre><p>使用 <code>num</code> 来配置提取文件头部数据的范围，提取起始处的索引从 <code>0</code> 开始</p><p>使用 <code>hexs</code> 来配置提取范围对应的十六进制字符串，用于策略逻辑判断</p></li><li><p>根据文件类型读取映射策略</p><pre><code class="lang-js">const validFileType = async (type, file) =&gt; &#123;  const &#123; num, hexs &#125; = typeMapping.get(type)  const str = await blobToString(file.slice(0, num))  if (type === &#39;image&#39; || type === &#39;video&#39;) &#123;    return hexs.some(hex =&gt; str.startsWith(hex))  &#125; else &#123;    return str === hexs.join()  &#125;&#125;</code></pre></li><li><p>文件的二进制数据转为十六进制字符串</p><pre><code class="lang-js">/*** @param &#123;Blob&#125; blob 二进制文件数据* @return &#123;String&#125; 16进制字符串*/const blobToString = async (blob) =&gt; &#123;        const buffer = await blob.arrayBuffer();        return [...new Uint8Array(buffer)]          .map((n) =&gt; n.toString(16).toUpperCase().padStart(2, &#39;0&#39;))          .join(&#39; &#39;);      &#125;;</code></pre></li><li><p>文件类型校验</p><pre><code class="lang-js">/*** @param &#123;String&#125; type 文件类型* @param &#123;Array&#125; files 文件对象* @return &#123;Array&#125; 文件类型校验不通过的文件列表*/const validator = async (type, files) =&gt;        (          await Promise.all(            files.map(async (file) =&gt; (&#123;              filename: file.name,              valid: await validFileType(type, file),            &#125;))          )        ).filter((f) =&gt; !f.valid);</code></pre><p>经测试，即便通过本地修改文件扩展名，文件也会被校验限制</p></li><li><p>总结</p><p>很多攻击方式都是把可执行文件的后缀名进行修改，然后上传到服务器进行攻击，可见文件类型校验的重要性</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 业务与性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务与性能优化(前端) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防盗链以减少第三方使用</title>
      <link href="/2023/07/19/%E9%98%B2%E7%9B%97%E9%93%BE%E4%BB%A5%E5%87%8F%E5%B0%91%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/07/19/%E9%98%B2%E7%9B%97%E9%93%BE%E4%BB%A5%E5%87%8F%E5%B0%91%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="xiang-jie-referer">详解Referer</h1><ul class="lvl-0"><li class="lvl-2"><p>Referer是什么</p><p>Referer 是请求头信息里的一个常见字段，它提供了访问来源的信息</p><p>当客户端向服务端发送请求时，都会携带 Referer 头字段，告知服务器该请求的来源，即 <code>触发请求的页面链接</code></p></li><li class="lvl-2"><p>Referer存在的条件</p><p>1、点击页面中的超链接</p><p>2、通过 <code>src</code> 或 <code>href</code> 属性加载静态资源，如图片、视频、脚本、样式等等</p><p>3、通过 <code>get</code> 或 <code>post</code> 发送请求</p></li><li class="lvl-2"><p>获取不到Referer的情况</p><p>1、直接在浏览器中输入 <code>URL</code> 地址</p><p>2、在 <code>HTTPS</code> 应用中使用第三方应用的 <code>HTTP</code> 资源</p></li><li class="lvl-2"><p>Referer的作用</p><p>1、对应用流量的来源做统计</p><p>2、防止资源被盗链</p></li></ul><p>当页面链接至使用 <code>target=&quot;_blank&quot;</code> 的另一个页面时，新页面将与您的页面在同一个进程上运行。 如果新页面正在执行开销极大的 <code>JavaScript</code>，页面性能可能会受影响。<code>target=&quot;_blank&quot;</code>也是一个安全漏洞。新的页面可以通过<code>window.opener</code> 访问您的窗口对象，并且它可以使用 <code>window.opener.location = newURL</code>将页面导航至不同的网址。</p><p>原来，<strong>当你使用<code>target=&quot;_blank&quot;</code>打开一个新的标签页时，新页面的<code>window</code>对象上有一个属性 <code>opener</code> ,它指向的是前一个页面的<code>window</code>对象，因此，后一个新打开的页面就可以控制前一个页面了，事情就是这么的可怕…</strong></p><p>a标签<code>&lt;a href='https://www.xxx.com'&gt;https://www.xxx.com&lt;/a&gt;</code>,如果<strong>打开的页面的域名和当前页面的域名是在同一个域名下</strong>，在打开后的控制台输入<code>window.opener.alert(1)</code>,你会惊讶的发现，上一个页面竟然弹出个大大的<code>1</code>，自己动手试一下吧！</p><p>而在<strong>跳转到另一个域名的页面</strong>的情况下，使用<code>window.opener.location.replace</code>方法，可以把上一个页面的<code>url</code>给改掉</p><h1 id="xiang-jie-dao-lian">详解盗链</h1><ul class="lvl-0"><li class="lvl-2"><p>什么是盗链</p><p>未经第三方授权或同意，就把其资源引用到了自己的应用上，比如图片、视频、文件下载等等，可以通过消耗第三方应用的流量来在自己的应用中使用这些资源</p><p>浏览器在页面呈现的过程中，拉取非当前应用的资源，就称为是<strong>盗链</strong></p></li><li class="lvl-2"><p>实现盗链</p><p>1、在 <code>HTTPS</code> 应用中使用第三方应用的 <code>HTTP</code> 资源</p><ul class="lvl-2"><li class="lvl-6"><p>2、通过设置 a 标签的 rel 属性</p></li></ul><pre><code class="language-html">&lt;a href=&quot;视频资源地址&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;</code></pre><p>通过设置 <code>noreferrer</code> 属性禁用请求头部的 <code>Referer</code> 属性，可在新页面中访问防盗链资源</p><p>通过设置 <code>noopener</code> 属性在新打开的页面中不授予对打开它的文档的访问权限，即 <code>window.opener</code> 属性值返回 <code>null</code>，以此来确保无法通过 <code>window.opener</code> 属性来篡改原始文档<br><code>rel=noreferrer</code> 是为了兼容旧浏览器。</p></li></ul><h1 id="zhu-yi-shi-xiang">注意事项</h1><p>平常在应用中通过 <code>a</code> 标签链接第三方外部资源时（打开新页面），都应该添加以上属性，以增强应用的<code>安全性</code></p><p>从 Chromium 88 版开始，默认情况下，带有 target=“_blank” 的锚点会自动获得 noopener 行为。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 业务与性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务与性能优化(前端) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码中大量ifelse的优化策略</title>
      <link href="/2023/07/19/%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%A4%A7%E9%87%8Fifelse%E7%9A%84%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"/>
      <url>/2023/07/19/%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%A4%A7%E9%87%8Fifelse%E7%9A%84%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h4 id="单个-if-语句单条件优化"><a href="#单个-if-语句单条件优化" class="headerlink" title="单个 if 语句单条件优化"></a>单个 if 语句单条件优化</h4><ul><li><p>优化前</p><pre><code class="lang-js">if (flag) &#123;  this.handleFunc()&#125;</code></pre></li><li><p>优化后</p><pre><code class="lang-js">flag &amp;&amp; this.handleFunc()</code></pre><p>如果有很多的 <code>if</code> 语句，但执行的功能函数是同一个的情况下，可以使用 <code>&amp;</code> 和 <code>||</code> 逻辑运算符合成一个表达式，增强其 <code>可读性</code></p></li></ul><h4 id="单个-if-语句多条件优化"><a href="#单个-if-语句多条件优化" class="headerlink" title="单个 if 语句多条件优化"></a>单个 if 语句多条件优化</h4><ul><li><p>优化前</p><pre><code class="lang-js">if (filetype === &#39;image/png&#39; || filetype === &#39;image/jpeg&#39; || filetype === &#39;image/gif&#39;) &#123;  console.log(&#39;文件类型为图片&#39;)&#125;</code></pre></li><li><p>优化后</p><pre><code class="lang-js">const mimetypes = [&#39;image/png&#39;, &#39;image/jpeg&#39;, &#39;image/gif&#39;]if (mimetypes.includes(filetype)) &#123;  console.log(&#39;文件类型为图片&#39;)&#125;</code></pre></li></ul><h4 id="单个-if-else-语句优化"><a href="#单个-if-else-语句优化" class="headerlink" title="单个 if/else 语句优化"></a>单个 if/else 语句优化</h4><ul><li><p>优化前</p><pre><code class="lang-js">let accountStatus = &#39;&#39;if (enabled) &#123;  accountStatus = &#39;正常&#39;&#125; else &#123;  accountStatus = &#39;禁用&#39;&#125;</code></pre></li><li><p>优化后</p><pre><code class="lang-js">const accountStatus = enabled ? &#39;正常&#39; : &#39;禁用&#39;</code></pre><p>只需要一行语句，代码既简练又易读</p></li></ul><h4 id="多个-else-if-分支优化"><a href="#多个-else-if-分支优化" class="headerlink" title="多个 else if 分支优化"></a>多个 else if 分支优化</h4><ul><li><p>优化前</p><pre><code class="lang-js">if (operation === &#39;open&#39;) &#123;  this.handleOpen()&#125; else if (operation === &#39;pause&#39;) &#123;  this.handlePause()&#125; else if (operation === &#39;edit&#39;) &#123;  this.handleEdit()&#125; else &#123;  this.handleDelete()&#125;</code></pre><p>设计复杂，代码可读性差，随着逻辑复杂性的增加，代码会变得越来越臃肿</p><p><img src="/2023/07/19/%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%A4%A7%E9%87%8Fifelse%E7%9A%84%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/f33b01ceebb24cc39b57ae7ed878d2c2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt></p></li></ul><p>  不同条件分支的代码具有很高的耦合度。前边的条件判断影响后续的代码流，这样的代码对于后期的维护非常的不友好</p><ul><li><p>优化后</p><pre><code class="lang-js">switch(operation) &#123;  case &#39;open&#39;:     this.handleOpen()    break  case &#39;pause&#39;:    this.handlePause()    break  case &#39;edit&#39;:    this.handleEdit()    break  default:    this.handleDelete()&#125;</code></pre></li></ul><h4 id="多个-if-语句多层复杂条件优化"><a href="#多个-if-语句多层复杂条件优化" class="headerlink" title="多个 if 语句多层复杂条件优化"></a>多个 if 语句多层复杂条件优化</h4><ul><li><p>优化前</p><pre><code class="lang-js">if (mode === &#39;kwai&#39;) &#123;  if (operation === &#39;open&#39;) &#123;    this.handleKwaiOpen()  &#125; else if (operation === &#39;pause&#39;) &#123;    this.handleKwaiPause()  &#125; else if (operation === &#39;edit&#39;) &#123;    this.handleKwaiEdit()  &#125; else &#123;    this.handleKwaiDelete()  &#125;&#125; else if (mode === &#39;tencent&#39;) &#123;  if (operation === &#39;open&#39;) &#123;    this.handleTencentOpen()  &#125; else if (operation === &#39;pause&#39;) &#123;    this.handleTencentPause()  &#125; else if (operation === &#39;edit&#39;) &#123;    this.handleTencentEdit()  &#125; else &#123;    this.handleTencentDelete()  &#125;&#125;</code></pre></li><li><p>优化后</p><pre><code class="lang-js">const operations = Object.assign(Object.create(null), &#123;  &#39;kwai&#39;: new Map([    [&#39;open&#39;, handleKwaiOpen],    [&#39;pause&#39;, handleKwaiPause],    [&#39;edit&#39;, handleKwaiEdit],    [&#39;delete&#39;, handleKwaiDelete],  ]),  &#39;tencent&#39;: new Map([    [&#39;open&#39;, handleTencentOpen],    [&#39;pause&#39;, handleTencentPause],    [&#39;edit&#39;, handleTencentEdit],    [&#39;delete&#39;, handleTencentDelete],  ])&#125;)function(mode, type) &#123;  console.log(&#39;handleType&#39;, operations[mode].get(type))&#125;</code></pre></li></ul><h4 id="可选链运算符"><a href="#可选链运算符" class="headerlink" title="可选链运算符"></a>可选链运算符</h4><ul><li><p>优化前</p><pre><code class="lang-js">if (res &amp;&amp; res.userInfo &amp;&amp; res.userInfo.roles) &#123;  const roles = res.userInfo.roles&#125;</code></pre><p><code>对象属性层层判断是否存在不仅麻烦还会产生冗余的代码</code></p></li><li><p>优化后</p><pre><code class="lang-js">const roles = res?.userInfo?.roles</code></pre></li></ul><h4 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h4><p><code>if-else</code> 不超过 <code>2</code> 层，块中代码 <code>1~5</code> 行，直接写到块中，否则封装为方法</p><p><code>if-else</code> 超过 <code>2</code> 层，但块中的代码不超过 <code>3</code> 行，尽量使用 <code>Switch</code> 语句</p><p><code>if-else</code> 超过 <code>2</code> 层，且块中代码超过 <code>3</code> 行，尽量使用<code>策略模式</code></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 业务与性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务与性能优化(前端) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遍历一次把扁平数组转Tree</title>
      <link href="/2023/07/19/%E9%81%8D%E5%8E%86%E4%B8%80%E6%AC%A1%E6%8A%8A%E6%89%81%E5%B9%B3%E6%95%B0%E7%BB%84%E8%BD%ACTree/"/>
      <url>/2023/07/19/%E9%81%8D%E5%8E%86%E4%B8%80%E6%AC%A1%E6%8A%8A%E6%89%81%E5%B9%B3%E6%95%B0%E7%BB%84%E8%BD%ACTree/</url>
      
        <content type="html"><![CDATA[<p><strong>树结构（Tree）</strong> 是一种典型的非线性数据结构，它是由 n (n &gt; 0) 个有限节点组成的一个具有层次关系的集合</p><p><img src="images/%E9%81%8D%E5%8E%86%E4%B8%80%E6%AC%A1%E6%8A%8A%E6%89%81%E5%B9%B3%E6%95%B0%E7%BB%84%E8%BD%ACTree/e50cf64cb55d4665b64f8183c942b532tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0-1689774035296-1.webp" alt></p><p>在实际的工作中，为了满足业务需求，需要把后端返回的扁平化的数组结构，转换成树形结构</p><h1 id="shu-ju-jie-gou">数据结构</h1><ul class="lvl-0"><li class="lvl-2"><p>扁平数据</p><pre><code class="language-js"> [   &#123; id: 1, pid: null, name: 'M1部门' &#125;,   &#123; id: 11, pid: 1, name: '张三' &#125;,   &#123; id: 12, pid: 1, name: '李四' &#125;,   &#123; id: 13, pid: 1, name: '王五' &#125;,   &#123; id: 2, pid: null, name: 'M2部门' &#125;,   &#123; id: 21, pid: 2, name: '赵六' &#125;,   &#123; id: 22, pid: 2, name: '周七' &#125;,   &#123; id: 23, pid: 2, name: '吴八' &#125; ]</code></pre></li><li class="lvl-2"><p>树形数据</p><pre><code class="language-js"> [   &#123;     id: 1, pid: null, name: 'M1部门',     children: [       &#123; id: 11, pid: 1, name: '张三' &#125;,       &#123; id: 12, pid: 1, name: '李四' &#125;,       &#123; id: 13, pid: 1, name: '王五' &#125;     ]   &#125;,   &#123;     id: 2, pid: null, name: 'M2部门',     children: [       &#123; id: 21, pid: 2, name: '赵六' &#125;,       &#123; id: 22, pid: 2, name: '周七' &#125;,       &#123; id: 23, pid: 2, name: '吴八' &#125;     ]   &#125; ]</code></pre></li></ul><h1 id="di-gui-suan-fa">递归算法</h1><ul class="lvl-0"><li class="lvl-2"><p>定义</p><p>程序调用自身的编程技巧称为<strong>递归</strong></p></li><li class="lvl-2"><p>作用</p><p>它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，<strong>大大地减少了程序的代码量</strong></p></li></ul><h1 id="di-gui-zhuan-huan">递归转换</h1><ul class="lvl-0"><li class="lvl-2"><p>根据 pid 和 id 的对应关系筛选出根结点</p><pre><code class="language-js">list.filter(item =&gt; item.pid === null)</code></pre></li><li class="lvl-2"><p>遍历根节点调用自身匹配子节点</p><pre><code class="language-js">const listToTree = (list, &#123;rootid = null, id = 'id', pid = 'pid'&#125; = &#123;&#125;) =&gt; &#123;  return list.filter(item =&gt; item[pid] === rootid)              .map(item =&gt; (&#123; ...item, children: listToTree(list, &#123; rootid: item[id] &#125;) &#125;))&#125;</code></pre></li><li class="lvl-2"><p>性能解析</p><p><strong>递归容易造成堆栈的溢出，且消耗大量的内存</strong></p></li></ul><h1 id="bian-li-zhuan-huan">遍历转换</h1><ul class="lvl-0"><li class="lvl-2"><p>核心思想</p><p>利用引用数据类型浅拷贝的特性，直接从 <code>Map</code> 中找对应的数据进行存储</p></li><li class="lvl-2"><p>通过 id 给列表的每一项做一个映射</p><pre><code class="language-JS">const hash = new Map()list.forEach(item =&gt; hash.set(item.id, item))</code></pre></li><li class="lvl-2"><p>通过 pid 从映射中取父节点</p><pre><code class="language-JS">const listToTree = (list = [], &#123;id = 'id', pid = 'pid', branch = 'children'&#125; = &#123;&#125;) =&gt; &#123;  const hash = new Map(), roots = []  list.forEach(item =&gt; &#123;    hash.set(item[id], item)    const parent = hash.get(item[pid])    if (!parent) &#123;      roots.push(item)    &#125; else &#123;      !parent[branch] &amp;&amp; (parent[branch] = [])      parent[branch].push(item)    &#125;  &#125;)  return roots&#125;</code></pre><p>如果节点不存在则当前节点 <code>item</code> 为根节点</p><p>如果存在则把当前 <code>item</code> 节点添加到 <code>parent</code> 节点的 <code>children</code> 属性中</p></li><li class="lvl-2"><p>参数注解</p><pre><code class="language-js">/*** 扁平数据结构转Tree* * @param &#123;Array&#125; list 源数据* @param &#123;String&#125; id 唯一的自增ID名称* @param &#123;String&#125; pid 父ID名称* @param &#123;String&#125; branch 树杈字段名称* @return &#123;Array&#125; roots 目标数据* @example**   listToTree(data)*   listToTree(data, &#123; branch: 'children' &#125;)*/</code></pre></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>chatGpt返回数据实时更新(SSE)</title>
      <link href="/2023/07/19/chatGpt%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0-SSE/"/>
      <url>/2023/07/19/chatGpt%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0-SSE/</url>
      
        <content type="html"><![CDATA[<p><strong>服务器发送事件（Server-Sent Events，简称 SSE）</strong> 其实就是浏览器向服务器发送一个 <code>HTTP</code> 请求，然后服务器不断单向地向浏览器推送消息</p><p>所谓的消息，其实就是一定格式的文本事件流（数据流）</p><p><img src="/2023/07/19/chatGpt%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0-SSE/v2-471e38eb6ef654800d28c7d623dd22a8_720w.png" alt></p><h1 id="sse-de-te-dian">SSE的特点</h1><ul class="lvl-0"><li class="lvl-4"><p>基于 <code>http</code> 协议的单向通信</p></li><li class="lvl-4"><p>默认支持断线重连，并支持发送自定义事件类型消息</p></li><li class="lvl-4"><p>只支持发送文本</p></li><li class="lvl-4"><p>是 <code>WebSocket</code> 的一种轻型替代方案，受同源策略的限制</p></li><li class="lvl-4"><p>前端: 不使用<code>xhr/fetch</code>,而使用特定的API : <code>EventSource</code></p></li><li class="lvl-4"><p>后端: <code>Content-Type: text/event-stream</code></p></li></ul><h1 id="xiao-xi-de-gou-cheng">消息的构成</h1><ul class="lvl-0"><li class="lvl-4"><p>消息唯一标识（id）</p><p>相当于每一条数据的编号，可通过 <code>lastEventId</code> 属性读取。一旦连接中断，浏览器会发送包含 <code>Last-Event-ID: id</code> 头信息来帮助服务器重建连接</p></li><li class="lvl-4"><p>消息内容（data）</p><p>只能为文本字符串，发送 <code>JSON</code> 数据 <code>data:$&#123;JSON.stringify(&#123; name: 'adiu', alias: '老夫子' &#125;)&#125;\n\n</code></p></li><li class="lvl-4"><p>自定义事件类型（event）</p><p>服务器端可自定义，浏览器端通过 <code>addEventListener</code> 监听，如果未指定，则触发浏览器端的 <code>message</code> 事件</p></li><li class="lvl-4"><p>最大间隔时间/毫秒（retry）</p><p>如果未指定通信的最大间隔时间，服务器端 <code>3</code> 秒内没有发送任何信息，浏览器端默认开始重连</p><p>由于网络错误导致连接出错，浏览器也会自动重新发起连接</p></li></ul><h1 id="sse-he-socket-de-qu-bie">SSE和Socket的区别</h1><ul class="lvl-0"><li class="lvl-2"><p>通信方式<br>SSE为单向通信,Socket为全双工、半双工通信</p></li><li class="lvl-2"><p>协议<br>SSE为http GET,Socket为ws</p></li><li class="lvl-2"><p>跨域<br>SSE不能跨域,Socket可以跨域</p></li></ul><h1 id="ke-hu-duan-dai-ma">客户端代码</h1><ul class="lvl-0"><li class="lvl-4"><p>检测浏览器是否支持</p><pre><code class="language-js">if (!!window.EventSource) &#123;  console.log('当前浏览器支持事件推送')&#125;</code></pre></li><li class="lvl-4"><p>建立连接</p><pre><code class="language-js">if (!!window.EventSource) &#123;  const ets = new EventSource('http://127.0.0.1/sse/notice')&#125;</code></pre></li><li class="lvl-4"><p>连接状态（ets.readyState）</p><p><code>0</code> 表示连接还未建立，或者连接断线</p><p><code>1</code> 表示连接已经建立，可以接受数据</p><p><code>2</code> 表示连接已断，且不会重连</p></li><li class="lvl-4"><p>建立连接，触发事件</p><pre><code class="language-js">ets.addEventListener('open', event =&gt; &#123;  console.log('handle open event')&#125;)</code></pre><p>连接一旦建立，就会触发 <code>open</code> 事件</p></li><li class="lvl-4"><p>错误处理</p><pre><code class="language-js">ets.addEventListener('error', event =&gt; &#123;  console.log('handle error event')&#125;)</code></pre><p>如果发生通信错误（比如连接中断），就会触发 <code>error</code> 事件</p></li><li class="lvl-4"><p>自定义事件</p><pre><code class="language-js">ets.addEventListener('notice', event =&gt; &#123;  const &#123; data, origin, lastEventId &#125; = event  console.log('消息内容', data)  console.log('服务器端URL的域名部分，即协议、域名和端口', origin)  console.log('数据的编号，由服务器端发送。如果没有编号，这个属性为空', lastEventId)&#125;)</code></pre></li><li class="lvl-4"><p>关闭推送</p><pre><code class="language-js">ets.close()</code></pre><p>默认情况下，如果客户端和服务端之间的连接关闭，则会自动重连。可以通过 <code>close()</code> 方法终止连接</p></li></ul><p><strong>实战</strong></p><pre><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;chatgpt stream 响应数据SSE测试 demo&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;button class=&quot;btn&quot;&gt;请求接口&lt;/button&gt;    &lt;div id=&quot;result&quot; style=&quot;word-wrap: break-word;&quot;&gt;&lt;/div&gt;    &lt;script type=&quot;module&quot;&gt;    let resultEl = document.querySelector('#result')    // SSE https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events/Using_server-sent_events#%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E5%8F%97%E4%BA%8B%E4%BB%B6    // 前端 EventStream API 发起请求，后端 Koa，ctx.body 设置 stream 可写流，ctx.set 响应类型 text/event-stream。    document.querySelector(&quot;.btn&quot;).addEventListener(&quot;click&quot;, () =&gt; &#123;        const evtSource = new EventSource(&quot;/open-ai/sendMsg&quot;);        evtSource.onmessage = function (event) &#123;          console.log(&quot;message: &quot; + event.data);          resultEl.innerHTML += event.data;        &#125;;      &#125;);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="zhu-yi-shi-xiang">注意事项</h1><ul class="lvl-0"><li class="lvl-4"><p>由于传输的数据格式必须是文本，所以每个字段之间要用换行符 <code>\n</code> 隔开，最后一个字段要用 <code>\n\n</code> 表示一条消息的结束</p></li><li class="lvl-4"><p>服务端发送数据时必须设置响应头标识推送的数据是流信息 <code>Content-Type: text/event-stream</code></p></li><li class="lvl-4"><p>不建议缓存事件推送数据</p></li><li class="lvl-4"><p>如果用户量很多，就需要保持很多长连接，因此会<strong>占用服务器大量内存和连接数</strong></p></li></ul><p>若前端部署使用的是Nginx配置</p><h1 id="nginx-pei-zhi-ruo-bu-jin-xing-pei-zhi-qian-duan-wu-fa-jie-shou">Nginx配置(若不进行配置,前端无法接收)</h1><p><strong>这并不是最优解</strong></p><pre><code class="language-json">server&#123;listen 80;server_name test.com;location / &#123;proxy_pass http://127.0.0.1:9000#修复sse eventSource 无法接收到消息的问题proxy_set_header Connection '';proxy_http_version 1.1;chunked_transfer_encoding off;// 默认配置中proxy_buffering是on,SSE的实时性被打破了,有缓存,前端不会定时输出proxy_buffering off;  proxy_cache off;&#125;&#125;</code></pre><p><strong>最优解是后端返回的接口响应头中设置 <code>Cache-Control:no-cache</code></strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 业务与性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务与性能优化(前端) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长任务优化</title>
      <link href="/2023/07/19/%E9%95%BF%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%8C%96/"/>
      <url>/2023/07/19/%E9%95%BF%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>由于浏览器 GUI 渲染线程与 JS 引擎线程是互斥的关系，当页面中有很多长任务时，会造成页面 UI 阻塞，出现界面卡顿、掉帧等情况</p><p>查看页面的长任务：</p><p>打开控制台，选择 Performance 工具，点击 Start 按钮，展开 Main 选项，会发现有很多红色的三角，这些就属于长任务（长任务：执行时间超过50ms的任务）<br><img src="/2023/07/19/%E9%95%BF%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7.png" alt="img"></p><h1 id="you-hua-fang-an">优化方案</h1><h2 id="web-worker">Web Worker</h2><p><strong>业务背景:前端需要进行大量的数学计算</strong></p><h3 id="jie-shao">介绍</h3><p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务可以交由 Worker 线程执行，主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。</p><p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p><h4 id="shi-yong-xian-zhi">使用限制</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>同源限制</strong></p><p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p></li><li class="lvl-2"><p><strong>DOM 限制</strong></p></li></ul><p>​Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用<code>document</code>、<code>window</code><code>parent</code>这些对象。但是，Worker 线程可以使用<code>navigator</code>对象和<code>location</code>对象。</p><ul class="lvl-0"><li class="lvl-2"><p><strong>全局对象限制</strong></p></li></ul><p>​Worker 的全局对象<code>WorkerGlobalScope</code>，不同于网页的全局对象<code>Window</code>，很多接口拿不到。比如，理论上 Worker 线程不能使用<code>console.log</code>，因为标准里面没有提到 Worker 的全局对象存在<code>console</code>接口，只定义了<code>Navigator</code>接口和<code>Location</code>接口。不过，浏览器实际上支持 Worker 线程使用<code>console.log</code>，保险的做法还是不使用这个方法。</p><ul class="lvl-0"><li class="lvl-2"><p><strong>通信联系</strong></p></li></ul><p>​Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p><ul class="lvl-0"><li class="lvl-2"><p><strong>脚本限制</strong></p></li></ul><p>​Worker 线程不能执行<code>alert()</code>方法和<code>confirm()</code>方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p><ul class="lvl-0"><li class="lvl-2"><p><strong>文件限制</strong></p></li></ul><p>​Worker 线程无法读取本地文件，即不能打开本机的文件系统（<code>file://</code>），它所加载的脚本，必须来自网络。</p><h3 id="ji-ben-yong-fa">基本用法</h3><h4 id="zhu-xian-cheng">主线程</h4><p>浏览器原生提供<code>Worker()</code>构造函数，用来供主线程生成 Worker 线程。</p><pre><code class="language-js">var worker = new Worker(jsUrl, options)</code></pre><p><code>Worker()</code>构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。</p><pre><code class="language-js">// 主线程var worker = new Worker('worker.js', &#123; name : 'myWorker' &#125;);// Worker 线程self.name //在worker线程中可以通过self.name来获取其线程名myWorker</code></pre><p>然后，主线程调用<code>worker.postMessage()</code>方法，向 Worker 发消息。<code>worker.postMessage()</code>方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。</p><pre><code class="language-js">worker.postMessage(&#123;method: 'echo', args: ['Work']&#125;)</code></pre><p>主线程通过<code>worker.onmessage</code>指定监听函数，接收子线程发回来的消息。通过 event.data 可以获取 Worker 子线程发过来的数据。</p><pre><code class="language-js">worker.onmessage = function (event) &#123;  doSomething(event.data);&#125;function doSomething() &#123;  ...&#125;</code></pre><p>Worker 完成任务以后，主线程就可以把它关掉。</p><pre><code class="language-js">worker.terminate()</code></pre><h4 id="worker-xian-cheng">Worker 线程</h4><p>Worker 线程内部需要有一个监听函数，监听<code>message</code>事件。通过 e.data 可以获取主线程发过来的数据。</p><pre><code class="language-js">self.addEventListener('message', function (e) &#123;  doSomething(e.data)&#125;, false)function doSomething() &#123;  ...&#125;</code></pre><p>上面代码中，<code>self</code>代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。</p><pre><code class="language-js">// 写法一this.addEventListener('message', function (e) &#123;...&#125;, false);// 写法二addEventListener('message', function (e) &#123;  ...&#125;, false);</code></pre><p><code>self.postMessage()</code>方法用来向主线程发送消息。</p><pre><code class="language-js">self.postMessage(...)</code></pre><p>Worker 也可以关闭自身</p><pre><code class="language-js">self.close()</code></pre><h4 id="worker-jia-zai-jiao-ben">Worker 加载脚本</h4><p>Worker 内部如果要加载其他脚本，有一个专门的方法<code>importScripts()</code>。</p><pre><code class="language-js">importScripts('script1.js'[,...'scripts']);</code></pre><h4 id="cuo-wu-chu-li">错误处理</h4><p>主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的<code>error</code>事件。Worker 内部也可以监听<code>error</code>事件。</p><pre><code class="language-js">worker.addEventListener('error', function (event) &#123;   console.log(    'ERROR: Line ', event.lineno, ' in ', event.filename, ': ', event.message  )&#125;);// 主线程worker.onerror = function () &#123;    // ...&#125;// 主线程使用专用线程worker.onmessageerror = function () &#123;    // ...&#125;// 主线程使用共享线程worker.port.onmessageerror = function () &#123;    // ...&#125;// worker 线程onerror = function () &#123;&#125;</code></pre><h4 id="shi-yong-shi-zhan">使用实战</h4><p>页面中有十万条数据，对其进行复杂运算，需要多久呢？</p><p>表格4000行，25列，共十万条数据</p><p><strong>运算包括</strong>：总和、算术平均、加权平均、最大、最小、计数、样本标准差、样本方差、中位数、总体标准差、总体方差</p><p>直接把下面这段代码直接丢到主线程中，计算过程中页面一直处于假死状态(大概35s)</p><pre><code class="language-js"> let sum = 0; let start = performance.now(); for (let i = 0; i &lt; 200000; i++) &#123;    for (let i = 0; i &lt; 10000; i++) &#123;      sum += Math.random()    &#125; &#125; let end = performance.now(); let time = end - start; console.log(`本次计算用时$&#123;time&#125;ms,结果为$&#123;sum&#125;`)</code></pre><p><strong>多线程代码</strong></p><pre><code class="language-js">//主线程&lt;template&gt;    &lt;div&gt;        &lt;button @click=&quot;makeWorker&quot;&gt;开始线程&lt;/button&gt;        &lt;!--在计算时 往input输入值时 没有发生卡顿--&gt;        &lt;p&gt;&lt;input type=&quot;text&quot;&gt;&lt;/p&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import Worker from &quot;worker-loader!./worker&quot;;    export default &#123;        data() &#123;          // 模拟数据          let arr = new Array(100000).fill(1).map(() =&gt; Math.random()* 10000);          let weightedList = new Array(100000).fill(1).map(() =&gt; Math.random()* 10000);          let calcList = [              &#123;type: 'sum', name: '总和'&#125;,              &#123;type: 'average', name: '算术平均'&#125;,              &#123;type: 'weightedAverage', name: '加权平均'&#125;,              &#123;type: 'max', name: '最大'&#125;,              &#123;type: 'middleNum', name: '中位数'&#125;,              &#123;type: 'min', name: '最小'&#125;,              &#123;type: 'variance', name: '样本方差'&#125;,              &#123;type: 'popVariance', name: '总体方差'&#125;,              &#123;type: 'stdDeviation', name: '样本标准差'&#125;,              &#123;type: 'popStandardDeviation', name: '总体标准差'&#125;          ]          return &#123;              workerList: [], // 用来存储所有的线程              calcList, // 计算类型              arr, // 数据              weightedList // 加权因子          &#125;        &#125;,        methods: &#123;            makeWorker() &#123;                this.calcList.forEach(item =&gt; &#123;                    let workerName = `worker$&#123;this.workerList.length&#125;`;                    let worker = new Worker();                    let start = performance.now();                    worker.postMessage(&#123;arr: this.arr, type: item.type, weightedList: this.weightedList&#125;);                    worker.addEventListener(&quot;message&quot;, (e) =&gt; &#123;                        worker.terminate();                        let tastName = '';                        this.calcList.forEach(item =&gt; &#123;                            if(item.type === e.data.type) &#123;                                item.value = e.data.value;                                tastName = item.name;                            &#125;                        &#125;)                        let end = performance.now();                        let duration = end - start;                        console.log(`当前任务: $&#123;tastName&#125;, 计算用时: $&#123;duration&#125; 毫秒`);                    &#125;);                    this.workerList.push(&#123; [workerName]: worker &#125;);                &#125;)            &#125;,            clearWorker() &#123;                if (this.workerList.length &gt; 0) &#123;                    this.workerList.forEach((item, key) =&gt; &#123;                        item[`worker$&#123;key&#125;`].terminate &amp;&amp; item[`worker$&#123;key&#125;`].terminate(); // 终止所有线程                    &#125;);                &#125;            &#125;        &#125;,        // 页面关闭，如果还没有计算完成，要销毁对应线程        beforeDestroy() &#123;            this.clearWorker();        &#125;,    &#125;&lt;/script&gt;</code></pre><pre><code class="language-js">//worker.jsimport &#123; create, all &#125; from 'mathjs'const config = &#123;  number: 'BigNumber',  precision: 20 // 精度&#125;const math = create(all, config);//加const numberAdd = (arg1,arg2) =&gt; &#123;  return math.number(math.add(math.bignumber(arg1), math.bignumber(arg2)));&#125;//减const numberSub = (arg1,arg2) =&gt; &#123;  return math.number(math.subtract(math.bignumber(arg1), math.bignumber(arg2)));&#125;//乘const numberMultiply = (arg1, arg2) =&gt; &#123;  return math.number(math.multiply(math.bignumber(arg1), math.bignumber(arg2)));&#125;//除const numberDivide = (arg1, arg2) =&gt; &#123;  return math.number(math.divide(math.bignumber(arg1), math.bignumber(arg2)));&#125;// 数组总体标准差公式const popVariance = (arr) =&gt; &#123;  return Math.sqrt(popStandardDeviation(arr))&#125;// 数组总体方差公式const popStandardDeviation = (arr) =&gt; &#123;  let s,    ave,    sum = 0,    sums= 0,    len = arr.length;  for (let i = 0; i &lt; len; i++) &#123;    sum = numberAdd(Number(arr[i]), sum);  &#125;  ave = numberDivide(sum, len);  for(let i = 0; i &lt; len; i++) &#123;    sums = numberAdd(sums, numberMultiply(numberSub(Number(arr[i]), ave), numberSub(Number(arr[i]), ave)))  &#125;  s = numberDivide(sums,len)  return s;&#125;// 数组加权公式const weightedAverage = (arr1, arr2) =&gt; &#123; // arr1: 计算列，arr2: 选择的权重列  let s,    sum = 0, // 分子的值    sums= 0, // 分母的值    len = arr1.length;  for (let i = 0; i &lt; len; i++) &#123;    sum = numberAdd(numberMultiply(Number(arr1[i]), Number(arr2[i])), sum);    sums = numberAdd(Number(arr2[i]), sums);  &#125;  s = numberDivide(sum,sums)  return s;&#125;// 数组样本方差公式const variance = (arr) =&gt; &#123;  let s,    ave,    sum = 0,    sums= 0,    len = arr.length;  for (let i = 0; i &lt; len; i++) &#123;    sum = numberAdd(Number(arr[i]), sum);  &#125;  ave = numberDivide(sum, len);  for(let i = 0; i &lt; len; i++) &#123;    sums = numberAdd(sums, numberMultiply(numberSub(Number(arr[i]), ave), numberSub(Number(arr[i]), ave)))  &#125;  s = numberDivide(sums,(len-1))  return s;&#125;// 数组中位数const middleNum = (arr) =&gt; &#123;  arr.sort((a,b) =&gt; a - b)  if(arr.length%2 === 0)&#123; //判断数字个数是奇数还是偶数    return numberDivide(numberAdd(arr[arr.length/2-1], arr[arr.length/2]),2);//偶数个取中间两个数的平均数  &#125;else&#123;    return arr[(arr.length+1)/2-1];//奇数个取最中间那个数  &#125;&#125;// 数组求和const sum = (arr) =&gt; &#123;  let sum = 0, len = arr.length;  for (let i = 0; i &lt; len; i++) &#123;    sum = numberAdd(Number(arr[i]), sum);  &#125;  return sum;&#125;// 数组平均值const average = (arr) =&gt; &#123;  return numberDivide(sum(arr), arr.length)&#125;// 数组最大值const max = (arr) =&gt; &#123;  let max = arr[0]  for (let i = 0; i &lt; arr.length; i++) &#123;    if(max &lt; arr[i]) &#123;      max = arr[i]    &#125;  &#125;  return max&#125;// 数组最小值const min = (arr) =&gt; &#123;  let min = arr[0]  for (let i = 0; i &lt; arr.length; i++) &#123;    if(min &gt; arr[i]) &#123;      min = arr[i]    &#125;  &#125;  return min&#125;// 数组有效数据长度const count = (arr) =&gt; &#123;  let remove = ['', ' ', null , undefined, '-']; // 排除无效的数据  return arr.filter(item =&gt; !remove.includes(item)).length&#125;// 数组样本标准差公式const stdDeviation = (arr) =&gt; &#123;  return Math.sqrt(variance(arr))&#125;// 数字三位加逗号，保留两位小数const formatNumber = (num, pointNum = 2) =&gt; &#123;  if ((!num &amp;&amp; num !== 0) || num == '-') return '--'  let arr = (typeof num == 'string' ? parseFloat(num) : num).toFixed(pointNum).split('.')  let intNum = arr[0].replace(/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+(.\d*)?$)/g,'$&amp;,')  return arr[1] === undefined ? intNum : `$&#123;intNum&#125;.$&#123;arr[1]&#125;`&#125;onmessage = function (e) &#123;  let &#123;arr, type, weightedList&#125; = e.data  let value = '';  switch (type) &#123;    case 'sum':      value = formatNumber(sum(arr));      break    case 'average':      value = formatNumber(average(arr));      break    case 'weightedAverage':      value = formatNumber(weightedAverage(arr, weightedList));      break    case 'max':      value = formatNumber(max(arr));      break    case 'middleNum':      value = formatNumber(middleNum(arr));      break    case 'min':      value = formatNumber(min(arr));      break    case 'variance':      value = formatNumber(variance(arr));      break    case 'popVariance':      value = formatNumber(popVariance(arr));      break    case 'stdDeviation':      value = formatNumber(stdDeviation(arr));      break    case 'popStandardDeviation':      value = formatNumber(popStandardDeviation(arr));      break    &#125;  // 发送数据事件  postMessage(&#123;type, value&#125;);&#125;</code></pre><h4 id="vue-zhong-shi-yong-web-worker">Vue中使用web worker</h4><p>在 Vue 项目中</p><p>webpack使用 Web Worker 需要安装 <code>worker-loader</code></p><p>vite使用:</p><p>在 Vite 中<a href="https://cn.vitejs.dev/guide/assets.html">静态资源处理 </a>，其中可以<a href="https://cn.vitejs.dev/guide/assets.html#importing-script-as-a-worker">导入脚本作为 Worker</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 业务与性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务与性能优化(前端) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js学习笔记</title>
      <link href="/2023/07/19/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/19/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h1><p>浏览器内核</p><p>Webkit 苹果开发 用于 Safari</p><p>Blink Webkit 的一个分支,Google 开发,目前应用于 Google Chrome,Edge,Opera 等浏览器</p><h1 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h1><p><img src="/2023/07/19/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/用户在浏览器地址栏中输入url.svg" alt></p><h1 id="Js-引擎"><a href="#Js-引擎" class="headerlink" title="Js 引擎"></a>Js 引擎</h1><p><strong>js 引擎</strong>将 <strong>js 代码</strong>翻译成<strong>CPU 指令</strong>来执行</p><h2 id="V8-引擎"><a href="#V8-引擎" class="headerlink" title="V8 引擎"></a>V8 引擎</h2><p><img src="/2023/07/19/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/V8引擎解析js.png" alt></p><p>1.js 引擎在解析成 AST 语法树中会在堆内存中默认创建一个全局对象 globalObject ,并将我们创建的属性名(值为 undefined)(普通变量)添加到 该全局对象中</p><p>预解析时函数会在内存中创建一个储存空间(函数对象) (函数 的父级作用域在定义时就已经确定,不会因调用的位置而改变)</p><pre><code class="lang-js">解析时全局对象时(GO)会首先解析变量 后声明函数并赋值</code></pre><pre><code>在预解析函数时(AO)首先形参和变量的声明然后实参赋值给形参最后声明函数并赋值</code></pre><p><img src="images/js学习笔记/Snipaste_2022-09-02_16-30-06.png" alt></p><p>然后在全局对象(GO)中则储存函数的地址</p><pre><code class="lang-js">GlobalObject:&#123;    name:undefined,    foo:0x...&#125;</code></pre><p>2.运行代码时</p><p>V8 引擎为了执行代码,其内部会有一个执行上下文栈(Execution Context Stack)(函数调用栈) 内放将要执行的函数</p><p>全局代码执行顺序</p><pre><code class="lang-js">const name = &#39;ljq&#39;;const num1 = 2;const num2 = 5;const num3 = num1 + num2;</code></pre><p>此时 V8 引擎创建了一个执行上下文栈 后创建一个全局执行上下文</p><p>此时创建 GEC(全局执行上下文) ,其中的 VO 指向 解析时创建的 GO</p><pre><code>在最新的规范中VO(variable Object)已经被更新为VE(VariableEnvironment)(变量环境)在执行代码中的变量和函数声明会作为环境记录(Environment Record) 添加到变量环境中,对于函数,其参数也会被作为环境记录被添加到变量环境中</code></pre><p><img src="images/js学习笔记/Snipaste_2022-09-02_15-29-5.png" alt></p><p>而函数则较为特殊</p><p>全局函数的执行过程</p><pre><code class="lang-js">function foo(num) &#123;  var m = 10;  var n = 20;&#125;foo();</code></pre><p>接着在执行上下文栈中创建一个函数执行上下文(FEC) (函数实例)</p><p><img src="images/js学习笔记/Snipaste_2022-09-02_15-29-50.png" alt="Snipaste_2022-09-02_15-29-50"></p><p>此时 AO(Actiction Object)为</p><pre><code class="lang-js">AO:&#123;    num:undefined,    m:undefined,    n:undefined&#125;</code></pre><p>接着函数内的代码将会执行</p><p>AO 中的属性被依次赋值</p><p>当函数执行完后,函数执行上下文将会被弹出执行上下文栈(被销毁)</p><p>面试题</p><pre><code class="lang-js">function foo() &#123;  m = 10;  // 没有使用变量关键字会被声明到全局对象中&#125;console.log(m); // 10</code></pre><pre><code class="lang-js">function foo() &#123;  var a = (b = 10);  // 此时这句语句在js引擎中会被转化为  // b = 10 ; var a = 10 (从右向左执行)&#125;console.log(a); // erro a is not definedconsole.log(b); // 10</code></pre><h1 id="js-的内存管理和闭包"><a href="#js-的内存管理和闭包" class="headerlink" title="js 的内存管理和闭包"></a>js 的内存管理和闭包</h1><p>对于基本数据类型内存的分配时会直接在栈空间内分配</p><p>对于复杂数据类型内存的分配时会直接在堆空间内分配</p><h2 id="js-的垃圾回收-GC"><a href="#js-的垃圾回收-GC" class="headerlink" title="js 的垃圾回收(GC)"></a>js 的垃圾回收(GC)</h2><p>常见的 GC 算法</p><p>引用计数</p><p>标记清除:</p><p>设置一个根对象,垃圾回收器会定期从这个根开始找所有从根开始有引用到的对象,对于那些没有引用到的对象,就认为是不可用对象</p><p>V8 GC 优化策略</p><p>因为 js 在 gc 时会停止响应其他操作,所以要通过优化来避免长时间的停止响应</p><p>1.分代回收</p><pre><code class="lang-js">通过区分&quot;临时&quot;和&quot;持久&quot;对象,多回收&quot;临时对象区&quot;,少回收&quot;持久对象区&quot;,减少每次需要的变量,减少每次GC耗时</code></pre><p>2.增量 GC</p><pre><code>就是每次处理一部分js运行 -&gt; gc运行js暂停 -&gt; js运行 -&gt; gc运行js暂停</code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>在计算机科学中</p><pre><code>闭包在实现上是一个结构体,它储存了一个函数和其关联的环境闭包跟函数最大的区别就是,当捕捉闭包的时候,它的自由变量会在捕捉的时候就被确定,这样即使脱离了捕捉时的上下文,它也能照常运行</code></pre><p>在 JavaScript 中</p><pre><code class="lang-js">一个函数和对其周围状态的引用绑定在一起 这就叫闭包</code></pre><pre><code class="lang-js">function foo() &#123;  var name = &#39;ljq&#39;;  function bar() &#123;    console.log(&#39;bar&#39;, name);  &#125;  return bar;&#125;var fn = foo();fn();</code></pre><p>在 fn = foo() 被执行后 GO 中的 fn 值已经被赋值为了 bar() 的地址值</p><p>foo 的 FEC 会被销毁 但是 bar 依旧能访问到 foo 中的 “name” 值</p><p>此时 函数 bar()和 “name” 变量 构成一个闭包(函数和其能访问的外层作用域的自由变量共同组成闭包)</p><h3 id="闭包的内存泄露"><a href="#闭包的内存泄露" class="headerlink" title="闭包的内存泄露"></a>闭包的内存泄露</h3><pre><code class="lang-js">function foo() &#123;  var name = &#39;ljq&#39;;  function bar() &#123;    console.log(&#39;foo&#39;, name);  &#125;  return bar;&#125;var fn = foo();fn();</code></pre><h1 id="函数中的-this-指向"><a href="#函数中的-this-指向" class="headerlink" title="函数中的 this 指向"></a>函数中的 this 指向</h1><p>函数在执行时才会绑定 this</p><p>在浏览器中 全局对象中 this 指向 window</p><p>在 nodejs 中的 this 是一个空对象</p><pre><code class="lang-js">// this指向什么与函数所处位置无关// this的指向与函数被调用的方式有关function foo() &#123;  console.log(this);&#125;foo(); // windowconst obj = &#123;  name: &#39;ljq&#39;,  foo: foo,&#125;;console.log(obj.foo()); // obj对象console.log(foo.apply(&#39;abc&#39;)); // String:&#123;&quot;abc&quot;&#125;</code></pre><p>优先级从上至下以此升高</p><h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><pre><code class="lang-js">// 函数调用的时无任何调用前缀 默认绑定时this指向全局对象window(非严格模式)function fn() &#123;  console.log(this); // window  let fn1 = function () &#123;    console.log(this); // window    fn2(); // window  &#125;;  function fn2() &#123;    console.log(this);  &#125;&#125;// 要注意的是在严格模式环境下 默认绑定的this指向undefinedfunction fn() &#123;  console.log(this); // window&#125;(&#39;use strict&#39;);function fn1() &#123;  console.log(this); // undefined  console.log(this.name);&#125;var name = &#39;dnmd&#39;;fn1(); // TypeError: Cannot read property &#39;name&#39; of undefined</code></pre><h2 id="间接函数引用"><a href="#间接函数引用" class="headerlink" title="间接函数引用"></a>间接函数引用</h2><pre><code class="lang-js">const obj1 = &#123;    name:&quot;obj1&quot;    foo:function()&#123;        console.log(this)    &#125;&#125;const obj2 = &#123;    name:&quot;obj2&quot;&#125;;(obj2.bar = obj1.foo)() // 作为独立的函数调用 output:window</code></pre><h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><pre><code class="lang-js">// 他的调用位置中,是通过某个对象发起的函数调用function foo() &#123;  console.log(this);&#125;const obj = &#123;  name: &#39;ljq&#39;,  foo: foo,&#125;;const obj1 = &#123;  obj: obj,&#125;;obj.foo(); // objobj1.obj.foo(); // objconst div = document.querySelector(&#39;.box&#39;);div.onclick = function () &#123;  console.log(this);&#125;;// 当点击box时 output:// &lt;div class=&quot;box&quot; style=&quot;width: 100px;height: 100px;background-color: red;&quot;&gt;&lt;/div&gt;// 所以其应该是进行了隐式绑定</code></pre><h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><pre><code class="lang-js">// 通过apply,call,bind进行绑定function foo() &#123;  console.log(this);&#125;var newFoo = foo.bind(&#39;aaa&#39;);newFoo(); // Stringconst div = document.querySelector(&#39;.box&#39;);div.addEventListener(&#39;click&#39;, function () &#123;  console.log(this);&#125;);div.addEventListener(&#39;click&#39;, function () &#123;  console.log(this);&#125;);div.addEventListener(&#39;click&#39;, function () &#123;  console.log(this);&#125;);// 所有的click函数被存入一个数组// 当点击发生是遍历调用数组中的函数// fn.call(div)// 当点击box时 output:// &lt;div class=&quot;box&quot; style=&quot;width: 100px;height: 100px;background-color: red;&quot;&gt;&lt;/div&gt;</code></pre><p>忽略显式绑定</p><pre><code class="lang-js">// apply,bind,call 当传入的值为 null/undefined 时,自动将this绑定为全局对象function foo() &#123;  console.log(this);&#125;foo.call(null); // windowfoo.apply(undefined); // windowconst data = foo.bind(null);data(); // window</code></pre><h2 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h2><pre><code class="lang-js">// 我们通过一个new关键字调用一个函数时(构造器),这个时候this是在调用这个构造器时创建出来的对象// this = 创建出来的对象// 这个过程就是new绑定function foo(name, age) &#123;  console.log(this);&#125;var p = new foo(); // foo&#123;&#125;</code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><pre><code class="lang-js">// 如果函数的执行体只有一行,那么&#123;&#125;可以省略,并且默认将这行代码的执行结果作为返回值// 箭头函数不适用this的四种规则,而是调用上层作用域中的this箭头函数与普通函数的区别1.语法更加清晰2.箭头函数不能作为构造函数调用(new)3.箭头函数没有&quot;arguments&quot;4.call(),bind()函数不能改变箭头函数的this指向5.箭头函数没有prototype6.箭头函数不会创建自己的this,其会继承上层作用域的this,且创建的上层作用域的</code></pre><p>this 面试题</p><pre><code class="lang-js">var name = &#39;ljq&#39;;var person = &#123;  name: &#39;person&#39;,  sayName: function () &#123;    console.log(this.name);  &#125;,&#125;;function sayName() &#123;  var sss = person.sayName;  sss(); // ljq  person.sayName(); // person  person.sayName(); // person  (b = person.sayName)(); // ljq&#125;sayName();</code></pre><pre><code class="lang-js">var name = &#39;ljq&#39;;var person1 = &#123;  name: &#39;person1&#39;,  foo1: function () &#123;    console.log(this.name);  &#125;,  foo2: () =&gt; console.log(this.name),  foo3: function () &#123;    return function () &#123;      console.log(this.name);    &#125;;  &#125;,  foo4: function () &#123;    return () =&gt; &#123;      console.log(this.name);    &#125;;  &#125;,&#125;;var person2 = &#123; name: &#39;person2&#39; &#125;;person1.foo1(); // person1person1.foo1.call(person2); // person2person1.foo2(); // ljqperson1.foo2.call(person2); // ljqperson1.foo3()(); // ljqperson1.foo3.call(person2)(); //  ljqperson1.foo4()(); // ljqperson1.foo4.call(person2)(); // persno2</code></pre><p>实现 apply,call,bind(手写 )</p><pre><code></code></pre><p>arguments 的使用</p><pre><code class="lang-js">// 在浏览器中全局状态下没有arguments , nodejs下有</code></pre><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><pre><code class="lang-js">// 确定的输入,一定会产生确定的输出// 函数的执行过程中,不会产生副作用(副作用的概念就是,在执行一个函数的时候,除了返回函数值外,还对调用函数产生了附加的影响,例如修改的全局变量,修改参数或者改变外部储存)</code></pre><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><pre><code class="lang-js">// 将多个传入参数,拆分成多个函数调用的过程const sum = function (x) &#123;  return function (y) &#123;    return function (z) &#123;      return x + y + z;    &#125;;  &#125;;&#125;;const res = sum(10)(20)(30);console.log(res); // 60// 使用箭头函数简写const sum1 = (x) =&gt; (y) =&gt; (z) =&gt; x + y + z;const res1 = sum(10)(20)(30);console.log(res1); // 60// 为什么需要柯里化// 函数式编程中我们往往希望一个函数处理的问题单一,而不是将一大堆处理过程中交给一个函数来处理// 模板字符串应用的柯里化const log = function (date, type, message) &#123;  console.log(`[$&#123;date.getHours()&#125;:$&#123;date.getMinutes()&#125;][$&#123;type&#125;]:[$message]`);&#125;;log(new Date(), &#39;DEBUG&#39;, &#39;查找到轮播图BUG&#39;);log(new Date(), &#39;DEBUG&#39;, &#39;查找到菜单BUG&#39;);log(new Date(), &#39;DEBUG&#39;, &#39;查找到数据BUG&#39;);//柯里化的优化const log1 = (date) =&gt; (type) =&gt; (message) =&gt;  console.log(`[$&#123;date.getHours()&#125;:$&#123;date.getMinutes()&#125;][$&#123;type&#125;]:[$message]`);// 定制化// 如果要打印的都是当前时间const nowlog = log1(new Date());nowlog(&#39;DEBUG&#39;)(&#39;查找到菜单BUG&#39;);nowlog(&#39;DEBUG&#39;)(&#39;查找到轮播图BUG&#39;);// 自动转柯里化函数的实现(手写)</code></pre><h2 id="组合函数-手写"><a href="#组合函数-手写" class="headerlink" title="组合函数(手写)"></a>组合函数(手写)</h2><pre><code class="lang-js"></code></pre><h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><pre><code class="lang-js">// 严格模式下,不允许静默错误// 不允许原先的八进制// with 语句不允许使用// eval函数不允许向上引用变量// 自执行函数(默认绑定)会指向undefined// setTimeout的this不变(指向window)</code></pre><h1 id="JS-的面向对象"><a href="#JS-的面向对象" class="headerlink" title="JS 的面向对象"></a>JS 的面向对象</h1><pre><code class="lang-js">Object.defineProperty(objName,objKeyName,descriptor//属性描述符) // 对对象中的属性做操作// 数据属性描述符  Configurable:表示属性是否能够通过delete删除属性 false表示不可配置(删除,修改)  也不可以重新定义属性描述符  enumerable:表示属性是否能被枚举(是否能被for-in或Object.key()返回该属性)  writeable: 表示属性是否能被修改(写入)//存取属性描述符  1.隐藏某一个私有属性不被外界直接使用和赋值    js并没有私有属性的定义 社区中默认 _keyName为私有属性  2.截获某一个属性它访问和设置值的过程    get:function()&#123;&#125;    set:function()&#123;&#125;Object.defineProperty(obj,&quot;height&quot;,&#123;    //配置    value:1.88&#125;)// 也可以一次性对多个属性配置属性描述符Object.defineProperty(obj,&#123;    name:&#123;        Configurable:false        writable:false        value:&quot;ljq&quot;    &#125;,    age:&#123;        Configurable:false        writable:false        value:20    &#125;&#125;)//获取属性描述符Object.getOwnPropertyDescriptor(obj_nmae,obj_key_name)Object.getOwnPropertyDescriptors()// 对对象进行限制Object.seal(obj_name) // 禁止对象配置/修改删除里面的属性Object.freeze(obj_name) // 属性不可修改</code></pre><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><pre><code class="lang-JS">// 工厂模式:工厂函数function createPerson(name,age,height,address)&#123;    const newObejct = &#123;&#125;    newObject.name = name    newObject.age = age    newObject.height = height    newObject.address = address    return newObject&#125;const p1 = createPerson(&quot;ljq&quot;,20,176,&quot;株洲市&quot;)</code></pre><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code class="lang-js">// new 操作符当一个new操作符被调用,那么他会执行如下操作1.在内存中创建一个新的空对象2.这个对象内部的prototype属性会被赋值为该构造函数的prototype属性3.构造函数内部的this会指向创建出来的新对象4.执行函数内部的代码(函数体代码)5.如果构造函数没有返回非空对象,则返回创建出来的新对象手写</code></pre><h1 id="继承与原型链"><a href="#继承与原型链" class="headerlink" title="继承与原型链"></a>继承与原型链</h1><pre><code class="lang-js">// 我们每个对象中提供了一个prototype,这个属性可以称为对象的原型(隐式原型)// 浏览器和node中支持查询隐式原型(__proto__)// ES5后提供了一个方法查看原型Object.getPrototypeOf(obj_name);// 函数也是一个对象// console.log(foo.__proto__) 函数作为对象来说 他也是有[[prototype]]隐式原型的// 函数因为他是一个函数,所以他还会多出一个显示原型属性:prototypeconsole.log(foo.prototype);</code></pre><p>当函数被 new 关键字创建后,他的执行过程为</p><pre><code class="lang-js">function Foo() &#123;&#125;var p1 = new Foo();var p2 = new Foo();</code></pre><p><img src="/2023/07/19/js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Users\ND_LJQ\Desktop\js\images\无标题.png" alt="无标题" style="zoom:200%;"></p><p>创建对象方案</p><pre><code class="lang-js">// 将函数通用属性加入函数原型function Person(name, age, height, address) &#123;  this.name = name;  this.age = age;  this.height = height;  this.address = address;&#125;Person.prototype.eating = function () &#123;  console.log(this.name + &#39;在吃东西&#39;);&#125;;Person.prototype.running = function () &#123;  console.log(this.name + &#39;在跑步&#39;);&#125;;</code></pre><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><pre><code class="lang-js"></code></pre><p>参数中的”[]”代表可选</p><h1 id="操作字符串的方法"><a href="#操作字符串的方法" class="headerlink" title="操作字符串的方法"></a>操作字符串的方法</h1><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h2><pre><code class="lang-js">String.indexOf(searchValue, [fromIndex]);// 返回子字符或字符串在父字符串中首次出现的索引位置// 若子字符串不存在则会返回 -1// 若 fromIndex 大于字符串长度,则会返回父字符串长度// 该方法区分大小写String.lastIndexOf(searchValue, [fromIndex]);// 返回子字符或字符串在父字符串中最后一次出现的索引位置</code></pre><h2 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h2><pre><code class="lang-js">String.charAt(index); // 获得字符串指定位置的字符</code></pre><h2 id="touppercase"><a href="#touppercase" class="headerlink" title="touppercase()"></a>touppercase()</h2><pre><code class="lang-js">String.toUpperCase();// 将字符串中的字符全变为大写后返回一个新字符串,原字符串不变String.tolowerCase();// 将字符串中的字符全变为小写后返回一个新字符串,原字符串不变</code></pre><h2 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h2><pre><code class="lang-js">String.concat(str, [...strN]);// 将一个或多个字符串与原字符串串联合并,返回一个新字符串</code></pre><h2 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h2><pre><code class="lang-js">String.slice(beginIndex, [endIndex]);// 提取父字符串自 beginIndex 位置开始 [到 endIndex 结束]的字符/字符串// 并返回一个新字符串,原字符串不变// slice()不传参数会返回一个跟原数组一样的新数组// 若 beginIndex/endIndex 的值为负数// 则其值看成 str.length-beginIndex/endIndex// 若 beginIndex 大于 endIndex 则 slice 的执行的效果为 从 beginIndex 开始向前截取到 endIndex</code></pre><h2 id="subString"><a href="#subString" class="headerlink" title="subString()"></a>subString()</h2><pre><code class="lang-js">String.subString(indexStart, [indexEnd]);// 返回一个提取自字符串 indexStart 开始[至indexEnd 结束]的一个新的子字符串// 如果参数中的值小于 &#39;0&#39; 或者 &#39;NaN&#39; 则自动默认为0// 如果参数中的任意一值大于父字符串的长度 那么该值默认为父字符串的长度// 如果 indexStart 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样。// 即 String.subString(indexEnd,indexStart)</code></pre><h2 id="subStr"><a href="#subStr" class="headerlink" title="subStr()"></a>subStr()</h2><pre><code class="lang-js">String.subStr(strat, [length]); //该方法半遗弃,尽量避免使用</code></pre><h2 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h2><pre><code class="lang-js">String.split([separator, [limit]]);// 以 separator 字符/字符串或正则表达式来切割原字符 ,用 limit(number) 来限制返回的数组中// 切割后的片段的数量// 若不传参,则返回原字符串的数组// 若以 &quot;&quot;/&#39;&#39; 来作为分隔符可能会破坏 unicode 安全// 例:// const a = &#39;𝟘𝟙𝟚𝟛&#39;.split(&#39;&#39;);// console.log(a);// Output: [&quot;�&quot;,&quot;�&quot;,&quot;�&quot;,&quot;�&quot;,&quot;�&quot;,&quot;�&quot;,&quot;�&quot;,&quot;�&quot;]// 这时候推荐使用es6的拓展运算符 &quot;...&quot; 来解决// 例:// const a = &#39;𝟘𝟙𝟚𝟛&#39;// console.log([...a])// Output: [&#39;𝟘&#39;, &#39;𝟙&#39;, &#39;𝟚&#39;, &#39;𝟛&#39;]</code></pre><h2 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h2><pre><code class="lang-js">String.trim();//去除字符串两端空白//该方法返回一个新的去除字符串两端空白的新字符串,并不影响原字符串本身</code></pre><h2 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h2><pre><code class="lang-js">String.replace(regexp|subStr , newSubStr|function)// 将字符串中某个字符串/字符(subStr),替换成新字符(newSubStr)// 若是是一个function,则newSubStr为function的返回值// 第一个参数是subStr则只有第一个匹配项会被替换// 若第一个参数是正则表达式则正则所匹配到的对象会被替换</code></pre><h1 id="操作数组的方法"><a href="#操作数组的方法" class="headerlink" title="操作数组的方法"></a>操作数组的方法</h1><p>数组的扁平化</p><pre><code class="lang-js">Array.flat();Array.toString().split();</code></pre><h2 id="不会改变原始数组的方法"><a href="#不会改变原始数组的方法" class="headerlink" title="不会改变原始数组的方法"></a>不会改变原始数组的方法</h2><h3 id="indexOf-1"><a href="#indexOf-1" class="headerlink" title="indexOf()"></a>indexOf()</h3><pre><code class="lang-js">Array.indexOf(searchElement, [fromIndex]);// 查找某一个值在数组中首次出现的位置// fromIndex 参数若大于 Array.length 则默认不会从数组中查找,返回 -1// 若小于 0 则其默认为数组长度的抵消值,若抵消值仍为负数则默认为 0// 即若数组长度为6 fromIndex值为 -1 则意味着从索引为 6+(-1) 开始查找</code></pre><h3 id="slice-1"><a href="#slice-1" class="headerlink" title="slice()"></a>slice()</h3><pre><code class="lang-js">Array.slice(begin, [end]);// 返回数组的某一部分(浅拷贝)// 提取从原数组中从索引 begin 到 end 中的元素// 若参数为负,则其值默认为 array.length + 参数值// 若 |begin| &gt; |end| 则会返回一个空数组,不会将end和begin交换</code></pre><h3 id="concat-1"><a href="#concat-1" class="headerlink" title="concat()"></a>concat()</h3><pre><code class="lang-js">Array.concat(value1, [...valueN]);// 将原数组进行浅拷贝的副本与参数中的数组/单个元素进行合并,返回合并后的副本</code></pre><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><pre><code class="lang-js">Array.join([separator]);// 将数组中的元素拼接起来后返回一个总的字符串// 可选参数separator 是指定每个元素之间的分隔符// 如果缺省参数 separator 则每个元素之间默认分隔符为&quot;,&quot;// 如果参数是空字符串(&quot;&quot;)则每个元素之间没有任何字符// 若数组中的某一个元素为 undefined 或 null ,则返回的字符串为空字符串</code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><pre><code class="lang-js">Array.fliter(callbackFunction(element, [index]));// 创建一个新数组，其包含通过所提供函数实现的测试的所有元素// callbackFunction为测试数组每个元素的函数 返回true则表示该元素通过测试,保留该元素,反之则返回false,不保留该元素// callbackFunction中的 element参数则是当前测试的元素 index是正在测试中的元素在原数组中的索引</code></pre><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><pre><code class="lang-js">Array.reduce(reducer, [initiaValue]);// 方法对数组中的每个元素按序执行一个由您提供的 reducer 函数，每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。//reducer = function(previousValue,currentValue,[currentIndex])&#123;&#125;// previousValue 为 上次调用reducer返回的的值// currentValue 为 数组中正在处理的元素// currentIndex 为 数组中正在处理的元素在数组中的索引值// 作为第一次调用 reducer 函数时参数 previousValue 的值。若指定了初始值 initialValue，则 currentValue 则将使用数组第一个元素；否则 previousValue 将使用数组第一个元素，而 currentValue 将使用数组第二个元素</code></pre><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><pre><code class="lang-js">Array.map(callbackFunction, [thisArg]);// callbackFunction(currentValue,[index]) 为数组每一个元素执行该函数 并返回一个由原数组每个元素执行回调函数的结果组成的新数组// currentValue为当前所处理的元素// index 为当前所处理元素在数组中的索引值// thisArg 为当执行回调函数 callbackFunction时，用作 this 的值。</code></pre><h2 id="会改变原始数组的方法"><a href="#会改变原始数组的方法" class="headerlink" title="会改变原始数组的方法"></a>会改变原始数组的方法</h2><h3 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h3><pre><code class="lang-js">Array.push(element1, ..., elementN)// 将元素添加到数组末尾// 调用该方法时的返回值为新数组的length</code></pre><h3 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h3><pre><code class="lang-js">Array.pop();// 从数组中删除最后一个元素 并返回被删除的元素// 在空数组中调用pop(),将返回undefined</code></pre><h3 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h3><pre><code class="lang-js">Array.shift();// 从数组中删除索引为0的元素 并返回被删除的元素// 在空数组中调用shift(),将返回undefined</code></pre><h3 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h3><pre><code class="lang-js">Array.unshift(element1, [...elementN]);// 将一个或多个元素添加到数组开头,并返回该数组的新length// 当传入参数为多个值时,它们将被以 块 的形式被插入到对象开始位置,他们的顺序和被传入时的顺序一致,所以，传入多个参数调用一次 unshift()，和传入一个参数调用多次 unshift()（例如，循环调用），它们将得到不同的结果。例如：let arr = [4, 5, 6];arr.unshift(1, 2, 3);console.log(arr);// [1, 2, 3, 4, 5, 6]arr = [4, 5, 6]; // 重置数组arr.unshift(1);arr.unshift(2);arr.unshift(3);console.log(arr);// [3, 2, 1, 4, 5, 6]</code></pre><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><pre><code class="lang-js">Array.sort([compareFunction(a, b)]);// 将数组按照某一规则来进行排序,返回排序后的数组// 若不指定规则则默认将数组中的元素转换为字符串的逐个字符的unicode位点进行排序// 若指定compareFunction(a,b) 那么数组会按照调用该函数返回值进行排序// 如果compareFunction(a,b) 大于 0 那么b会排列到a之前// 如果compareFunction(a,b) 小于 0 那么a会排列到b之前// 如果compareFunction(a,b) 等于 0 那么a与b的相对位置不变</code></pre><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><pre><code class="lang-js">Array.splice(start, [deleteCount, [item1, ...itemN]]);// 删除或替换或添加元素来修改数组,并以数组的方式返回被删除元素所组成的数组// 从指定修改从 start 索引开始修改// 若 start 的值大于Array.length则意味着从数组末尾开始修改// 若 start 的值为负数 则值默认为Array.length + start的值// 若 start 的值为负数 且绝对值大于Array.length 则默认为0// deleteCount为删除元素的个数// item1-itemN为需要添加进数组的元素</code></pre><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><pre><code class="lang-js">Array.forEach(callbackFucntion);// callbackFunction(currentValue,[index],[thisArg]) 为数组每一个元素执行该函数// currentValue为当前所处理的元素// index 为当前所处理元素在数组中的索引值// thisArg 为当执行回调函数 callbackFunction时，用作 this 的值。</code></pre><h1 id="ES6-新特性"><a href="#ES6-新特性" class="headerlink" title="ES6 新特性"></a>ES6 新特性</h1><h2 id="Set-对象"><a href="#Set-对象" class="headerlink" title="Set()对象"></a>Set()对象</h2><pre><code class="lang-js">// Set 对象允许储存任何类型的唯一值,无论是原始值或是对象引用const newSet = new Set();// Set的一些实例方法Set.size(); // 返回Set对象中值的个数Set.add(value); // 在Set对象的尾部添加一个元素并返回,该Set对象Set.has(value); // 查询Set对象中是否有value值 返回一个布尔值Set.value(); // 返回一个Set迭代器对象内包含Set对象中按插入属性顺序摆列的所有元素Set.delete(value); // 删除Set对象中的value值Set.forEach(callback); // dddd// 使用Set进行数组去重const arr = [1, 1, 2, 2, 3, 3, 4, 4];const arrSet = new Set(arr);return [...arrSet];// 利用Set将字符串转为数组const str = &#39;hello&#39;;const newSet = new Set(str);return [...newSet];// 用Set获得并集const arr1 = [1, 2, 3, 4];const arr2 = [3, 4, 5, 6];const newSet = new Set([...arr1, ...arr2]); // &#123;1, 2, 3, 4, 5, 6&#125;// 用Set获得交集const arr1 = [1, 2, 3, 4];const arr2 = [3, 4, 5, 6];const newSet = new Set([...arr1].fliter((e) =&gt; arr2.has(e)));</code></pre><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol()"></a>Symbol()</h2><pre><code class="lang-js">//symbol 是一种基本数据类型（primitive data type）。Symbol() 函数会返回 symbol 类型的值// 每个从Symbol()方法返回的值都是唯一的// 但是Symbol 不支持 new Symbol() 构造</code></pre><h2 id="Map-对象"><a href="#Map-对象" class="headerlink" title="Map()对象"></a>Map()对象</h2><pre><code class="lang-js">// Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值（对象或者基本类型）都可以作为一个键或一个值。const newMap = new Map();</code></pre><h2 id="es6-的剩余参数"><a href="#es6-的剩余参数" class="headerlink" title="es6 的剩余参数"></a>es6 的剩余参数</h2><pre><code class="lang-js">// rest parametersfunction foo(...nums) &#123;  //nums是形参名  =&gt; var nums = [  ]&#125;foo(10);foo(10, 20, 30);foo(10, 20, 30, 40);</code></pre><h2 id="Es6-展开运算符"><a href="#Es6-展开运算符" class="headerlink" title="Es6 展开运算符"></a>Es6 展开运算符</h2><pre><code class="lang-js">var nums = [&#39;abc&#39;, &#39;cba&#39;, &#39;bac&#39;];foo(...nums);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hbase基础</title>
      <link href="/2023/07/19/Hbase%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/07/19/Hbase%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="h-base-jian-jie">HBase 简介</h1><p>Google 三篇论文</p><table><thead><tr><th>论文名</th><th>说明</th><th>hadoop</th></tr></thead><tbody><tr><td>《GFS》</td><td>分布式文件系统</td><td>HDFS(Hadoop Distributed File System)</td></tr><tr><td>《MapReduce》</td><td>分布式计算模型</td><td>MapReduce</td></tr><tr><td>《Bigtable》</td><td>超级大表</td><td>HBase</td></tr></tbody></table><p>结论：HBase 起源于 Google 的《Bigtable: A Distributed Storage System for Structured Data》这篇论文。</p><p><strong>Hadoop HBase 是一个高可靠、高性能、可伸缩、面向列、随机实时读写的，分布式的数据库</strong>由于 HBase 属于我们的 Hadoop 生态圈，所以 HBase 的底层使用 HDFS 来进行存储，使用 MapReduce 来进行计算。并且主要存储的是“半结构化”与“非结构化”的数据。</p><h2 id="h-base-yu-chuan-tong-guan-xi-shu-ju-ku-de-dui-bi-fen-xi">HBase 与传统关系数据库的对比分析</h2><ol><li class="lvl-3"><p>数据类型：关系数据库采用关系模型，具有丰富的数据类型和存储方式，HBase 则采用了更加简单的数据模型，它把数据存储为未经解释的字符串；</p></li><li class="lvl-3"><p>数据操作：关系数据库中包含了丰富的操作，其中会涉及复杂的多表连接。HBase 操作则不存在复杂的表与表之间的关系，只有简单的插入、查询、删除、清空等，因为 HBase 在设计上就避免了复杂的表和表之间的关系；</p></li><li class="lvl-3"><p>存储模式：关系数据库是基于行模式存储的。HBase 是基于列存储的，每个列族都由几个文件保存，不同列族的文件是分离的；</p></li><li class="lvl-3"><p>数据索引：关系数据库通常可以针对不同列构建复杂的多个索引，以提高数据访问性能。HBase 只有一个索引——行键，通过巧妙的设计，HBase 中的所有访问方法，或者通过行键访问，或者通过行键扫描，从而使得整个系统不会慢下来；</p></li><li class="lvl-3"><p>数据维护：在关系数据库中，更新操作会用最新的当前值去替换记录中原来的旧值，旧值被覆盖后就不会存在。而在 HBase 中执行更新操作时，并不会删除数据旧的版本，而是生成一个新的版本，旧有的版本仍然保留；</p></li><li class="lvl-3"><p>可伸缩性：关系数据库很难实现横向扩展，纵向扩展的空间也比较有限。相反，HBase 和 BigTable 这些分布式数据库就是为了实现灵活的水平扩展而开发的，能够轻易地通过在集群中增加或者减少硬件数量来实现性能的伸缩</p></li></ol><h2 id="shu-ju-mo-xing-xiang-guan-gai-nian">数据模型相关概念</h2><ol><li class="lvl-3"><p>表：HBase 采用表来组织数据，表由行和列组成，列划分为若干个列族；</p></li><li class="lvl-3"><p>行：每个 HBase 表都由若干行组成，每个行由行键（row key）来标识；</p></li><li class="lvl-3"><p>列族：一个 HBase 表被分组成许多“列族”（Column Family）的集合，它是基本的访问控制单元，创建表的时候创建；</p></li><li class="lvl-3"><p>列限定符：列族里的数据通过列限定符（或列）来定位；</p></li><li class="lvl-3"><p>单元格：在 HBase 表中，通过行、列族和列限定符确定一个“单元格”（cell）；</p></li><li class="lvl-3"><p>时间戳：每个单元格都保存着同一份数据的多个版本，这些版本采用时间戳进行索引；</p></li></ol><h2 id="shu-ju-zuo-biao">数据坐标</h2><p><strong>HBase 中需要根据行键、列族、列限定符和时间戳来确定一个单元格，因此，可以视为一个“四维坐标”，即[行键, 列族, 列限定符, 时间戳]</strong></p><h2 id="h-base-de-shu-ju-cun-chu-mo-xing">HBase 的数据存储模型</h2><p><strong>HBase 的数据的存储结构不同于传统的关系型数据库，HBase 是一种结构松散，分布式，多维 度有序映射的持久化存储系统</strong>，它索引的依据是行键、列键和时间戳。</p><p>HBase 数据存储结构中主要包括：<strong>表、行、列族、列限定符、单元格和时间戳</strong>，下面将对 HBase 的数据存储模型的概念进行解释：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>表(Table)</strong>：对应于关系型数据库中的一张张表，HBase 以“表”为单位组织数据，表由多行组成。</p></li><li class="lvl-2"><p><strong>行(Row)</strong>：行包含在表中，数据以行的形式存储在 HBase 的表中。HBase 的表中的每一行数 据都会被一个唯一标识的行键（RowKey）标识，这个 RowKey 类似于关系型数据库表中的 主键，RowKey 根据字典序进行排序，并且只能存储 64KB 的数据。</p></li><li class="lvl-2"><p><strong>列族(Colunm Family)</strong>：行中的数据又分为多个列族，并且每个列族下可包含多个列。列族 会在使用前定义，也就是在定义表的时候就定义列族。</p></li><li class="lvl-2"><p><strong>列限定符(Column Qualifier)</strong>：通常以列族，和列限定符来确定列族中的某列。</p></li><li class="lvl-2"><p><strong>时间戳(Timestamp)</strong>：每个单元格里面可以存储每一份数据的多个版本，时间戳是区分每 一份数据的一个版本号标识，每一个值都会对应一个时间戳，在默认情况下，时间戳表示数 据写入的时间。并且是按照时间倒序进行排序（最新的数据放在最上面）。也可以自己设 置，但是一般情况下不需要。</p></li><li class="lvl-2"><p><strong>单元格(Cell)</strong>：单元格由 RowKey、列族、列限定符唯一定位，单元格之中存放一个值**{row key， column(= family + qualifier)， version}** ，并且值以字节形式存储。</p></li></ul><p>下面是一个具体的 HBase 表数据，来研究它的逻辑存储方式 👇</p><p><img src="/2023/07/19/Hbase%E5%9F%BA%E7%A1%80/image-20230613103922334.png" alt="image-20230613103922334"></p><p>上表展示的是 HBase 中的学生信息表 Student，有三行记录和两个列族，行键分别为 0001、 0002 和 0003，两个列族分别为 Stulnfo 和 Grades，每个列族中含有若干列，如列族 Stulnfo 包括 Name、Age、Sex 和 Class 四列，列族 Grades 包括 BigData、Computer 和 Math 三列。</p><p>在 HBase 中，列不是固定的表结构，在创建表时，不需要预先定义列名，可以在插入数据时临时创建。</p><p>从上表的逻辑模型来看，HBase 表与关系型数据库中的表结构之间似乎没有太大差异，只不过 多了列族的概念。但实际上是有很大差别的，关系型数据库中表的结构需要预先定义，如列名及 其数据类型和值域等内容。</p><p>如果需要添加新列，则需要修改表结构，这会对已有的数据产生很大影响。同时，关系型数据 库中的表为每个列预留了存储空间，即上表中的空白 Cell 数据在关系型数据库中以“NULL”值占 用存储空间。因此，对稀疏数据来说，关系型数据库表中就会产生很多“NULL”值，消耗大量的存储空间。</p><p>在 HBase 中，如上表中的空白 Cell 在物理上是不占用存储空间的，即不会存储空白的键值对。因此，若一个请求为获取 RowKey 为 0001 在 T2 时间的 Stulnfo:class 值时，其结果为空。 类似地，若一个请求为获取 RowKey 为 0002 在 T1 时间的 Grades Computer 值时，其结果也为空。</p><p>下表展示了 Stulnfo 这个列族的实际物理存储方式，列族 Grades 的存储与之类似。在下表中可以看到空白 Cell 是没有被存储下来的。</p><table><thead><tr><th style="text-align:center">行键</th><th style="text-align:center">列标识</th><th style="text-align:center">值</th><th style="text-align:center">时间戳</th></tr></thead><tbody><tr><td style="text-align:center">0001</td><td style="text-align:center">Name</td><td style="text-align:center">Tom</td><td style="text-align:center">T2</td></tr><tr><td style="text-align:center">0001</td><td style="text-align:center">Age</td><td style="text-align:center">18</td><td style="text-align:center">T2</td></tr><tr><td style="text-align:center">0001</td><td style="text-align:center">Sex</td><td style="text-align:center">Male</td><td style="text-align:center">T2</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">Name</td><td style="text-align:center">Amy</td><td style="text-align:center">T1</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">Age</td><td style="text-align:center">19</td><td style="text-align:center">T1</td></tr><tr><td style="text-align:center">0002</td><td style="text-align:center">Class</td><td style="text-align:center">01</td><td style="text-align:center">T1</td></tr><tr><td style="text-align:center">0003</td><td style="text-align:center">Name</td><td style="text-align:center">Allen</td><td style="text-align:center">T1</td></tr><tr><td style="text-align:center">0003</td><td style="text-align:center">Age</td><td style="text-align:center">19</td><td style="text-align:center">T1</td></tr><tr><td style="text-align:center">0003</td><td style="text-align:center">Sex</td><td style="text-align:center">Male</td><td style="text-align:center">T1</td></tr><tr><td style="text-align:center">0003</td><td style="text-align:center">Class</td><td style="text-align:center">02</td><td style="text-align:center">T1</td></tr></tbody></table><p><img src="/2023/07/19/Hbase%E5%9F%BA%E7%A1%80/image-20230613114316010.png" alt="image-20230613114316010"></p><h1 id="h-base-jia-gou">HBase 架构</h1><p>从下面的架构图可以发现 HBase 里面有这么几个角色：Client、Zookeeper、HMaster、 HRegionServer、HRegion、Store、MemStore、StoreFile、HFile、HLog 等。👇</p><p><img src="/2023/07/19/Hbase%E5%9F%BA%E7%A1%80/image-20230613114452670.png" alt="image-20230613114452670"></p><h2 id="client">Client</h2><p>包含访问 HBase 的接口，Client 访问用户数据前需要首先访问 ZooKeeper，Region 所在的位 置，然后才能找到用户所需要的数据，客户端会通过维护 cache 来加快对 HBase 的访问。</p><h2 id="zoo-keeper">ZooKeeper</h2><p>我们的 HBase 会使用到<code>zookeeper</code>，这里要注意，我们的 HBase 采用的是“主从结构”，有别于 HDFS 高可用中的“主备模式”，很凑巧它使用的是跟 zookeeper 一样的“主从模式”。在 HBase 中 zookeeper 主要有以下几个作用：</p><ol><li class="lvl-3"><p>✅ 为 HBase 提供故障转义机制，选举<code>HMaster</code>，避免单点 HMaster 单点故障问题。</p></li><li class="lvl-3"><p>✅ 存储所有 <code>Region</code> 的寻址入口，我们的表在哪台服务器上，也就是这张表的位置信息。</p></li><li class="lvl-3"><p>✅ 实时监控<code>RegionServer</code>的状态，将 RegionServer 的上线和下线信息实时通知给 HMaster。</p></li><li class="lvl-3"><p>✅ 存储 HBase 的<code>schema</code>和<code>table元数据</code>，包括有哪些 Table，每个 Table 有哪些 Column Family。</p></li></ol><h2 id="h-master">HMaster</h2><p>HMaster 一般运行在 NameNode 节点上面，它的主要作用有以下几点：</p><ol><li class="lvl-3"><p>✅ 为 RegionServer 分配 Region</p></li><li class="lvl-3"><p>✅ 负责 RegionServer 的负载均衡</p></li><li class="lvl-3"><p>✅ 发现失效的 RegionServer 并重新分配其上的 Region</p></li><li class="lvl-3"><p>✅HDFS 上属于 HBase 的垃圾文件回收。</p></li><li class="lvl-3"><p>✅ 处理客户端的更新请求（表的创建，删除，修改，列簇的增加等等）。</p></li></ol><h2 id="h-region">HRegion</h2><p>HBase 的<code>table</code>在行的方向上分隔为多个<code>Region</code>（对应列族）。<code>Region</code>是 HBase 中分布式存储 和负载均衡的最小单元，即不同的<code>region</code>可以分别在不同的<code>Region Server</code>上，但同一个<code>Region</code>是不会拆分到多个 server 上，每个 region 会保存一个表里面某段连续的数据。</p><p><code>Region</code>按大小分隔，表中每一行只能属于一个<code>region</code>。随着数据不断插入表，<code>region</code>不断增大，当<code>region</code>的 某个列族达到一个阈值时(<code>默认256M</code>)就会分成两个新的<code>region</code>。当一个表的数据越来越多的时候，有可能张在表的数据被保存在多个 Regionserver 上。</p><h2 id="store">Store</h2><p>每一个<code>region</code>有一个或多个<code>store</code>组成，至少是一个<code>store</code>，hbase 会把一起访问的数据放在一个<code>store</code>里面，即为每个<code>ColumnFamily</code>建一个<code>store</code>（<strong>即有几个<code>ColumnFamily</code>，也就有几个 Store</strong>）。一个<code>Store</code>由一个<code>memStore</code>和<code>0</code>或<code>多个StoreFile</code>组成。<strong>HBase 以 store 的大小来判断是否需要切分 region。</strong></p><p><code>MemStore</code>的值达到某个阈值（<code>默认128MB</code>），<code>RegionServer</code>会启动<code>flashcache</code>进程写入 <code>StoreFile</code>，每次写入形成单独的一个<code>StoreFile</code>，当<code>StoreFile</code>文件的数量增长到一定阈值后，系统会进行合并，在合并过程中会进行版本合并和删除工作，形成更大的<code>StoreFile</code>。</p><p>当一个<code>Region</code>所有<code>StoreFile</code>的大小和数量超过一定阈值后，会把当前的<code>Region</code>分割为两个， 并由 HMaster 分配到相应的 RegionServer 服务器，实现系统的负载均衡。</p><h2 id="h-file">HFile</h2><p>HBase 中的数据的存储格式，HFile 是 Hadoop 的 二进制格式文件，实际上 StoreFile 就是对 HFile 做了轻量级包装，即 StoreFile 底层就是 HFile。</p><h2 id="h-log">HLog</h2><p>HLog(WAL log)：WAL 意为 write ahead log，用来做灾难恢复使用，HLog 记录数据的所有变 更，一旦 region server 宕机，就可以从 log 中进行恢复</p><p>HLog 文件就是一个普通的 Hadoop Sequence File， Sequence File 的 value 是 key 时 HLogKey 对象，其中记录了写入数据的归属信息，除了 table 和 region 名字外，还同时包括 sequence number 和 timestamp，timestamp 是写入时间，sequence number 的起始值为 0，或者是最近 一次存入文件系统中的 sequence number。 Sequence File 的 value 是 HBase 的 KeyValue 对象， 即对应 HFile 中的 KeyValue。</p><p><strong>整体物理结构如下</strong>👇</p><p><img src="/2023/07/19/Hbase%E5%9F%BA%E7%A1%80/image-20230613121317590.png" alt="image-20230613121317590"></p><p><strong>总结</strong>：</p><p>1️⃣HRegion 是 HBase 中分布式存储和负载均衡的最小单元。最小单元就表示不同的 HRegion 可 以分布在不同的 HRegionServer 上。</p><p>2️⃣HRegion 由一个或者多个 Store 组成，每个 store 保存一个 columns family。</p><p>3️⃣ 每个 Strore 又由一个 MemStore 和 0 至多个 StoreFile 组成，最终 StoreFile 以 HFile 格式保存在 HDFS 上。</p><h1 id="h-base-de-shell-cao-zuo">HBase 的 shell 操作</h1><h2 id="cao-zuo-ming-ming-kong-jian">操作命名空间</h2><p><code>命名空间(namespace)</code>是与关系数据库系统中的数据库类似，我们以前使用 MySQL 的时候会先 创建数据库，然后在这个数据库里面创建表，我们的 HBase 也类似。</p><h3 id="cha-kan-suo-you-ming-ming-kong-jian">查看所有命名空间</h3><p>使用“list_namespace”查看命名空间，有点类似于 MySQL 里面的“show databases”来查看系统 里面的所有数据库一样。</p><pre><code class="language-shell"># 查看系统里面的所有的命名空间。list_namespace</code></pre><h3 id="chuang-jian-ming-ming-kong-jian">创建命名空间</h3><pre><code class="language-shell"># 创建命名空间的语法create_namespace '命名空间的名称'</code></pre><h3 id="xian-shi-ming-ming-kong-jian-xia-de-biao">显示命名空间下的表</h3><pre><code class="language-shell">list_namespace_tables '命名空间名称'</code></pre><h3 id="shan-chu-ming-ming-kong-jian">删除命名空间</h3><p>如果命名空间不需要了可以使用“drop_namespace”命令来删除，要注意删除命名空间的时 候，这个命名空间得是空的。</p><pre><code class="language-shell">drop_namespace '要删除的命名空间的名称'</code></pre><h2 id="hbase-biao-ge-de-ji-ben-jie-gou">hbase 表格的基本结构</h2><p><img src="/2023/07/19/Hbase%E5%9F%BA%E7%A1%80/hbase-logical-to-phisical-view.png" alt="hbase-logical-to-phisical-view"></p><p><img src="/2023/07/19/Hbase%E5%9F%BA%E7%A1%80/Snipaste_2023-05-06_17-54-25.png" alt></p><ul class="lvl-0"><li class="lvl-2"><p>表(Table)：对应于关系型数据库中的一张张表，HBase 以“表”为单位组织数据，表由多行组 成。</p></li><li class="lvl-2"><p>行(Row)：行包含在表中，数据以行的形式存储在 HBase 的表中。HBase 的表中的每一行数 据都会被一个唯一标识的行键（RowKey）标识，这个 RowKey 类似于关系型数据库表中的 主键，RowKey 根据字典序进行排序，并且只能存储 64KB 的数据。</p></li><li class="lvl-2"><p>列族(Colunm Family)：行中的数据又分为多个列族，并且每个列族下可包含多个列。列族 会在使用前定义，也就是在定义表的时候就定义列族。</p></li><li class="lvl-2"><p>列限定符(Column Qualifier)：通常以列族，和列限定符来确定列族中的某列。</p></li><li class="lvl-2"><p>时间戳(Timestamp)：每个单元格里面可以存储每一份数据的多个版本，时间戳是区分每 一份数据的一个版本号标识，每一个值都会对应一个时间戳，在默认情况下，时间戳表示数 据写入的时间。并且是按照时间倒序进行排序（最新的数据放在最上面）。也可以自己设 置，但是一般情况下不需要。</p></li><li class="lvl-2"><p>单元格(Cell)：单元格由 RowKey、列族、列限定符唯一定位，单元格之中存放一个值{row key， column(= family + qualifier)， version} ，并且值以字节形式存储。</p></li></ul><h3 id="chuang-jian-biao">创建表</h3><h4 id="chang-gui-biao-de-chuang-jian">常规表的创建</h4><pre><code class="language-shell">  create '表名', '列族名1'[,…]  create '命名空间:表名', '列族名1'[,…]# 或者  create '表名', &#123;NAME =&gt; '列族1',VERSIONS =&gt; versionNum(最多存储的版本数量)&#125; [, &#123;NAME =&gt; '列族2'&#125; ... ]  create '命名空间:表名', &#123;NAME =&gt; '列族1'&#125; [, &#123;NAME =&gt; '列族2'&#125; ... ] # =&gt;不是&gt;=的意思# 创建一个test的表，并且指定一个列族cf。create 'test', 'cf'# 创建一个学生表“student”，然后指定两个列族，一个是“detail”一个是“grade”。 create 'student', 'detail', 'grade'# 在my_nn命名空间下面创建学生表create 'my_nn:student1', 'detail', 'grade'</code></pre><blockquote><p>⚠<strong>注意</strong>：建表的时候需要指定表名，并且还需要同时指定至少一个列族。</p></blockquote><h4 id="cha-kan-biao-de-xin-xi">查看表的信息</h4><p>我们可以通过“list”命令查看表是否存在，以及使用“describe”命令来查看表的结构信息。</p><pre><code class="language-shell"># 查看'test'表是否存在list 'test'</code></pre><p>我们也可以通过“exists ”来检查表是否存在，他比上面的“list”更加直观。</p><pre><code class="language-shell">exists 'my_tab'=&gt; true/false</code></pre><p>我们可以通过“describe”查看表的描述信息，这个和以前的 MySQL 里面的“desc”的效果是类似 的。</p><pre><code class="language-shell">describe 'test'</code></pre><h3 id="cao-zuo-biao">操作表</h3><h4 id="cha-ru-shu-ju">插入数据</h4><pre><code class="language-shell">put '表名' 'RowKey', '列族名:列名', '列对应的值'#使用put语句插入数据put 'test', 'row1', 'cf:a', 'value1'put 'test', 'row2', 'cf:b', 'value2'put 'test', 'row3', 'cf:c', 'value3'#插入数据并且带时间戳。put 'test', 'row4', 'cf:a', 'value1', 1647938469167put 'test', 'row5', 'cf:b', 'value2', 1647938469167put 'test', 'row5', 'cf:c', 'value3', 1647938469167</code></pre><h4 id="sao-miao-biao-de-shu-ju">扫描表的数据</h4><p><strong>scan(全表查询)</strong></p><pre><code class="language-shell">scan '表名'#通过版本来获取值：查看最近两个版本的数据。scan 'tab_ver', &#123; COLUMNS =&gt; ['cf:col1'], VERSIONS =&gt; 2 &#125;</code></pre><p><strong>通过 get 查询</strong></p><p>上面的查询是全表查询，有的时候我们是通过 RowId 或者单元(cell)的值来进行查询，这个时候 就可以通过 get。</p><pre><code class="language-shell"># 获取列族下面的全部数据。get '表名', 'RowKey'# 获取列族下面的某一列。get '表名', 'RowKey', '列族名称:列'#使用get命令通过&quot;RowKey&quot;查询数据get 'test', 'row1'#通过列来查询数据get 'test', 'row1', 'cf:a'#通过版本来获取值：查看最近两个版本的数据get 'tab_ver', '0001', &#123; COLUMNS =&gt; ['cf:col1'],VERSIONS =&gt; 2 &#125;</code></pre><h4 id="shan-chu-biao-de-shu-ju">删除表的数据</h4><p><strong>delete</strong></p><pre><code class="language-shell">delete '表名', 'RowKey', '列族名称:列' [, 时间戳]#注意:如果不指定时间戳会删除最新的version!# 删除'test'表，RowKey为‘row1’的，并且列族“cf”的值为“a”的值。delete 'test', 'row1', 'cf:a'</code></pre><p><strong>delete 只会删除指定列中的指定位置的数据,并不会删除这个数据的所在行</strong></p><p><strong>deleteall</strong></p><p>如需删除表中某一行上所有列族的数据，即删除上表中一个逻辑行， 则需要使用 deleteall，如下所示，不需要指定列族和列的名称。</p><pre><code class="language-shell">deleteall '表名', 'RowKey'</code></pre><p><strong>truncate</strong></p><p><strong>“truncate”<strong>命令也是删除表的数据，但是它和上面的 delete、deleteall 有不同，它的作用和关 系型数据库里面的作用类似，使用它的效果是：</strong>“使得表无效，然后删除表，再重新创建表”</strong>。使 用场景：就是当表的数据很大时候，可以使用“truncate”来清空表。</p><pre><code class="language-shell">truncate '表名'</code></pre><h4 id="shan-chu-biao">删除表</h4><p>先要使用表不可用，然后再使用删除</p><pre><code class="language-shell"># 使得表不可用disable 'test'# 删除表drop 'test'</code></pre><h2 id="deng-lu-shell">登录 shell</h2><pre><code class="language-shell">hbase shell</code></pre>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis6.0学习笔记</title>
      <link href="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong><em>Redis</em></strong>  是典型的  <strong><em>NoSQL</em></strong>  数据库，支持多种数据结构类型。设计思想是：<strong>单线程+多路 IO 复用技术</strong></p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/说明.png" alt></p><p><a href="https://redis.io/download">redis 官方介绍</a></p><blockquote><p><strong><em>Redis</em></strong>  是一个开源的  <strong><em>key-value</em></strong>  存储系统。<br>和  <strong><em>Memcached</em></strong>  类似，它支持存储的  <strong><em>value</em></strong>  类型相对更多，包括  <strong><em>string、list、set、zset、sorted set、hash</em></strong>。</p><p>这些数据类型都支持  <strong><em>push/pop、add/remove</em></strong>  及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的</p><p>这些数据类型都支持  <strong><em>push/pop、add/remove</em></strong>  及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p><p>在此基础上，<strong><em>Redis</em></strong>  支持各种不同方式的排序。</p><p>与  <strong><em>memcached</em></strong>一样，为了保证效率，数据都是缓存在内存中。<br>区别的是  <strong><em>Redis</em></strong>  会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p><p>并且在此基础上实现了<strong><em>master-slave</em></strong> （主从）同步。<br>单线程 + <strong><em>IO</em></strong>  多路复用。</p></blockquote><h1 id="Redis-中的-key-操作"><a href="#Redis-中的-key-操作" class="headerlink" title="Redis 中的 key 操作"></a>Redis 中的 key 操作</h1><h2 id="查看当前库中所有的-key-值"><a href="#查看当前库中所有的-key-值" class="headerlink" title="查看当前库中所有的 key 值"></a>查看当前库中所有的 key 值</h2><pre><code class="lang-sql">keys  *</code></pre><h2 id="设置-key-value-值"><a href="#设置-key-value-值" class="headerlink" title="设置 key-value 值"></a>设置 key-value 值</h2><pre><code class="lang-sql">set key_name value //返回ok代表成功</code></pre><h2 id="查看-key-是否存在"><a href="#查看-key-是否存在" class="headerlink" title="查看 key 是否存在"></a>查看 key 是否存在</h2><pre><code class="lang-sql">exists key_name //返回值为1表示存在,0则不存在</code></pre><h2 id="查看-key-的-type"><a href="#查看-key-的-type" class="headerlink" title="查看 key 的 type"></a>查看 key 的 type</h2><pre><code class="lang-sql">type key_name</code></pre><p>redis 的操作是原子操作，即不会被线程调度机制打断的操作</p><h2 id="同时设置一个或多个-key-value-对"><a href="#同时设置一个或多个-key-value-对" class="headerlink" title="同时设置一个或多个 key-value 对"></a>同时设置一个或多个 key-value 对</h2><pre><code class="lang-sql">mset key1_name value1 key2_name value2.....</code></pre><h2 id="key-值不存在的时候设置-key-的值"><a href="#key-值不存在的时候设置-key-的值" class="headerlink" title="key 值不存在的时候设置 key 的值"></a>key 值不存在的时候设置 key 的值</h2><pre><code class="lang-sql">setnx key_name value</code></pre><h2 id="key-值不存在的时候设置一个或多个-key-的值"><a href="#key-值不存在的时候设置一个或多个-key-的值" class="headerlink" title="key 值不存在的时候设置一个或多个 key 的值"></a>key 值不存在的时候设置一个或多个 key 的值</h2><pre><code class="lang-sql">msetnx key1_name value1 key2_name value2 key3_name value3.... // 原子性，有一个失败则都失败</code></pre><h2 id="设置键值的同时，设置过期时间"><a href="#设置键值的同时，设置过期时间" class="headerlink" title="设置键值的同时，设置过期时间"></a>设置键值的同时，设置过期时间</h2><pre><code class="lang-sql">setex key_name time value</code></pre><h2 id="设置旧值的同时设置新值"><a href="#设置旧值的同时设置新值" class="headerlink" title="设置旧值的同时设置新值"></a>设置旧值的同时设置新值</h2><pre><code class="lang-sql">getset key_name value</code></pre><h2 id="获取-key-的-value-值"><a href="#获取-key-的-value-值" class="headerlink" title="获取 key 的 value 值"></a>获取 key 的 value 值</h2><pre><code class="lang-sql">get key_name</code></pre><h2 id="获取一个或多个-key-value-对"><a href="#获取一个或多个-key-value-对" class="headerlink" title="获取一个或多个 key-value 对"></a>获取一个或多个 key-value 对</h2><pre><code class="lang-sql">mget key1_name key2_name key3_name...</code></pre><h2 id="将给定的值追加到目标-key-的末尾"><a href="#将给定的值追加到目标-key-的末尾" class="headerlink" title="将给定的值追加到目标 key 的末尾"></a>将给定的值追加到目标 key 的末尾</h2><pre><code class="lang-sql">append key_name value</code></pre><h2 id="获得-key-值长度"><a href="#获得-key-值长度" class="headerlink" title="获得 key 值长度"></a>获得 key 值长度</h2><pre><code class="lang-sql">strlen key_name</code></pre><h2 id="将-key-中存储的数字增长-1"><a href="#将-key-中存储的数字增长-1" class="headerlink" title="将 key 中存储的数字增长 1"></a>将 key 中存储的数字增长 1</h2><pre><code class="lang-sql">incr key_name  //只能对数字值操作，如果为空，新增值为1</code></pre><h2 id="将-key-中存储的数字增长任意值"><a href="#将-key-中存储的数字增长任意值" class="headerlink" title="将 key 中存储的数字增长任意值"></a>将 key 中存储的数字增长任意值</h2><pre><code class="lang-sql">incrby key_name value</code></pre><h2 id="将-key-中存储的数字减一"><a href="#将-key-中存储的数字减一" class="headerlink" title="将 key 中存储的数字减一"></a>将 key 中存储的数字减一</h2><pre><code class="lang-sql">decr key_name</code></pre><h2 id="将-key-中存储的数字减去任意值"><a href="#将-key-中存储的数字减去任意值" class="headerlink" title="将 key 中存储的数字减去任意值"></a>将 key 中存储的数字减去任意值</h2><pre><code class="lang-sql">decrby key_name value</code></pre><h2 id="删除指定-key"><a href="#删除指定-key" class="headerlink" title="删除指定 key"></a>删除指定 key</h2><pre><code class="lang-sql">del key_name //返回值为1表示成功</code></pre><h2 id="非阻塞删除"><a href="#非阻塞删除" class="headerlink" title="非阻塞删除"></a>非阻塞删除</h2><pre><code class="lang-sql">unlink key_name  //仅将keys从keyspace元数据中删除，真正的删除会在后续一步操作</code></pre><h2 id="设置-key-过期时间"><a href="#设置-key-过期时间" class="headerlink" title="设置 key 过期时间"></a>设置 key 过期时间</h2><pre><code class="lang-sql">expire key_name time //以s为单位</code></pre><h2 id="查看-key-的过期时间"><a href="#查看-key-的过期时间" class="headerlink" title="查看 key 的过期时间"></a>查看 key 的过期时间</h2><pre><code class="lang-sql">ttl key_name  // -1代表永不过期 -2代表已经过期</code></pre><h2 id="查看当前库的-key-的数量"><a href="#查看当前库的-key-的数量" class="headerlink" title="查看当前库的 key 的数量"></a>查看当前库的 key 的数量</h2><pre><code class="lang-sql">dbsize</code></pre><h2 id="清空当前库"><a href="#清空当前库" class="headerlink" title="清空当前库"></a>清空当前库</h2><pre><code class="lang-sql">flushdb</code></pre><h2 id="清空所有库"><a href="#清空所有库" class="headerlink" title="清空所有库"></a>清空所有库</h2><pre><code class="lang-sql">flushall</code></pre><h1 id="Redis-的基本数据类型"><a href="#Redis-的基本数据类型" class="headerlink" title="Redis 的基本数据类型"></a>Redis 的基本数据类型</h1><p>Redis 是使用了一个「哈希表」保存所有键值对，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。</p><p>Redis 的哈希桶是怎么保存键值对数据的呢？</p><p>哈希桶存放的是指向键值对数据的指针（dictEntry<em>），这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身，而是保存了 void </em> key 和 void <em> value 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 void </em> value 指针找到。</p><p>这里有一张 Redis 保存键值对所涉及到的数据结构。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/redis全景图.png" alt="redis基本数据结构一览"></p><ul><li>redisDb 结构，表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针；</li><li>dict 结构，结构体里存放了 2 个哈希表，正常情况下都是用「哈希表 1」，「哈希表 2」只有在 rehash 的时候才用，具体什么是 rehash，在哈希表数据结构会讲；</li><li>ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；</li><li>dictEntry 结构，表示哈希表节点的结构，结构里存放了  <strong>void <em> key 和 void </em> value 指针， <em>key 指向的是 String 对象，而 </em>value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象</strong>。</li></ul><p>特别说明下，void <em> key 和 void </em> value 指针指向的是  <strong>Redis 对象</strong>，Redis 中的每个对象都由 redisObject 结构表示，如下图：</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/对象结构.png" alt><br>对象结构里包含的成员变量：</p><ul><li>type，标识该对象是什么类型的对象（String 对象、 List 对象、Hash 对象、Set 对象和 Zset 对象）；</li><li>encoding，标识该对象使用了哪种底层的数据结构；</li><li><strong>ptr，指向底层数据结构的指针</strong>。</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h3><p>字符串在 Redis 中是很常用的，键值对中的键是字符串类型，值有时也是字符串类型。</p><p>Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS。</p><p>既然 Redis 设计了 SDS 结构来表示字符串，肯定是 C 语言的 char* 字符数组存在一些缺陷。</p><p>要了解这一点，得先来看看 char* 字符数组的结构。</p><h3 id="C-语言字符串的缺陷"><a href="#C-语言字符串的缺陷" class="headerlink" title="C 语言字符串的缺陷"></a>C 语言字符串的缺陷</h3><p>C 语言的字符串其实就是一个字符数组，即数组中每个元素是字符串中的一个字符。</p><p>比如，下图就是字符串“xiaolin”的 char* 字符数组的结构：</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/38e4949cc380698609129c20459ae0c3_MD5.png" alt></p><p>没学过 C 语言的同学，可能会好奇为什么最后一个字符是“\0”？</p><p>在 C 语言里，对字符串操作时，char * 指针只是指向字符数组的起始位置，而<strong>字符数组的结尾位置就用“\0”表示，意思是指字符串的结束</strong>。</p><p>因此，C 语言标准库中的字符串操作函数就通过判断字符是不是 “\0” 来决定要不要停止操作，如果当前字符不是 “\0” ，说明字符串还没结束，可以继续操作，如果当前字符是 “\0” 是则说明字符串结束了，就要停止操作。</p><p>举个例子，C 语言获取字符串长度的函数  <code>strlen</code>，就是通过字符数组中的每一个字符，并进行计数，等遇到字符为 “\0” 后，就会停止遍历，然后返回已经统计到的字符个数，即为字符串长度。下图显示了 strlen 函数的执行流程：</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3d93bb27b72acda3c4387834c43909a5_MD5.png" alt></p><p>很明显，<strong>C 语言获取字符串长度的时间复杂度是 O（N）（<em>这是一个可以改进的地方</em></strong>）</p><p>C 语言字符串用 “\0” 字符作为结尾标记有个缺陷。假设有个字符串中有个 “\0” 字符，这时在操作这个字符串时就会<strong>提早结束</strong>，比如 “xiao\0lin” 字符串，计算字符串长度的时候则会是 4，如下图：</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1f49b3b41356a712d2b6fb2dee533f0a_MD5.png" alt></p><p>因此，除了字符串的末尾之外，<strong>字符串里面不能含有 “\0” 字符</strong>，否则最先被程序读入的 “\0” 字符将被误认为是字符串结尾，这个限制使得 C 语言的字符串只能保存文本数据，<strong>不能保存像图片、音频、视频文化这样的二进制数据（<em>这也是一个可以改进的地方</em>）</strong></p><p>另外， C 语言标准库中字符串的操作函数是很不安全的，对程序员很不友好，稍微一不注意，就会导致缓冲区溢出。</p><p>举个例子，strcat 函数是可以将两个字符串拼接在一起。</p><p><code>c //将 src 字符串拼接到 dest 字符串后面 char *strcat(char *dest, const char* src);</code></p><p><strong>C 语言的字符串是不会记录自身的缓冲区大小的</strong>，所以 strcat 函数假定程序员在执行这个函数时，已经为 dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而<strong>一旦这个假定不成立，就会发生缓冲区溢出将可能会造成程序运行终止，（<em>这是一个可以改进的地方</em></strong>）。</p><p>而且，strcat 函数和 strlen 函数类似，时间复杂度也很高，也都需要先通过遍历字符串才能得到目标字符串的末尾。然后对于 strcat 函数来说，还要再遍历源字符串才能完成追加，<strong>对字符串的操作效率不高</strong>。</p><p>好了， 通过以上的分析，我们可以得知 C 语言的字符串不足之处以及可以改进的地方：</p><ul><li>获取字符串长度的时间复杂度为 O（N）；</li><li>字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据；</li><li>字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；</li></ul><p>Redis 实现的 SDS 的结构就把上面这些问题解决了，接下来我们一起看看 Redis 是如何解决的。</p><h3 id="SDS-结构设计"><a href="#SDS-结构设计" class="headerlink" title="SDS 结构设计"></a>SDS 结构设计</h3><p>下图就是 Redis 5.0 的 SDS 的数据结构：</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/acd89e40ca2c7821459850c7524f62f3_MD5.png" alt></p><p>结构中的每个成员变量分别介绍下：</p><ul><li><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。</li><li><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过  <code>alloc - len</code>  计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。</li><li><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面再说明区别之处。</li><li><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。</li></ul><p>总的来说，Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据：len、alloc、flags，用来解决 C 语言字符串的缺陷。</p><h3 id="O（1）复杂度获取字符串长度"><a href="#O（1）复杂度获取字符串长度" class="headerlink" title="O（1）复杂度获取字符串长度"></a>O（1）复杂度获取字符串长度</h3><p>C 语言的字符串长度获取 strlen 函数，需要通过遍历的方式来统计字符串长度，时间复杂度是 O（N）。</p><p>而 Redis 的 SDS 结构因为加入了 len 成员变量，那么<strong>获取字符串长度的时候，直接返回这个成员变量的值就行，所以复杂度只有 O（1）</strong>。</p><h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>因为 SDS 不需要用 “\0” 字符来标识字符串结尾了，而是<strong>有个专门的 len 成员变量来记录长度，所以可存储包含 “\0” 的数据</strong>。但是 SDS 为了兼容部分 C 语言标准库的函数， SDS 字符串结尾还是会加上 “\0” 字符。</p><p>因此， SDS 的 API 都是以处理二进制的方式来处理 SDS 存放在 buf[] 里的数据，程序不会对其中的数据做任何限制，数据写入的时候时什么样的，它被读取时就是什么样的。</p><p>通过使用二进制安全的 SDS，而不是 C 字符串，使得 Redis 不仅可以保存文本数据，也可以保存任意格式的二进制数据。</p><h3 id="不会发生缓冲区溢出"><a href="#不会发生缓冲区溢出" class="headerlink" title="不会发生缓冲区溢出"></a>不会发生缓冲区溢出</h3><p>C 语言的字符串标准库提供的字符串操作函数，大多数（比如 strcat 追加字符串函数）都是不安全的，因为这些函数把缓冲区大小是否满足操作需求的工作交由开发者来保证，程序内部并不会判断缓冲区大小是否足够用，当发生了缓冲区溢出就有可能造成程序异常结束。</p><p>所以，Redis 的 SDS 结构里引入了 alloc 和 len 成员变量，这样 SDS API 通过  <code>alloc - len</code>  计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。</p><p>而且，<strong>当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小（小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容）</strong>，以满足修改所需的大小。</p><p>在扩展 SDS 空间之前，SDS API 会优先检查未使用空间是否足够，如果不够的话，API 不仅会为 SDS 分配修改所必须要的空间，还会给 SDS 分配额外的「未使用空间」。</p><p>这样的好处是，下次在操作 SDS 时，如果 SDS 空间够的话，API 就会直接使用「未使用空间」，而无须执行内存分配，<strong>有效的减少内存分配次数</strong>。</p><p>所以，使用 SDS 即不需要手动修改 SDS 的空间大小，也不会出现缓冲区溢出的问题。</p><h3 id="节省内存空间"><a href="#节省内存空间" class="headerlink" title="节省内存空间"></a>节省内存空间</h3><p>SDS 结构中有个 flags 成员变量，表示的是 SDS 类型。</p><p>Redos 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。</p><p>这 5 种类型的主要<strong>区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同</strong>。</p><p>比如 sdshdr16 和 sdshdr32 这两个类型，它们的定义分别如下：</p><pre><code class="lang-c">struct __attribute__ ((__packed__)) sdshdr16 &#123;    uint16_t len;    uint16_t alloc;     unsigned char flags;     char buf[];&#125;;struct __attribute__ ((__packed__)) sdshdr32 &#123;    uint32_t len;    uint32_t alloc;     unsigned char flags;    char buf[];&#125;;</code></pre><p>可以看到：</p><ul><li>sdshdr16 类型的 len 和 alloc 的数据类型都是 uint16_t，表示字符数组长度和分配空间大小不能超过 2 的 16 次方。</li><li>sdshdr32 则都是 uint32_t，表示表示字符数组长度和分配空间大小不能超过 2 的 32 次方。</li></ul><p><strong>之所以 SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间</strong>。比如，在保存小字符串时，结构头占用空间也比较少。</p><p>除了设计不同类型的结构体，Redis 在编程上还<strong>使用了专门的编译优化来节省内存空间</strong>，即在 struct 声明了  <code>__attribute__ ((packed))</code> ，它的作用是：<strong>告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐</strong>。</p><p>比如，sdshdr16 类型的 SDS，默认情况下，编译器会按照 16 字节对齐的方式给变量分配内存，这意味着，即使一个变量的大小不到 16 个字节，编译器也会给它分配 16 个字节。</p><p>举个例子，假设下面这个结构体，它有两个成员变量，类型分别是 char 和 int，如下所示：</p><pre><code class="lang-c">#include &lt;stdio.h&gt; struct test1 &#123;    char a;    int b; &#125; test1;int main() &#123;     printf(&quot;%lu\n&quot;, sizeof(test1));     return 0;&#125;</code></pre><p>猜猜这个结构体大小是多少？我先直接说答案，这个结构体大小计算出来是 8。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/f146749f3864d3731b9ffae675c9ce8e_MD5.png" alt></p><p>这是因为默认情况下，编译器是使用「字节对齐」的方式分配内存，虽然 char 类型只占一个字节，但是由于成员变量里有 int 类型，它占用了 4 个字节，所以在成员变量为 char 类型分配内存时，会分配 4 个字节，其中这多余的 3 个字节是为了字节对齐而分配的，相当于有 3 个字节被浪费掉了。</p><p>如果不想编译器使用字节对齐的方式进行分配内存，可以采用了  <code>__attribute__ ((packed))</code>  属性定义结构体，这样一来，结构体实际占用多少内存空间，编译器就分配多少空间。</p><p>比如，我用  <code>__attribute__ ((packed))</code>  属性定义下面的结构体 ，同样包含 char 和 int 两个类型的成员变量，代码如下所示：</p><pre><code class="lang-c">#include &lt;stdio.h&gt;struct __attribute__((packed)) test2  &#123;    char a;    int b; &#125; test2;int main() &#123;     printf(&quot;%lu\n&quot;, sizeof(test2));     return 0;&#125;</code></pre><p>这时打印的结果是 5（1 个字节 char + 4 字节 int）。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/35d85b3f8a490fa1502107879d9ff1f3_MD5.png" alt></p><p>可以看得出，这是按照实际占用字节数进行分配内存的，这样可以节省内存空间。</p><h3 id="部分操作指令"><a href="#部分操作指令" class="headerlink" title="部分操作指令"></a>部分操作指令</h3><p><strong><em>获取 key 的指定范围的值</em></strong></p><pre><code class="lang-sql">getrange key_name start_number end_number</code></pre><p><strong><em>在 key 的指定位置插入值</em></strong></p><pre><code class="lang-sql">setrange key_name start_number value</code></pre><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>允许重复值</p><p>单键多值<br>底层：双向链表 对两端的操作性能高，中间的操作性能低</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>qickList:链表+ziplist</p><ul><li>首先在<strong>列表元素较少的情况下会使用一块连续的内存存储</strong>，这个结构是  <strong><em>ziplist</em></strong>，也即是<strong>压缩列表</strong><ul><li>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</li></ul></li><li>当<strong>数据量比较多</strong>的时候才会改成  <strong><em>quicklist</em></strong>。<ul><li>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是  <strong><em>int</em></strong>  类型的数据，结构上还需要两个额外的指针  <strong><em>prev</em></strong>  和  <strong><em>next</em></strong></li></ul></li></ul><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1751903-20220127114010280-898156568.png" alt></p><ul><li><strong><em>Redis</em></strong>  将<strong>链表</strong>和  <strong><em>ziplist</em></strong>  结合起来组成了  <strong><em>quicklist</em></strong>。也就是将多个  <strong><em>ziplist</em></strong>  使<strong>用双向指针串起来使用</strong>。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。<strong><em>quicklist</em></strong>结构图如下：<br><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211022122514593.png" alt></li></ul><h2 id="链表节点结构设计"><a href="#链表节点结构设计" class="headerlink" title="链表节点结构设计"></a>链表节点结构设计</h2><p>先来看看「链表节点」结构的样子：</p><pre><code class="lang-c">typedef struct listNode &#123;    //前置节点    struct listNode *prev;    //后置节点    struct listNode *next;    //节点的值    void *value;&#125; listNode;</code></pre><p>有前置节点和后置节点，可以看的出，这个是一个双向链表。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2809989f806dc74957bb01f308aafd61_MD5.png" alt></p><h3 id="链表结构设计"><a href="#链表结构设计" class="headerlink" title="链表结构设计"></a>链表结构设计</h3><p>不过，Redis 在 listNode 结构体基础上又封装了 list 这个数据结构，这样操作起来会更方便，链表结构如下：</p><pre><code class="lang-c">typedef struct list &#123;    //链表头节点    listNode *head;    //链表尾节点    listNode *tail;    //节点值复制函数    void *(*dup)(void *ptr);    //节点值释放函数    void (*free)(void *ptr);    //节点值比较函数    int (*match)(void *ptr, void *key);    //链表节点数量    unsigned long len;&#125; list;</code></pre><p>list 结构为链表提供了链表头指针 head、链表尾节点 tail、链表节点数量 len、以及可以自定义实现的 dup、free、match 函数。</p><p>举个例子，下面是由 list 结构和 3 个 listNode 结构组成的链表。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/a1419c63bed3a88896609b20f1d614cc_MD5.png" alt></p><h3 id="链表的优势与缺陷"><a href="#链表的优势与缺陷" class="headerlink" title="链表的优势与缺陷"></a>链表的优势与缺陷</h3><p>Redis 的链表实现优点如下：</p><ul><li>listNode 链表节点的结构里带有 prev 和 next 指针，<strong>获取某个节点的前置节点或后置节点的时间复杂度只需 O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表</strong>；</li><li>list 结构因为提供了表头指针 head 和表尾节点 tail，所以<strong>获取链表的表头节点和表尾节点的时间复杂度只需 O(1)</strong>；</li><li>list 结构因为提供了链表节点数量 len，所以<strong>获取链表中的节点数量的时间复杂度只需 O(1)</strong>；</li><li>listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此<strong>链表节点可以保存各种不同类型的值</strong>；</li></ul><p>链表的缺陷也是有的：</p><ul><li><p>链表每个节点之间的内存都是不连续的，意味着<strong>无法很好利用 CPU 缓存</strong>。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。</p></li><li><p>还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，<strong>内存开销较大</strong>。</p></li></ul><p>因此，Redis 3.0 的 List 对象在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。</p><p>不过，压缩列表存在性能问题（具体什么问题，下面会说），所以 Redis 在 3.2 版本设计了新的数据结构 quicklist，并将 List 对象的底层数据结构改由 quicklist 实现。</p><p>然后在 Redis 5.0 设计了新的数据结构 listpack，沿用了压缩列表紧凑型的内存布局，最终在最新的 Redis 版本，将 Hash 对象和 Zset 对象的底层数据结构实现之一的压缩列表，替换成由 listpack 实现。</p><hr><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。</p><p>但是，压缩列表的缺陷也是有的：</p><ul><li>不能保存过多的元素，否则查询效率就会降低；</li><li>新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。</li></ul><p>因此，Redis 对象（List 对象、Hash 对象、Zset 对象）包含的元素数量较少，或者元素值不大的情况才会使用压缩列表作为底层数据结构。</p><p>接下来，就跟大家详细聊下压缩列表。</p><h3 id="压缩列表结构设计"><a href="#压缩列表结构设计" class="headerlink" title="压缩列表结构设计"></a>压缩列表结构设计</h3><p>压缩列表是 Redis 为了节约内存而开发的，它是<strong>由连续内存块组成的顺序型数据结构</strong>，有点类似于数组。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/d21c4278d9d71f4938b76d2328189630_MD5.png" alt></p><p>压缩列表在表头有三个字段：</p><ul><li><strong><em>zlbytes</em></strong>，记录整个压缩列表占用对内存字节数；</li><li><strong><em>zltail</em></strong>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li><li><strong><em>zllen</em></strong>，记录压缩列表包含的节点数量；</li><li><strong><em>zlend</em></strong>，标记压缩列表的结束点，固定值 0xFF（十进制 255）。</li></ul><p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</strong>。</p><p>另外，压缩列表节点（entry）的构成如下：</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/985302f3e0228d5e55c5474bcfb7e0d3_MD5.png" alt></p><p>压缩列表节点包含三部分内容：</p><ul><li><strong><em>prevlen</em></strong>，记录了「前一个节点」的长度；</li><li><strong><em>encoding</em></strong>，记录了当前节点实际数据的类型以及长度；</li><li><strong><em>data</em></strong>，记录了当前节点的实际数据；</li></ul><p>当我们往压缩列表中插入数据时，压缩列表就会根据数据是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，<strong>这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的</strong>。</p><p>分别说下，prevlen 和 encoding 是如何根据数据的大小和类型来进行不同的空间大小分配。</p><p>压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度」，而且 prevlen 属性的空间大小跟前一个节点长度值有关，比如：</p><ul><li>如果<strong>前一个节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用  <strong>1 字节的空间</strong>来保存这个长度值；</li><li>如果<strong>前一个节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用  <strong>5 字节的空间</strong>来保存这个长度值；</li></ul><p>encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关：</p><ul><li>如果<strong>当前节点的数据是整数</strong>，则 encoding 会使用  <strong>1 字节的空间</strong>进行编码。</li><li>如果<strong>当前节点的数据是字符串，根据字符串的长度大小</strong>，encoding 会使用  <strong>1 字节/2 字节/5 字节的空间</strong>进行编码。</li></ul><h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>压缩列表除了查找复杂度高的问题，还有一个问题。</p><p><strong>压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降</strong>。</p><p>前面提到，压缩列表节点的 prevlen 属性会根据前一个节点的长度进行不同的空间大小分配：</p><ul><li>如果前一个<strong>节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用  <strong>1 字节的空间</strong>来保存这个长度值；</li><li>如果前一个<strong>节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用  <strong>5 字节的空间</strong>来保存这个长度值；</li></ul><p>现在假设一个压缩列表中有多个连续的、长度在 250 ～ 253 之间的节点，如下图：</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/08968fccc8baa1f596b85c872f3c843c_MD5.png" alt></p><p>因为这些节点长度值小于 254 字节，所以 prevlen 属性需要用 1 字节的空间来保存这个长度值。</p><p>这时，如果将一个长度大于等于 254 字节的新节点加入到压缩列表的表头节点，即新节点将成为 e1 的前置节点，如下图：</p><p><img src="images/Redis6.0学习笔记/96ebc09237508ab25190a507c9978fde_MD5.png" alt></p><p>因为 e1 节点的 prevlen 属性只有 1 个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重分配操作，并将 e1 节点的 prevlen 属性从原来的 1 字节大小扩展为 5 字节大小。</p><p>多米诺牌的效应就此开始。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6cbf966e531d613a4d3050f5e5235dd2_MD5.png" alt></p><p>e1 原本的长度在 250 ～ 253 之间，因为刚才的扩展空间，此时 e1 的长度就大于等于 254 了，因此原本 e2 保存 e1 的 prevlen 属性也必须从 1 字节扩展至 5 字节大小。</p><p>正如扩展 e1 引发了对 e2 扩展一样，扩展 e2 也会引发对 e3 的扩展，而扩展 e3 又会引发对 e4 的扩展…. 一直持续到结尾。</p><p><strong>这种在特殊情况下产生的连续多次空间扩展操作就叫做「连锁更新」</strong>，就像多米诺牌的效应一样，第一张牌倒下了，推动了第二张牌倒下；第二张牌倒下，又推动了第三张牌倒下….，</p><h3 id="压缩列表的缺陷"><a href="#压缩列表的缺陷" class="headerlink" title="压缩列表的缺陷"></a>压缩列表的缺陷</h3><p>空间扩展操作也就是重新分配内存，因此<strong>连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能</strong>。</p><p>所以说，<strong>虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题</strong>。</p><p>因此，<strong>压缩列表只会用于保存的节点数量不多的场景</strong>，只要节点数量足够小，即使发生连锁更新，也是能接受的。</p><p>虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题。</p><h2 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h2><p>在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。</p><p>其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。</p><p>在前面讲压缩列表的时候，我也提到了压缩列表的不足，虽然压缩列表是通过紧凑型的内存布局节省了内存开销，但是因为它的结构设计，如果保存的元素数量增加，或者元素变大了，压缩列表会有「连锁更新」的风险，一旦发生，会造成性能下降。</p><p>quicklist 解决办法，<strong>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</strong></p><h3 id="quicklist-结构设计"><a href="#quicklist-结构设计" class="headerlink" title="quicklist 结构设计"></a>quicklist 结构设计</h3><p>quicklist 的结构体跟链表的结构体类似，都包含了表头和表尾，区别在于 quicklist 的节点是 quicklistNode。</p><pre><code class="lang-c">typedef struct quicklist &#123;    //quicklist的链表头    quicklistNode *head;      //quicklist的链表头    //quicklist的链表头    quicklistNode *tail;     //所有压缩列表中的总元素个数    unsigned long count;    //quicklistNodes的个数    unsigned long len;           ...&#125; quicklist;</code></pre><p>接下来看看，quicklistNode 的结构定义：</p><pre><code class="lang-c">typedef struct quicklistNode &#123;    //前一个quicklistNode    struct quicklistNode *prev;     //前一个quicklistNode    //下一个quicklistNode    struct quicklistNode *next;     //后一个quicklistNode    //quicklistNode指向的压缩列表    unsigned char *zl;                  //压缩列表的的字节大小    unsigned int sz;                    //压缩列表的元素个数    unsigned int count : 16;        //ziplist中的元素个数     ....&#125; quicklistNode;</code></pre><p>可以看到，quicklistNode 结构体里包含了前一个节点和下一个节点指针，这样每个 quicklistNode 形成了一个双向链表。但是链表节点的元素不再是单纯保存元素值，而是保存了一个压缩列表，所以 quicklistNode 结构体里有个指向压缩列表的指针 *zl。</p><p>我画了一张图，方便你理解 quicklist 数据结构。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/47fff23194a56091d71d0c6c9c07059b_MD5.png" alt></p><p>在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。</p><p>quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。</p><h2 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h2><p>quicklist 虽然通过控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是并没有完全解决连锁更新的问题。</p><p>因为 quicklistNode 还是用了压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，所以要想彻底解决这个问题，需要设计一个新的数据结构。</p><p>于是，Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p><h3 id="listpack-结构设计"><a href="#listpack-结构设计" class="headerlink" title="listpack 结构设计"></a>listpack 结构设计</h3><p>listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。</p><p>我们先看看 listpack 结构：</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cbd68ba65eb3ade3bf61f6c68acaacac_MD5.png" alt></p><p>listpack 头包含两个属性，分别记录了 listpack 总字节数和元素数量，然后 listpack 末尾也有个结尾标识。图中的 listpack entry 就是 listpack 的节点了。</p><p>每个 listpack 节点结构如下：</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/6014f7281be6c8f9b0b5aa14a9351e91_MD5.png" alt></p><p>主要包含三个方面内容：</p><ul><li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li><li>data，实际存放的数据；</li><li>len，encoding+data 的总长度；</li></ul><p>可以看到，<strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong>。</p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><pre><code class="lang-sql">从左边插入一个或多个数据lpush key_name value1 value2 value3...例子: lpush k1 v1 v2 v3     lrange k1 0 -1  //代表取所有     (1)v3     (2)v2     (3)v1从右边插入一个或多个数据rpush key_name value1 value2 value3...在list的某一值前或后插入数据linsert key_name target_value new_value</code></pre><p>lpush 原理(推箱子):</p><div class="table-container"><table><thead><tr><th>v1</th><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>v2</th><th>v1</th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>v3</th><th>v2</th><th>v1</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>rpush 原理(同理):</p><div class="table-container"><table><thead><tr><th></th><th></th><th>v1</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th></th><th>v1</th><th>v2</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>v1</th><th>v2</th><th>v3</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><h2 id="获取范围内的数据"><a href="#获取范围内的数据" class="headerlink" title="获取范围内的数据"></a>获取范围内的数据</h2><pre><code class="lang-sql">从左边取lrange key_name start_number end_number  // lrange k1 0 -1 代表list中的全部valuelindex key_name index //取list中的某一索引的值llen key_name  //获取list长度</code></pre><h2 id="弹出数据"><a href="#弹出数据" class="headerlink" title="弹出数据"></a>弹出数据</h2><pre><code class="lang-sql">rpop/lpop key_name //字面意思从左边或者右边弹出值rpoppush key1_name key2_name //从key1列表右边吐出一个值,插到key2左边</code></pre><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><pre><code class="lang-sql">lrem key_name n value // 从左边删除n个value</code></pre><h2 id="数据的替换"><a href="#数据的替换" class="headerlink" title="数据的替换"></a>数据的替换</h2><pre><code class="lang-sql">lset key_name index value //将列表下标为index的值替换为value</code></pre><h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合 )"></a>Set(集合 )</h2><p>Set 是 string 类型的无序集合.底层是一个 value 为 null 的 hash 表,所以添加,删除,查找的复杂度都是 o(0),单位是 menmber(成员)</p><p>集合中的值具有唯一性</p><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>Set 的数据结构是 dict 字典,字典是用哈希表实现的</p><p>在<code>Redis7.2</code>之前，当一个集合满足以下两个条件时，Redis 会选择使用<code>intset</code>编码：</p><ul><li>集合对象保存的所有元素都是整数值</li><li>集合对象保存的元素数量小于等于 512 个（默认）</li><li>intset 最大元素数量可在 redis.conf 配置</li></ul><pre><code class="lang-sql">set-max-intset-entries 512</code></pre><p>为什么加入了<a href="#####listpack">listpack</a><br>在<code>redis7.2</code>之前，<a href="######SDS">sds</a>类型的数据会直接放入到编码结构式为<a href="#####Hash(哈希">hashtable</a>&gt;) 的 set 中。其中，<a href="######SDS">sds</a>其实就是 redis 中的 string 类型。</p><p>而在<code>redis7.2</code>之后，<a href="######SDS">sds</a>类型的数据，首先会使用<a href="#####listpack">listpack</a>结构当 set 达到一定的阈值时，才会自动转换为<a href="#####Hash(哈希">hashtable</a>&gt;)。</p><p>添加<a href="#####listpack">listpack</a>结构是为了提高内存利用率和操作效率，因为 <a href="#####Hash(哈希">hashtable</a>&gt;) 的空间开销和碰撞概率都比较高。</p><h3 id="整数集合-intset"><a href="#整数集合-intset" class="headerlink" title="整数集合(intset)"></a>整数集合(intset)</h3><p>整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不时，就会使用整数集这个数据结构作为底层实现。</p><h3 id="整数集合结构设计"><a href="#整数集合结构设计" class="headerlink" title="整数集合结构设计"></a>整数集合结构设计</h3><p>整数集合本质上是一块连续内存空间，它的结构定义如下：</p><pre><code class="lang-c">typedef struct intset &#123;    //编码方式    uint32_t encoding;    //集合包含的元素数量    uint32_t length;    //保存元素的数组    int8_t contents[];&#125; intset;</code></pre><p>可以看到，保存元素的容器是一个 contents 数组，虽然 contents 被声明为 int8_t 类型的数组，但是实际上 contents 数组并不保存任何 int8_t 类型的元素，contents 数组的真正类型取决于 intset 结构体里的 encoding 属性的值。比如：</p><ul><li>如果 encoding 属性值为 INTSET_ENC_INT16，那么 contents 就是一个 int16_t 类型的数组，数组中每一个元素的类型都是 int16_t；</li><li>如果 encoding 属性值为 INTSET_ENC_INT32，那么 contents 就是一个 int32_t 类型的数组，数组中每一个元素的类型都是 int32_t；</li><li>如果 encoding 属性值为 INTSET_ENC_INT64，那么 contents 就是一个 int64_t 类型的数组，数组中每一个元素的类型都是 int64_t；</li></ul><p>不同类型的 contents 数组，意味着数组的大小也会不同。</p><h3 id="整数集合的升级操作"><a href="#整数集合的升级操作" class="headerlink" title="整数集合的升级操作"></a>整数集合的升级操作</h3><p>整数集合会有一个升级规则，就是当我们将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，也就是按新元素的类型（int32_t）扩展 contents 数组的空间大小，然后才能将新元素加入到整数集合里，当然升级的过程中，也要维持整数集合的有序性。</p><p>整数集合升级的过程不会重新分配一个新类型的数组，而是在原本的数组上扩展空间，然后在将每个元素按间隔类型大小分割，如果 encoding 属性值为 INTSET_ENC_INT16，则每个元素的间隔就是 16 位。</p><p>举个例子，假设有一个整数集合里有 3 个类型为 int16_t 的元素。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2a14433f719e4b889e4e56e88ad20a8c_MD5.png" alt></p><p>现在，往这个整数集合中加入一个新元素 65535，这个新元素需要用 int32_t 类型来保存，所以整数集合要进行升级操作，首先需要为 contents 数组扩容，<strong>在原本空间的大小之上再扩容多 80 位（4x32-3x16=80），这样就能保存下 4 个类型为 int32_t 的元素</strong>。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/d7bcbee3cd9694a0f73b4186c4aea753_MD5.png" alt></p><p>扩容完 contents 数组空间大小后，需要将之前的三个元素转换为 int32_t 类型，并将转换后的元素放置到正确的位上面，并且需要维持底层数组的有序性不变，整个转换过程如下：</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5c956d0733797e86a5f3b4d397d3248a_MD5.png" alt></p><blockquote><p>整数集合升级有什么好处呢？</p></blockquote><p>如果要让一个数组同时保存 int16_t、int32_t、int64_t 类型的元素，最简单做法就是直接使用 int64_t 类型的数组。不过这样的话，当如果元素都是 int16_t 类型的，就会造成内存浪费的情况。</p><p>整数集合升级就能避免这种情况，如果一直向整数集合添加 int16_t 类型的元素，那么整数集合的底层实现就一直是用 int16_t 类型的数组，只有在我们要将 int32_t 类型或 int64_t 类型的元素添加到集合时，才会对数组进行升级操作。</p><p>因此，整数集合升级的好处是<strong>节省内存资源</strong>。</p><blockquote><p>整数集合支持降级操作吗？</p></blockquote><p><strong>不支持降级操作</strong>，一旦对数组进行了升级，就会一直保持升级后的状态。比如前面的升级操作的例子，如果删除了 65535 元素，整数集合的数组还是 int32_t 类型的，并不会因此降级为 int16_t 类型。</p><h3 id="添加一个或多个数据"><a href="#添加一个或多个数据" class="headerlink" title="添加一个或多个数据"></a>添加一个或多个数据</h3><pre><code class="lang-sql">sadd key_name value1 value2 value3....</code></pre><h3 id="查看集合中所有的数据"><a href="#查看集合中所有的数据" class="headerlink" title="查看集合中所有的数据"></a>查看集合中所有的数据</h3><pre><code class="lang-sql">smembers key_name</code></pre><h3 id="判断集合中是否有某一个值"><a href="#判断集合中是否有某一个值" class="headerlink" title="判断集合中是否有某一个值"></a>判断集合中是否有某一个值</h3><pre><code class="lang-sql">sismember key_name value</code></pre><h3 id="查询集合元素个数"><a href="#查询集合元素个数" class="headerlink" title="查询集合元素个数"></a>查询集合元素个数</h3><pre><code class="lang-sql">scard key_name</code></pre><h3 id="删除集合中的某一元素"><a href="#删除集合中的某一元素" class="headerlink" title="删除集合中的某一元素"></a>删除集合中的某一元素</h3><pre><code class="lang-sql">srem key_name value1 value2 value3...</code></pre><h3 id="在集合中随机弹值"><a href="#在集合中随机弹值" class="headerlink" title="在集合中随机弹值"></a>在集合中随机弹值</h3><pre><code class="lang-sql">spop key_name</code></pre><h3 id="集合中随机取-n-个值"><a href="#集合中随机取-n-个值" class="headerlink" title="集合中随机取 n 个值"></a>集合中随机取 n 个值</h3><pre><code class="lang-sql">srandmember key_name n</code></pre><h3 id="集合间传值"><a href="#集合间传值" class="headerlink" title="集合间传值"></a>集合间传值</h3><pre><code class="lang-sql">smove key1_name key2_name key1_value //相同的值会忽略,但是还是会删除</code></pre><h3 id="集合间取交集"><a href="#集合间取交集" class="headerlink" title="集合间取交集"></a>集合间取交集</h3><pre><code class="lang-sql">sinter key1_name key2_name</code></pre><h3 id="集合间取并集"><a href="#集合间取并集" class="headerlink" title="集合间取并集"></a>集合间取并集</h3><pre><code class="lang-sql">sunion key1_name key2_name</code></pre><h3 id="集合间取差集"><a href="#集合间取差集" class="headerlink" title="集合间取差集"></a>集合间取差集</h3><pre><code class="lang-sql">sdiif key1_name key2_name //key1中有的,不包含key2中的</code></pre><h2 id="Hash-哈希"><a href="#Hash-哈希" class="headerlink" title="Hash(哈希)"></a>Hash(哈希)</h2><p>哈希表是一种保存键值对（key-value）的数据结构。</p><p>哈希表中的每一个 key 都是独一无二的，程序可以根据 key 查找到与之关联的 value，或者通过 key 来更新 value，又或者根据 key 来删除整个 key-value 等等。</p><p>在讲压缩列表的时候，提到过 Redis 的 Hash 对象的底层实现之一是压缩列表（最新 Redis 代码已将压缩列表替换成 listpack）。Hash 对象的另外一个底层实现就是哈希表。</p><p>哈希表优点在于，它<strong>能以 O(1) 的复杂度快速查询数据</strong>。怎么做到的呢？将 key 通过 Hash 函数的计算，就能定位数据在表中的位置，因为哈希表实际上是数组，所以可以通过索引值快速查询到数据。</p><p>但是存在的风险也是有，在哈希表大小固定的情况下，随着数据不断增多，那么<strong>哈希冲突</strong>的可能性也会越高。</p><p>解决哈希冲突的方式，有很多种。</p><p><strong>Redis 采用了「链式哈希」来解决哈希冲突</strong>，在不扩容哈希表的前提下，将具有相同哈希值的数据串起来，形成链接起，以便这些数据在表中仍然可以被查询到。</p><p>接下来，详细说说哈希表。</p><p><strong><em>Hash</em></strong>  类型对应的数据结构是两种：<em><strong>ziplist</strong></em>（压缩列表），<em><strong>hashtable</strong></em>（哈希表）。</p><p>当  <strong><em>field-value</em></strong>  长度较短且个数较少时，使用  <strong><em>ziplist</em></strong>，否则使用  <strong><em>hashtable</em></strong>。</p><p>hash 是一个 string 类型的 field 和 value 的映射表,hash 特别适合用来储存对象如:</p><div class="table-container"><table><thead><tr><th>key</th><th>value</th><th></th></tr></thead><tbody><tr><td>user</td><td><em>field</em></td><td><em>value</em></td></tr><tr><td></td><td>id</td><td>1</td></tr><tr><td></td><td>name</td><td>张三</td></tr><tr><td></td><td>age</td><td>20</td></tr></tbody></table></div><p>存储格式</p><p>第一种</p><p> key value</p><p> user: {id:1,name:jack,age:20} 修改太麻烦(不推荐)</p><p>第二种</p><p> key value</p><p> user :id 1</p><p> user :name jack</p><p> user :age 20</p><p>第三种 hash</p><p> key value</p><p> field value</p><p> user id 1</p><p>name jack</p><p> age 20</p><h3 id="哈希表结构设计"><a href="#哈希表结构设计" class="headerlink" title="哈希表结构设计"></a>哈希表结构设计</h3><p>Redis 的哈希表结构如下：</p><pre><code class="lang-c">typedef struct dictht &#123;    //哈希表数组    dictEntry **table;    //哈希表大小    unsigned long size;      //哈希表大小掩码，用于计算索引值    unsigned long sizemask;    //该哈希表已有的节点数量    unsigned long used;&#125; dictht;</code></pre><p>可以看到，哈希表是一个数组（dictEntry **table），数组的每个元素是一个指向「哈希表节点（dictEntry）」的指针。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/b4f2f799a8f80d0c6902ce03ecba5e28_MD5.png" alt></p><p>哈希表节点的结构如下：</p><pre><code class="lang-c">typedef struct dictEntry &#123;    //键值对中的键    void *key;    //键值对中的值    union &#123;        void *val;        uint64_t u64;        int64_t s64;        double d;    &#125; v;    //指向下一个哈希表节点，形成链表    struct dictEntry *next;&#125; dictEntry;</code></pre><p>dictEntry 结构里不仅包含指向键和值的指针，还包含了指向下一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对链接起来，以此来解决哈希冲突的问题，这就是链式哈希。</p><p>另外，这里还跟你提一下，dictEntry 结构里键值对中的值是一个「联合体 v」定义的，因此，键值对中的值可以是一个指向实际值的指针，或者是一个无符号的 64 位整数或有符号的 64 位整数或 double 类的值。这么做的好处是可以节省内存空间，因为当「值」是整数或浮点数时，就可以将值的数据内嵌在 dictEntry 结构里，无需再用一个指针指向实际的值，从而节省了内存空间。</p><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>哈希表实际上是一个数组，数组里多每一个元素就是一个哈希桶。</p><p>当一个键值对的键经过 Hash 函数计算后得到哈希值，再将(哈希值 % 哈希表大小)取模计算，得到的结果值就是该 key-value 对应的数组元素位置，也就是第几个哈希桶。</p><blockquote><p>什么是哈希冲突呢？</p></blockquote><p>举个例子，有一个可以存放 8 个哈希桶的哈希表。key1 经过哈希函数计算后，再将「哈希值 % 8 」进行取模计算，结果值为 1，那么就对应哈希桶 1，类似的，key9 和 key10 分别对应哈希桶 1 和桶 6。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/c3755f6a86db3144ddb22682041a6d5a_MD5.png" alt></p><p>此时，key1 和 key9 对应到了相同的哈希桶中，这就发生了哈希冲突。</p><p>因此，<strong>当有两个以上数量的 kay 被分配到了哈希表中同一个哈希桶上时，此时称这些 key 发生了冲突。</strong></p><h3 id="链式哈希"><a href="#链式哈希" class="headerlink" title="链式哈希"></a>链式哈希</h3><p>Redis 采用了「<strong>链式哈希</strong>」的方法来解决哈希冲突。</p><blockquote><p>链式哈希是怎么实现的？</p></blockquote><p>实现的方式就是每个哈希表节点都有一个 next 指针，用于指向下一个哈希表节点，因此多个哈希表节点可以用 next 指针构成一个单项链表，<strong>被分配到同一个哈希桶上的多个节点可以用这个单项链表连接起来</strong>，这样就解决了哈希冲突。</p><p>还是用前面的哈希冲突例子，key1 和 key9 经过哈希计算后，都落在同一个哈希桶，链式哈希的话，key1 就会通过 next 指针指向 key9，形成一个单向链表。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5cacb138848230dad58b68d7db25a3a0_MD5.png" alt></p><p>不过，链式哈希局限性也很明显，随着链表长度的增加，在查询这一位置上的数据的耗时就会增加，毕竟链表的查询的时间复杂度是 O(n)。</p><p>要想解决这一问题，就需要进行 rehash，也就是对哈希表的大小进行扩展。</p><p>接下来，看看 Redis 是如何实现的 rehash 的。</p><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>哈希表结构设计的这一小节，介绍了 Redis 使用 dictht 结构体表示哈希表。不过，在实际使用哈希表时，Redis 定义一个 dict 结构体，这个结构体里定义了<strong>两个哈希表（ht[2]）</strong>。</p><pre><code class="lang-c">typedef struct dict &#123;    …    //两个Hash表，交替使用，用于rehash操作    dictht ht[2];     …&#125; dict;</code></pre><p>之所以定义了 2 个哈希表，是因为进行 rehash 的时候，需要用上 2 个哈希表了。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/c31a25bdb9c38097ef3105cc6203953e_MD5.png" alt></p><p>在正常服务请求阶段，插入的数据，都会写入到「哈希表 1」，此时的「哈希表 2 」 并没有被分配空间。</p><p>随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：</p><ul><li>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；</li><li>将「哈希表 1 」的数据迁移到「哈希表 2」 中；</li><li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。</li></ul><p>为了方便你理解，我把 rehash 这三个过程画在了下面这张图：</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/103eb10e1f3be076c67f652fc629ed1a_MD5.png" alt></p><p>这个过程看起来简单，但是其实第二步很有问题，<strong>如果「哈希表 1 」的数据量非常大，那么在迁移至「哈希表 2 」的时候，因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求</strong>。</p><h3 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h3><p>为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了<strong>渐进式 rehash</strong>，也就是将数据的迁移的工作不再是一次性迁移完成，而是分多次迁移。</p><p>渐进式 rehash 步骤如下：</p><ul><li>给「哈希表 2」 分配空间；</li><li><strong>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上</strong>；</li><li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间嗲呢，会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。</li></ul><p>这样就巧妙地把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中，避免了一次性 rehash 的耗时操作。</p><p>在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。</p><p>比如，查找一个 key 的值的话，先会在「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。</p><p>另外，在渐进式 rehash 进行期间，新增一个 key-value 时，会被保存到「哈希表 2 」里面，而「哈希表 1」 则不再进行任何添加操作，这样保证了「哈希表 1 」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表 1 」就会变成空表。</p><h3 id="rehash-触发条件"><a href="#rehash-触发条件" class="headerlink" title="rehash 触发条件"></a>rehash 触发条件</h3><p>介绍了 rehash 那么多，还没说什么时情况下会触发 rehash 操作呢？</p><p>rehash 的触发条件跟<strong>负载因子（load factor）</strong>有关系。</p><p>负载因子可以通过下面这个公式计算：</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/c61457275db3f8e54e114594d90fcb37_MD5.png" alt></p><p>触发 rehash 操作的条件，主要有两个：</p><ul><li><strong>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。</strong></li><li><strong>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</strong></li></ul><h3 id="存储数据-单个"><a href="#存储数据-单个" class="headerlink" title="存储数据(单个)"></a>存储数据(单个)</h3><pre><code class="lang-sql">hset key_name field_name field_value //给key_name集合中的 field键赋值</code></pre><h3 id="存储数据-多个"><a href="#存储数据-多个" class="headerlink" title="存储数据(多个)"></a>存储数据(多个)</h3><pre><code class="lang-sql">hmset key_name field1_name value1 field2_name value2</code></pre><h3 id="取出数据"><a href="#取出数据" class="headerlink" title="取出数据"></a>取出数据</h3><pre><code class="lang-sql">hget key_name field_name</code></pre><h3 id="取出-key-hash-集合内所有的-field-值"><a href="#取出-key-hash-集合内所有的-field-值" class="headerlink" title="取出 key hash 集合内所有的 field 值"></a>取出 key hash 集合内所有的 field 值</h3><pre><code class="lang-sql">hkeys key_name</code></pre><h3 id="取出-key-hash-集合内所有的-value-值"><a href="#取出-key-hash-集合内所有的-value-值" class="headerlink" title="取出 key hash 集合内所有的 value 值"></a>取出 key hash 集合内所有的 value 值</h3><pre><code class="lang-sql">hvals key_name</code></pre><h3 id="查看-key-中的-field-是否存在"><a href="#查看-key-中的-field-是否存在" class="headerlink" title="查看 key 中的 field 是否存在"></a>查看 key 中的 field 是否存在</h3><pre><code class="lang-sql">hexists key_name field_name</code></pre><h3 id="key-中的-hash-集合中-field-加值"><a href="#key-中的-hash-集合中-field-加值" class="headerlink" title="key 中的 hash 集合中 field 加值"></a>key 中的 hash 集合中 field 加值</h3><pre><code class="lang-sql">hincrby key_name field_name n</code></pre><h3 id="key-中-hash-集合中的-field-值不存在的时候设置一个-field-值"><a href="#key-中-hash-集合中的-field-值不存在的时候设置一个-field-值" class="headerlink" title="key 中 hash 集合中的 field 值不存在的时候设置一个 field 值"></a>key 中 hash 集合中的 field 值不存在的时候设置一个 field 值</h3><pre><code class="lang-sql">hsetnx key_name field_name value</code></pre><h2 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset(有序集合)"></a>Zset(有序集合)</h2><p>Redis 有序集合 zset 与普通合集 set 非常相似,是一个<strong>没有重复元素</strong>的字符串集合</p><p>不同之处在于有序集合中的每一个成员都关联了一个评分,这个评分(score)被用来按照从低到高的方式</p><p>排序集合中的成员,集合的成员是唯一的,但是评分可以是重复的</p><h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>数据结构</strong></p><p><strong><em>SortedSet</em></strong>（<strong><em>zset</em></strong>是  <strong><em>Redis</em></strong>  提供的一个非常特别的数据结构，一方面它等价于  <strong><em>Java</em></strong>  的数据结构  <strong><em>Map<String, double></String,></em></strong>，可以给每一个元素  <strong><em>value</em></strong>  赋予一个权重  <strong><em>score</em></strong>，另一方面它又类似于  <strong><em>TreeSet</em></strong>，内部的元素会按照权重  <strong><em>score</em></strong>  进行排序，可以得到每个元素的名次，还可以通过  <strong><em>score</em></strong>  的范围来获取元素的列表。</p><p><strong><em>zset</em></strong>  底层使用了两个数据结构</p><p>(1) hash(存储成员) field value</p><p> member_name score</p><p>(2)跳跃表(可以快速找到成员),跳跃表的目的<strong>在于给元素  <em>value</em>  排序，根据  <em>score</em>  的范围获取元素列表</strong><br><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1751903-20220127231807136-1683727598.png" alt></p><h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>Redis 只有在 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。</p><p>Zset 对象是唯一一个同时使用了两个数据结构来实现的 Redis 对象，这两个数据结构一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。</p><pre><code class="lang-c">typedef struct zset &#123;    dict *dict;    zskiplist *zsl;&#125; zset;</code></pre><p>Zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了哈希表进行索引。</p><p>接下来，详细的说下跳表。</p><h3 id="跳表结构设计"><a href="#跳表结构设计" class="headerlink" title="跳表结构设计"></a>跳表结构设计</h3><p>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是 O(N)，于是就出现了跳表。<strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>，这样的好处是能快读定位数据。</p><p>那跳表长什么样呢？我这里举个例子，下图展示了一个层级为 3 的跳表。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/f8033bbd89b988d3588c4567089c0ac2_MD5.png" alt></p><p>图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：</p><ul><li>L0 层级共有 5 个节点，分别是节点 1、2、3、4、5；</li><li>L1 层级共有 3 个节点，分别是节点 2、3、5；</li><li>L2 层级只有 1 个节点，也就是节点 3 。</li></ul><p>如果我们要在链表中查找节点 4 这个元素，只能从头开始遍历链表，需要查找 4 次，而使用了跳表后，只需要查找 2 次就能定位到节点 4，因为可以在头节点直接从 L2 层级跳到节点 3，然后再往前遍历找到节点 4。</p><p>可以看到，这个查找过程就是在多个层级上跳来跳去，最后定位到元素。当数据量很大时，跳表的查找复杂度就是 O(logN)。</p><p>那跳表节点是怎么实现多层级的呢？这就需要看「跳表节点」的数据结构了，如下：</p><pre><code class="lang-c">typedef struct zskiplistNode &#123;    //Zset 对象的元素值    sds ele;    //元素权重值    double score;    //后向指针    struct zskiplistNode *backward;    //节点的level数组，保存每层上的前向指针和跨度    struct zskiplistLevel &#123;        struct zskiplistNode *forward;        unsigned long span;    &#125; level[];&#125; zskiplistNode;</code></pre><p>Zset 对象要同时保存元素和元素的权重，对应到跳表节点结构里就是 sds 类型的 ele 变量和 double 类型的 score 变量。每个跳表节点都有一个后向指针，指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。</p><p>跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的<strong>zskiplistLevel 结构体类型的 level 数组</strong>。</p><p>level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel 结构体表示，比如 leve[0] 就表示第一层，leve[1] 就表示第二层。zskiplistLevel 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离。</p><p>比如，下面这张图，展示了各个节点的跨度。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/198958b60ad0ccafb11e375957f696d0_MD5.png" alt></p><p>第一眼看到跨度的时候，以为是遍历操作有关，实际上并没有任何关系，遍历操作只需要用前向指针就可以完成了。</p><p><strong>跨度实际上是为了计算这个节点在跳表中的排位</strong>。具体怎么做的呢？因为跳表中的节点都是按序排列的，那么计算某个节点排位的时候，从头节点点到该结点的查询路径上，将沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排位。</p><p>举个例子，查找图中节点 3 在跳表中的排位，从头节点开始查找节点 3，查找的过程只经过了一个层（L3），并且层的跨度是 3，所以节点 3 在跳表中的排位是 3。</p><p>另外，图中的头节点其实也是 zskiplistNode 跳表节点，只不过头节点的后向指针、权重、元素值都会被用到，所以图中省略了这部分。</p><p>问题来了，由谁定义哪个跳表节点是头节点呢？这就介绍「跳表」结构体了，如下所示：</p><pre><code class="lang-c">typedef struct zskiplist &#123;    struct zskiplistNode *header, *tail;    unsigned long length;    int level;&#125; zskiplist;</code></pre><p>跳表结构里包含了：</p><ul><li>跳表的头尾节点，便于在 O(1)时间复杂度内访问跳表的头节点和尾节点；</li><li>跳表的长度，便于在 O(1)时间复杂度获取跳表节点的数量；</li><li>跳表的最大层数，便于在 O(1)时间复杂度获取跳表中层高最大的那个节点的层数量；</li></ul><h3 id="跳表节点查询过程"><a href="#跳表节点查询过程" class="headerlink" title="跳表节点查询过程"></a>跳表节点查询过程</h3><p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p><ul><li>如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</li><li>如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li></ul><p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。</p><p>举个例子，下图有个 3 层级的跳表。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/a1a86db7c8e46e0c337748a89751d172_MD5.png" alt></p><p>如果要查找「元素：abcd，权重：4」的节点，查找的过程是这样的：</p><ul><li>先从头节点的最高层开始，L2 指向了「元素：abc，权重：3」节点，这个节点的权重比要查找节点的小，所以要访问该层上的下一个节点；</li><li>但是该层上的下一个节点是空节点，于是就会跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[1];</li><li>「元素：abc，权重：3」节点的 leve[1] 的下一个指针指向了「元素：abcde，权重：4」的节点，然后将其和要查找的节点比较。虽然「元素：abcde，权重：4」的节点的权重和要查找的权重相同，但是当前节点的 SDS 类型数据「大于」要查找的数据，所以会继续跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[0]；</li><li>「元素：abc，权重：3」节点的 leve[0] 的下一个指针指向了「元素：abcd，权重：4」的节点，该节点正是要查找的节点，查询结束。</li></ul><h3 id="跳表节点层数设置"><a href="#跳表节点层数设置" class="headerlink" title="跳表节点层数设置"></a>跳表节点层数设置</h3><p>跳表的相邻两层的节点数量的比例会影响跳表的查询性能。</p><p>举个例子，下图的跳表，第二层的节点数量只有 1 个，而第一层的节点数量有 6 个。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/a5f8dc48cd6085bd9b4347740f823bb0_MD5.png" alt></p><p>这时，如果想要查询节点 6，那基本就跟链表的查询复杂度一样，就需要在第一层的节点中依次顺序查找，复杂度就是 O(N) 了。所以，为了降低查询复杂度，我们就需要维持相邻层结点数间的关系。</p><p><strong>跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)</strong>。</p><p>下图的跳表就是，相邻两层的节点数量的比例是 2 : 1。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/f1e5782db076bdb2322e7d7999a19e1a_MD5.png" alt></p><blockquote><p>那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？</p></blockquote><p>如果采用新增节点或者删除节点时，来调整跳表节点以维持比例的方法的话，会带来额外的开销。</p><p>Redis 则采用一种巧妙的方法是，<strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。</p><p>具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</p><p>这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。</p><h3 id="添加一个或多个成员"><a href="#添加一个或多个成员" class="headerlink" title="添加一个或多个成员"></a>添加一个或多个成员</h3><pre><code class="lang-sql">zadd key_name score1 value1 score2 value2 score3 value3... //score(评分)</code></pre><h3 id="输出范围中的值"><a href="#输出范围中的值" class="headerlink" title="输出范围中的值"></a>输出范围中的值</h3><pre><code class="lang-sql">zrange key_name start_index end_index [withscores] // 0 -1代表输出所有的值//输出下标在start_index和end_index之间的元素,添加withscores则会将评分(score)一起输出zrangebyscore key_name min_score max_score [withscore] [limit offset count]//返回有序集合key中,所有score值介于min和max之间的(包括min或max)成员//有序集合按score值从小到大的次序排列zrevrangescore key_name min_score max_score [withscore] [limit offset count]//返回有序集合key中,所有score值介于min和max之间的(包括min或max)成员//有序集合按score值大到小 的次序排列</code></pre><h3 id="增加成员的值"><a href="#增加成员的值" class="headerlink" title="增加成员的值"></a>增加成员的值</h3><pre><code class="lang-sql">zincrby key_name incre_number member_name</code></pre><h3 id="删除成员"><a href="#删除成员" class="headerlink" title="删除成员"></a>删除成员</h3><pre><code class="lang-sql">zrem key_name member_name</code></pre><h3 id="统计评分区间的成员个数"><a href="#统计评分区间的成员个数" class="headerlink" title="统计评分区间的成员个数"></a>统计评分区间的成员个数</h3><pre><code class="lang-sql">zcount key_name min_score max_score</code></pre><h3 id="查看成员在集合中的排名"><a href="#查看成员在集合中的排名" class="headerlink" title="查看成员在集合中的排名"></a>查看成员在集合中的排名</h3><pre><code class="lang-sql">zrank key_name member_name //返回索引(索引从0开始)</code></pre><h1 id="Redis6-新数据类型"><a href="#Redis6-新数据类型" class="headerlink" title="Redis6 新数据类型"></a>Redis6 新数据类型</h1><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1751903-20220130095125761-652530924.png" alt></p><ul><li>将 Bitmaps 数据类型理解为一个数组，每个单位只存储 0 和 1<br>实例：<br><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1751903-20220130095603624-864852729.png" alt></li><li>getbit ：获取 Bitmaps 中某个偏移量的值</li><li>bitcount [start end]：统计字符串被设置为 1 的 bit 数，start end 可以指定范围，且可以使用负数值，例如：-1 表示最后一个位，-2 表示倒数第二个位置（从 0 开始….）</li><li><p>bitop and(or/not/xor) [key…]：复合操作，可以做多个 Bitmaps 的交集、并集等操作，并将结果保存在 destkey 中</p><ul><li>例如：bitop and users:1 users:2 users:3，将 users:2 与 users:3 的交集结果存放到 key 为 users:1 的值中</li></ul></li></ul><p><strong>Bitmaps 与 set 对比</strong><br><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1751903-20220130101108367-1370827612.png" alt><br><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1751903-20220130101116294-825337259.png" alt><br><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1751903-20220130101123120-819954855.png" alt></p><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>[<img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5d72247a2259e41f5c7b5000b203df22_MD5.png" alt="2022-01-30_101307"><br><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4665c8c889132a944c9e552419c10c75_MD5.png" alt><br><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3a14c3695b247825efbc61954ae8f048_MD5.png" alt="-01-30_101721"></p><ol><li><p>pfadd [element…]：添加指定元素到 HyperLogLog 中，执行命令后，若基数发生变化则返回 1，否则返回 0</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ab32d9ad182ae8aa27e1fd95c0070351_MD5.png" alt="2022-01-30_102109"><br>count [key…]：计算基数值</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/526441d1074ee64c61549efeb303ff66_MD5.png" alt="2022-01-30_102558"><br>merge [其中，sourcekey 可以为多个]：将多个 HyperLogLog 数据类型进行合并，例子比如将月活跃用户数与日活跃用户数进行合并，就可以使用 pfcount 进行统计基数</p></li></ol><h2 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h2><p>[<img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/adcda2a55b7d2013053157499944d00a_MD5.png" alt="2022-01-30_102917"><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4e4ffaf733e4c7f4bd3c3e82cb8d8b16_MD5.png" alt="-01-30_103044"><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/c481d01aa47652b799d3c2dc1da63425_MD5.png" alt="-01-30_103806"><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7ceb5d248ae5038da441c97bdc813bcd_MD5.png" alt="-01-30_103854"><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/def9bb17bc13a23053fc5db4544e9aa9_MD5.png" alt="-01-30_104205"></p><h1 id="Redis-的配置文件"><a href="#Redis-的配置文件" class="headerlink" title="Redis 的配置文件"></a>Redis 的配置文件</h1><p>只支持 bytes 不支持 bit</p><h2 id="NETWORK"><a href="#NETWORK" class="headerlink" title="NETWORK"></a>NETWORK</h2><h3 id="修改配置以网络连接-默认只能本地连接"><a href="#修改配置以网络连接-默认只能本地连接" class="headerlink" title="修改配置以网络连接(默认只能本地连接)"></a>修改配置以网络连接(默认只能本地连接)</h3><pre><code class="lang-sql">bind 127.0.0.1 -::1 (默认本地连接)// 用#号注释掉即可允许远程连接protected-mode yes //保护模式(只允许本机连接) 将yes改为no即可支持远程访问</code></pre><h3 id="Port"><a href="#Port" class="headerlink" title="Port"></a>Port</h3><p>默认 6379</p><h3 id="tcp-backlog"><a href="#tcp-backlog" class="headerlink" title="tcp-backlog"></a>tcp-backlog</h3><p><em>默认值 511</em></p><p><em>backlog 其实是一个连接队列,backlog 队列的总和=未完成三次握手队列+已完成三次握手的队列</em></p><p><em>高并发环境下需要一个高 backlog 来避免慢客户端的连接问题</em></p><pre><code class="lang-sql">tcp-backlog 511</code></pre><h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><pre><code class="lang-sql">timeout 0 //客户端未操作指定时间后断开连接 默认值为0(永不过期) 单位为秒</code></pre><h3 id="tcp-keepalive"><a href="#tcp-keepalive" class="headerlink" title="tcp-keepalive"></a>tcp-keepalive</h3><p>检测客户端的 tcp 是否活着(操作) 默认每 300 秒检查一次</p><pre><code class="lang-sql">tcp-keepalive 300</code></pre><h2 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a>GENERAL</h2><h3 id="允许后台启动-默认为-no"><a href="#允许后台启动-默认为-no" class="headerlink" title="允许后台启动(默认为 no)"></a>允许后台启动(默认为 no)</h3><pre><code class="lang-sql">daemonize yes</code></pre><h2 id="Limits"><a href="#Limits" class="headerlink" title="Limits"></a>Limits</h2><h3 id="设置最大的客户端连接数"><a href="#设置最大的客户端连接数" class="headerlink" title="设置最大的客户端连接数"></a>设置最大的客户端连接数</h3><pre><code class="lang-sql">maxclients 10000 //默认最大连接数10000</code></pre><h3 id="设置最大的内存占用量"><a href="#设置最大的内存占用量" class="headerlink" title="设置最大的内存占用量"></a>设置最大的内存占用量</h3><pre><code class="lang-sql">maxmemory &lt;bytes&gt;   //达到最大的内存占用数后根据maxmemory-policy规则进行操作</code></pre><h3 id="设置最大内存占用规则"><a href="#设置最大内存占用规则" class="headerlink" title="设置最大内存占用规则"></a>设置最大内存占用规则</h3><pre><code class="lang-sql">maxmemory-policy</code></pre><h1 id="Redis-发布和订阅"><a href="#Redis-发布和订阅" class="headerlink" title="Redis 发布和订阅"></a>Redis 发布和订阅</h1><p><strong><em>Redis</em></strong>  发布订阅（ <strong><em>pub/sub</em></strong> ）是一种消息通信模式：发送者（ <strong><em>pub</em></strong> ）发送消息，订阅者（ <strong><em>sub</em></strong> ）接收消息。</p><p><strong><em>Redis</em></strong>  客户端可以订阅任意数量的频道。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/24841c0e421a088d18108f59d08b3bb7_MD5.png" alt="2022-01-30_094007"><br>可以建立许多个频道进行消息的发送（如上图频道 1、频道 2、频道 3），供订阅者进行接收和监听消息。</p><ol><li>客户端可以订阅频道</li></ol><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/b194767a5f6cabe32724636d689a1bf8_MD5.png" alt></p><ol><li>当给这个频道发布消息后，消息就会发送给订阅的客户端</li></ol><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/d759a0c1f90b29e573c5e0dd944c37b4_MD5.png" alt></p><p><strong>发布订阅命令行实现</strong></p><ol><li>打开一个客户端订阅 channel1</li></ol><ul><li>subscribe channel1</li></ul><ol><li>打开另一个客户端，给 channel1 发布消息 hello</li></ol><ul><li><p>publish channel1 hello</p></li><li><p>返回的数字表示：订阅者的数量、</p></li></ul><ol><li>打开第一个客户端可以看到发送的信息</li></ol><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/5a97d7ca234dc4d8392be731113fcd6a_MD5.png" alt="2022-01-30_094743"><br>发布的消息如果没有持久化，那么在订阅的客户端是接收不到消息的，只能收到订阅后发布的消息</p><h2 id="订阅频道"><a href="#订阅频道" class="headerlink" title="订阅频道"></a>订阅频道</h2><pre><code class="lang-sql">SUBSCRIBE channel_name //   返回值为订阅人数</code></pre><h2 id="向频道发送信息"><a href="#向频道发送信息" class="headerlink" title="向频道发送信息"></a>向频道发送信息</h2><pre><code class="lang-sql">publish channel_name message</code></pre><h1 id="Redis6-新数据类型-1"><a href="#Redis6-新数据类型-1" class="headerlink" title="Redis6 新数据类型"></a>Redis6 新数据类型</h1><h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>Bitmap 本身不是一种数据类型,它实际上就是字符串(key-value)</p><p>但是它可以对字符串进行位操作</p><h1 id="通过-jedis-操作-Redis"><a href="#通过-jedis-操作-Redis" class="headerlink" title="通过 jedis 操作 Redis"></a>通过 jedis 操作 Redis</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ol><li>依赖</li></ol><pre><code class="lang-xml">&lt;dependency&gt;  &lt;groupId&gt;redis.clients&lt;/groupId&gt;  &lt;artifactId&gt;jedis&lt;/artifactId&gt;  &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol><li>连接 <strong><em>Redis</em></strong></li></ol><pre><code class="lang-java">public class JedisDemo &#123;  public static void main(String[] args) &#123;    // 创建Jedis对象    Jedis jedis = new Jedis(&quot;192.168.xx.xxx&quot;, 6379);    // 测试，能够连接上的话，ping通，会返回一个值    String ping = jedis.ping();    System.out.println(&quot;连接成功：&quot; + ping);    jedis.close();  &#125;&#125;</code></pre><p>注意：使用 Jedis 进行操作，需要对 Redis 的网络相关配置文件进行修改：</p><ul><li><strong>bind：</strong>默认是 bind 绑定本机，不进行修改的情况下，只能接受本机的访问请求，<strong>不写的情况下，能够无限制接受任何 ip 地址的访问。</strong></li><li><strong>protected-mode：将本机访问保护模式设置为 no</strong></li></ul><p>如果出现 <strong>connet timed out</strong> 错误，检查两块，第一是否配置文件进行了修改，第二防火墙是否关闭。</p><p><strong><em>key</em></strong></p><pre><code class="lang-java">jedis.set(&quot;k1&quot;, &quot;v1&quot;); jedis.set(&quot;k2&quot;, &quot;v2&quot;);jedis.set(&quot;k3&quot;, &quot;v3&quot;); Set&lt;String&gt; keys = jedis.keys(&quot;*&quot;); // 返回所有keySystem.out.println(keys.size());System.out.println(key);&#125;System.out.println(jedis.exists(&quot;k1&quot;)); // 是否存在System.out.println(jedis.ttl(&quot;k1&quot;)); // 过期时间System.out.println(jedis.get(&quot;k1&quot;)); // 获取key对应value值</code></pre><p><strong><em>String</em></strong></p><pre><code class="lang-java"> jedis.mset(&quot;str1&quot;,&quot;v1&quot;,&quot;str2&quot;,&quot;v2&quot;,&quot;str3&quot;,&quot;v3&quot;); System.out.println(jedis.mget(&quot;str1&quot;,&quot;str2&quot;,&quot;str3&quot;));</code></pre><p><strong><em>List</em></strong></p><pre><code class="lang-java">// 可以使用lpush或者rpush添加k-vList&lt;String&gt; list = jedis.lrange(&quot;mylist&quot;,0,-1);for (String element : list) &#123;    System.out.println(element);&#125;</code></pre><p><strong><em>Set</em></strong></p><pre><code class="lang-java">jedis.sadd(&quot;orders&quot;, &quot;order01&quot;);jedis.sadd(&quot;orders&quot;, &quot;order02&quot;);jedis.sadd(&quot;orders&quot;, &quot;order03&quot;);jedis.sadd(&quot;orders&quot;, &quot;order04&quot;);Set&lt;String&gt; smembers = jedis.smembers(&quot;orders&quot;);for (String order : smembers) &#123;    System.out.println(order);&#125;jedis.srem(&quot;orders&quot;, &quot;order02&quot;);</code></pre><p><strong><em>Hash</em></strong></p><pre><code class="lang-java">jedis.hset(&quot;hash1&quot;,&quot;userName&quot;,&quot;lisi&quot;);System.out.println(jedis.hget(&quot;hash1&quot;,&quot;userName&quot;));Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();map.put(&quot;telphone&quot;,&quot;13810169999&quot;);map.put(&quot;address&quot;,&quot;atguigu&quot;);map.put(&quot;email&quot;,&quot;abc@163.com&quot;);jedis.hmset(&quot;hash2&quot;,map);List&lt;String&gt; result = jedis.hmget(&quot;hash2&quot;, &quot;telphone&quot;,&quot;email&quot;);for (String element : result) &#123;    System.out.println(element);&#125;</code></pre><p><strong><em>zset</em></strong></p><pre><code class="lang-java">jedis.zadd(&quot;zset01&quot;, 100d, &quot;z3&quot;);jedis.zadd(&quot;zset01&quot;, 90d, &quot;l4&quot;);jedis.zadd(&quot;zset01&quot;, 80d, &quot;w5&quot;);jedis.zadd(&quot;zset01&quot;, 70d, &quot;z6&quot;);Set&lt;String&gt; zrange = jedis.zrange(&quot;zset01&quot;, 0, -1);for (String e : zrange) &#123;    System.out.println(e);&#125;</code></pre><h2 id="模拟验证码发送"><a href="#模拟验证码发送" class="headerlink" title="模拟验证码发送"></a>模拟验证码发送</h2><p>[<img src="images/Redis6.0学习笔记/9f8e2266b7c02f2f0d31021d8f7f4d07_MD5.png" alt="2022-01-30_113532"></p><pre><code class="lang-java">public class PhoneCode &#123;    public static void main(String[] args) &#123;        // 模拟验证码发送//        verifyCode(&quot;123456789&quot;);        getRedisCode(&quot;123456789&quot;, &quot;123456&quot;);    &#125;    // 1. 生成6位数字验证码    public static String getCode()&#123;        Random random = new Random();        String code = &quot;&quot;;        for (int i = 0; i &lt; 6; i++) &#123;            int nextInt = random.nextInt(10);            code += nextInt;        &#125;        return code;    &#125;    // 2. 每个手机每天只能发送三次验证码请求，验证码放到redis中，并设置过期时间    public static void verifyCode(String phone) &#123;        // 连接redis        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);        // 拼接key        // 手机发送次数的key        String countKey = &quot;VerifyCode-&quot; + phone + &quot;:count&quot;;        // 验证码的key        String phoneKey = &quot;VerifyCode-&quot; + phone + &quot;:code&quot;;        // 每个手机每天只能发送三次验证码        String count = jedis.get(countKey);        if(count == null) &#123;            // 之前还没发送过，这次是第一次发送，设置发送次数为1            jedis.setex(countKey, 24*60*60, &quot;1&quot;); // 设置过期时间为一天        &#125; else if (Integer.parseInt(count) &lt; 3) &#123;            // 发送次数加1            jedis.incr(countKey);        &#125; else if (Integer.parseInt(count) &gt;= 3) &#123;            // 发送已经有三次了，不能再发送了            System.out.println(&quot;今天发送验证码的次数已经达到三次，无法再发送！&quot;);            jedis.close(); // 关闭连接            return; // 不执行下面的代码        &#125;        // 验证码放到redis中        String code1 = getCode();        jedis.setex(phoneKey, 120, code1); // 设置验证码的过期时间为两分钟，会进行覆盖        jedis.close();    &#125;    // 3. 验证码校验    public static void getRedisCode(String phone, String code)&#123;        // 连接redis        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);        // 拼接key        // 验证码的key        String phoneKey = &quot;VerifyCode-&quot; + phone + &quot;:code&quot;;        // 判断        String codePhone = jedis.get(phoneKey);        if(codePhone.equals(code)) &#123;            System.out.println(&quot;成功！&quot;);        &#125; else &#123;            System.out.println(&quot;失败！&quot;);        &#125;        jedis.close();    &#125;&#125;</code></pre><h2 id="Jedis-主从复制"><a href="#Jedis-主从复制" class="headerlink" title="Jedis 主从复制"></a><em>Jedis</em> 主从复制</h2><pre><code class="lang-java">private static JedisSentinelPool jedisSentinelPool=null;public static  Jedis getJedisFromSentinel()&#123;  if(jedisSentinelPool==null)&#123;    Set&lt;String&gt; sentinelSet=new HashSet&lt;&gt;();    sentinelSet.add(&quot;172.16.88.168:26379&quot;); // 端口为sentinal    JedisPoolConfig jedisPoolConfig =new JedisPoolConfig();    jedisPoolConfig.setMaxTotal(10); // 最大可用连接数    jedisPoolConfig.setMaxIdle(5); // 最大闲置连接数    jedisPoolConfig.setMinIdle(5); // 最小闲置连接数    jedisPoolConfig.setBlockWhenExhausted(true); // 连接耗尽是否等待    jedisPoolConfig.setMaxWaitMillis(2000); // 等待时间    jedisPoolConfig.setTestOnBorrow(true); // 取连接的时候进行测试    jedisSentinelPool=new JedisSentinelPool(&quot;mymaster&quot;,sentinelSet,jedisPoolConfig); // 服务主机名    return jedisSentinelPool.getResource();  &#125;  else &#123;    return jedisSentinelPool.getResource();  &#125;&#125;</code></pre><h2 id="集群的-Jedis-开发"><a href="#集群的-Jedis-开发" class="headerlink" title="集群的 Jedis 开发"></a>集群的 <em>Jedis</em> 开发</h2><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。</p><p>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p><pre><code class="lang-java">public class JedisClusterTest &#123;  public static void main(String[] args) &#123;     // 创建对象     Set&lt;HostAndPort&gt; set = new HashSet&lt;HostAndPort&gt;();     set.add(new HostAndPort(&quot;172.16.xx.xxx&quot;,6379)); // 任何一个端口     JedisCluster jedisCluster = new JedisCluster(set);     // 操作     jedisCluster.set(&quot;k1&quot;, &quot;v1&quot;);     System.out.println(jedisCluster.get(&quot;k1&quot;));     jedisCluster.close();  &#125;&#125;</code></pre><h2 id="SpringBoot-整合-Redis"><a href="#SpringBoot-整合-Redis" class="headerlink" title="SpringBoot 整合 Redis"></a>SpringBoot 整合 Redis</h2><ol><li>依赖</li></ol><pre><code class="lang-xml">&lt;!-- redis --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 连接池：spring2.X集成redis所需common-pool2--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;  &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;  &lt;version&gt;2.6.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol><li>配置文件配置 <strong><em>Redis</em></strong></li></ol><pre><code class="lang-properties">#Redis服务器地址spring.redis.host= ip地址#Redis服务器连接端口spring.redis.port=6379#Redis数据库索引（默认为0，一共有16个）spring.redis.database= 0#连接超时时间（毫秒）spring.redis.timeout=1800000#连接池最大连接数（使用负值表示没有限制）spring.redis.lettuce.pool.max-active=20#最大阻塞等待时间(负数表示没限制)spring.redis.lettuce.pool.max-wait=-1#连接池中的最大空闲连接spring.redis.lettuce.pool.max-idle=5#连接池中的最小空闲连接spring.redis.lettuce.pool.min-idle=0</code></pre><ol><li><strong><em>Redis</em></strong> 配置类（需要继承 <strong><em>CachingConfigurerSupport</em></strong>）</li></ol><pre><code class="lang-java">@EnableCaching@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        template.setConnectionFactory(factory);                // key序列化方式        template.setKeySerializer(redisSerializer);                // value序列化        template.setValueSerializer(jackson2JsonRedisSerializer);                // value hashmap序列化        template.setHashValueSerializer(jackson2JsonRedisSerializer);        return template;    &#125;    @Bean    public CacheManager cacheManager(RedisConnectionFactory factory) &#123;        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);                // 解决查询缓存转换异常的问题        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);                // 配置序列化（解决乱码的问题）,过期时间600秒        RedisCacheConfiguration config =          RedisCacheConfiguration.defaultCacheConfig()                .entryTtl(Duration.ofSeconds(600))      .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))                .disableCachingNullValues();        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)                .cacheDefaults(config)                .build();        return cacheManager;    &#125;&#125;</code></pre><ol><li>测试</li></ol><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/864a35245816e530fcd957a9a322e1b7_MD5.png" alt="2022-01-30_122709"></p><h1 id="Redis-中的事务操作"><a href="#Redis-中的事务操作" class="headerlink" title="Redis 中的事务操作"></a>Redis 中的事务操作</h1><h2 id="Multi、Exec、discard"><a href="#Multi、Exec、discard" class="headerlink" title="Multi、Exec、discard"></a>Multi、Exec、discard</h2><p>从输入 Multi 命令开始,输入的命令一次进入命令队列,但不会执行,知道输入 Exec 后,Redis 会将之前的命令队列中的命令依次执行</p><p>组队的时候可以通过 discard 来放弃组队</p><pre><code class="lang-sql">--redis客户端127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt;set key1 value1QUEUED127.0.0.1:6379(TX)&gt;set key2 value2QUEUED127.0.0.1:6379(TX)&gt;exec1) OK2) OK127.0.0.1:6379&gt;127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt;set key1 value1QUEUED127.0.0.1:6379(TX)&gt;set key2 value2QUEUED127.0.0.1:6379(TX)&gt;discardOK127.0.0.1:6379&gt;</code></pre><h2 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h2><h3 id="提交错误"><a href="#提交错误" class="headerlink" title="提交错误"></a>提交错误</h3><p>使用 exec 语句提交时,命令队列无法执行</p><pre><code class="lang-sql">--redis客户端127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt;set key1 value1QUEUED127.0.0.1:6379(TX)&gt;set key2 //语句有语法错误(error) ERR wrong number of arguments for &#39;set&#39; command127.0.0.1:6379(TX)&gt;exec(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt;</code></pre><h3 id="执行错误"><a href="#执行错误" class="headerlink" title="执行错误"></a>执行错误</h3><p>能正确执行 exec 提交,但是命令队列中错误的语句报错</p><pre><code class="lang-sql">--redis客户端127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt;set key1 value1QUEUED127.0.0.1:6379(TX)&gt;incr key1 //此时语句语法正确 但是逻辑不正确QUEUED127.0.0.1:6379(TX)&gt;set key2 value2QUEUED127.0.0.1:6379(TX)&gt;exec1) OK2) (erro)ERR value is not an integer or out of range3) OK127.0.0.1:6379&gt;</code></pre><h2 id="事务冲突问题"><a href="#事务冲突问题" class="headerlink" title="事务冲突问题"></a>事务冲突问题</h2><h3 id="悲观-🔒"><a href="#悲观-🔒" class="headerlink" title="悲观 🔒"></a>悲观 🔒</h3><p>每次拿数据的时候都认为其他事务会修改数据,所以每次拿数据的时候都会上 🔒</p><p>这样别的事务想拿这个数据就会被 block(阻塞)直到它拿到 🔒</p><p>乐观 🔒</p><p>在数据上添加版本号,当有事务对数据成功进行更新后同步更新版本号,同时间在进行的事务会将开始事务时</p><p>获得的版本号与现在的版本号进行对比,若版本号更新则更新数据后再进行事务的操作</p><p>在执行 multi 之前,先执行 watch 指令 ,可以监视一个(或多个)key,如果在事务执行之前这个(或这些)key 被其他命令所改动</p><p>那么事务将会被打断(返回 nil)</p><pre><code class="lang-sql">watch key1 [key2]</code></pre><h2 id="事务的三特性"><a href="#事务的三特性" class="headerlink" title="事务的三特性"></a>事务的三特性</h2><h3 id="单独隔离操作"><a href="#单独隔离操作" class="headerlink" title="单独隔离操作"></a>单独隔离操作</h3><p> 事务中的所有命令都会序列化、按顺序的执行.事务在执行的过程中,不会</p><p> 被其他客户端发送来的命令请求所打断</p><h3 id="没有隔离级别"><a href="#没有隔离级别" class="headerlink" title="没有隔离级别"></a>没有隔离级别</h3><p> 队列中的命令么有提交之前都不会实际被执行,因为事务提交前任何指令都</p><p> 不会被实际执行</p><h3 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h3><p> 事务中有一条命令执行失败,其后命令仍然会被执行,没有回滚</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h3><p>ab 模拟测试</p><p>安装:</p><pre><code class="lang-sql">yum install httpd-tools</code></pre><h3 id="通过浏览器测试"><a href="#通过浏览器测试" class="headerlink" title="通过浏览器测试"></a>通过浏览器测试</h3><pre><code class="lang-sql">ab -n 1000 -c 100 -p ~/postfile -T application/x-www-form-urlencoded http://192.168.137.1:8080/seckill/doseckil//ab -n 1000 -c 100 代表1000个请求中有100个是并发操作//-p ~/postfile 代表此目录下的postfile文件// -p的意思是提交类型为POST ,-T的意思是 content-type的类型//http://192.168.137.1:8080/seckill 本地的cotroller方法的路径</code></pre><h3 id="并发出现的问题"><a href="#并发出现的问题" class="headerlink" title="并发出现的问题"></a>并发出现的问题</h3><pre><code class="lang-java">出现秒杀后商品存量为负值(超买超卖)--乐观锁解决//监视库存jedis.watch(kcKey)//使用事务Transaction multi = jedis.multi();//组队操作multi.decr(kcKey) //kcKey 库存keymulti.sadd(userKey,uid) //秒杀成功的用户uid并发量太大出现连接超时问题--使用jedis连接池解决库存遗留问题(秒杀结束,但是商品未被抢完)LUA脚本将复杂的或者多步的redis操作,写为一个脚本,一次提交给redis执行,减少反复连接redis的次数,性能利用LUA脚本淘汰用户,解决超卖问题(实际上是redis利用其单线程的特性,用任务队列的方式解决多任务并发问题)</code></pre><h1 id="Redis-中的持久化操作"><a href="#Redis-中的持久化操作" class="headerlink" title="Redis 中的持久化操作"></a>Redis 中的持久化操作</h1><p>Redis 会单独创建(fork)一个子进程来进行持久化,会先将数据写入到一个临时文件中</p><p>待持久化过程结束了,再用这个临时文件取替换上次持久化好的文件.整个过程中,主进程</p><p>是不进行任何 IO 操作的,这就确保了极高的性能,如果需要进行大规模数据的恢复,且对数据恢复</p><p>完整性并不是很敏感,那 RDB 方式要比 AOF 方式更加高效.RDB 的缺点是最后一次持久化后</p><p>数据可能会丢失</p><h2 id="dump-rdb"><a href="#dump-rdb" class="headerlink" title="dump.rdb"></a>dump.rdb</h2><p>在 redis.conf 中的配置文件,默认为 dump.rdb</p><pre><code class="lang-properties">dbfilename dump.rdb</code></pre><p>在指定目录生成 rdb 文件(默认在启动目录生成文件)</p><pre><code class="lang-properties">dir ./</code></pre><p>save<br>表示写操作的次数。</p><pre><code class="lang-properties">save time num //在time时间(秒)内至少有num个key被改变时执行数据持久化操作</code></pre><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/98baf70787c7bb0cf81b07b0d0ff3859_MD5.png" alt></p><p>redis 无法写入硬盘时停止写入(默认 no)</p><pre><code class="lang-properties">stop-writes-on-bgsave-error yes</code></pre><p>对存入到磁盘中的快照是否进行压缩</p><pre><code class="lang-properties">rdbcompression yes //使用LZF算法进行压缩 但是会消耗CPU性能</code></pre><p>检查快照完整性</p><pre><code class="lang-properties">rdbchecksum yes //开启会有大概10%的数据损耗</code></pre><h2 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h2><p>在指定时间间隔内将内存中的数据集快照写入磁盘</p><h2 id="AOF-Append-only-File"><a href="#AOF-Append-only-File" class="headerlink" title="AOF(Append only File)"></a>AOF(Append only File)</h2><p><strong>以日志的形式来记录每个写操作（增量保存）</strong>，将  <strong><em>Redis</em></strong>  执行过的<strong>所有写指令记录下来（读操作不记录）</strong>， <strong>只许追加文件但不可以改写文件</strong>（可能是使用的 redo 和 undo 日志恢复？）。<strong><em>Redis</em></strong>  启动之初会读取该文件重新构建数据，换言之，如果  <strong><em>Redis</em></strong>  重启就会<strong>根据日志文件的内容</strong>将写指令从前到后执行一次，以完成数据的恢复工作。</p><p><strong>一种使用追加方式记录数据的方法</strong></p><p><strong>执行流程</strong></p><ul><li><p>客户端的请求写命令会被  <strong><em>append</em></strong>  追加到  <strong><em>AOF</em></strong>  缓冲区内；</p></li><li><p><strong><em>AOF</em></strong>  缓冲区根据  <strong><em>AOF</em></strong>  持久化策略  <code>[always,everysec,no]</code>  将操作  <strong><em>sync</em></strong>  同步到磁盘的  <strong><em>AOF</em></strong>  文件中；</p></li><li><p><strong><em>AOF</em></strong>  文件大小超过重写策略或手动重写时，会对  <strong><em>AOF</em></strong>  文件  <strong><em>Rewrite</em></strong>  重写，压缩  <strong><em>AOF</em></strong>  文件容量；</p></li><li><p><strong><em>Redis</em></strong>  服务重启时，会重新  <strong><em>load</em></strong>  加载  <strong><em>AOF</em></strong>  文件中的写操作达到数据恢复的目的。</p></li></ul><p><strong><em>AOF</em></strong>  和  <strong><em>RDB</em></strong>  同时开启时，系统默认读取  <strong><em>AOF</em></strong>  的数据（数据不会存在丢失）</p><h3 id="AOF-开启"><a href="#AOF-开启" class="headerlink" title="AOF 开启"></a>AOF 开启</h3><p>AOF 和 RDB 同时开启后,系统默认取 AOF 数据(数据不会存在丢失)</p><p>在 redis.conf 中修改</p><pre><code class="lang-properties">appendonly no // 默认为no 启动为yes</code></pre><h3 id="生成路径"><a href="#生成路径" class="headerlink" title="生成路径"></a>生成路径</h3><pre><code class="lang-properties">跟RDB生成路径相同</code></pre><h3 id="异常恢复"><a href="#异常恢复" class="headerlink" title="异常恢复"></a>异常恢复</h3><p>如果遇到 AOF 文件损坏,通过/usr/loacl!/bin/redis-check-aof—fix appendonly.aof 来进行修复</p><pre><code class="lang-properties">redis-check-aof --fix appendonly.aof</code></pre><h3 id="AOF-配置"><a href="#AOF-配置" class="headerlink" title="AOF 配置"></a>AOF 配置</h3><p><strong>AOF 同步频率设置</strong></p><pre><code class="lang-properties">appendfsync always//始终同步,每次Redis的写入都会立刻记入日志;性能较差但是数据完整性较好appendfsync everysec//每秒同步,每秒记入日志一次,如果宕机,本秒的数据可能丢失appendfsync noredis不主动进行同步,把同步时机交给操作系统</code></pre><h3 id="Rewrite-压缩"><a href="#Rewrite-压缩" class="headerlink" title="Rewrite 压缩"></a>Rewrite 压缩</h3><p>AOF 采用文件追加方式,文件会越来越大,为避免出现此种情况,新增了重写机制</p><p>当 AOF 文件超过所设定的阈值时,Redis 就会采用 AOF 文件压缩,只保留可以恢复</p><p>数据的最小指令集.可以使用命令 bgrewriteaof</p><pre><code class="lang-properties">auto-aof-rewrite-min-size:设置重写基准值,最小文件为64位.达到这个值后开始重写重写后达到前一次重写大小的200%后再次重写</code></pre><p>系统载入或者上次重写完毕时,Redis 会记录此时 AOF 大小,设为 base_size</p><p>如果 Redis 的 AOF 当前大小&gt;= base_size + base_size*100% 且当前大小&gt;=64mb(默认)的情况下,Redis 会对 AOF 进行重写</p><h2 id="持久化操作总结"><a href="#持久化操作总结" class="headerlink" title="持久化操作总结"></a>持久化操作总结</h2><p>官方推荐两个都启用</p><p>如果对数据不敏感,可以单独用 RDB</p><p>不建议单独用 AOF ,因为会出现 bug</p><p>如果只是做纯内存缓存,可以都不用</p><h1 id="Redis-的主从复制"><a href="#Redis-的主从复制" class="headerlink" title="Redis 的主从复制"></a>Redis 的主从复制</h1><p>主服务器进行写操作,从服务器只能进行读操作</p><ul><li>读写分离,性能拓展</li><li>容灾的快速恢复</li></ul><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/主服务器.png" alt="主服务器"></p><ol><li><p>当从服务器连接到主服务器后,从服务器向主服务器发送进行数据同步的消息</p></li><li><p>主服务器收到消息后对数据进行持久化操作,生成 rdb 文件,再将 rdb 文件发送给</p><p>从服务器,从服务器拿到 rdb 文件后进行读取</p></li><li><p>每次主服务器进行写操作之后,就会和服务器进行数据同步</p></li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="查看主机信息"><a href="#查看主机信息" class="headerlink" title="查看主机信息"></a>查看主机信息</h3><pre><code class="lang-sql">info replication</code></pre><h3 id="在从机上设置主机"><a href="#在从机上设置主机" class="headerlink" title="在从机上设置主机"></a>在从机上设置主机</h3><pre><code class="lang-sql">slaveof &lt;主机ip&gt; &lt;主机端口号&gt;//从服务器挂掉后重启并不能自动连接之前的主服务器,而是恢复成默认(将自己认为是主服务器),必须重新设置//主服务器挂了后重启还是主服务器,他的从服务器仍不会&quot;篡位&quot;</code></pre><h2 id="搭建一主两从"><a href="#搭建一主两从" class="headerlink" title="搭建一主两从"></a>搭建一主两从</h2><ol><li>创建文件目录</li></ol><pre><code class="lang-bash">/opt/etc</code></pre><ol><li>将  <strong><em>redis.conf</em></strong>  复制到当前目录</li></ol><pre><code class="lang-bash">cp /etc/redis.conf /opt/etc/</code></pre><ol><li>创建 3 个  <strong><em>redis.conf</em></strong>  配置文件</li></ol><pre><code class="lang-shell">redis6379.confredis6380.confredis6381.conf</code></pre><pre><code class="lang-bash"># redis6379.confinclude /opt/etc/redis.confpidfile /var/run/redis_6379.pidport 6379dbfilename dump6379.rdb# redis6380.confinclude /opt/etc/redis.confpidfile /var/run/redis_6380.pidport 6380dbfilename dump6380.rdb# redis6381.confinclude /opt/etc/redis.confpidfile /var/run/redis_6381.pidport 6381dbfilename dump6381.rdb</code></pre><ol><li>启动 3 台  <strong><em>redis</em></strong>  服务器</li></ol><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/a61843c9cff3fc5e37465663f6c04992_MD5.png" alt></p><ol><li>查看主机运行情况</li></ol><pre><code class="lang-shell">info replication</code></pre><p>[<img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/e4e37ad7b3359f9503d8f6a5bb6a78ca_MD5.png" alt></p><ol><li><p>配从不配主</p><p>在从机中进行设置，成为谁的从机</p></li></ol><pre><code class="lang-bash">slaveof  &lt;ip&gt; &lt;port&gt;# 成为某个实例的从服务器</code></pre><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/f3c836bf84ad1b0e1ca681047a05668c_MD5.png" alt></p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/b194fcedb26744bd8754a127d2965c87_MD5.png" alt="截屏2021-10-30 15.03.40"></p><ol><li>再次查看主机运行情况</li></ol><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/7af0b9003c9361386a0d982ffa66a8d1_MD5.png" alt></p><p>成功搭建。</p><h2 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h2><p><strong>特点：</strong></p><blockquote><p>主机  <strong><em>6379</em></strong>，从机  <strong><em>6380</em></strong>  和  <strong><em>6381</em></strong>。</p><ol><li><p>假设从机  <strong><em>6380</em></strong>  挂掉。（从机挂掉）</p><ul><li>当 6380 重启后，<strong>6380 不再是 6379 的从机，而是作为新的 master</strong>；（<strong>从机重启后，不再是某个主机的从机，其自身就是一个主机）</strong></li><li>当再次把 6380 作为 6379 的从机加入后，从机才会把数据从头到尾复制。<strong>（从机重启后，需要再输入成为从机的指令）</strong></li></ul></li><li><p>假设主机  <strong><em>6379</em></strong>  挂掉。（主机挂掉）</p><ul><li>6380 和 6381 仍然是 6379 的从机，不会做任何事；<strong>（从机不会改变）</strong></li><li>当 6379 重启后，既然是主服务器。<strong>（主机重启后，还是主机）</strong></li></ul></li></ol></blockquote><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p>完整版：</p><ul><li><p><strong><em>slave</em></strong>  启动成功连接到  <strong><em>master</em></strong>  后会发送一个  <strong><em>sync</em></strong>  命令（同步命令）。</p></li><li><p><strong><em>master</em></strong>  接到命令启动后台的存盘进程，对数据进行持久化操作，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<strong><em>master</em></strong>  将传送整个数据文件（<em><strong>rdb</strong></em>）到  <strong><em>slave</em></strong>，以完成一次完全同步。</p></li><li><p>当主服务进行写操作后，和从服务器进行数据同步。</p></li><li><p><strong>全量复制</strong>：而  <strong><em>slave</em></strong>  服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p></li><li><p><strong>增量复制</strong>：<strong><em>master</em></strong>  继续将新的所有收集到的修改命令依次传给  <strong><em>slave</em></strong>，完成同步。</p></li><li><p>只要是重新连接  <strong><em>master</em></strong>，一次完全同步（全量复制）将被自动执行。</p></li></ul><blockquote><p>全量复制：是从机主动去请求主机进行同步操作，是一开始连接的时候</p><p>增量复制：主机进行一次写操作之后，就主动同步从机</p></blockquote><p>简洁版：</p><p>[<img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/b262ce0098d5b031b8258015816612d9_MD5.png" alt="2022-01-31_111926"></p><h2 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h2><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/薪火相传.png" alt></p><p>上一个  <strong><em>slave</em></strong>  可以是下一个  <strong><em>slave</em></strong>  的  <strong><em>master</em></strong>（<strong>从机是另一个从机的主机，并由这个担任主机的从机，进行数据同步</strong>），<strong><em>slave</em></strong>  同样可以接收其他  <strong><em>slave</em></strong>的连接和同步请求，那么该  <strong><em>slave</em></strong>  作为了链条中下一个的  <strong><em>master</em></strong>，可以有效减轻  <strong><em>master</em></strong>  的写压力，去中心化降低风险。</p><pre><code class="lang-xml">slaveof &lt;ip&gt; &lt;port&gt;</code></pre><ul><li><p>特点与一主二从类似</p></li><li><p>中途变更转向：会清除之前的数据，重新建立拷贝最新的。</p></li><li><p>当某个担任主机的  <strong><em>slave</em></strong>  宕机，其挂在后面的  <strong><em>slave</em></strong>  都没法备份。</p><ul><li>即当主机挂掉，从机还是从机，但是无法继续写数据。</li></ul></li></ul><h3 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h3><p>大哥挂了小弟立马上位(主服务器挂了,从服务器变成主服务器)</p><pre><code class="lang-sql">slaveof no one  //将从机设置为主机 必须我们在从机手动设置</code></pre><h3 id="哨兵模式-反客为主自动版"><a href="#哨兵模式-反客为主自动版" class="headerlink" title="哨兵模式(反客为主自动版)"></a>哨兵模式(反客为主自动版)</h3><p>反客为主自动版,能够后台监控主机是否故障,如果故障了根据投票数自动将从库转换为主库</p><p>规则:</p><ol><li>优先级:值越小优先级越高</li><li>偏移量:获得原主机数据最全的</li><li>runid:每个 redis 实例启动后都会生成一个随机的 runid</li></ol><pre><code class="lang-sql">--在自定义的/myredis目录下新建sentinel.conf文件,名字绝对不能错--在文件中配置哨兵,填写内容sentinel monitor mymaster 127.0.0.1 6379 1 //  mymaster是为监控对象起的服务器名称,1为至少有多少个哨兵同意迁移的数量启动redis-sentinel /myredis/sentinel.conf从服务器的优先级在redis.conf中默认slave-priority 100 --值越小优先度越高</code></pre><p><strong>主机挂掉，哨兵监控到之后，会按照选举规则，从 从机 中选举中产生新的主机，原来挂掉的主机会变成新主机的从机</strong>。</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/8eeef98de5e5e1fba8a4ff71871035ae_MD5.png" alt="2022-01-31_120213"></p><h3 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h3><p>选择条件依次为：</p><ul><li><p>根据优先级别，<em><strong>slave-priority/replica-priority</strong></em>，<strong>优先选择优先级靠前</strong>的。（越小优先级越高）</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/f65c3ee1d6b39e4c363bb68be630329c_MD5.png" alt></p></li><li><p>根据偏移量，<strong>优先选择偏移量大</strong>的。（偏移量是指获得原主机数据最全的）</p></li><li><p>若前两个条件相同，那么选择  <strong><em>runid</em></strong>  最小的，<strong>优先选择最小的服务</strong></p><ul><li>每个 redis 实例启动后，都会随机生成一个 40 位的 runid</li></ul></li></ul><h3 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h3><p>由于所有的写操作都是先在  <strong><em>master</em></strong>  上操作，然后同步更新到  <strong><em>slave</em></strong>  上，所以从  <strong><em>master</em></strong>  同步到  <strong><em>slave</em></strong>  从机有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，<strong><em>slave</em></strong>  机器数量的增加也会使这个问题更加严重。</p><h1 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h1><p>容量不够,redis 如何进行扩容?</p><p>并发操作,redis 如何分摊?</p><p>解决方法:<strong>无中心化集群</strong></p><h2 id="代理服务器模式"><a href="#代理服务器模式" class="headerlink" title="代理服务器模式"></a>代理服务器模式</h2><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/代理服务器.png" alt></p><h2 id="无中心化集群模式"><a href="#无中心化集群模式" class="headerlink" title="无中心化集群模式"></a>无中心化集群模式</h2><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/订单服务器.png" alt="订单服务器"></p><h2 id="无中心化集群配置"><a href="#无中心化集群配置" class="headerlink" title="无中心化集群配置"></a>无中心化集群配置</h2><pre><code class="lang-properties">//redis.conf中进行配置cluster-enbled yes --打开集群模式cluster-config-file nodes-6379.conf --设定节点配置文件名,自定义cluster-node-timeout 15000 设定节点失联时间,超过该时间(毫秒),集群自动进行主从切换</code></pre><h3 id="合体"><a href="#合体" class="headerlink" title="合体"></a>合体</h3><p>进入 redis 的主目录下的 src 目录</p><pre><code class="lang-properties">redis-cli --cluster create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391--replicacs 1 采用最简单的方式配集群,一台主机,一台从机正好三组</code></pre><p>以集群的方式连接 Redis</p><pre><code class="lang-properties">redis-cli -c -p 6379 // -c是以集群的策略连接Redis  -p是连接到6379端口(从服务器)这时候在从服务器中执行写操作,Redis集群会自动切换到集群中的写服务器(主服务器 )</code></pre><p>查看集群中的服务器信息</p><pre><code class="lang-shell">cluster nodes</code></pre><h3 id="集群如何分配系节点"><a href="#集群如何分配系节点" class="headerlink" title="集群如何分配系节点"></a>集群如何分配系节点</h3><p>一个集群至少要有<strong>三个主节点</strong></p><p>选项—cluster-reolicas 1 表示我们希望为集群中的每一个主节点创建一个从节点</p><p>插槽(slot)</p><p>一个 Redis 集群中包含 16384 个插槽,数据库中的每个键都属于这 16384 个插槽的其中一个</p><p>集群使用 CRC16(key)%16384 来计算键 key 属于哪个槽,其中 CRC16(key)语句用于计算键</p><p>key 的 CRC16 的校验和</p><p>集群中的每个节点负责处理一部分插槽.举个例子,如果一个集群可以有主节点,其中:</p><p>节点 A 负责处理 0 号至 5460 号插槽</p><p>节点 B 负责处理 5461 号至 10922 号插槽</p><p>节点 C 负责处理 10923 号至 16384 号插槽</p><p>在集群中设置多个值</p><pre><code class="lang-sql">&gt; mset name lucy age 20 address china&gt;(error) CROSSSLOT Keys in request don&#39;t hash to the same slot&gt; mset name&#123;user&#125; lucy age&#123;user&#125; 20 address(user) china //为这些值设置一个共同的组</code></pre><p>查询集群中的值</p><pre><code class="lang-shell">cluster keyslot key_name返回值为插槽值</code></pre><p>故障恢复</p><pre><code class="lang-sql">//redis.confcluster-require-full-coverage yes/no --yes(如果某段插槽的主从服务器全部挂掉,那么整个集群都挂掉)                                     --no(如果某一段插槽的主从都挂掉,那么该插槽数据全部不能使用,也无法存储)</code></pre><h2 id="集群的-Jedis-开发-1"><a href="#集群的-Jedis-开发-1" class="headerlink" title="集群的 Jedis 开发"></a>集群的 Jedis 开发</h2><pre><code class="lang-java">HostAndPort hostAndPort =  new HostAndPort(&quot;集群中任意服务器的IP地址&quot;,集群中任意服务器的端口号)JedisCluster jediscluster = new Jediscluster(hostAndPort)jedisCluster.set(&quot;b1&quot;,&quot;value1&quot;) //设置值String value = jedisCluster.get(&quot;b1&quot;) //取值jedisCluster.close()</code></pre><h1 id="Redis-应用问题的解决"><a href="#Redis-应用问题的解决" class="headerlink" title="Redis 应用问题的解决"></a>Redis 应用问题的解决</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/f8f1086b9bab7ef3489a4e5281b194b7_MD5.png" alt="img"></p><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p><strong><em>key</em></strong> 对应的数据在数据源并不存在，每次针对此 <strong><em>key</em></strong> 的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。</p><p>redis 查询不到数据库，出现了很多非正常 url 访问。黑客攻击就是通过查询一个不存在的值，缓存里面没有，那么就会查数据库，大量类似的请求发生后，导致数据库崩溃。若黑客利用此漏洞进行攻击可能压垮数据库。</p><p>造成的条件：</p><ol><li>应用服务器压力变大，访问请求增光</li><li><strong>*redis* 命中率下降</strong>（重点）</li><li>导致一直访问查询数据库</li></ol><blockquote><p>服务器压力变大，请求太多，导致 redis 缓存命中率开始下降，对数据库的访问越来越多，数据库最终承受不住压力，崩溃了。</p></blockquote><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><ul><li><p><strong>对空值缓存</strong></p><p>如果一个查询返回的数据为空（不管是数据是否不存在），仍然把这个空结果（<strong><em>null</em></strong>）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</p></li><li><p><strong>设置可访问的名单（白名单）：</strong></p><p>使用 <strong><em>bitmaps</em></strong> 类型定义一个可以访问的名单，名单 <strong><em>id</em></strong> 作为 <strong><em>bitmaps</em></strong> 的偏移量，每次访问和 <strong><em>bitmap</em></strong> 里面的 <strong><em>id</em></strong> 进行比较，如果访问 <strong><em>id</em></strong> 不在 <strong><em>bitmaps</em></strong> 里面，进行拦截，则不允许访问。</p></li><li><p><strong>采用布隆过滤器</strong></p><p>布隆过滤器（<strong><em>Bloom Filter</em></strong>）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数）。（跟 bitmaps 类似，不过效率更高）</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的<strong>优点是空间效率和查询时间都远远超过一般的算法</strong>，<strong>缺点是有一定的误识别率和删除困难，命中率不一定高</strong>。</p><p>将所有可能存在的数据哈希到一个足够大的 <strong><em>bitmaps</em></strong> 中，一个一定不存在的数据会被这个 <strong><em>bitmaps</em></strong> 拦截掉，从而避免了对底层存储系统的查询压力。</p></li><li><p><strong>进行实时监控</strong></p><p>当发现 <strong><em>Redis</em></strong> 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以<strong>设置黑名单限制服务</strong>。</p></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/e4a18d9d357bd8a6af6750916a0c43a5_MD5.png" alt="img"></p><blockquote><p>注意与缓存穿透的区别：</p><ul><li>缓存穿透<ul><li>redis 命中率下降，导致数据库访问量激增</li></ul></li><li>缓存击穿<ul><li>redis 正常访问，但某个热点 key 突然失效，导致瞬间数据库的访问量激增</li></ul></li></ul></blockquote><h3 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h3><p><strong><em>key</em></strong> 对应的数据存在，但在 <strong><em>redis</em></strong> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端<strong><em>DB</em></strong> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <strong><em>DB</em></strong> 压垮。</p><ol><li>数据库访问压力瞬间增大</li><li><strong><em>redis</em></strong> 中没有出现大量 <strong><em>key</em></strong> 过期，<strong><em>redis 正常运行</em></strong>（与缓存穿透的区别）</li><li><strong>某个经常访问的 *key*，即十分热点的 key，不停地被大量访问，当这个 key 过期的瞬间，持续的高并发就击穿了缓存，大量请求数据库，导致数据库奔溃</strong></li></ol><h3 id="如何解决-1"><a href="#如何解决-1" class="headerlink" title="如何解决"></a>如何解决</h3><ul><li><p><strong>预先设置热门数据</strong></p><p>在 <strong><em>redis</em></strong> 高峰访问之前，把一些热门数据提前存入到 <strong><em>redis</em></strong> 里面，<strong>加大这些热门数据 *key* 的时长</strong>。</p></li><li><p><strong>实时调整</strong></p><p>现场监控哪些数据热门，实时调整 <strong><em>key</em></strong> 的过期时长。</p></li><li><p><strong>使用锁</strong></p></li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/73e0f4659d0effe60dc6312df76c83ac_MD5.png" alt></p><h2 id="现象-2"><a href="#现象-2" class="headerlink" title="现象"></a>现象</h2><p><strong><em>key</em></strong> 对应的数据存在，但在 <strong><em>redis</em></strong> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期后，一般都会从后端 <strong><em>DB</em></strong> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <strong><em>DB</em></strong> 压垮。</p><p>缓存雪崩与缓存击穿的区别在于这里针对很多 <strong><em>key</em></strong> 缓存，前者则是某一个 <strong><em>key</em></strong>。</p><ol><li>数据库压力变大</li><li><strong>极少的时间段，查询大量 *key* 的集中过期情况</strong>（大量 key 集中过期，而缓存击穿是热点 key 过期）</li></ol><h3 id="如何解决-2"><a href="#如何解决-2" class="headerlink" title="如何解决"></a>如何解决</h3><ul><li><p><strong>构建多级缓存架构</strong></p><p><strong><em>nginx</em></strong> 缓存 + <strong><em>redis</em></strong> 缓存 + 其他缓存（<strong><em>ehcache</em></strong>等）</p></li><li><p><strong>使用锁或队列：</strong></p><p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。<strong>不适用高并发情况</strong>。</p></li><li><p><strong>设置过期标志更新缓存：</strong></p><p><strong>记录缓存数据是否过期（设置提前量）</strong>，快过期的时候，提前进行一个缓存。如果过期会触发通知另外的线程在后台去更新实际 <strong><em>key</em></strong> 的缓存。</p></li><li><p><strong>将缓存失效时间分散开：</strong></p><p>比如我们可以在原有的失效时间基础上增加一个随机值，比如 1 ～ 5 分钟随机，这样<strong>每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件</strong>。</p></li></ul><h1 id="分布式锁-共享锁"><a href="#分布式锁-共享锁" class="headerlink" title="分布式锁(共享锁)"></a>分布式锁(共享锁)</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，<strong>由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效</strong>，单纯的 Java API 并不能提供分布式锁的能力。为了解决这个问题就需要<strong>一种跨 JVM 的互斥机制来控制共享资源的访问</strong>，这就是分布式锁要解决的问题。</p><p>分布式锁主流的实现方案：</p><ul><li>基于数据库实现分布式锁</li><li>基于缓存（Redis 等）</li><li>基于 Zookeeper</li></ul><p>每一种分布式锁解决方案都有各自的优缺点：</p><ul><li>性能：redis 最高</li><li>可靠性：zookeeper 最高</li></ul><h2 id="设置锁以及过期时间"><a href="#设置锁以及过期时间" class="headerlink" title="设置锁以及过期时间"></a>设置锁以及过期时间</h2><ul><li>设置锁的命令</li></ul><pre><code class="lang-java">SETNX KEY VALUE  # 设置锁del key   # 删除锁</code></pre><ul><li>给锁设置过期时间</li></ul><pre><code class="lang-java">expire users 30 # 给users上锁30s</code></pre><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/82ff822ff8ec8ca52e620cee68928647_MD5.png" alt="2022-01-31_151329"></p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9c611885258374eb5056e3ae5d4b60ae_MD5.png" alt="-01-31_151536"></p><p>上锁的同时设置过期时间</p><pre><code class="lang-java">set key value nx ex time # nx 上锁；ex 设置过期时间</code></pre><ul><li>Java 实现</li></ul><pre><code class="lang-java">@GetMapping(&quot;testLock&quot;)public void testLock()&#123;    //1获取锁，setne ,顺便设置过期时间    Boolean lock = redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;111&quot;,3,TimeUnit.SECONDS); // key, value, 过期时间，时间单位    //2获取锁成功、查询num的值    if(lock)&#123;        Object value = redisTemplate.opsForValue().get(&quot;num&quot;);        //2.1判断num为空return        if(StringUtils.isEmpty(value))&#123;            return;        &#125;        //2.2有值就转成成int        int num = Integer.parseInt(value+&quot;&quot;);        //2.3把redis的num加1        redisTemplate.opsForValue().set(&quot;num&quot;, ++num);        //2.4释放锁，del        redisTemplate.delete(&quot;lock&quot;);    &#125;else&#123;        //3获取锁失败、每隔0.1秒再获取        try &#123;            Thread.sleep(100); // 休眠，等一会            testLock(); // 再去尝试获取锁        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><h2 id="分布式锁产生的问题"><a href="#分布式锁产生的问题" class="headerlink" title="分布式锁产生的问题"></a>分布式锁产生的问题</h2><h3 id="使用-UUID-防止误删锁"><a href="#使用-UUID-防止误删锁" class="headerlink" title="使用 UUID 防止误删锁"></a>使用 UUID 防止误删锁</h3><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022-01-31_152914.png" alt="2022-01-31_152914"></p><p><strong>现象</strong></p><p>a 先上锁后，在执行操作的过程中，服务器卡顿，而 10 秒过期后，b 抢到锁进行具体操作，然而此时 a 的服务器恢复正常，a 继续执行操作并结束，此时有一个释放锁的操作，那么此时释放的锁是 b 的锁，这就是导致误删除锁的现象发生。</p><p><strong>解决方案</strong></p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4fa0c163933ece70106a9d22813c9f91_MD5.png" alt="2022-01-31_153659"></p><p>现修改版：</p><pre><code class="lang-java">@GetMapping(&quot;testLock&quot;)public void testLock()&#123;    // 设置UUID    String uuid = UUID.randomUUID().toString();    .....    if(lock)&#123;       ...        // 判断UUID值是否一样        String lockUuid = (String)redisTemplate.opsForValue().get(&quot;lock&quot;);        if(uuid.equals(lockUuid))&#123; // UUID一样时，才释放锁             //2.4释放锁，del            redisTemplate.delete(&quot;lock&quot;);        &#125;    &#125;else&#123;       ...    &#125;&#125;</code></pre><h3 id="Lua-保证删除原子性"><a href="#Lua-保证删除原子性" class="headerlink" title="Lua 保证删除原子性"></a>Lua 保证删除原子性</h3><p>问题：<strong>删除操作缺乏原子性，即 uuid 的比较操作和删除操作不是原子操作</strong></p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/9e22048deefb586b50b938f7f46ae9e9_MD5.png" alt="2022-01-31_154515"></p><p>现修改：</p><pre><code class="lang-java">@GetMapping(&quot;testLockLua&quot;)public void testLockLua() &#123;    //1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中    String uuid = UUID.randomUUID().toString();    //2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！    String skuId = &quot;25&quot;; // 访问skuId 为25号的商品 100008348542    String locKey = &quot;lock:&quot; + skuId; // 锁住的是每个商品的数据    // 3 获取锁    Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid, 3, TimeUnit.SECONDS);    // 第一种： lock 与过期时间中间不写任何的代码。    // redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);//设置过期时间    // 如果true    if (lock) &#123;        // 执行的业务逻辑开始        // 获取缓存中的num 数据        Object value = redisTemplate.opsForValue().get(&quot;num&quot;);        // 如果是空直接返回        if (StringUtils.isEmpty(value)) &#123;            return;        &#125;        // 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！        int num = Integer.parseInt(value + &quot;&quot;);        // 使num 每次+1 放入缓存        redisTemplate.opsForValue().set(&quot;num&quot;, String.valueOf(++num));        /*使用lua脚本来锁*/        // 定义lua 脚本        String script = &quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot;;        // 使用redis执行lua执行        DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;();        redisScript.setScriptText(script);        // 设置一下返回值类型 为Long        // 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，        // 那么返回字符串与0 会有发生错误。        redisScript.setResultType(Long.class);        // 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。        redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid);    &#125; else &#123;        .....    &#125;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了确保分布式锁可用，我们<strong>至少要确保锁的实现同时满足以下四个条件</strong>：</p><ul><li><p>互斥性。<strong>在任意时刻，只有一个客户端能持有锁</strong>。</p></li><li><p><strong>不会发生死锁</strong>。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</p></li><li><p>解铃还须系铃人。<strong>加锁和解锁必须是同一个客户端</strong>，客户端自己不能把别人加的锁给解了。</p></li><li><p><strong>加锁和解锁必须具有原子性</strong>。</p></li></ul><h1 id="Redis6-的新功能"><a href="#Redis6-的新功能" class="headerlink" title="Redis6 的新功能"></a>Redis6 的新功能</h1><h2 id="ACL-访问控制列表"><a href="#ACL-访问控制列表" class="headerlink" title="ACL(访问控制列表)"></a>ACL(访问控制列表)</h2><p>将用户的权限进行更细粒度的权限控制</p><p>(1),接入权限:用户名,密码</p><p>(2)用户可执行的命令</p><p>(3)用户可以操作的 key</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><pre><code>acl list //展现当前所有用户的信息acl cat  //查看具体操作的指令列表acl setuser user_name //添加用户以及权限acl whoami //查看当前用户名</code></pre><h1 id="模拟秒杀"><a href="#模拟秒杀" class="headerlink" title="模拟秒杀"></a>模拟秒杀</h1><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>核心的逻辑代码：</p><pre><code class="lang-java">public class SecKill_redis &#123;    public static void main(String[] args) &#123;        Jedis jedis =new Jedis(&quot;192.168.242.110&quot;,6379);        System.out.println(jedis.ping());        jedis.close();    &#125;    //秒杀过程    public static boolean doSecKill(String uid,String prodid) throws IOException &#123;        //1 uid和prodid非空判断        if(uid == null || prodid == null)&#123;            return false;        &#125;        //2 连接redis        Jedis jedis =new Jedis(&quot;192.168.xx.xxx&quot;,6379);        //3 拼接key        // 3.1 库存key        String kcKey = &quot;sk:&quot;+prodid+&quot;:qt&quot;;        // 3.2 秒杀成功用户key        String userKey = &quot;sk:&quot;+prodid+&quot;:user&quot;;        //4 获取库存，如果库存null，秒杀还没有开始        String kc = jedis.get(kcKey);        if(kc == null)&#123;            System.out.println(&quot;秒杀还没开始，请稍等&quot;);            jedis.close();            return false;        &#125;        // 5 判断用户是否重复秒杀操作        if(jedis.sismember(userKey, uid))&#123;            System.out.println(&quot;每个用户只能秒杀成功一次，请下次再来&quot;);            jedis.close();            return false;        &#125;        //6 判断如果商品数量，库存数量小于1，秒杀结束        if(Integer.parseInt(kc) &lt; 1)&#123;            System.out.println(&quot;秒杀结束，请下次参与&quot;);            jedis.close();            return false;        &#125;        //7 秒杀过程        //7.1库存-1        jedis.decr(kcKey);        //7.2 把秒杀成功的用户添加到清单里面        jedis.sadd(userKey,uid);        System.out.println(&quot;用户&quot; + uid + &quot;秒杀成功&quot;);        jedis.close();        return true;    &#125;&#125;</code></pre><h2 id="使用-ab-工具模拟并发以及暴露出的问题"><a href="#使用-ab-工具模拟并发以及暴露出的问题" class="headerlink" title="使用 ab 工具模拟并发以及暴露出的问题"></a>使用 ab 工具模拟并发以及暴露出的问题</h2><blockquote><p>CentOS 6 默认安装</p><p>CentOS 7 手动安装（yum -y install httpd-tools）</p></blockquote><ul><li><p>通过 ab 命令发送并发操作</p><pre><code class="lang-java">ab -n 2000 -c 200 -k -p ~/postfile -T application/x-www-form-urlencoded http://192.168.0.43:8080/Seckill/doseckill</code></pre><p>-n：测试会话中所执行的请求个数</p><p>-c：一次产生的请求个数</p></li><li><p>并发暴露出来的问题</p><ul><li><p>会出现<strong>超卖问题</strong>：卖完了商品，但还存在继续购买，即库存变为负数</p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/bd88f0c555d2ebca992b86b7140ad08f_MD5.png" alt="2022-01-30_203603"></p><ul><li><p>解决方案：使用<strong>乐观锁</strong>，进行版本控制<strong>（redis 事务+watch）</strong></p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3b1e161138b4eb786b74ddef177fe9fc_MD5.png" alt="2022-01-30_204947"><br>代码修改：</p><pre><code class="lang-java">//秒杀过程public static boolean doSecKill(String uid,String prodid) throws IOException &#123;    //1 uid和prodid非空判断    if(uid == null || prodid == null)&#123;        return false;    &#125;    //2 连接redis    //Jedis jedis =new Jedis(&quot;192.168.xx.xxx&quot;,6379);    //通过连接池获取连接redis的对象    JedisPool jedisPoolInstance = JedisPoolUtil.getJedisPoolInstance();    Jedis jedis = jedisPoolInstance.getResource();    //3 拼接key    // 3.1 库存key    String kcKey = &quot;sk:&quot;+prodid+&quot;:qt&quot;;    // 3.2 秒杀成功用户key    String userKey = &quot;sk:&quot;+prodid+&quot;:user&quot;;    //监视库存    jedis.watch(kcKey);    //4 获取库存，如果库存null，秒杀还没有开始    String kc = jedis.get(kcKey);    if(kc == null)&#123;        System.out.println(&quot;秒杀还没开始，请稍等&quot;);        jedis.close();        return false;    &#125;    // 5 判断用户是否重复秒杀操作    if(jedis.sismember(userKey, uid))&#123;        System.out.println(&quot;每个用户只能秒杀成功一次，请下次再来&quot;);        jedis.close();        return false;    &#125;    //6 判断如果商品数量，库存数量小于1，秒杀结束    if(Integer.parseInt(kc) &lt; 1)&#123;        System.out.println(&quot;秒杀结束，请下次参与&quot;);        jedis.close();        return false;    &#125;    //7 秒杀过程    //使用事务    Transaction multi = jedis.multi();    //组队操作    multi.decr(kcKey);    multi.sadd(userKey,uid);    //执行    List&lt;Object&gt; results = multi.exec();    if(results == null || results.size()==0) &#123;        System.out.println(&quot;秒杀失败了....&quot;);        jedis.close();        return false;    &#125;    //        //7.1库存-1    //        jedis.decr(kcKey);    //        //7.2 把秒杀成功的用户添加到清单里面    //        jedis.sadd(userKey,uid);    System.out.println(&quot;用户&quot; + uid + &quot;秒杀成功&quot;);    jedis.close();    return true;&#125;</code></pre></li></ul></li><li><p><strong>连接超时问题</strong></p><ul><li>解决方案：采用连接池</li></ul><pre><code class="lang-java">// 创建工具类public class JedisPoolUtil &#123;    private static volatile JedisPool jedisPool = null;    private JedisPoolUtil() &#123;    &#125;    public static JedisPool getJedisPoolInstance() &#123;        if (null == jedisPool) &#123;            synchronized (JedisPoolUtil.class) &#123;                if (null == jedisPool) &#123;                    JedisPoolConfig poolConfig = new JedisPoolConfig();                    poolConfig.setMaxTotal(200);                    poolConfig.setMaxIdle(32);                    poolConfig.setMaxWaitMillis(100*1000);                    poolConfig.setBlockWhenExhausted(true);                    poolConfig.setTestOnBorrow(true);  // ping  PONG                    jedisPool = new JedisPool(poolConfig, &quot;192.168.xx.xxx&quot;, 6379, 60000 );                &#125;            &#125;        &#125;        return jedisPool;    &#125;    public static void release(JedisPool jedisPool, Jedis jedis) &#123;        if (null != jedis) &#123;            jedisPool.returnResource(jedis);        &#125;    &#125;&#125;</code></pre><p>修改代码，主要是针对前面基本实现中的核心代码，对获取 redis 对象进行修改：</p><pre><code class="lang-java">//2 连接redis//Jedis jedis =new Jedis(&quot;192.168.xx.xxx&quot;,6379);//通过连接池获取连接redis的对象JedisPool jedisPoolInstance = JedisPoolUtil.getJedisPoolInstance();Jedis jedis = jedisPoolInstance.getResource();</code></pre></li><li><p><strong>商品遗留问题</strong>，即秒杀已经结束了，却还有商品库存</p><ul><li>解决方案：使用 Lua 脚本</li></ul><blockquote><p>Lua 是一个小巧的脚本语言，Lua 脚本可以很容易的被 C/C++ 代码调用，也可以反过来调用 C/C++的函数，Lua 并没有提供强大的库，一个完整的 Lua 解释器不过 200k，所以 Lua 不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。很多应用程序、游戏使用 LUA 作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。</p></blockquote><p><strong>将复杂的或者多步的 redis 操作，写为一个脚本，一次提交给 redis 执行</strong>，减少反复连接 redis 的次数。提升性能。</p><p><strong>Lua 脚本是类似 redis 事务，有一定的原子性，不会被其他命令插队</strong>，可以完成一些 redis 事务性的操作。</p><p>但是注意 redis 的 lua 脚本功能，只有在 Redis 2.6 以上的版本才可以使用。</p><p><strong>利用 Lua 脚本淘汰用户，解决超卖问题</strong>。</p><p>redis 2.6 版本以后，通过 lua 脚本解决争抢问题，<strong>实际上是 redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题。</strong></p><p><img src="/2023/07/19/Redis6.0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/739bc930419ef903046dfdb5f8653b9f_MD5.png" alt="2022-01-30_205550"></p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基本操作</title>
      <link href="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h1><h2 id="Linux-系统的起源与发展"><a href="#Linux-系统的起源与发展" class="headerlink" title="Linux 系统的起源与发展"></a>Linux 系统的起源与发展</h2><p><strong>Linux 是一种免费使用和自由传播的类 UNIX 操作系统</strong>,是一个基于 POSIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。它能运行主要的 Unix 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心 的设计思想，是一个性能稳定的多用户网络操作系统。并且 Linux 是一款自由软件，可以完全免费自由地提供给用户使用。</p><h2 id="Linux-系统的介绍"><a href="#Linux-系统的介绍" class="headerlink" title="Linux 系统的介绍"></a>Linux 系统的介绍</h2><h3 id="Linux-系统的特点"><a href="#Linux-系统的特点" class="headerlink" title="Linux 系统的特点"></a>Linux 系统的特点</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>① <strong>一切都是文件</strong> :系统中的所有都归结为一个文件，包括命令、硬件和软件设备、操作系统、进程 等等对于操作系统内核而言，都被视为拥有各自特性或类型的文件。</p><p>② <strong>每个文件都有确定的用途</strong></p><p><strong>==特点==</strong></p><p>① <strong>开放系统</strong> : Linux 系统遵循[[计算机网络基础#==OSI与TCP/IP模型==|开放式系统互联通信参考模型（Open System Interconnection Reference Model，缩写为 OSI）]]</p><p>② <strong>完全开源免费</strong></p><p>③ <strong>多用户、多用户</strong> : 多用户是指系统资源可以被不同用户同各自拥有，即每个用户对自己的资源（文件、设备） 有特定的权限，并且互不影响。</p><p>④ <strong>出色的稳定性和速度性能</strong> : Linux 可以连续运行很长时间而不需要重启（Linux 的主要使用场景是作为服务器，服务器是很 大重启或者关机的）</p><p>⑥ <strong>安全可靠的系统</strong> : Linux 采取了许多安全技术措施，可以在网络及多用户的情况下提供：包括对读/写文件系统进 行权限的限制、核心程序、关键操作的授权等。再有由于 Linux 是开源免费的（不像 Winidows），在敏感行业（政府、军工）可以避免后门漏洞造成的系统安全问题。</p><p>⑦ <strong>提供丰富的网络功能 </strong>: Linux 的设计初衷就是基于网络，所以 Linux 系统中有完善的内置网络服务，比如： DNS,DHCP,Samba 等，完善的网络服务也是 Linux 由于其它操作系统的一个原因</p><p>⑧ <strong>支持多种平台</strong> : Linux 可以运行在多种硬件平台上，如具有 x86、ARM、SPARC 等处理器的平台架构。此外 Linux 还是一种嵌入式操作系统，可以运行在掌上电脑、手机、机顶盒或游戏机上。</p><p>⑨ <strong>良好的界面</strong> : Linux 同时具有字符界面和图形界面。在字符界面用户可以通过键盘输入相应的指令来进行操 作。它同时也提供了类似 Windows 图形界面的 X-Window 系统</p><h3 id="Linux-系统的组成"><a href="#Linux-系统的组成" class="headerlink" title="Linux 系统的组成"></a>Linux 系统的组成</h3><p>Linux 系统一般有 4 个主要部分：<strong>内核</strong>、<strong>shell</strong>、<strong>文件系统</strong>和<strong>应用程序</strong>，如下图所示（最内层是各种硬件设备）。</p><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/11.png" alt="image-20230623105133894"></p><h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>内核(Kernel)是操作系统的核心，具有很多最基本功能，它负责管理系统的进程、内存、设备 驱动程序、文件和网络系统，决定着系统的性能和稳定性。内核从应用层接受命令，根据调度算 法调度相关进程使用系统资源，使得程序能够顺利的运行。</p><p>Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。</p><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p>shell 是一种<strong>命令解释器</strong>，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令 并把它送入内核去执行，并且将执行的结果返回个给用户。shell 还有自己的编程语言，运行用户 编写由 shell 命令组成的程序。</p><p>shell 有多个版本，目前主流的 shell 版本有四个：</p><div class="table-container"><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>BASH</td><td>bash 是 BourneAgain Shell 的缩写，<em>bash 是 Linux 标准默认的 shell</em>。它基于 Bourne shell，吸收了 C shell 和 Korn shell 的一些特性。bash 完全兼容 Bourne shell。</td></tr><tr><td>Bourne Shell</td><td>一般缩写成 sh，由贝尔实验室开发，<em>是 Unix 标准默认的 shell</em>。</td></tr><tr><td>Korn Shell</td><td>Korn shell 缩写 ksh，其特点是兼容性好。</td></tr><tr><td>C Shell</td><td>Sun 公司 Shell 的 BSD 版本。</td></tr></tbody></table></div><p>shell 是用户与 Linux 操作系统之间的沟通的桥梁，在使用 shell 命令之前了解一下 Shell 命令的格式：</p><pre><code class="lang-shell"> 命令名称 [选项] [参数1] [参数2]...</code></pre><p><strong>命令名</strong>：需要提交给系统执行的命令，这些命令是个可执行文件或 She 脚本文件。</p><p><strong>选项</strong>：是对命令的特别定义，以短线(-) 开始。在 Linux 中，如果一个命令有多个选项可以使用一 个短线 (-)将所有选项连接起来，也可分开输入。同一个命令可以通过不同的选项来实现不同的功 能。</p><p><strong>参数</strong>：是提供给命令运行的信息或命令执行过程中所使用的文件名。 一个简单的 Shell 命令可以只有命令名，复杂一些的可以通过不同的选项和参数来实现命令、选项以及参数之间通过空格键来分隔。如果有多条命令要执行，可将这些令输入在一行中， 各命令 之间用分号(;) 进行分隔。命令的执行顺序与输入的顺序相同。</p><p><strong>文件系统</strong>:文件系统是文件存放在磁盘等存储设备上的存储规则，系统只有规定了文件系统，也就是文件数据的存储组织方式，数据的读/写才能正常进行。目前 Linux 支持多种文件系统，如 EXT2、 EXT3、 XFS、FAT、 VFAT 和 MFS 等。</p><p><strong>应用程序</strong>:标准的 Linux 系统除了系统核心外，一般都有一套都有称为应用程序的程序集，以方便用户的 使用。它包括文本编辑器（vi）、编程语言、XWindow、办公套件、Internet 工具和数据库等。</p><h1 id="Linux-的基本操作"><a href="#Linux-的基本操作" class="headerlink" title="Linux 的基本操作"></a>Linux 的基本操作</h1><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><pre><code class="lang-shell">xfs #centOs7 默认的文件系统 高性能日志文件系统ext2 #linux自带的文件系统类型ext3 #是在ext2的基础之上发展演变而来的，二者区别在于ext3文件系统带有日志功能，它会跟踪对于磁盘的写入操作并记录于日志，这样可以在需要时回溯查找。swap #文件系统在 Linux中作为交换分区的文件系统使用。交换分区是在硬盘上分配出来的一块存储空间，用来弥补物理内存空间的不足。交换空间由操作系统自动管理。因为Linux系统有提前读和延后写的操作机制，所以在安装Linux系统的过程中，交换分区是必须被分配的，其文件系统类型是swap。</code></pre><h3 id="各个系统文件夹的意义"><a href="#各个系统文件夹的意义" class="headerlink" title="各个系统文件夹的意义"></a>各个系统文件夹的意义</h3><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/22.png" alt="image-20230623111250592"></p><div class="table-container"><table><thead><tr><th style="text-align:center">目录</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">/</td><td>根目录</td></tr><tr><td style="text-align:center">/boot</td><td>引导程序，内核等存放的目录</td></tr><tr><td style="text-align:center"><strong>/sbin</strong></td><td>超级用户可以使用的命令的存放目录 —软链接(快捷方式) 真实路径是/usr/sbin</td></tr><tr><td style="text-align:center">/selinux</td><td>这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类 似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的。</td></tr><tr><td style="text-align:center">/srv</td><td>该目录存放一些服务启动之后需要提取的数据。</td></tr><tr><td style="text-align:center"><strong>/bin</strong></td><td>普通用户可以使用的命令的存放目录 —软链接(快捷方式) 真实路径是/usr/bin</td></tr><tr><td style="text-align:center"><strong>/lib</strong></td><td>根目录下的所程序的共享库目录</td></tr><tr><td style="text-align:center"><strong>/dev</strong></td><td>设备文件目录 在 linux 系统中设备是以文件的形式存在,通过访问设备文件(设备驱动)则可以访问到设备</td></tr><tr><td style="text-align:center">/home</td><td>普通用户的家目录</td></tr><tr><td style="text-align:center"><strong>/root</strong></td><td>用户 root 的$HOME 目录</td></tr><tr><td style="text-align:center">/etc</td><td>全局的配置文件存放目录。 —系统和程序一般都可以通过修改相应的配置文件，来进行配置</td></tr><tr><td style="text-align:center"><strong>/usr</strong></td><td>这个目录中包含了命令库文件和在通常操作中不会修改的文件。 —安装程序时默认安装到此目录下的某个子目录 (相当于 window 中软件默认安装到 Program Files 文件夹中)<br> <em>/usr/local</em> 程序默认安装位置<br> <em>/usr/sbin</em> 超级用户使用的比较高级的管理程序和系统守护程序。<br> <em>/usr/src</em> 内核源代码默认的放置目录。</td></tr><tr><td style="text-align:center"><strong>/opt</strong></td><td>可择的文件目录<br>这个目录表示的是可择的意思，些自定义软件包或者第三方工具，就可以安装在这里。(比如自己编的程序可以安装到这里)</td></tr><tr><td style="text-align:center"><strong>/mnt</strong></td><td>临时挂载目录<br>这个目录一般是用于存放挂载储存设备的挂载目录的，比如磁盘，光驱，网络文件系统等，当我们需要挂载某个磁盘设备的时候，可以把磁盘设备挂载到这个目录上去</td></tr><tr><td style="text-align:center"><strong>/media</strong></td><td>挂载的媒体设备目录<br>例如 u 盘</td></tr><tr><td style="text-align:center">/tmp</td><td>临时文件目录<br>该目录存放系统中的一些临时文件，文件可能会被系统自动清空。</td></tr><tr><td style="text-align:center">/proc</td><td>process(进程)的缩写</td></tr><tr><td style="text-align:center">/var</td><td>var 是 variable(变量) 的缩写，用于存放运行时需要改变数据的文件，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</td></tr><tr><td style="text-align:center">/run</td><td>是一个临时文件系统，存储系统启动以来的信息。当系统重启时,这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让 它指向 run。</td></tr></tbody></table></div><p><strong>特殊目录</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td>当前目录</td></tr><tr><td style="text-align:center">..</td><td>上一级目录</td></tr><tr><td style="text-align:center">~</td><td>用户的主目录</td></tr><tr><td style="text-align:center">-</td><td>前一个工作目录</td></tr></tbody></table></div><pre><code class="lang-shell"># 当前目录cd .# 上一级目录cd ..# 去用户的主目录cd ~# 去上一次目录cd -</code></pre><p><strong>文件的命名</strong></p><p>Linux 支持长文件名，最长可以达到<code>256字节</code>。Linux 的文件名中不能含有空格和以下特殊字符：</p><pre><code class="lang-shell">! @ # ￥ % ~ &amp; × () [] &#123;&#125; &#39; &quot; \ / | ; &lt; &gt; &lt;&lt; &gt;&gt;</code></pre><p><a href="###文件">文件介绍之后进行,先进行系统基础命令的学习</a></p><h2 id="系统基础命令"><a href="#系统基础命令" class="headerlink" title="系统基础命令"></a>系统基础命令</h2><h3 id="查看-修改当前时间"><a href="#查看-修改当前时间" class="headerlink" title="查看/修改当前时间"></a>查看/修改当前时间</h3><pre><code class="lang-shell">date [-options] [mm/dd/yy] [hh:mm:ss]options:    d : 设置年月日    s : 设置时分秒    #设置月日年    date -d 02/28/21    #设置时分秒    date -s 23:45:00</code></pre><h3 id="查看命令类型"><a href="#查看命令类型" class="headerlink" title="查看命令类型"></a>查看命令类型</h3><pre><code class="lang-shell">type 命令名称[nd_ljq@ROOT ~]$ type ifconfigifconfig is /usr/sbin/ifconfig[nd_ljq@ROOT ~]$ type typetype is a shell builtinps:若响应为路径则代表这条命令是`外部命令`   若响应为`xxx is a shell builtin`则代表这条命令是`内核命令`</code></pre><h3 id="查看命令帮助文档"><a href="#查看命令帮助文档" class="headerlink" title="查看命令帮助文档"></a>查看命令帮助文档</h3><pre><code class="lang-shell">help [options] 命令名称help typehelp cdps:该命令只能用来查询linux`内部命令`的帮助文档</code></pre><pre><code class="lang-shell">man [options] 命令名称man sshps: man（manual：手册），“Linux System Administrator&#39;s Manual”，命令可以快速查询Linux命令（内核命令/外部命令）的详细描述和使用方法。</code></pre><h3 id="查看系统基础信息"><a href="#查看系统基础信息" class="headerlink" title="查看系统基础信息"></a>查看系统基础信息</h3><pre><code class="lang-shell">uname [options] [--help][--version]options:    -a 或--all 　显示全部的信息，包括内核名称、主机名、操作系统版本、处理器类型和硬件架构等。    -m 或--machine 　显示处理器类型。    -n 或--nodename 　显示主机名。    -r 或--release 　显示内核版本号。    -s 或--sysname 　显示操作系统名称。    -v 　显示操作系统的版本。    --help 　显示帮助。    --version 　显示版本信息。    -p 显示处理器类型（与 -m 选项相同）。</code></pre><h3 id="查看历史输入"><a href="#查看历史输入" class="headerlink" title="==查看历史输入=="></a>==查看历史输入==</h3><pre><code class="lang-shell">history numps: num为选取最近的n条指令打印</code></pre><h3 id="注销用户"><a href="#注销用户" class="headerlink" title="注销用户"></a>注销用户</h3><pre><code class="lang-shell">logoutexit</code></pre><h3 id="重启与关机"><a href="#重启与关机" class="headerlink" title="==重启与关机=="></a>==重启与关机==</h3><pre><code class="lang-shell">shutdown [-t seconds] [option] time [message]-t seconds : 设定在几秒钟之后进行关机程序。-k : 并不会真的关机，只是将警告讯息传送给所有使用者。-r : (reboot)关机后重新开机。-h : (halt)关机后停机。-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。-c : 取消目前已经进行中的关机动作。time : 设定关机的时间。message : 传送给所有使用者的警告讯息。shutdown -k 5 &quot;system will be reboot! &quot;!号后要有空格poweroff 关机reboot 重启</code></pre><h3 id="组-用户的操作"><a href="#组-用户的操作" class="headerlink" title="==组/用户的操作=="></a>==组/用户的操作==</h3><blockquote><p>对用户组的操作,实质性是对/etc/group 文件和/etc/gshadow 文件的操作</p></blockquote><h4 id="创建组"><a href="#创建组" class="headerlink" title="创建组"></a>创建组</h4><pre><code class="lang-shell">groupadd [-g gid] groupNameps: -g 为指定组的id</code></pre><h4 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h4><pre><code class="lang-shell">groupdel goupNameps:删除组的前提是这个组为空</code></pre><blockquote><p>对用户的操作,实质上是对/etc/passwd 文件的操作</p><p>用户的密码是经过加密后存储在 /etc/shadow 文件中</p><p>查看所有用户可以查看/etc/passwd 文件中的记录数</p><p>查看组(组数)可以查看/etc/group 文件中的记录数</p></blockquote><p>/etc/passwd 中</p><p>每一行有七个字段组成，之间用”:”分隔，各个字段的顺序和含义如下：</p><pre><code class="lang-shell">LOGNAME:PASSWORD:UID:GID:USERINFO:HOME:SHELL</code></pre><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><pre><code class="lang-shell">useradd [options] userNameoptions:    -e:有效期    -f:缓冲天数    -g:用户所属群    -s:指定用户的shell 若未指定centos7会给其默认分配一个shell 为 /bin/bash     /bin/sh     /bin/ksshell     /bin/bash ...    -d:用户的工作目录(家目录)    -u:指定用户id例子:    1.创建一个不能登录的的用户        useradd -s /sbin/nologin(更优,后面会提及)        useradd -s /bin/false</code></pre><div class="table-container"><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>LOGNAME</td><td>用户名：用于区分不同的用户。在同一系统中注册名是惟一的。注意！通常 在 Linux 系统中对字母大小写是敏感的。</td></tr><tr><td>PASSWORD</td><td>口令：用户的口令，注意用户的密码系统会加密存储在/etc/shadow 下，所以这里只显示一个 x 字符。</td></tr><tr><td>UID</td><td>UID：用户的 ID，是 Linux 系统中惟一的用户标识，用于区别不同的用户。 这个 ID 可以创建用户的时候指定，或者由系统自动分配。</td></tr><tr><td>GID</td><td>GID：用户所属的组 ID，用户的组存放在/etc/group 文件中。</td></tr><tr><td>USERINFO</td><td>用户信息：包含有关用户的一些信息。</td></tr><tr><td>HOME</td><td>用户主目录：该字段定义了用户的主目录，当用户登录后，他的 Shell 将把 该目录作为用户的工作目录。 在 Linux 系统中，root 的工作目录为/root； 而其它个人用户在的默认主目录在/home/用户名的目录，或者也可以创建 用户的时候指定。</td></tr><tr><td>SHELL</td><td>Shell：用户的 shell，比如：bash、sh、csh、ksh 等。</td></tr></tbody></table></div><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><pre><code class="lang-shell">userdel [option] userName  option:    -r: 删除用户登录目录以及目录中的所有文件</code></pre><h4 id="查看当前用户-ID"><a href="#查看当前用户-ID" class="headerlink" title="查看当前用户 ID"></a>查看当前用户 ID</h4><pre><code class="lang-shell">id</code></pre><h4 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h4><pre><code class="lang-shell">passwd [options] userNameoptions:    -d 删除密码    -w 口令要到期提前警告的天数    -k 更新只能发送在过期之后    -l (lock)停止账号使用    -S 显示密码信息    -u (unlock)启用已被停止的账户    -x 指定口令最长存活期    -g 修改群组密码    -n 指定口令最短存活期    -i 口令过期后多少天停用账户</code></pre><h4 id="修改用户信息"><a href="#修改用户信息" class="headerlink" title="修改用户信息"></a>修改用户信息</h4><pre><code class="lang-shell">usermod [options] userNameoptions:    -d &lt;登入目录&gt; 　修改用户登入时的目录。    -e &lt;有效期限&gt; 　修改帐号的有效期限。    -f &lt;缓冲天数&gt; 　修改在密码过期后多少天即关闭该帐号。    -g &lt;群组&gt; 　修改用户所属的群组。    -l &lt;帐号名称&gt; 　修改用户帐号名称。    -L 锁定用户密码，使密码无效。    -s 修改用户登入后所使用的shell。    -u 修改用户ID。    -U 解除密码锁定。    查看用户信息:    cat /etc/passwd | grep userName</code></pre><h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4><p>su（英文全拼：switch user）命令用于变更为其他使用者的身份。同时使用 whoami 命令查看当前用户。</p><p>su 命令语法：</p><pre><code class="lang-shell">su [-] userName#切换到root用户susu -su root</code></pre><blockquote><p>su 命令用户切换登录用户的命令。注意：普通用户切 root 是需要 root 密码的，但是 root 切普通 用户不要密码，并且英文安全考虑，输入的密码是不回显的。</p></blockquote><h2 id="系统高级应用与设置"><a href="#系统高级应用与设置" class="headerlink" title="系统高级应用与设置"></a>系统高级应用与设置</h2><h3 id="系统性能分析"><a href="#系统性能分析" class="headerlink" title="系统性能分析"></a>系统性能分析</h3><h4 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h4><pre><code class="lang-shell">uptime 命令可以用来查看服务器已经运行了多久，依次显示：现在时间，系统运行了多久，当前登录的用户有多少，以及服务器在过去的1分钟、5分钟、15分钟的系统平均负载值。</code></pre><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>free 命令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及 系统核心使用的缓冲区等。</p><pre><code class="lang-shell">free [-options] [-s &lt;间隔秒数&gt;] options:    -b:以Byte为单位显示内存使用情况。    -k:以KB为单位显示内存使用情况。    -m:以MB为单位显示内存使用情况。    -h:以人可视化的单位显示内存使用情况。    -s &lt;间隔秒数&gt;:每隔n秒刷新一次</code></pre><p>结果说明：</p><ul><li>total: 内存总数。</li><li>used: 已经使用内存数。</li><li>free: 完全空闲内存。</li><li>shared: 多个进程共享的内存。</li><li>buffers: 用于块设备数据缓冲，记录文件系统 metadata（目录，权限，属性等)。</li><li>cached: 用于文件内容的缓冲。</li><li>available：真正剩余的可被程序应用的内存数。</li></ul><h4 id="top-指令"><a href="#top-指令" class="headerlink" title="top 指令"></a>top 指令</h4><p>相当于 windows 中的任务管理器</p><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/linux任务管理器.png" alt="linux任务管理器"></p><h5 id="第一行，任务队列信息，同-uptime-命令的执行结果"><a href="#第一行，任务队列信息，同-uptime-命令的执行结果" class="headerlink" title="第一行，任务队列信息，同 uptime 命令的执行结果"></a>第一行，任务队列信息，同 uptime 命令的执行结果</h5><pre><code class="lang-bash">第一行，任务队列信息，同 uptime 命令的执行结果系统时间：11:08:47运行时间：up 36 min,当前登录用户：  1 user负载均衡(uptime)  load average: 0.32, 0.26, 0.20average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了</code></pre><h5 id="第二行，Tasks-—-任务（进程）"><a href="#第二行，Tasks-—-任务（进程）" class="headerlink" title="第二行，Tasks — 任务（进程）"></a>第二行，Tasks — 任务（进程）</h5><pre><code class="lang-bash">总进程:150 total, 运行:1 running, 休眠:149 sleeping, 停止: 0 stopped, 僵尸进程: 0 zombie</code></pre><h5 id="第三行，cpu-状态信息"><a href="#第三行，cpu-状态信息" class="headerlink" title="第三行，cpu 状态信息"></a>第三行，cpu 状态信息</h5><pre><code class="lang-shell">0.0%us【user space】— 用户空间占用CPU的百分比。0.3%sy【sysctl】— 内核空间占用CPU的百分比。0.0%ni【】— 改变过优先级的进程占用CPU的百分比99.7%id【idolt】— 空闲CPU百分比0.0%wa【wait】— IO等待占用CPU的百分比0.0%hi【Hardware IRQ】— 硬中断占用CPU的百分比0.0%si【Software Interrupts】— 软中断占用CPU的百分比</code></pre><h5 id="第四行-内存状态"><a href="#第四行-内存状态" class="headerlink" title="第四行,内存状态"></a>第四行,内存状态</h5><pre><code class="lang-shell">1003020k total,   234464k used,   777824k free,    24084k buffers【缓存的内存量】</code></pre><h5 id="第五行，swap-交换分区信息"><a href="#第五行，swap-交换分区信息" class="headerlink" title="第五行，swap 交换分区信息"></a>第五行，swap 交换分区信息</h5><pre><code class="lang-shell">2031612k total,      536k used,  2031076k free,   505864k cached【缓冲的交换区总量】备注：可用内存=free + buffer + cached对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，第四行中空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。</code></pre><h5 id="第六行，空行"><a href="#第六行，空行" class="headerlink" title="第六行，空行"></a>第六行，空行</h5><h5 id="第七行以下：各进程（任务）的状态监控"><a href="#第七行以下：各进程（任务）的状态监控" class="headerlink" title="第七行以下：各进程（任务）的状态监控"></a>第七行以下：各进程（任务）的状态监控</h5><pre><code class="lang-bash">PID — 进程idUSER — 进程所有者PR — 进程优先级NI — nice值。负值表示高优先级，正值表示低优先级VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RESRES —  进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATASHR — 共享内存大小，单位kbS —进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程%CPU — 上次更新到现在的CPU时间占用百分比%MEM — 进程使用的物理内存百分比TIME+ — 进程使用的CPU时间总计，单位1/100秒COMMAND — 进程名称（命令名/命令行）说明:VIRT：virtual memory usage 虚拟内存1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等2、假如进程申请100m的内存，但实际只使用了10m，那么它会增长100m，而不是实际的使用量RES：resident memory usage 常驻内存1、进程当前使用的内存大小，但不包括swap out2、包含其他进程的共享3、如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反4、关于库占用内存的情况，它只统计加载的库文件所占内存大小SHR：shared memory 共享内存1、除了自身进程的共享内存，也包括其他进程的共享内存2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小3、计算某个进程所占的物理内存大小公式：RES – SHR4、swap out后，它将会降下来DATA1、数据占用的内存。如果top没有显示，按f键可以显示出来。2、真正的该程序要求的数据空间，是真正在运行中要使用的。</code></pre><h5 id="top-指令的相关参数"><a href="#top-指令的相关参数" class="headerlink" title="top 指令的相关参数"></a>top 指令的相关参数</h5><pre><code class="lang-shell">在top运行中可以使用以下命令在top中进行操作s – 改变画面更新频率l – 关闭或开启第一部分第一行 top 信息的表示t – 关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示m – 关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示N – 以 PID 的大小的顺序排列表示进程列表P – 以 CPU 占用率大小的顺序排列进程列表M – 以内存占用率大小的顺序排列进程列表h – 显示帮助n – 设置在进程列表所显示进程的数量q – 退出 top</code></pre><p>启动 top 时的参数列表</p><pre><code class="lang-bash">top [-] [options]options:d：指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。p:通过指定监控进程ID来仅仅监控某个进程的状态。q:该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。S：指定累计模式。s：使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。i：使top不显示任何闲置或者僵死进程。c:显示整个命令行而不只是显示命令名。</code></pre><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>df（英文全拼：disk free） 命令用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。</p><pre><code class="lang-shell">df [-options] options:     -a, --all 包含所有的具有 0 Blocks 的文件系统     -h, --human-readable 使用人类可读的格式(预设值是不加这个选项的...)     -i, --inodes 列出 inode 资讯，不列出已使用 block    -k, --kilobytes 就像是 --block-size=1024    -l, --local 限制列出的文件结构    -m, --megabytes 就像 --block-size=1048576</code></pre><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="==防火墙=="></a>==防火墙==</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p><strong>基本操作包括</strong>：查看防火墙状况、开启防火墙、关闭防火墙、重启防火墙、设置防火墙随系统 启动而启动、关闭防火墙随着系统的启动而启动、查看防火墙随统启动而启动。</p><pre><code class="lang-shell"># 查看防火墙的状态systemctl status firewalld# 开启防火墙systemctl start firewalld# 关闭防火墙systemctl stop firewalld# 重启防火墙systemctl restart firewalld# 设置防火墙，并且随着系统的启动而启动systemctl enable firewalld# 关闭防火墙随着系统的启动而启动，重启以后生效systemctl disable firewalld# 检查防火墙服务是否开机启动systemctl is-enabled firewalld</code></pre><h5 id="开启端口"><a href="#开启端口" class="headerlink" title="开启端口"></a>开启端口</h5><pre><code class="lang-shell">firewall-cmd [选项...]选项:    --state: 显示firewalld的状态。    --reload: 不中断服务的重新加载防火墙。    --list-ports: 查看所有打开的端口。    --zone: 作用域：block dmz drop external home internal public trusted work    --add-port=80/tcp :添加端口，格式为：端口/通讯协议。    --permanent: 永久生效，没有此参数重启后失效。    --query-service: 查看对应的服务，比如：ftp、ssh服务。#查看已经打开的端口firewall-cmd --zone=public --list-ports# 查看8080端口有没有打开firewall-cmd --query-port=8080/tcp# 如果不需要了，可以删除防火墙上面开辟的8080端口firewall-cmd --zone=public --remove-port=8080/tcp --permanent</code></pre><h3 id="系统的启动与配置"><a href="#系统的启动与配置" class="headerlink" title="系统的启动与配置"></a>系统的启动与配置</h3><ol><li><strong>硬件启动阶段</strong>：开机，然后初始化硬件设备，然后检查硬件设备，比如：CPU、内存、硬 盘、键盘等设备。</li><li><strong>GRUB 引导阶段</strong>：硬件启动后，通过执行固件里面的指令跳转到 BIOS，然后 BIOS 找到启动设 备并获取 MBR，MBR 又指向 GRUB。当 GRUB 获得引导控制权后，会现实 GRUB 的提示符，此时 如果用户不做任何操作，GRUB 将在等待指定时间后自动引导默认的操作系统，如果此时按 TAB 键，则可以看到一个可引导的操作系统的列表，用户可以选择相应的操作系统。如果用户选择了 某个 Linux 操作系统，GRUB 就会从/boot 分区里面读取并装载的压缩内核，然后压缩的内核解 压，加载内核镜像到内存，之后构建虚拟根文件系统，然后把控制权交给内核。</li><li><strong>内核引导阶段</strong>：通过内存中的虚拟根文件系统，加载驱动，然后切换到真正的根文件系统， 然后执行的初始化程序/sbin/init（其实指向的是/usr/lib/systemd/systemd）。</li><li><strong>systemed 初始化阶段</strong>：又叫系统初始化阶段，CentOS7 中我们的初始化进程为 systemd （天字号排行第一的进程，因为其 PID 为 1，可以通过 top 命令查看），然后系统执行默认 target 配置文件（/etc/systemd/system/default.target），然后根据这个默认的 target，引导系 统启动并进入<strong>指定的运行级别</strong>，并启动相应的服务程序。然后等待用户登录使用。</li></ol><h3 id="系统的运行级别"><a href="#系统的运行级别" class="headerlink" title="==系统的运行级别=="></a>==系统的运行级别==</h3><div class="table-container"><table><thead><tr><th style="text-align:center">级别</th><th style="text-align:center">描述</th><th style="text-align:center">详解</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center"><strong>系统停机模式</strong></td><td style="text-align:center">系统关机状态，系统默认运行级别不能设置为 0，否则不能正常启动。</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">单用户模式</td><td style="text-align:center">root 权限，用于系统维护，禁止远程登陆，就像 Windows 下的安全 模式登录。</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">多用户模式</td><td style="text-align:center">多用户状态，但是没有 NFS 和网络支持。</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center"><strong>完全多用户模式</strong></td><td style="text-align:center">有 NFS 和网络，登陆后进入控制台命令行模式（如果默认是命令行则 它是默认的）。</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">系统未使用</td><td style="text-align:center">保留一般不用，在一些特殊情况下可以用它来做一些事情。</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center"><strong>图形化模式</strong></td><td style="text-align:center">登陆后进入图形用户模式，X Window 系统。</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center"><strong>重启模式</strong></td><td style="text-align:center">默认运行级别不能设为 6，否则不能正常启动。运行 init 6 机器就会 重启。</td></tr></tbody></table></div><pre><code class="lang-shell">#使用启动级别来关机、重启、进入命令行模式、进入图形用户模式# 关机init 0#复习 还有 halt\poweroff\shutdown -h now# 重启init 6#复习 还有reboot\shutdown -r now# 进入命令行模式init 3# 进入图形用户模式init 5</code></pre><p>每个运行级别都有属于自己的 target 文件，这些 target 文件都是以链接文 件的形式保存在<code>“/lib/systemd/system”</code>目录。运行级别的设置由<code>“/etc/systemd/system/default.target”</code>来控制，default.target 里面配置的是什么运行级别，系统启动的时候就运行哪个运行级别。</p><p><strong>“/lib/systemd/system”定义好的运行级别文件：</strong></p><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-03-21_11-04-22.png" alt></p><p>default.target 指向的默认的一个运行级别。</p><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-03-21_11-05-36.png" alt></p><p>由于不同的运行级别将要启动的服务不尽相同，所以，为了合理的管理各个运行级别的服务进 程，系统为每一个运行级别在目录下准备了一个目录用于存放各自的服务程序，命名规范是 “rcn.d”（n 代表 0~6 的七个运行级别），具体如下图所示。</p><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-03-21_11-07-05.png" alt></p><p>在运行级别对应的目录中，<strong>所有文件的命名规则是“Snnxxxx” 和“Knnxxxx” 。其中，以 “S”开头的文件是系统启动时调用的服务程序，以“K”开头的文件是系统终止时调用的服务程序。 nn 是 00 ～ 99 之间的一个整数，数字 nn 的大小决定程序执行的先后顺序。xxx 是服务程序的名 称。</strong> 由于各个运行级别中的服务程序集合有可能存在交集，所以为了节省硬盘空间和便于更新服务 程序，在 rcn.d 目录中存放的只是各个服务程序的链接文件，我们装 CentOS7 的默认运行级别是 “完全多用户模式”，我们进入它对应的目录“/etc/rc.d/rc3.d”，如下图所示。</p><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-03-21_11-09-02.png" alt></p><h4 id="查看系统默认运行级别"><a href="#查看系统默认运行级别" class="headerlink" title="查看系统默认运行级别"></a><strong>查看系统默认运行级别</strong></h4><pre><code class="lang-shell">runlevel</code></pre><h4 id="设置系统运行级别"><a href="#设置系统运行级别" class="headerlink" title="设置系统运行级别"></a>设置系统运行级别</h4><h5 id="systemctl-设置"><a href="#systemctl-设置" class="headerlink" title="systemctl 设置"></a>systemctl 设置</h5><pre><code class="lang-shell"># 设置默认第三启动级别systemctl set-default multi-user.target# 设置默认第五启动级别systemctl set-default graphical.target# 查看当前默认的启动级别systemctl get-default</code></pre><h5 id="重置软链接文件"><a href="#重置软链接文件" class="headerlink" title="重置软链接文件"></a>重置软链接文件</h5><pre><code class="lang-shell">#设置完全多用户模式为默认的运行级别# 先删除原有的软链接文件rm -rf /etc/systemd/system/default.target# 创建软连接文件ln -s /usr/lib/systemd/system/multi-user.target/etc/systemd/system/default.target# 重启reboot</code></pre><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="网卡的配置"><a href="#网卡的配置" class="headerlink" title="网卡的配置"></a>网卡的配置</h4><h5 id="网卡配置文件"><a href="#网卡配置文件" class="headerlink" title="网卡配置文件"></a>网卡配置文件</h5><p>网卡的配置信息，通常包括 IP 地址、子网掩码、网关。这些网卡信息保存在配置文件中，这个 网卡的配置文件位于<strong>/etc/sysconfig/network-scripts</strong>，我们的 CentOS7 的网卡配置信息就在 <strong>ifcfg-ens33</strong>文件中。</p><p><strong>查看 ifcfg-ens33 的内容</strong></p><pre><code class="lang-shell">cat /etc/sysconfig/network-scripts/ifcfg-ens33</code></pre><p><strong>显示内容</strong>:</p><pre><code class="lang-shell">TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;dhcp&quot;DEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;1bedffd6-a745-41a6-b981-e3fff4e13b71&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;IPV6_PRIVACY=&quot;no&quot;</code></pre><p><strong>配置信息</strong></p><div class="table-container"><table><thead><tr><th>配置项</th><th>介绍</th></tr></thead><tbody><tr><td>DEVICE</td><td>定义该网卡的识别名称。</td></tr><tr><td>TYPE</td><td>网卡类型。</td></tr><tr><td>BOOTPROTO</td><td>启动该网卡的方式。有 static/none 表示固定 IP 地址；bootp/dhcp 表示通 过 BOOTP 或者 DHCP 协议动态获取 IP 地址。 如果自己设置就用 static，如果想自动获取就用 dhcp。</td></tr><tr><td>ONBOOT</td><td>启动 NetworkManager 的时候，是否启动该网卡。有些情况下安装 CentOS 的时候网络老是不启动这个时候，就可以看这个配置项是否是 “yes”</td></tr><tr><td>IPADDR</td><td>静态方式设置指定的 IP 地址。</td></tr><tr><td>NETMASK</td><td>指定子网掩码。</td></tr><tr><td>GATEWAY</td><td>指定默认网关。</td></tr><tr><td>DNS1</td><td>配置 DNS 服务器</td></tr></tbody></table></div><p><strong>设置静态 IP</strong></p><p>安装的时候，我们设置的是网络采取的是“dhcp”网络配置方式，这种方式 IP 是动态设置的，这 个在我们以后的集群里面是不行的，所以我们设置成静态 ip，具体的步骤如下：</p><pre><code class="lang-shell"># 进入网络配置目录cd /etc/sysconfig/network-scripts/# 查看网络配置文件ls -al# 编辑网络配置文件vi + /etc/sysconfig/network-scripts/ifcfg-ens33</code></pre><pre><code class="lang-shell">TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;# 注意这个要注释或者删除#BOOTPROTO=&quot;dhcp&quot;DEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;e9ce67e1-7d2a-41b4-9989-dfbc75278d80&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;IPV6_PRIVACY=&quot;no&quot;# 配置静态的IPBOOTPROTO=&quot;static&quot;# IP地址IPADDR=192.168.60.100# 子网掩码NETMASK=255.255.255.0# 默认网关GATEWAY=192.168.60.1# 配置DNSDNS1=8.8.8.8</code></pre><p><strong>重启网络与重新登陆</strong></p><pre><code class="lang-shell"># 重启网络：systemctl restart network# 重新登录ssh root@192.168.60.100</code></pre><h5 id="ifconfig-命令"><a href="#ifconfig-命令" class="headerlink" title="ifconfig 命令"></a>ifconfig 命令</h5><p>ifconfig 命令（来源于 net-tools 软件包，默认的精简版的 CentOS7 里面是没遇的，得先安装） 功能比较的强大，用于显示或设置网络设备。</p><pre><code class="lang-shell">yum -y install net-tools</code></pre><p><strong>查看网卡信息</strong></p><p><strong>命令格式</strong>：</p><pre><code class="lang-shell">ifconfig [选项]</code></pre><p><strong>选项说明</strong>:</p><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">无选项</td><td>显示当前活动的网卡信息。</td></tr><tr><td style="text-align:center">-a</td><td>显示系统中所有的网卡配置信息。</td></tr><tr><td style="text-align:center">网卡设备名</td><td>显示指定网卡的配置信息。</td></tr></tbody></table></div><p><strong>设置 IP 地址</strong></p><p><strong>命令格式</strong>：</p><pre><code class="lang-shell">ifconfig 网卡设备名 IP地址 netmask 子网掩码#使用ifconfig将ens33网卡的ip改成192.168.60.133，子网掩码改成255.255.255.0ifconfig ens33 192.168.60.133 netmask 255.255.255.0</code></pre><blockquote><p>注意：这种方式设置 IP 只是临时性的，如果重启机器，IP 又会恢复到原来的 IP。</p></blockquote><h5 id="ifdown"><a href="#ifdown" class="headerlink" title="ifdown"></a><strong>ifdown</strong></h5><p>用于禁用网卡</p><p><strong>命令格式</strong>：</p><pre><code class="lang-shell">ifdown 网卡设备名#禁用ens33ifdown ens33</code></pre><h5 id="ifup"><a href="#ifup" class="headerlink" title="ifup"></a>ifup</h5><p>重新启用网卡</p><pre><code class="lang-shell">ifup 网卡设备名#重新启用ens33ifup ens33</code></pre><h5 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h5><p>ping 命令用于检测主机。执行 ping 指令会发出要求回应的信息，若远端主机的网络功能没有问 题，就会回应该信息，因而得知该主机运作正常。</p><p><strong>命令格式</strong>：</p><pre><code class="lang-shell">ping [选项] 主机ip地址、主机名、或者域名选项说明：-c：指定向目标主机发送的报文次数。-s：指定发送报文的大小，单位字节。-W：设置等待接收响应报文的时间间隔，单位秒。</code></pre><blockquote><p>ping 命令默认情况下是一直往目标地址发生 ping 请求，然后数据包的大小是 64KB，直到按” Ctrl+c“才退出。</p></blockquote><h3 id="软件的安装"><a href="#软件的安装" class="headerlink" title="软件的安装"></a>软件的安装</h3><p>Linux 各个不同版本中内置了一些不同的工具用于下载和安装软件</p><h4 id="文件的下载"><a href="#文件的下载" class="headerlink" title="文件的下载"></a>文件的下载</h4><h5 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h5><p>wget 是 Linux 中的一个下载文件的工具，wget 是在 Linux 下开发的开放源代码的软件，作者是 Hrvoje Niksic，后来被移植到包括 Windows 在内的各个平台上。</p><p>wget 工具体积小但功能完善，它支持断点下载功能，同时支持 FTP 和 HTTP 下载方式</p><p><strong>安装 wget</strong></p><pre><code class="lang-shell">yum install -y wget</code></pre><p><strong>命令格式</strong></p><pre><code class="lang-shell">wget [参数] [URL地址]</code></pre><p><strong>使用实例</strong>:</p><p><strong>实例 1：使用 wget 下载单个文件</strong></p><p>以下的例子是从网络下载一个文件并保存在当前目录，在下载的过程中会显示进度条，包含下载完成百分比，已经下载的字节，当前下载速度和剩余下载时间：</p><pre><code class="lang-shell">wget http://www.minjieren.com/wordpress-3.1-zh_CN.zip</code></pre><p><strong>实例 2：使用 wget -O 下载并以不同的文件名保存</strong></p><p>wget 默认会以最后一个符合”/”的后面的字符来命名，对于动态链接的下载通常文件名会不正确<br>下面的例子会下载一个文件并以名称 download.aspx?id=1080 保存，即使下载的文件是 zip 格式，它仍然以 download.php?id=1080 命令：</p><pre><code class="lang-shell">wget http://www.minjieren.com/download?id=1</code></pre><p>为了解决这个问题，我们可以使用参数-O 来指定一个文件名：</p><pre><code class="lang-shell">wget -O wordpress.zip http://www.minjieren.com/download.aspx?id=1080</code></pre><p><strong>实例 3：使用 wget –limit -rate 限速下载</strong></p><p>当你执行 wget 的时候，它默认会占用全部可能的宽带下载。但是当你准备下载一个大文件，而你还需要下载其它文件时就有必要限速了：</p><pre><code class="lang-shell">wget --limit-rate=300k http://www.minjieren.com/wordpress-3.1-zh_CN.zip</code></pre><p><strong>实例 4：使用 wget -c 断点续传</strong></p><p>使用 wget -c 重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用-c 参数</p><pre><code class="lang-shell">wget -c http://www.minjieren.com/wordpress-3.1-zh_CN.zip</code></pre><p><strong>实例 5：使用 wget -b 后台下载</strong></p><p>对于下载非常大的文件的时候，我们可以使用参数-b 进行后台下载</p><pre><code class="lang-shell">wget -b http://www.minjieren.com/wordpress-3.1-zh_CN.zipwget -b http://www.minjieren.com/wordpress-3.1-zh_CN.zipContinuing in background, pid 1840.Output will be written to `wget-log&#39;.</code></pre><p>你可以使用以下命令来察看下载进度：</p><pre><code class="lang-shell">tail -f wget-log</code></pre><p><strong>实例 6：伪装代理名称下载</strong></p><p>有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过–user-agent 参数伪装。</p><pre><code class="lang-shell">wget --user-agent=&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot; http://www.minjieren.com/wordpress-3.1-zh_CN.zip</code></pre><p><strong>实例 7：使用 wget –spider 测试下载链接</strong></p><p>当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加–spider 参数进行检查。</p><pre><code class="lang-shell">wget --spider URL</code></pre><p>如果下载链接正确，将会显示：</p><pre><code class="lang-shell">wget --spider URLSpider mode enabled. Check if remote file exists.HTTP request sent, awaiting response... 200 OKLength: unspecified [text/html]Remote file exists and could contain further links,but recursion is disabled -- not retrieving.</code></pre><p>这保证了下载能在预定的时间进行，但当你给错了一个链接，将会显示如下错误：</p><pre><code class="lang-shell">wget --spider urlSpider mode enabled. Check if remote file exists.HTTP request sent, awaiting response... 404 Not FoundRemote file does not exist -- broken link!!!</code></pre><p>你可以在以下几种情况下使用 spider 参数：</p><ul><li>定时下载之前进行检查</li><li>间隔检测网站是否可用</li><li>检查网站页面的死链接</li></ul><p><strong>实例 8：使用 wget –tries 增加重试次数</strong></p><p>如果网络有问题或下载一个大文件也有可能失败。wget 默认重试 20 次连接下载文件。如果需要，你可以使用–tries 增加重试次数：</p><pre><code class="lang-shell">wget --tries=40 URL</code></pre><p><strong>实例 9：使用 wget -i 下载多个文件</strong></p><p>首先，保存一份下载链接文件：</p><pre><code class="lang-shell">cat &gt; filelist.txturl1url2url3url412345</code></pre><p>接着使用这个文件和参数-i 下载：</p><pre><code>wget -i filelist.txt1</code></pre><p><strong>实例 10：使用 wget –mirror 镜像网站</strong></p><p>下载整个网站到本地：</p><pre><code>wget --mirror -p --convert-links -P ./LOCAL URL1</code></pre><p>说明：</p><p>–miror:开户镜像下载</p><p>-p:下载所有为了 html 页面显示正常的文件</p><p>–convert-links:下载后，转换成本地的链接</p><p>-P ./LOCAL：保存所有文件和目录到本地指定目录</p><p><strong>实例 11：使用 wget –reject 过滤指定格式下载</strong></p><p>下载一个网站，但你不希望下载图片，可以使用以下命令：</p><pre><code class="lang-shell">wget --reject=gif url</code></pre><p><strong>实例 12：使用 wget -o 把下载信息存入日志文件</strong></p><p>不希望下载信息直接显示在终端而是在一个日志文件，可以使用：</p><pre><code class="lang-shell">wget -o download.log URL</code></pre><p><strong>实例 13：使用 wget -Q 限制总下载文件大小</strong></p><p>命令：</p><pre><code class="lang-shell">wget -Q5m -i filelist.txt</code></pre><p>说明：</p><p>当你想要下载的文件超过 5M 而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。</p><p><strong>实例 14：使用 wget -r -A 下载指定格式文件</strong></p><p>Example：</p><pre><code class="lang-shell">wget -r -A.pdf url</code></pre><p>可以在以下情况使用该功能：</p><ul><li>下载一个网站的所有图片</li><li>下载一个网站的所有视频</li><li>下载一个网站的所有 PDF 文件</li></ul><p><strong>实例 15：使用 wget FTP 下载</strong></p><p>使用 wget 匿名 ftp 下载：</p><pre><code class="lang-shell">wget ftp-url</code></pre><p>使用 wget 用户名和密码认证的 ftp 下载</p><pre><code class="lang-shell">wget --ftp-user=USERNAME --ftp-password=PASSWORD url</code></pre><h5 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h5><p><code>cURL</code>是用于数据传输的命令行工具，支持多种传输协议，包括 HTTP、HTTPS、SCP、FTP、SFTP、TELNET、FILE、SMTP、POP3 等等。可以使用<code>cURL</code>进行<code>HTTP/HTTPS</code>请求、上传/下载文件等，且支持<code>Cookie</code>、用户身份验证、代理支持、限速等。</p><p><strong>基本语法</strong>:</p><pre><code class="lang-shell">curl [options] [URL...]</code></pre><p><strong>常见用法</strong>:</p><pre><code class="lang-shell">#1、下载(option:-o或者option:-O)#1.1、下载页面：curl -o dodo1.jpg http:www.linux.com/dodo1.JPG#要注意-O这里后面的url要具体到某个文件，不然抓不下来curl -O http://www.linux.com/dodo1.JPG#1.2：循环下载#有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样。这样就会把dodo1，dodo2，dodo3，dodo4，dodo5全部保存下来curl -O http://www.linux.com/dodo[1-5].JPG#1.3：下载重命名#在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖curl -o #1_#2.JPG http://www.linux.com/&#123;hello,bb&#125;/dodo[1-5].JPG#由于下载的hello与bb中的文件名都是dodo1，dodo2，dodo3，dodo4，dodo5。因此第二次下载的会把第一次下载的覆盖，这样就需要对文件进行重命名。curl -O http://www.linux.com/&#123;hello,bb&#125;/dodo[1-5].JPG#1.4：分块下载(option：-r)curl -r 0-100 -o dodo1_part1.JPG http://www.linux.com/dodo1.JPGcurl -r 100-200 -o dodo1_part2.JPG http://www.linux.com/dodo1.JPGcurl -r 200- -o dodo1_part3.JPG http://www.linux.com/dodo1.JPGcat dodo1_part* &gt; dodo1.JPG  #这样就可以查看dodo1.JPG的内容了#1.5：通过ftp下载文件(option：-u)curl可以通过ftp下载文件，curl提供两种从ftp中下载的语法curl -O -u 用户名:密码 ftp://www.linux.com/dodo1.JPGcurl -O ftp://用户名:密码@www.linux.com/dodo1.JPG#1.6:下载，显示进度条(option：-#)或不显示进度条(option：-s)curl -# -O http://www.linux.com/dodo1.JPGcurl -s -O http://www.linux.com/dodo1.JPG#1.7、下载，断点续传(-C &lt;offset&gt;)断点续转，从文件头的指定位置开始继续下载/上传；offset续传开始的位置，如果offset值为“-”，curl会自动从文件中识别起始位置开始传输；curl -# -o centos6.8.iso -C - http://mirrors.aliyun.com/centos/6.8/isos/x86_64/CentOS-6.8-x86_64-minimal.isocurl -C -O http://www.linux.com/dodo1.JPG#2、上传文件(option:-T)curl -T dodo1.JPG -u 用户名:密码 ftp://www.linux.com/img/#3、伪造来源页面|伪造referer|盗链 (option：-e)#很多服务器会检查http访问的referer从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了#这样就会让服务器其以为你是从www.linux.com点击某个链接过来的curl -e &quot;www.linux.com&quot; http://mail.linux.com#告诉爱E族，我是从百度来的curl -e http://baidu.com http://aiezu.com#4、伪造代理设备(模仿浏览器)#有些网站需要使用特定的浏览器去访问他们，有些还需要使用某些特定的版本。curl内置option:-A可以让我们指定浏览器去访问网站curl -A &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)&quot; http://www.linux.com#告诉爱E族，我是GOOGLE爬虫蜘蛛（其实我是curl命令）curl -A &quot; Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)&quot; http://aiezu.com#告诉爱E族，我用的是微信内置浏览器curl -A &quot;Mozilla/5.0 AppleWebKit/600 Mobile MicroMessenger/6.0&quot; http://aiezu.com#5、设置http请求#5.1、设置http请求头(或option:-H或option:--head)curl -H &quot;Cache-Control:no-cache&quot;  http://aiezu.com#5.2、指定proxy服务器以及其端口(option::-x)#很多时候上网需要用到代理服务器(比如是使用代理服务器上网或者因为使用curl别人网站而被别人屏蔽IP地址的时候)，幸运的是curl通过使用内置option：-x来支持设置代理curl -x 192.168.100.100:1080 http://www.linux.com#6、http响应头#6.1、查看http响应头(option:-I)# 看看本站的http头是怎么样的curl -I  http://aiezu.com输出：HTTP/1.1 200 OKDate: Fri, 25 Nov 2016 16:45:49 GMTServer: ApacheSet-Cookie: rox__Session=abdrt8vesprhnpc3f63p1df7j4; path=/Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0Pragma: no-cacheVary: Accept-EncodingContent-Type: text/html; charset=utf-8#6.2、保存http的response里面的header信息(option:-D)curl -D cookied.txt http://www.linux.com执行后cookie信息就被存到了cookied.txt里面了注意：-c(小写)产生的cookie和-D里面的cookie是不一样的。#7、发送表单数据curl -F &quot;pic=@logo.png&quot; -F &quot;site=aiezu&quot;  http://aiezu.com/#8、cookie#8.1、发送cookie(option:-b）#有些网站是使用cookie来记录session信息。对于chrome这样的浏览器，可以轻易处理cookie信息，但在curl中只要增加相关参数也是可以很容易的处理cookiecurl -b &quot;domain=aiezu.com&quot;  http://aiezu.com#很多网站都是通过监视你的cookie信息来判断你是否按规矩访问他们的网站的，因此我们需要使用保存的cookie信息。内置option: -bcurl -b cookiec.txt http://www.linux.com#8.2、保存http的response里面的cookie信息(option:-c）#执行后http的response里面的cookie信息就被存到了cookiec.txt里面了curl -c cookiec.txt  http://www.linux.com#9、测试一个网址#9.1、测试一个网址是否可达curl -v http://www.linux.com#9.2、测试网页返回值(option:-w [format])curl -o /dev/null -s -w %&#123;http_code&#125; www.linux.com#10、保存访问的网页(&gt;&gt;)#2.1:使用linux的重定向功能保存curl http://www.linux.com &gt;&gt; linux.html</code></pre><h4 id="RedHat"><a href="#RedHat" class="headerlink" title="RedHat"></a>RedHat</h4><h5 id="rpm"><a href="#rpm" class="headerlink" title="==rpm=="></a>==rpm==</h5><p>rpm（英文全拼：redhat package manager） 原本是<code>Red Hat Linux</code>发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。包的格式为<code>*.rpm</code></p><p><strong>命令格式</strong>:</p><pre><code class="lang-SHELL">rpm [选项] [文件/软件包]</code></pre><p><strong>常见选项</strong>:</p><div class="table-container"><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><strong>-a</strong></td><td>(all)显示所有软件包。</td></tr><tr><td><strong>-q</strong></td><td>(query)查询功能。</td></tr><tr><td><strong>-i</strong></td><td>安装指定的软件包。通常和-v，-h 选项结合使用。</td></tr><tr><td><strong>-e</strong></td><td>(erase)删除指定的软件包。</td></tr><tr><td><strong>-f</strong></td><td>查询拥有指定文件的软件包。</td></tr><tr><td><strong>-l</strong></td><td>(list)显示软件包的文件列表。</td></tr><tr><td>-p</td><td>查询待安装的软件包。</td></tr><tr><td>-s</td><td>显示文件状态，通常结合-l 选项使用。</td></tr><tr><td>-U</td><td>升级指定的软件包。</td></tr><tr><td><strong>-h</strong></td><td>在安装过程中将显示一系列的“#”来表示安装进度。</td></tr><tr><td><strong>-v</strong></td><td>显示指令执行过程。</td></tr><tr><td>-vv</td><td>详细显示指令执行过程，便于排错。</td></tr><tr><td><strong>—nodeps</strong></td><td>强制删除，不管它的依赖关系。</td></tr></tbody></table></div><p><strong>常用命令</strong>:</p><pre><code class="lang-shell">#查询系统中已经安装的全部RPM包rpm -qa#结合管道符进行查询rpm -qa | morerpm -qa | lessrpm -qa | wc -l#结合全局正则表达式进行查询rpm -qa | grep python#查询是否安装特定(多个)的软件包rpm -q openssh-server [openssh-clients ...] #软件包间空格隔开#查询软件包的描述信息rpm -qi openssh-server#查询已经安装的软件包的文件列表(即查询软件包的安装目录)rpm -ql 软件包名称#查询某个文件所属的软件包rpm -qf 文件#安装软件包rpm -ivh 软件包名称rpm -ivh jdk-8u221-linux-x64.rpm#卸载软件包rpm -e 软件包名称</code></pre><blockquote><p>rpm 安装软件包过程总结(以安装 jdk8 为例)</p><p>1、把 jdk 解压到“/usr/java/jdk1.8.0_221-amd64”。</p><p>2、在“/etc/alternatives/”创建链接指向解压目录“/usr/java/jdk1.8.0_221-amd64”。</p><p>3、然后在“/usr/bin/”目录下创建链接指向“/etc/alternatives/”。</p><p>4、由于“/usr/bin/”已经被添加到环境变量里面去，我们可以直接使用。</p></blockquote><h5 id="yum"><a href="#yum" class="headerlink" title="==yum=="></a>==yum==</h5><p>yum（ Yellow dog Updater, Modified）是一个在 <code>Fedora</code> 和 <code>RedHat</code> 以及 <code>SUSE</code> 中的 Shell 前端软件包管理器。<code>基于 RPM 包管理</code>，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p><p>yum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p><pre><code class="lang-shell">yum [options] [command] [package ...]    options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为 &quot;yes&quot;），-q（不显示安装的过程）等等。    command：要进行的操作。    package：安装的包名。#yum常用命令#1. 列出所有可更新的软件清单命令：yum check-update#2. 更新所有软件命令：yum update#3. 仅安装指定的软件命令：yum install &lt;package_name&gt;#4. 仅更新指定的软件命令：yum update &lt;package_name&gt;#5. 列出所有可安裝的软件清单命令：yum list#6. 删除软件包命令：yum remove &lt;package_name&gt;#7. 查找软件包命令：yum search &lt;keyword&gt;#8. 清除缓存命令:yum clean packages: 清除缓存目录下的软件包yum clean headers: 清除缓存目录下的 headersyum clean oldheaders: 清除缓存目录下旧的 headersyum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers</code></pre><h4 id="Debian、Ubuntu"><a href="#Debian、Ubuntu" class="headerlink" title="Debian、Ubuntu"></a>Debian、Ubuntu</h4><h5 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a>dpkg</h5><p>dpkg 命令的英文全称是“Debian package”，故名意思是 Debian Linux 系统用来安装、创建和管理软件包的实用工具。能直接本地安装<code>*.deb</code>的包文件</p><pre><code class="lang-shell">dpkg [参数] [包名]常用参数：    -i    安装软件包    -r    删除软件包    -l    显示已安装软件包列表    -L    显示于软件包关联的文件    -c    显示软件包内文件列表#安装包dpkg -i package.deb#删除包dpkg -r package.deb#列出当前已安装的包dpkg -l#列出deb包的内容dpkg -c package.deb#配置dpkg --configure package</code></pre><h5 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h5><p>apt（Advanced Packaging Tool）是一个在 <code>Debian</code> 和<code>Ubuntu</code>中的 Shell 前端软件包管理器。</p><p>apt 命令提供了查找、安装、升级、删除某一个、一组甚至全部<code>软件包(*.deb)</code>的命令，而且命令简洁而又好记。</p><p>apt 命令执行需要超级管理员权限(root)。</p><p><code>apt</code> = <code>apt-get</code>+ <code>apt-cache</code> + <code>apt-config</code> 中最常用命令选项的集合</p><p><strong>基本格式</strong></p><pre><code class="lang-shell">apt [options] [command] [package ...]    options：可选，选项包括 -h（帮助），-y（当安装过程提示选择全部为&quot;yes&quot;），-q（不显示安装的过程）等等。    command：要进行的操作。    package：安装的包名。</code></pre><p><strong>常用命令</strong>:</p><pre><code class="lang-shell">#列出所有可更新的软件清单命令,刷新存储库索引sudo apt update#列出可更新的软件包及版本信息：apt list --upgradeable#升级所有可升级的软件包sudo apt upgrade#升级软件包，在升级软件包时自动处理依赖关系：sudo apt full-upgrade#安装指定的软件命令：sudo apt install &lt;package_name&gt;#安装多个软件包：sudo apt install &lt;package_1&gt; &lt;package_2&gt; &lt;package_3&gt;#更新指定的软件命令：sudo apt update &lt;package_name&gt;#显示软件包具体信息,例如：版本号，安装大小，依赖关系等等：sudo apt show &lt;package_name&gt;#删除软件包命令：sudo apt remove &lt;package_name&gt;#清理不再使用的依赖和库文件:sudo apt autoremove#移除软件包及配置文件:sudo apt purge &lt;package_name&gt;#自动删除不需要的包sudo apt autoremove#查找软件包命令：sudo apt search &lt;keyword&gt;#列出所有已安装的包：apt list --installed#列出所有已安装的包的版本信息：apt list --all-versions</code></pre><h3 id="挂载"><a href="#挂载" class="headerlink" title="==挂载=="></a>==挂载==</h3><p>挂载在 Linux 系统中是一个比较重要的操作，我们 使用 CentOS 使需要插入 U 盘了，由于我们使用的是命令行不像 Windows 有图形用户界面，那 么直观的帮助用户使用。或者当我们的硬盘满了的时候，我们可能就需要加硬盘,这个需要使用挂载这个功能。</p><h4 id="挂载点"><a href="#挂载点" class="headerlink" title="挂载点"></a>挂载点</h4><p>由于 Linux 操作系统只有一个根目录(/)，所以当向系统中添加新的存储设备时，不会像 Windows 操作系统那样出现一个新的根目录或者盘符（比如：K 盘，L 盘等）。因此，在 Linux 下 访问新存储设备时需要首先创建挂载点。</p><p><strong>所谓的挂载点就是文件系统中存在的一个目录</strong>,通常情况下，创建在/mnt 目录下，挂载成功后,访问挂载点就是访问新的存储设备。挂载点应该是空目录,否则原来该挂载点中存在的文件将会被隐藏。而且,挂载点在实施挂载操作之前就应该存在。</p><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>Linux fdisk 是一个创建和维护分区表的命令，它兼容 DOS 类型的分区表、BSD 或者 SUN 类型的 磁盘列表。fdisk 能划分的最大分区为<strong><code>2T</code></strong></p><pre><code class="lang-shell">fdisk [必要参数][选择参数]必要参数：    -l 列出所有分区表    -u 与 -l 搭配使用，显示分区数目选择参数：    -s&lt;分区编号&gt; 指定分区    -v 版本信息</code></pre><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-03-21_11-17-25.png" alt></p><p>我们可以发现系统中有两块硬盘分别是：/dev/sda1 与/dev/sda2，大小分别是 19.1G 与 2G 左 右，前面的是“根节点‘/’”，后面的分区是交换区。</p><pre><code class="lang-shell">#输入fdisk /指定设备#可进入该设备以执行分区的相关操作</code></pre><h4 id="parted"><a href="#parted" class="headerlink" title="parted"></a>parted</h4><ul><li><p><code>parted</code> 命令可以创建全局惟一的标识符分区表 <a href="https://en.wikipedia.org/wiki/GUID_Partition_Table">GPT</a>，而 <code>fdisk</code> 和 <code>cfdisk</code> 则仅限于 DOS 分区表。</p></li><li><p><strong>更大的磁盘：</strong> DOS 分区表可以格式化最多 2TB 的磁盘空间，尽管在某些情况下最多可以达到 16TB。然而，一个 GPT 分区表可以处理最多 8ZB 的空间。</p></li><li><p><strong>更多的分区：</strong> 使用主分区和扩展分区，DOS 分区表只允许 16 个分区。在 GPT 中，默认情况下您可以得到 128 个分区，并且可以选择更多的分区。</p></li><li><p><strong>可靠性：</strong> 在 DOS 分区表中，只保存了一份分区表备份，在 GPT 中保留了两份分区表的备份（在磁盘的起始和结束部分），同时 GPT 还使用了 <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC</a> 校验和来检查分区表的完整性，在 DOS 分区中并没有实现。</p><h6 id="1、列出分区"><a href="#1、列出分区" class="headerlink" title="1、列出分区"></a>1、列出分区</h6><p>使用 <code>parted -l</code> 来标识你要进行分区的设备。一般来说，第一个硬盘 （<code>/dev/sda</code> 或 <code>/dev/vda</code> ）保存着操作系统， 因此要寻找另一个磁盘，以找到你想要分区的磁盘 (例如，<code>/dev/sdb</code>、<code>/dev/sdc</code>、 <code>/dev/vdb</code>、<code>/dev/vdc</code> 等)。</p><pre><code class="lang-shell">$ sudo parted -l[sudo] password for daniel:Model: ATA RevuAhn_850X1TU5 (scsi)Disk /dev/vdc: 512GBSector size (logical/physical): 512B/512BPartition Table: msdosDisk Flags:Number  Start   End    Size   Type     File system  Flags 1      1049kB  525MB  524MB  primary  ext4         boot 2      525MB   512GB  512GB  primary               lvm</code></pre><h5 id="2、打开存储设备"><a href="#2、打开存储设备" class="headerlink" title="2、打开存储设备"></a>2、打开存储设备</h5><p>使用 <code>parted</code> 选中要分区的设备。在这里例子中，是虚拟系统上的第三个磁盘（<code>/dev/vdc</code>）。指明要使用哪一个设备非常重要。 如果你仅仅输入了 <code>parted</code> 命令而没有指定设备名字， 它会<strong>随机</strong>选择一个设备进行操作。</p><pre><code class="lang-shell">$ sudo parted /dev/vdcGNU Parted 3.2Using /dev/vdcWelcome to GNU Parted! Type &#39;help&#39; to view a list of commands.(parted)</code></pre><h5 id="3、-设定分区表"><a href="#3、-设定分区表" class="headerlink" title="3、 设定分区表"></a>3、 设定分区表</h5><p>设置分区表为 GPT ，然后输入 <code>Yes</code> 开始执行。</p><pre><code class="lang-shell">(parted) mklabel gptWarning: the existing disk label on /dev/vdc will be destroyedand all data on this disk will be lost. Do you want to continue?Yes/No? Yes</code></pre><p><code>mklabel</code> 和 <code>mktable</code> 命令用于相同的目的（在存储设备上创建分区表）。支持的分区表有：aix、amiga、bsd、dvh、gpt、mac、ms-dos、pc98、sun 和 loop。记住 <code>mklabel</code> 不会创建一个分区，而是创建一个分区表。</p><h5 id="4、-检查分区表"><a href="#4、-检查分区表" class="headerlink" title="4、 检查分区表"></a>4、 检查分区表</h5><p>查看存储设备信息:</p><pre><code class="lang-shell">(parted) printModel: Virtio Block Device (virtblk)Disk /dev/vdc: 1396MBSector size (logical/physical): 512B/512BPartition Table: gptDisk Flags:Number Start End Size File system Name Flags</code></pre><h5 id="5、-获取帮助"><a href="#5、-获取帮助" class="headerlink" title="5、 获取帮助"></a>5、 获取帮助</h5><p>为了知道如何去创建一个新分区，输入： <code>(parted) help mkpart</code> 。</p><pre><code class="lang-shell">(parted) help mkpart  mkpart PART-TYPE [FS-TYPE] START END     make a partition        PART-TYPE is one of: primary, logical, extended        FS-TYPE is one of: btrfs, nilfs2, ext4, ext3, ext2, fat32, fat16, hfsx, hfs+, hfs, jfs, swsusp,        linux-swap(v1), linux-swap(v0), ntfs, reiserfs, hp-ufs, sun-ufs, xfs, apfs2, apfs1, asfs, amufs5,        amufs4, amufs3, amufs2, amufs1, amufs0, amufs, affs7, affs6, affs5, affs4, affs3, affs2, affs1,        affs0, linux-swap, linux-swap(new), linux-swap(old)        START and END are disk locations, such as 4GB or 10%.  Negative values count from the end of the        disk.  For example, -1s specifies exactly the last sector.        &#39;mkpart&#39; makes a partition without creating a new file system on the partition.  FS-TYPE may be        specified to set an appropriate partition ID.</code></pre><h5 id="6、-创建分区"><a href="#6、-创建分区" class="headerlink" title="6、 创建分区"></a>6、 创建分区</h5><p>为了创建一个新分区（在这个例子中，分区 0 有 1396MB），输入下面的命令：</p><pre><code class="lang-shell">(parted) mkpart primary 0 1396MBWarning: The resulting partition is not properly aligned for best performanceIgnore/Cancel? I(parted) printModel: Virtio Block Device (virtblk)Disk /dev/vdc: 1396MBSector size (logical/physical): 512B/512BPartition Table: gptDisk Flags:Number Start   End     Size    File system Name Flags1      17.4kB  1396MB  1396MB  primary</code></pre><p>文件系统类型（<code>fstype</code>）并不是在 <code>/dev/vdc1</code>上创建 ext4 文件系统。 DOS 分区表的分区类型是主分区 primary、逻辑分区 logical 和扩展分区 extended。 在 GPT 分区表中，分区类型用作分区名称。 在 GPT 下必须提供分区名称；在上例中，<code>primary</code> 是分区名称，而不是分区类型。</p><h5 id="7、-保存退出"><a href="#7、-保存退出" class="headerlink" title="7、 保存退出"></a>7、 保存退出</h5><p>当你退出 <code>parted</code> 时，修改会自动保存。退出请输入如下命令：</p><pre><code class="lang-shell">(parted) quitInformation: You may need to update /etc/fstab.$</code></pre></li></ul><h4 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h4><p>在 Linux 中使用 mount 这个命令来挂载文件系统。</p><pre><code class="lang-shell">mount [选项] [设备名] [挂载点] 选项：    -r： 以只读方式挂载文件系统。    -w：以读写方式挂载文件系统，默认选项。    mount不加任何参数，会列出系统中所有已经挂载的文件系统。</code></pre><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-03-21_11-20-18.png" alt></p><p>比如：“/dev/mapper/centos-root on / type xfs (rw,relatime,seclabel,attr2,inode64,noquota)”，表示“/dev/mapper/centos-root”挂载到“/”下 面了，并且文件类型是“xfs”。</p><h5 id="挂载-u-盘"><a href="#挂载-u-盘" class="headerlink" title="挂载 u 盘"></a>挂载 u 盘</h5><p>使用 fdisk 命令查看 U 盘的分区：</p><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-03-21_11-25-00.png" alt></p><pre><code class="lang-shell"># 创建一个目录用于挂载U盘（创建挂载点）。mkdir /root/upan# 将U盘所在分区挂载到我们刚刚创建的目录下面。mount /dev/sdb /root/upan/# 对U盘里面的文件进行查看或者操作ls -hl /root/upan/# 卸载U盘umount /dev/sdb</code></pre><p><strong>如果挂载的时候出现“mount: unknown filesystem type ‘(null)’</strong></p><pre><code class="lang-shell"># 格式化U盘所在的分区,window的文件系统类型linux无法识别mkfs.ext4 /dev/sdb</code></pre><h4 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h4><p>在 Linux 中使用 umount 这个命令来解挂文件系统。如果某个文件系统你不需要使用了，就可以 使用 umount 命令来进行卸载。这个命令可以把文件系统从 Linux 系统中分离。</p><pre><code class="lang-shell">umount [设备名]</code></pre><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><h4 id="服务的概念"><a href="#服务的概念" class="headerlink" title="服务的概念"></a><strong>服务的概念</strong></h4><p>服务是指执行指定系统功能的程序、或者进程，以便于支持其它程序的运行，尤其是接近底层 （接近硬件）的程序，比如：FTP、HTTP、防火墙、网络等服务。服务的管理包括：<strong>开启</strong>、<strong>查 看</strong>、<strong>重启</strong>、<strong>停止</strong>等操作</p><h4 id="服务的分类"><a href="#服务的分类" class="headerlink" title="服务的分类"></a><strong>服务的分类</strong></h4><p>Linux 系统的服务分为<strong>独立运行的服务</strong>和<strong>受 xinetd 管理的服务</strong>两大类。独立运行的服务在系统 启动后可以独立运行并直接进行管理，这种服务与运行级别有关；而 xinetd，其本身是一个独立 运行的服务，它负责管理一些不常用的服务，当这些不常用的服务被请求时，由 xinetd 服务负责 启动运行，完成服务请求，再结束该服务的运行，以减少系统资源的占用，这些服务的启动和停 止都由 xinetd 控制。</p><p>xinetd 服务的配置文件是“/etc/xinetd.conf”，受 xinetd 服务管理的服务在“/etc/xinetd.d”目 录下有相应的配置脚本文件。例如，telnet 服务就是一个受 xinetd 管理的服务。</p><h4 id="服务的启动脚本"><a href="#服务的启动脚本" class="headerlink" title="服务的启动脚本"></a><strong>服务的启动脚本</strong></h4><p>在管理服务时，Linux 中的每个服务都有相应的启动脚本，可用于设置启动、停止、重启和查 询服务等功能。所有的服务脚本都保存在“/etc/rc.d/init.d”目录中，脚本名称和服务器名称相对 应。在服务的启动脚本中，一般还有对该脚本文件的有效期和使用方法的描述，可以使用查看命 令来查看。</p><h4 id="systemctl-命令"><a href="#systemctl-命令" class="headerlink" title="systemctl 命令"></a><strong>systemctl 命令</strong></h4><p>服务在使用过程中可以进行启动、状态查询、停止、重启，实现服务自启动状态设置，禁用服 务等操作。在 Linux 中对服务的管理可以通过 systemctl 命令来实现。之前版本的 CentOS7 使用 <strong>service</strong>命令和<strong>chkconfig</strong>命令实现对服务的状态设置和自启动设置，目前 CentOS Linux 7 使用 <strong>systemctl</strong>替换了原有命令。</p><pre><code class="lang-shell">systemctl [start|stop|status|restart|reload] 服务名 参数说明:     start：启动服务。    stop：停止服务。    status：查看服务运行情况。    restart：重启服务。    reload：重新加载服务，加载更新后的配置文件（并不是所有服务都支持这个选项)。用户可以使用该命令管理服务，systemctl命令会自动到/etc/rc.d/init.d/下查找并执行相应的服务脚本。</code></pre><p>服务名一般以<strong>“.service”</strong>结尾，这些服务是被 systemctl 监视的进程，如果要求启动或停止的某 个服务不存在，系统将会寻找同名的初始化脚本，即去掉.service 后缀的服务脚本。这主要用于 与传统的 Linux 系统兼容。</p><h4 id="设置服务自启动"><a href="#设置服务自启动" class="headerlink" title="设置服务自启动"></a>设置服务自启动</h4><h5 id="systemctl-设置自启动"><a href="#systemctl-设置自启动" class="headerlink" title="systemctl 设置自启动"></a>systemctl 设置自启动</h5><p><strong>查看服务是不是自启动</strong></p><pre><code class="lang-shell">systemctl is-enable 服务名称</code></pre><p><strong>设置服务自启动/取消自启动</strong></p><pre><code class="lang-shell">systemctl enable/disable 服务名#enable：表示设置服务随着系统启动而启动。#disable：表示设置取消服务随系统启动而启动。</code></pre><h3 id="进程"><a href="#进程" class="headerlink" title="==进程=="></a>==进程==</h3><h4 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a><strong>进程的概念</strong></h4><p><strong>进程(Process)：是指操作系统中一个独立运行的程序</strong>（这里强调的是运行中的程序，如果程 序不运行，仅仅保存在硬盘上就不能称为进程）。例如在 windows 中，同时运行着 Winxin、 Word、QQ，那么 Winxin 程序是一个进程，Word 程序也是一个进程。在 Windows 操作系统中的 任务管理器中，就可以清晰的看到当前操作系统中正在运行的进程信息。</p><p><strong>进程</strong>，也称<strong>任务</strong>，所有支持多个进程同时执行的操作系统就被称作<strong>多进程操作系统</strong>或<strong>多任务操作系统</strong>，现在主流的操作系统都属于这种类型。</p><h4 id="进程的分类"><a href="#进程的分类" class="headerlink" title="进程的分类"></a><strong>进程的分类</strong></h4><p>进程一般分为<strong>交互进程</strong>、批处理进程和<strong>守护进程</strong>三类。</p><ul><li>交互进程指 Shell 下通过执行程序产生的进程，可在前台运行，也可在后台运行。</li><li>批处理进程是进程的序列，在执行批处理进程时是不需要人机交互的。</li><li>守护进程总是活跃的，一般在后台运行（也叫后台进程）。守护进程一般是由系统在开机时 通过脚本自动启动或者由 root 用户启动的。由于守护进程是一直运行着的，所以它所处的 状态是等待请求处理任务。比如，httpd 服务一直在运行，等待着用户来访问，也就是等待 需要处理的任务。</li></ul><h4 id="进程的查看"><a href="#进程的查看" class="headerlink" title="进程的查看"></a>进程的查看</h4><h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><p>用于查看系统进程的信息的命令。</p><pre><code class="lang-shell">#查找指定进程的信息ps [options] [| grep 进程名]options:    -A    显示所有的进程，跟-e的效果相同    -a    显示现行终端机下的所有进程，包括其他用户的进程    -u    显示当前用户的进程状态    -x    通常与 a 这个参数一起使用，可列出较完整信息    -l    较长、较详细的将该PID的信息列出    -j    工作的格式(jobs format)    -f    把进程的所有信息都显示出来    -e    表示显示所有继承    -p：显示由进程ID指定的进程的信息。# 获得所有用户进程的信息ps -aux# 跟more/less一起使用ps -aux | more# 查看pid=1号进程的信息ps -p 1# 查看MySQL进程的运行情况ps -ef | grep mysql</code></pre><blockquote><p>ps 只能显示进程的瞬时状态,如果要动态监控进程状态则使用一个’top’指令<br>​ 进程名后的 d<br>​ mysqld<br>​ firewalld<br>​ 是后台进程(守护进程的意思) daemon</p></blockquote><p><strong>查看指定端口的进程</strong></p><pre><code class="lang-shell">ss [options] [| grep 端口号]ss 是 Socket Statistics 的缩写options: -h, –help 帮助 -V, –version 显示版本号 -t, –tcp 显示 TCP 协议的 sockets -u, –udp 显示 UDP 协议的 sockets -x, –unix 显示 unix domain sockets，与 -f 选项相同 -n, –numeric 不解析服务的名称，如 “22” 端口不会显示成 “ssh” -l, –listening 只显示处于监听状态的端口 -p, –processes 显示监听端口的进程(Ubuntu 上需要 sudo) -a, –all 对 TCP 协议来说，既包含监听的端口，也包含建立的连接 -r, –resolve 把 IP 解释为域名，把端口号解释为协议名称# 输出所有建立的连接不包含端口ss | more# 查看主机监听的端口。ss -tnl# 使用 -p查看监听端口的程序名称ss -tlp# 过滤SSH进程的信息。ss -tlp | grep sshss -tnlp | grep ssh</code></pre><h5 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h5><p><strong>kill</strong></p><pre><code class="lang-shell">kill [信号代码] 进程编号</code></pre><p>kill 命令可将指定的信息送至程序。预设的信息 SIGTERM(15)，可将指定进程终止。若仍无法 终止该进程，可使用 SIGKILL(9)，尝试强制删除进程。kill 命令的工作原理是：<strong>向 Linux 系统的内 核发送一个系统操作信号和某个进程的进程标志号，然后系统内核就可以对该进程进行操作。</strong>一 般情况下，kill 命令与 ps、grep 命令结合在一起使用（因为要查询进程的编号）。</p><p><strong>killall</strong></p><pre><code class="lang-shell">killall [信号代码] 进程名#关闭sshd所有的进程killall sshd</code></pre><h4 id="查看被文件被哪个进程占用-拓展"><a href="#查看被文件被哪个进程占用-拓展" class="headerlink" title="查看被文件被哪个进程占用(拓展)"></a>查看被文件被哪个进程占用(拓展)</h4><h5 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h5><p>lsof 是 List Open File 的缩写, 它主要用来获取被进程打开文件的信息，我们都知道，在 Linux 中，一切皆文件，lsof 命令可以查看所有已经打开了的文件，比如: 普通文件，目录，特殊的块文件，管道，socket 套接字，设备，Unix 域套接字等等，同时，它还可以结合 grep 以及 ps 命令进行更多的高级搜索</p><p><strong>安装</strong></p><p>lsof 命令默认是没有安装的，而且它的使用需要有 root 权限或者赋予普通用于 sudo 权限, 使用以下命令安装</p><pre><code class="lang-mipsasm">yum install -y lsof</code></pre><p><code>lsof</code> 命令有很多可选参数,以下是一些常用的场景</p><p><strong>列出所有打开的文件</strong></p><p>不带任何参数执行 <code>lsof</code> 命令会输出当前所有活跃进程打开的所有文件</p><pre><code class="lang-bash">[root@ecs-centos-7 ~]# lsof | moreCOMMAND     PID   TID    USER   FD      TYPE             DEVICE  SIZE/OFF       NODE NAMEsystemd       1          root  cwd       DIR              253,1      4096          2 /systemd       1          root  rtd       DIR              253,1      4096          2 /systemd       1          root  txt       REG              253,1   1624520     530313 /usr/lib/systemd/systemdsystemd       1          root  mem       REG              253,1     20064     528340 /usr/lib64/libuuid.so.1.3.0systemd       1          root  mem       REG              253,1    265600     532853 /usr/lib64/libblkid.so.1.1.0systemd       1          root  mem       REG              253,1     90248     525942 /usr/lib64/libz.so.1.2.7systemd       1          root  mem       REG              253,1    157424     525955 /usr/lib64/liblzma.so.5.2.2systemd       1          root  mem       REG              253,1     23968     526159 /usr/lib64/libcap-ng.so.0.0.0systemd       1          root  mem       REG              253,1     19896     526135 /usr/lib64/libattr.so.1.1.0systemd       1          root  mem       REG              253,1     19288     525996 /usr/lib64/libdl-2.17.sosystemd       1          root  mem       REG              253,1    402384     525931 /usr/lib64/libpcre.so.1.2.0systemd       1          root  mem       REG              253,1   2156160</code></pre><p>由于<code>lsof</code>命令会输出很多信息，所以上面例子中使用了 <code>lsof | more</code> 来分页显示命令输出结果</p><p>输出结果中，第一列中 <code>systemd</code> 的进程 ID 是 <code>1</code>,它是一个守护进程</p><p>其中列 <code>COMMAND</code> 、<code>PID</code>、<code>USER</code> 分别表示进程名、进程 ID、所属用户</p><p>列 <code>FD</code> 是文件描述符，下面是可能的类型以及说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">FD</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">cwd</td><td style="text-align:center">当前目录</td></tr><tr><td style="text-align:center">txt</td><td style="text-align:center">txt 文件</td></tr><tr><td style="text-align:center">rtd</td><td style="text-align:center">root 目录</td></tr><tr><td style="text-align:center">mem</td><td style="text-align:center">内存映射文件</td></tr></tbody></table></div><p>列 <code>TYPE</code> 是文件类型，下面是可能的值以及说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">TYPE</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">DIR</td><td style="text-align:center">目录</td></tr><tr><td style="text-align:center">REG</td><td style="text-align:center">普通文件</td></tr><tr><td style="text-align:center">CHR</td><td style="text-align:center">字符</td></tr><tr><td style="text-align:center">a_inode</td><td style="text-align:center">Inode 文件</td></tr><tr><td style="text-align:center">FIFO</td><td style="text-align:center">管道或者 socket 文件</td></tr><tr><td style="text-align:center">netlink</td><td style="text-align:center">网络</td></tr><tr><td style="text-align:center">unknown</td><td style="text-align:center">未知</td></tr></tbody></table></div><p>列 <code>DEVICE</code> 表示设备 ID</p><p>列 <code>SIZE/OFF</code> 表示进程大小</p><p>列 <code>NODE</code> 表示文件的 Inode 号</p><p>列<code>NAME</code> 表示路径或者链接</p><p><strong>列出指定用户已打开的文件</strong></p><p>使用 <code>-u</code> 选项可以列出指定用户已经打开的文件，该选项后面可以接多个用户名，每个用户名之间用空格隔开，表示列出所有指定用户已打开的所有文件</p><pre><code class="lang-bash">[root@ecs-centos-7 ~]# lsof -u tt | moreCOMMAND   PID USER   FD   TYPE DEVICE  SIZE/OFF   NODE NAMEbash    27789   tt  cwd    DIR  253,1      4096 131090 /home/ttbash    27789   tt  rtd    DIR  253,1      4096      2 /bash    27789   tt  txt    REG  253,1    964600 525779 /usr/bin/bashvim     27813   tt  txt    REG  253,1   2337192 531847 /usr/bin/vimvim     27813   tt    4u   REG  253,1     12288 131167 /home/tt/.p.txt.swp</code></pre><p>上面的例子中，<code>lsof -u tt</code> 命令表示列出 <code>tt</code> 用户已经打开了的文件，从结果可以看出，用户打开了 <code>/home/tt</code>、<code>/</code>、<code>/usr/bin/bash</code>、<code>/usr/bin/vim</code>、<code>/home/tt/.p.txt.swp</code> 这几个文件</p><p>如果要排除指定用户已经打开的文件，可以在用户名前加 <code>^</code> 符号，下面的命令会列出除<code>tt</code>用户外其他所有用户已打开了的文件</p><pre><code class="lang-dos">lsof -u ^tt | more</code></pre><p><strong>找出打开着但已被删除了的文件</strong></p><p>有这样一种场景，有一个服务正在往日志文件中写日志，这个时候，不小心把正在写入的日志文件删除了</p><p>上面的场景中，日志文件虽然被删除了，但是文件仍然是打开着的，它仍然占用文件系统的空间，我们可以结合 <code>grep</code> 命令找出这种打开着，但是已经被删除的文件</p><pre><code class="lang-bash">[root@ecs-centos-7 ~]# lsof -u tt | grep deletedvim     27813   tt    4u   REG  253,1    12288 131167 /home/tt/.p.txt.swp(deleted)</code></pre><p>上面例子中使用 <code>lsof -u tt | grep deleted</code> 命令查看用户 <code>tt</code>打开着的确被删除的文件</p><p>从结果可以看出，在往 <code>p.txt</code>写入内容的时候，文件被删除了</p><p><strong>列出所有打开了的网络文件</strong></p><pre><code class="lang-x86asm">[root@ecs-centos-7 ~]# lsof -iCOMMAND    PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEntpd       567   ntp   18u  IPv4  12657      0t0  UDP localhost:ntpntpd       567   ntp   22u  IPv6  16095      0t0  UDP ecs-centos-7.4-64bit-20200212:ntpdhclient   651  root    6u  IPv4  14594      0t0  UDP *:bootpcmaster     960  root   13u  IPv4  15791      0t0  TCP localhost:smtp (LISTEN)master     960  root   14u  IPv6  15792      0t0  TCP localhost:smtp (LISTEN)mysqld    1053 mysql   13u  IPv6  15147      0t0  TCP *:mysql (LISTEN)sshd      1348  root    3u  IPv4  16698      0t0  TCP *:ssh (LISTEN)</code></pre><ul><li>列出所有 IPV4/6 网络文件</li></ul><p>列出所有已经打开了的 ipv4 网络文件</p><pre><code class="lang-ruby">[root@ecs-centos-7 ~]# lsof -i 4COMMAND    PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEntpd       567  ntp   16u  IPv4  12651      0t0  UDP *:ntpntpd       567  ntp   18u  IPv4  12657      0t0  UDP localhost:ntpntpd       567  ntp   21u  IPv4  16094      0t0  UDP ecs-centos-7.4-64bit-20200212:ntpdhclient   651 root    6u  IPv4  14594      0t0  UDP *:bootpcmaster     960 root   13u  IPv4  15791      0t0  TCP localhost:smtp (LISTEN)sshd      1348 root    3u  IPv4  16698      0t0  TCP *:ssh (LISTEN)</code></pre><p>所有已经打开了的 ipv6 网络文件</p><pre><code class="lang-ruby">[root@ecs-centos-7 ~]# lsof -i 6COMMAND  PID  USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEntpd     567   ntp   17u  IPv6  12652      0t0  UDP *:ntpntpd     567   ntp   19u  IPv6  12658      0t0  UDP localhost:ntpntpd     567   ntp   22u  IPv6  16095      0t0  UDP ecs-centos-7.4-64bit-20200212:ntpmaster   960  root   14u  IPv6  15792      0t0  TCP localhost:smtp (LISTEN)mysqld  1053 mysql   13u  IPv6  15147      0t0  TCP *:mysql (LISTEN)sshd    1348  root    4u  IPv6  16700      0t0  TCP *:ssh (LISTEN)</code></pre><ul><li>列出在指定端口上打开的文件</li></ul><p>使用 <code>lsof -i:端口号</code> 可以获得所有在指定端口号上打开的文件</p><pre><code class="lang-ruby">[root@ecs-centos-7 ~]# lsof -i:22COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEsshd     1348 root    3u  IPv4  16698      0t0  TCP *:ssh (LISTEN)sshd     1348 root    4u  IPv6  16700      0t0  TCP *:ssh (LISTEN)sshd    27741 root    3u  IPv4 458958      0t0  TCP ecs-centos-7.4-64bit-20200212:ssh-&gt;113.118.121.220:42395 (ESTABLISHED)sshd    27819 root    3u  IPv4 459250      0t0  TCP ecs-centos-7.4-64bit-20200212:ssh-&gt;113.118.121.220:19807 (ESTABLISHED)sshd    27895 root    3u  IPv4 459828      0t0  TCP</code></pre><p>上面例子列出了所有在 22 号端口上打开的文件</p><p>在服务器开发中，经常会部署一个网关或者代理程序，用来和客户端通讯，网关或者代理程序需要开放一个固定的端口供客户端连接用</p><p>如果客户端连接不上网关或者代理程序，我们可以用上述命令检查网关或代理程序的端口是否开启，来排除因为端口关闭了导致连接不上网关的情况</p><ul><li>列出使用了指定协议(TCP/UDP) 的文件</li></ul><p>使用 <code>lsof -i TCP/UDP</code> 列出使用了 TCP 或 UDP 协议的文件</p><pre><code class="lang-ruby">[root@cghost8 /home/cgyx]# lsof -i TCP | moreCOMMAND      PID   USER   FD   TYPE  DEVICE SIZE/OFF NODE NAMEsshd        1704   root    3u  IPv4   13593      0t0  TCP *:ssh (LISTEN)sshd        1704   root    4u  IPv6   13595      0t0  TCP *:ssh (LISTEN)redis-serer   1725   root    4u  IPv4   19773      0t0  TCP localhost:6380 (LISTEN)nc          2067   cgyx    4u  IPv4   39167      0t0  TCP *:60600 (LISTEN)mysqld      3020  mysql    4u  IPv6 5514608      0t0  TCP 192.168.70.10:mysql-&gt;192.168.70.10:37084 (ESTABLISHED)</code></pre><p>使用 <code>lsof -i TCP:3306</code> 列出使用了 TCP 协议并且端口为 3306 的文件</p><pre><code class="lang-ruby">[root@cghost8 /home/cgyx]# lsof -i TCP:3306COMMAND      PID  USER   FD   TYPE  DEVICE SIZE/OFF NODE NAMEmysqld      3020 mysql    4u  IPv6 5514608      0t0  TCP 192.168.70.10:mysql-&gt;192.168.70.10:37084 (ESTABLISHED)</code></pre><p>使用 <code>lsof -i TCP:1-1024</code> 列出使用了 TCP 协议并且端口范围为 1 到 1024 的文件</p><pre><code class="lang-ruby">[root@cghost8 /home/cgyx]# lsof -i TCP:1-1024COMMAND   PID   USER   FD   TYPE  DEVICE SIZE/OFF NODE NAMEsshd     1704   root    3u  IPv4   13593      0t0  TCP *:ssh (LISTEN)sshd     1704   root    4u  IPv6   13595      0t0  TCP *:ssh (LISTEN)cupsd    1709   root   12u  IPv6   39148      0t0  TCP localhost:ipp (LISTEN)cupsd    1709   root   13u  IPv4   39149      0t0  TCP localhost:ipp (LISTEN)smbd     1824   root   35u  IPv6   17658      0t0  TCP *:microsoft-ds (LISTEN)smbd     1824   root   36u  IPv6   17659      0t0  TCP *:netbios-ssn (LISTEN)smbd     1824   root   37u  IPv4   17660      0t0  TCP *:microsoft-ds (LISTEN)smbd     1824   root   38u  IPv4   17661      0t0  TCP *:netbios-ssn (LISTEN)</code></pre><p><strong>列出目录中所有打开的文件</strong></p><p>可以使用<code>lsof</code>命令列出指定目录中的所有打开文件</p><p>现有一个<code>data</code>目录 ,结构如下：</p><pre><code class="lang-haskell">[root@ecs-centos-7 tt]# tree data/data/├── dira│   └── a.txt└── d.s1 directory, 2 files</code></pre><p>列出 <code>data</code> 目录中打开的文件</p><pre><code class="lang-powershell">[root@ecs-centos-7 tt]# lsof +D ./data/COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF   NODE NAMEbash    28473 root  cwd    DIR  253,1     4096 131146 ./databash    28502 root  cwd    DIR  253,1     4096 131172 ./data/diravim     28530 root  cwd    DIR  253,1     4096 131172 ./data/diravim     28530 root    4u   REG  253,1    12288 131174 ./data/dira/.a.txt.swp[root@ecs-centos-7 tt]# lsof +d ./data/COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF   NODE NAMEbash    28473 root  cwd    DIR  253,1     4096 131146 ./databash    28502 root  cwd    DIR  253,1     4096 131172 ./data/diravim     28530 root  cwd    DIR  253,1     4096 131172 ./data/dira</code></pre><p>上面例子中，<code>+D</code> 和 <code>+d</code> 选项都是列出目录中打开的文件</p><p><code>+D</code> 选项会列出一个目录和其子目录中打开的文件，而 <code>+d</code> 选项只会列出当前目录下已打开的文件</p><p><strong>列出指定进程 ID 打开的文件</strong></p><p>进程 ID 是操作系统进程的唯一标识，以下命令列出了进程 ID 为 <code>1053</code> 相关的文件, 从结果中可以知道这个进程 ID 对应的进程是 MySQL</p><pre><code class="lang-yaml">[root@ecs-centos-7 ~]# lsof -p 1053COMMAND  PID  USER   FD   TYPE             DEVICE  SIZE/OFF    NODE NAMEmysqld  1053 mysql  cwd    DIR              253,1      4096 1055765 /var/lib/mysqlmysqld  1053 mysql  rtd    DIR              253,1      4096       2 /mysqld  1053 mysql  txt    REG              253,1 251841448  534935 /usr/sbin/mysqldmysqld  1053 mysql  mem    REG              253,1    209512  659436 /usr/lib64/mysql/plugin/validate_password.somysqld  1053 mysql    1w   REG              253,1    206658  924771 /var/log/mysqld.logmysqld  1053 mysql    2w   REG              253,1    206658  924771 /var/log/mysqld.log</code></pre><p>上述命令中，<code>-p</code> 选项后面可以指定多个进程 ID，每个进程 ID 之间用逗号分隔，如果想排除掉某个进程打开的文件，可以在该进程 ID 前面加上 <code>^</code>符号</p><pre><code class="lang-css">lsof -p 1,2,3,^4</code></pre><p>上述命令会列出进程 1，进程 2，进程 3 打开的所有文件，同时忽略进程 4 打开的文件</p><h4 id="使用文件或文件结构识别进程"><a href="#使用文件或文件结构识别进程" class="headerlink" title="使用文件或文件结构识别进程"></a>使用文件或文件结构识别进程</h4><h5 id="fuser"><a href="#fuser" class="headerlink" title="fuser"></a>fuser</h5><p>用于报告进程使用的文件和网络套接字。fuser 命令列出了本地进程的进程号，那些本地进程使用 file，参数指定的本地或远程文件。每个进程号后面都跟随一个字母，该字母指示进程如何使用文件。</p><ul><li><code>c</code> ：指示进程的工作目录。</li><li><code>e</code> ：指示该文件为进程的可执行文件(即进程由该文件拉起)。</li><li><code>f</code> ：指示该文件被进程打开，默认情况下 f 字符不显示。</li><li><code>F</code> ：指示该文件被进程打开进行写入，默认情况下 F 字符不显示。</li><li><code>r</code> ：指示该目录为进程的根目录。</li><li><code>m</code> ：指示进程使用该文件进行内存映射，抑或该文件为共享库文件，被进程映射进内存。</li></ul><p><strong>语法</strong></p><pre><code class="lang-shell">fuser(选项)(参数)选项:    -a：显示命令行中指定的所有文件；    -k：杀死访问指定文件的所有进程；    -i：杀死进程前需要用户进行确认；    -l：列出所有已知信号名；    -m：指定一个被加载的文件系统或一个被加载的块设备；    -n：选择不同的名称空间；    -u：在每个进程后显示所属的用户名。参数:    文件：可以是文件名或者TCP、UDP端口号。</code></pre><p><strong>实例</strong></p><p>要列出使用<code>/etc/passwd</code>文件的本地进程的进程号，请输入：</p><pre><code class="lang-shell">fuser /etc/passwd</code></pre><p>要列出使用<code>/etc/filesystems</code>文件的进程的进程号和用户登录名，请输入：</p><pre><code class="lang-shell">fuser -u /etc/filesystems</code></pre><p>要终止使用给定文件系统的所有进程，请输入：</p><pre><code class="lang-shell">fuser -k -x -u -c /dev/hd1  或者  fuser -kxuc /home</code></pre><p>任一命令都列出了进程号和用户名，然后终止每个正在使用<code>/dev/hd1 (/home)</code>文件系统的进程。仅有 root 用户能终止属于另一用户的进程。如果您正在试图卸下<code>/dev/hd1</code>文件系统，而一个正在访问<code>/dev/hd1</code>文件系统的进程不允许这样，您可能希望使用此命令。</p><p>要列出正在使用已从给定文件系统删除的文件的全部进程，请输入：</p><pre><code class="lang-shell">fuser -d /usr文件</code></pre><p><code>/dev/kmem</code> 用于系统映像。<br><code>/dev/mem</code> 也用于系统映像。</p><h4 id="杀死指定用户的所有进程"><a href="#杀死指定用户的所有进程" class="headerlink" title="杀死指定用户的所有进程"></a>杀死指定用户的所有进程</h4><p>前面介绍了列出指定用户所有打开的文件，我们可以组合 <code>kill</code> 命令一起使用，实现杀死指定用户的所有进程的功能，具体的命令如下</p><pre><code class="lang-perl">kill -9 `lsof -t -u tt`</code></pre><p>上述命令中，<code>lsof -u tt</code> 是列出<code>tt</code>用户所有打开的文件，加上 <code>-t</code> 选项之后表示结果只列出 PID 列，也就是进程 ID 列，其他列都忽略，前面的 <code>kill -9</code> 表示强制结束指定的进程 ID</p><h3 id="shell-1"><a href="#shell-1" class="headerlink" title="shell"></a>shell</h3><h4 id="echo"><a href="#echo" class="headerlink" title="==echo=="></a>==echo==</h4><p>用于字符串的输出</p><pre><code class="lang-shell">echo string#1.显示字符串echo &quot;It is a test&quot;#这里的双引号完全可以省略，以下命令与上面实例效果一致echo It is a test#2.显示转义字符echo &quot;\&quot;It is a test\&quot;&quot;#结果&quot;It is a test&quot;#3.显示变量#read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量#!/bin/shread nameecho &quot;$name It is a test&quot;#以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:[root@www ~]# sh test.shOK                     #标准输入OK It is a test        #输出#4.显示换行echo -e &quot;OK! \n&quot; # -e 开启转义echo &quot;It is a test&quot;#输出结果：OK!It is a test#6.显示结果定向至文件echo &quot;It is a test&quot; &gt; myfile#7.原样输出字符串，不进行转义或取变量(用单引号)echo &#39;$name\&quot;&#39;#输出结果:$name\&quot;#8.显示命令执行结果(使用反引号)echo `date`</code></pre><h3 id="后台运行任务"><a href="#后台运行任务" class="headerlink" title="==后台运行任务=="></a>==后台运行任务==</h3><h4 id="任务日志打印"><a href="#任务日志打印" class="headerlink" title="任务日志打印"></a>任务日志打印</h4><p>0:标准输入 操作重定向符为<code>&lt;</code></p><p>1:标准输出(不指定的话默认省略)</p><p>2:错误输出</p><div class="table-container"><table><thead><tr><th>重定向操作符</th><th>说明</th></tr></thead><tbody><tr><td>&gt;</td><td>指定标准输出文件(即无报错输出)，若有则覆盖</td></tr><tr><td>>&gt;</td><td>指定标准输出文件，若有则追加</td></tr><tr><td>2&gt;</td><td>错误重定向，如果重定向文件存在，则覆盖</td></tr><tr><td>2&gt;&gt;</td><td>错误重定向，如果重定向文件存在，则追加</td></tr><tr><td>&amp;&gt;</td><td>错误重定向和标准输出重定向一起操作，如果重定向文件存在，则覆盖</td></tr><tr><td>&amp;&gt;&gt;</td><td>错误重定向和标准输出重定向一起操作，如果重定向文件存在，则追加</td></tr></tbody></table></div><p>这个命令可以实现两个文件的合并</p><pre><code class="lang-plain">cat helloWord1.txt &gt;&gt; helloWord2.txt</code></pre><p>&amp;1 表示标准输出的引用，所以 2&gt;&amp;1 是指把标准错误输出重定向到标准输出的引用，即也重定向到 file</p><div class="table-container"><table><thead><tr><th>重定向操作符</th><th>说明</th></tr></thead><tbody><tr><td>cmd &gt; filename 2&gt;&amp;1</td><td>把标准输出和标准错误一起重定向到一个文件中。</td></tr><tr><td>cmd &gt;&gt; filename 2&gt;&amp;1</td><td>把标准输出和标准错误一起重定向到一个文件中(追加)。</td></tr><tr><td>cmd &lt; filename</td><td>输入重定向，命令的输入不是通过键盘来完成，而是通过其它方式实 现。cmd 命令以 filename 文件作为标准输入。</td></tr><tr><td>cmd &lt; filename &gt; filename2</td><td>把 cmd 命令以 filename 文件作为标准输入，以 filename2 文件作为标准 输出。</td></tr></tbody></table></div><h4 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h4><p>使进程后台不挂起运行（即用户退出登录后，进程仍然运行）</p><pre><code class="lang-plain">nohup command [Args...] [&amp;]command ： 需要执行的命令[Args...] : 些参数，可以指定输出文件&amp; ：让命令在后台执行，终端正常退出后命令仍旧执行,即使用exit命令</code></pre><h3 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="==创建定时任务=="></a>==创建定时任务==</h3><h4 id="cron-和-crontab"><a href="#cron-和-crontab" class="headerlink" title="cron 和 crontab"></a>cron 和 crontab</h4><p>cron 是系统主要的非常好用的调度进程，它可以在无需人工干预的情况下运行作业。我们可以 通过 crontab 的命令提交、编辑或删除相应的作业。每一个用户都可以有一个 crontab 文件来保存 调度信息。可以使用它运行任意一个 shell 脚本或某个命令，可以是每小时运行一次，每一天、或 一周一次，这完全取决于用户自己。每一个用户都可以有自己的 crontab 文件，但在一个较大的 系统中，系统管理员一般会禁止这些文件，而只在整个系统保留一个这样的文件。系统管理员是 通过<strong>/etc/cron.deny</strong>和<strong>/etc/cron.allow</strong>这两个文件来禁止或允许用户拥有自己的 crontab 文件。</p><p>如果我们把 test 用户加入到<strong>/etc/cron.deny</strong>文件中去：</p><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-04-12_07-43-12.png" alt></p><p>如果我们以 test 用户登录，然后配置 crontab，会得到下面的提示：</p><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-04-12_07-44-12.png" alt></p><h5 id="crontab-命令"><a href="#crontab-命令" class="headerlink" title="crontab 命令"></a>crontab 命令</h5><pre><code class="lang-shell">crontab [-u user] file#或者crontab [ -u user ] &#123; -l | -r | -e &#125;Options:    -u：用户名，一般不用，都是自己管理自己的crontab任务。    -e：编辑(edit)crontab文件。    -l：列出(list)crontab文件中的内容。    -r：删除(remove)crontab文件。#如果使用自己的名字登录，就不用使用-u选项，因为在执行crontab命令时，该命令能够知道当前的用户。</code></pre><p><strong>crontab 的域</strong></p><p>为了能够在特定的时间运行作业，需要了解 crontab 文件每个条目的格式，以及其中各个域的 意义。下面就是这些域：</p><div class="table-container"><table><thead><tr><th style="text-align:center">列</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">第 1 列</td><td>分钟 1 ～ 59</td></tr><tr><td style="text-align:center">第 2 列</td><td>小时 0 ～ 23（0 表示子夜）</td></tr><tr><td style="text-align:center">第 3 列</td><td>日期 1 ～ 31</td></tr><tr><td style="text-align:center">第 4 列</td><td>月份 1 ～ 12</td></tr><tr><td style="text-align:center">第 5 列</td><td>星期 0 ～ 6（注意：0 表示星期天）</td></tr><tr><td style="text-align:center">第 6 列</td><td>要运行的命令或者脚本</td></tr></tbody></table></div><p>下面是 crontab 的格式：</p><pre><code class="lang-shell">分 时 日 月 星期几 要运行的命令或者要执行的脚本</code></pre><p>在这些域中，可以用横杠<code>-</code>来表示一个时间范围，例如你希望星期一至星期五运行某个作业， 那么可以在星期域使用<code>1 - 5</code>来表示。还可以在这些域中使用逗号<code>,</code>，例如你希望星期一和星期四 运行某个作业，只需要使用<code>1, 4</code>来表示。如果你对某个表示时间域没有特别的限定，也应该在该 域填入*。该文件的每一个条目必须含有 5 个时间域，而且每个域之间要用空格分隔。该文件中所有的注释行要在行首用<code>#</code>来表示。</p><p><strong>案例</strong>:</p><pre><code class="lang-shell"># 表示每晚的21:30运行主目录目录下的cleanup.sh。30 21 * * * ~/cleanup.sh# 表示每月1、10、22日的4:45运行主目录目录下的backup.sh。45 4 1,10,22 * * ~/backup.sh# 表示每周六、周日的1:10运行一个find命令，查询日志文件然后删除10 1 * * 6,0 /bin/find / -name &quot;*.log&quot; -exec rm &#123;&#125; \;# 表示在每天18:00至23:00之间每隔30分钟运行主目录目录下的check.sh。0,30 18-23 * * * ~/check.sh# 表示每星期六的23:59进行系统的重启(执行命令得写命令的绝对路径)59 23 * * 6 /sbin/reboot# 表示每分钟执行一次时钟同步。*/1 * * * * /usr/sbin/ntpdate ntp4.aliyun.com</code></pre><p><strong>注意</strong>：如果是执行命令，请写命令的绝对路径，比如上面的 reboot、find 命令。 即<code>/sbin/reboot</code>,<code>/bin/find</code></p><p>其中当 第一列 为 <em>/n 时表示每 n 分钟个时间间隔执行一次，第二列为 </em>/n 表示每 n 小时个时间间隔执行一次，其余类推</p><h5 id="创建新的-crontab"><a href="#创建新的-crontab" class="headerlink" title="创建新的 crontab"></a>创建新的 crontab</h5><p>创建新的 crontab 可以直接编辑 crontab，也可以创建一个文件把 crontab 的内容写进入， 然后进行提交。</p><p>创建一个文件“mycron”，然后输入下面的内容：</p><pre><code class="lang-shell"># 每隔一分钟将当前时间写入主目录下面的system.log文件*/1 * * * * /bin/echo `date` &gt;&gt; ~/system.log</code></pre><p>向“crontab”提交 mycron 文件</p><pre><code class="lang-shell">crontab mycron</code></pre><h4 id="at"><a href="#at" class="headerlink" title="at"></a>at</h4><p>at 命令允许用户向 cron 守护进程提交作业，使其在稍后的时间运行。这里稍后的时间可能是指 10min 以后，也可能是指几天以后。如果你希望在一个月或更长的时间以后运行，最好还是使用 crontab 文件。</p><p>一旦一个作业被提交， at 命令将会保留所有当前的环境变量，包括路径，不象 crontab，只提 供缺省的环境。该作业的所有输出都将以电子邮件的形式发送给用户，除非你对其输出进行了重 定向，绝大多数情况下是重定向到某个文件中。</p><p>at 在系统中可能是没有安装的,如果需要使用,则需要使用<code>yum</code>或者<code>apt</code>进行安装,然后使用<code>systemctl</code>开启<code>atd</code>服务,并最好设置其随着系统启动而启动</p><pre><code class="lang-shell"># 安装at。yum -y install at# 设置atd服务随机启动systemctl enable atd# 启动atd服务systemctl start atd</code></pre><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><pre><code class="lang-shell">at [options] [-f file] [time] [date]    Options:        -V：显示作业将被执行的时间。        -q：选队列名称，队列名称可以是a-z和A-Z之间的任意字母。队列字母顺序越高，则队列优先级别越低。        -f：从文件中读取命令或Shell脚本。        -l：(list)列出当前所有等待运行的作业。atq命令具有相同的作用。        -r：(remove)清除作业。为了清除某个作业，还要提供相应的作业标识(id)。        -m：执行完作业后发送电子邮件到用户。      date：日期格式可以是月份数或日期数，而且at命令还能够识别诸如today、tomorrow这样的词。      time：设定作业执行的时间。time选项可以是下面格式中的任何一种。        1、HH:MM格式，例如04:00，代表4:00AM。如果时间已过，就会在第二天的这一时间执行。        2、midnight代表12:00AM、teatime代表4:00PM。        3、英文月名日期年份格式，例如 January 15 2022，代表2022年1月15        4、MMDDYY、MM/DD/YY 或 MM.DD.YY格式，如051522，代表2022年5月15日。        5、now +时间格式，时间以minutes、hours、day或 weeks为单位。如now +5 days，代表命令应该在5天之后的此时此刻执行。此种格式可以写为“时间＋偏移量”的形式，偏移量的单位是minutes、 hours和 days。</code></pre><h5 id="at-提交命令或脚本"><a href="#at-提交命令或脚本" class="headerlink" title="at 提交命令或脚本"></a>at 提交命令或脚本</h5><p>使用 at 命令提交作业有几种不同的形式，可以通过<strong>命令行</strong>方式，也可以使用<strong>at 命令提示符</strong>。一 般来说在提交若干行的系统命令时，我使用 at 命令提示符方式，而在提交 shell 脚本时，使用命令 行方式。</p><p>如果你想提交若干行的命令，可以在 at 命令后面跟上日期/时间并回车。然后就进入了 at 命令提 示符，这时只需逐条输入相应的命令，然后按“<strong>CTRL - D</strong>”退出。</p><p>1.打印当前时间到主目录下面的 system.log 文件。</p><pre><code class="lang-shell"># 设要执行的时间at -m 00:02# 设置要执行的语句echo `date` &gt;&gt; ~/system.log</code></pre><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-04-12_09-03-58.png" alt></p><p>其中， 就是。在 00:02 系统将执行我们指定的命令。你应当已经注意到，我所提交的作业被分 配了一个唯一标识 job4。并且提示我们了，这个 job 具体的执行时间。该命令在完成以后会将全 部结果以邮件的形式发送给我。</p><p>2.如果希望向 at 命令提交一个 shell 脚本，使用其命令行方式即可，在提交脚本时使用-f 选项。</p><pre><code class="lang-shell"># 将下面的内容写入~/my_at.sh文件find / -name &quot;*.txt&quot; &gt; ~/result.log# 今天晚上的23:59执行主目录下面的my_at.shat 23:59 -f ~/my_at.sh</code></pre><p>3.可以使用管道符来提交 at 作业</p><pre><code class="lang-shell">find /root/ -name &quot;*.txt&quot; | at now +1 minute</code></pre><p><strong>下面这些日期/时间格式都是 at 命令可以接受的：</strong></p><pre><code class="lang-shell"># 四月16号的早上6:45分触发at 6:45am April 16# 晚上的10:10触发at 10:10pm# 两分钟后触发at now + 2 minutes# 一个小时后触发at now + 1 hour# 明天上午九点触发at 9:00am tomorrow# yesterda是无效的。at 9:00am yesterday</code></pre><h5 id="列出所提交的作业"><a href="#列出所提交的作业" class="headerlink" title="列出所提交的作业"></a>列出所提交的作业</h5><pre><code class="lang-shell">at -l#或atq</code></pre><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-04-12_12-49-05.png" alt></p><p><strong>注意：</strong>其中，第一列是作业标识也就是 ID，后面是作业运行的日期/时间。第三列 a 代表 at，最后 一列代表谁提交的作业。如果作业已经运行完了，这里面是看不见的，也就是里面的 id 为什么不 连贯的原因。</p><p>当提交一个作业后，它就被拷贝到<strong>/var/spool/at</strong>目录中，准备在要求的时间运行。我们发现 里面正好有四个文件，就对应我们提交的四个作业。</p><pre><code class="lang-plain">echo &amp;变量名# 定义变量hello=&quot;world&quot;# 打印变量echo $hello</code></pre><pre><code class="lang-plain">set</code></pre><pre><code class="lang-plain">unset variable_name</code></pre><h2 id="文件"><a href="#文件" class="headerlink" title="==文件=="></a>==文件==</h2><h3 id="文件的基本属性"><a href="#文件的基本属性" class="headerlink" title="==文件的基本属性=="></a>==文件的基本属性==</h3><pre><code class="lang-shell">d rw- rw- r--   1   nd_ljq   nd_ljq   110   Sep 12 18:20   javaTest</code></pre><ul><li>第一个字符代表这个文件是目录,文件,链接文件等</li></ul><pre><code class="lang-shell">d 目录- 文件l 链接文件b 可供存取的接口设备c 表示串行的端口设备</code></pre><ul><li>接下来的三组都是以 <code>rwx</code>的三个参数的组合(没有权限则是<code>-</code>号)</li></ul><pre><code class="lang-shell">r代表可读(readable) 4w代表可写(writable) 2x代表可执行(executable) 1第一组rwx:所有者权限(owner)第二组rwx:组权限(group)第三组rwx:其他用户权限(other)</code></pre><h3 id="为文件添加软-硬链接"><a href="#为文件添加软-硬链接" class="headerlink" title="==为文件添加软/硬链接=="></a>==为文件添加软/硬链接==</h3><pre><code class="lang-shell">#在linux中链接相当于windows中的快捷方式#在linux中存在两种不同的链接:分别是`软链接`和`硬链接`硬链接:是指同一个系统中的两个文件修改其中一个文件内容另一个文件也会改变 即两个文件指向一个node软链接:又被称作符号链接,他是一个指向文件的指针,这个指针代表一个初始状态与指向文件一致的文件,修改软链接的内容,指向文件的内容不变简而言之，硬链接是指两个文件指向同一个 inode，而软链接是指一个文件指向另一个文件的路径(更像快捷方式)ln [-s] source_path target_path -s :soft 创建软链接例:ifcfg-ens33文件用于配置网络信，但是这个文件目录比较深，所以我们可以设置这个文件的链接文件。ln -s /etc/sysconfig/network-scripts/ifcfg-ens33 my-ifcfg-ens33</code></pre><h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="==修改文件权限=="></a>==修改文件权限==</h3><pre><code class="lang-shell">符号格式:chmod [who]operator[permission] filenamewho的选项是    u:文件属主的权限    g:同组用户权限    o:其他用户权限    a:所有用户权限operator的选项是:    + :增加权限    - :取消权限    = :设定权限permission的选项是:    r :读权限(4)    w :写权限(2)    x :执行权限(1)绝对模式:chmod 第一组权限数字(累加)第二组权限数字(累加)第三组权限数字(累加) fileName</code></pre><h3 id="修改文件所属用户-组"><a href="#修改文件所属用户-组" class="headerlink" title="==修改文件所属用户/组=="></a>==修改文件所属用户/组==</h3><pre><code class="lang-shell">#更改所有者chown [-options] userName fileName#更改所属组chgrp [-options] groupName fileNameoptions:    R: 对所有子目录下的文件都进行同样操作    h: 改变符号链接文件的属主不影响</code></pre><h3 id="查看当前目录绝对路径"><a href="#查看当前目录绝对路径" class="headerlink" title="==查看当前目录绝对路径=="></a>==查看当前目录绝对路径==</h3><pre><code class="lang-js">pwd;</code></pre><h3 id="拷贝文件-文件夹到指定目录"><a href="#拷贝文件-文件夹到指定目录" class="headerlink" title="拷贝文件/文件夹到指定目录"></a>拷贝文件/文件夹到指定目录</h3><pre><code>cp [options] source destcp [options] source diroptions:    -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。    -d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。    -f：覆盖已经存在的目标文件而不给出提示。    -i：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖。    -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。    -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。    -l：不复制文件，只是生成链接文件。</code></pre><h3 id="拷贝文件到远程服务器"><a href="#拷贝文件到远程服务器" class="headerlink" title="==拷贝文件到远程服务器=="></a>==拷贝文件到远程服务器==</h3><pre><code class="lang-shell">scp [options] fileName/dir targetPathoptions:    -C:使用压缩    -P:指定远程主机号    -p:保留文件最后修改时间,最后访问时间和权限模式    -q:不显示复制进程    -r:以递归的方式复制# 普通文件scp source user@hostname:filePath(fileName)# 拷贝目录需要使用-r。scp -r source user@hostname:filePath(fileName)# 除了使用主机名也可以用IP地址scp -r source user@ip:filePath(fileName)</code></pre><h3 id="剪切文件-文件夹"><a href="#剪切文件-文件夹" class="headerlink" title="剪切文件/文件夹"></a>剪切文件/文件夹</h3><pre><code class="lang-shell">mv [options] source destoptions:    -b: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。    -i: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。    -f: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。    -n: 不覆盖任何已存在的文件或目录。    -u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作</code></pre><h3 id="查看当前目录下的文件-文件夹信息"><a href="#查看当前目录下的文件-文件夹信息" class="headerlink" title="查看当前目录下的文件/文件夹信息"></a>查看当前目录下的文件/文件夹信息</h3><pre><code class="lang-shell">ls [options] fileName/conditionoptions:    -l:除文件名其文件的所有信息全部列出(文件形态,权限,拥有者,文件大小等)  ==&gt; ll = ls -l    -t:按照创建时间依次列出    -a:列出目录下所有文件夹名(包括隐藏文件)    -R:递归显示当前目录下的文件和子目录      -h:以人类可读的方式显示当前目录中的文件和目录大小</code></pre><h3 id="创建文件-文件夹"><a href="#创建文件-文件夹" class="headerlink" title="==创建文件/文件夹=="></a>==创建文件/文件夹==</h3><pre><code class="lang-shell">创建文件:vim fileNametouch fileName1 [fileName2 ...]创建目录(文件夹):mkdir dirName</code></pre><h3 id="删除文件夹-文件"><a href="#删除文件夹-文件" class="headerlink" title="==删除文件夹/文件=="></a>==删除文件夹/文件==</h3><pre><code class="lang-shell">rm [options] fileName/dirNameoptions:    -i:删除前逐个询问    -r:将目录以及以下的文件遍历删除    -f:即使文件为只可读也直接删除,无需确认 (-force)</code></pre><h3 id="统计目录-文件大小"><a href="#统计目录-文件大小" class="headerlink" title="统计目录/文件大小"></a>统计目录/文件大小</h3><pre><code class="lang-shell">du [-options] [fileName/dirName]options:    a或-all 显示目录中个别文件的大小。    b或-bytes 显示目录或文件大小时，以byte为单位。    h或--human-readable 以K，M，G为单位，提高信息的可读性。    k或--kilobytes 以1024 bytes为单位。    l或--count-links 重复计算硬件连接的文件。    m或--megabytes 以1MB为单位。    s或--summarize 仅显示总计。    --exclude=&lt;目录或文件&gt; 略过指定的目录或文件。    --max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。    --help 显示帮助。</code></pre><h3 id="查找文件"><a href="#查找文件" class="headerlink" title="==查找文件=="></a>==查找文件==</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p><code>find</code>命令与<code>locate</code>命令相比各有各的优缺点，<code>locate</code>命令的优点就是查找速度比<code>find</code>命令快的多，但是缺点也比较明显，<code>locate</code>命令无法查找最新添加的文件/目录以及会查找出来已经过期的文件/目录。</p><p>相反<code>find</code>命令的优点就是可以按照自定义的方法查找任何文件，缺点就是查询速度比较慢，因为是通过遍历硬盘来查找而不像<code>locate</code>命令事先建立好数据库来进行查找。</p><pre><code class="lang-shell">find path -options [-print] [-exec command /-ok command &#123;&#125; \ ]    -exec: 将前面查询到的文件交给 exec后的命令完成    -ok:将前面查询到的文件交给 ok 后的命令完成 (安全,执行一次,询问一次)    但是性能较低,做一次操作创建一个进程,而且有参数长度限制(文件过多执行出错)    推荐使用:        find path -options | xargs command        在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。options:    name/iname : 文件名符合name的文件,iname会忽略大小写    path/ipath : 路径名符合p的文件,ipath会忽略大小写    empty : 空的文件夹,或者是空目录    size [+/-]n:文件大小是(大于/小于)n的文件    type c:文件类型是c的文件,类型:f(文件),d(目录),l(链接)    user : 按照文件属于的用户来查找文件    nouser : 查找无效用户的文件(userdel删除用户时没有-r)    group : 按照文件所属的组来查找文件    mtime -/+ n :按照文件的更改时间来查找文件(-n表示距离现在n天以内 +n代表更改时间距现在n天以前)    perm : 按照文件权限来查找文件例:    想要在/etc目录中查找文件名以host开头的文件    find /etc -name &quot;host*&quot;</code></pre><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p><code>locate</code>命令要比其他查找文件命令（例如:<code>find</code>）快得多，原因在于它不搜索具体目录，而是搜索一个数据库<code>/var/lib/mlocate/mlocate.db</code>。</p><p><code>/var/lib/mlocate/mlocate.db</code>这个数据库中含有本地所有文件信息。Linux 系统自动创建这个数据库，并且每天自动更新一次，因此，我们在用<code>locate</code>查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。为了避免这种情况，可以在使用<code>locate</code>之前，先使用<strong><code>updatedb</code></strong>命令，手动更新数据库。</p><pre><code class="lang-shell">locate　命令参数　文件/目录    参数列表:        -c, --count            只输出找到的数量；        -d, --database DBPATH  使用DBPATH指定的数据库，而不是默认数据库/var/lib/mlocate/mlocate.db；        -i, --ignore-case      忽略大小写；        -q, --quiet            安静模式，不会显示任何错误讯息；        -e, --existing         只显示当前存在的文件条目；</code></pre><p>案例演示<code>1</code>：</p><p>搜索<code>etc</code>目录下以<code>pass</code>开头的文件或目录，具体使用如下命令：</p><pre><code class="lang-shell">locate /etc/pass</code></pre><p>案例演示<code>２</code>：</p><p>搜索包含<code>passwd</code>字母的文件或目录总个数，具体使用如下命令：</p><pre><code class="lang-shell">locate -c passwd</code></pre><h3 id="管道符"><a href="#管道符" class="headerlink" title="==管道符=="></a>==管道符==</h3><pre><code class="lang-shell">somecommand |</code></pre><h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><h4 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h4><pre><code class="lang-shell">file filePath[nd_ljq@ROOT ~]$ file part-r-00000part-r-00000: ASCII text[nd_ljq@ROOT ~]$ type ifconfigifconfig is /usr/sbin/ifconfig[nd_ljq@ROOT ~]$ file /usr/sbin/ifconfig/usr/sbin/ifconfig: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=96ce19fd01f2ed4f0a677a4b412ba28142d7ac3b, stripped, too many notes (256)ps: ELF全称为(Executable and Linkable Format)    相当于window中的exe可执行文件</code></pre><h4 id="查找文件位置"><a href="#查找文件位置" class="headerlink" title="==查找文件位置=="></a>==查找文件位置==</h4><h5 id="which"><a href="#which" class="headerlink" title="which"></a>which</h5><p><code>which</code>命令主要是用来查找系统<code>PATH</code>目录下的可执行文件，说白了就是查找那些我们已经安装好的可以直接执行的命令。</p><p><code>which</code>命令用于查找并显示给定命令的绝对路径，环境变量<code>PATH</code>中保存了查找命令时需要遍历的目录。<code>which</code>指令会在环境变量<code>$PATH</code>设置的目录里查找符合条件的文件。也就是说，使用<code>which</code>命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p><p><code>which</code>是<code>shell</code>内建命令，内建命令要比系统论命令有比较高的执行效率。</p><pre><code class="lang-shell">which　需要查找的命令</code></pre><h5 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h5><p><code>whereis</code>命令可以用来查找二进制（命令）、源文件、<code>man</code>文件。与<code>which</code>不同的是这条命令可以是通过文件索引数据库而非<code>PATH</code>来查找的，所以查找的面比<code>which</code>要广。</p><pre><code class="lang-shell">whereis [options] [-B &lt;目录&gt;...] [-M &lt;目录&gt;...] [-S &lt;目录&gt;...] [文件...]options:-b 　只查找二进制文件。-f 　不显示文件名前的路径名称。-m 　只查找说明文件。-s 　只查找原始代码文件。-u 　查找不包含指定类型的文件。-B&lt;目录&gt; 　只在设置的目录下查找二进制文件。-M&lt;目录&gt; 　只在设置的目录下查找说明文件。-S&lt;目录&gt; 　只在设置的目录下查找原始代码文件。ps:该指令只能用于查找二进制文件、源代码文件和man手册页</code></pre><h4 id="查看-小-文件内容并打印到控制台"><a href="#查看-小-文件内容并打印到控制台" class="headerlink" title="==查看(小)文件内容并打印到控制台=="></a>==查看(小)文件内容并打印到控制台==</h4><pre><code class="lang-shell">cat [options] fileNameoptions:    -n:显示行号    -b:只显示有内容行的行号,忽略无内容行</code></pre><h4 id="查看-大-文件内容并打印到控制台"><a href="#查看-大-文件内容并打印到控制台" class="headerlink" title="==查看(大)文件内容并打印到控制台=="></a>==查看(大)文件内容并打印到控制台==</h4><pre><code class="lang-shell">less [options] fileName按Q键退出less命令/字符串：向下搜索&quot;字符串&quot;的功能?字符串：向上搜索&quot;字符串&quot;的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）b 向上翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一页回车键 滚动一行options:    -i:忽略大小写    -e:文件显示完自动退出    -g:只显示搜索到的最后一个关键词    -N:显示每行行号</code></pre><h4 id="查看文件头-尾"><a href="#查看文件头-尾" class="headerlink" title="==查看文件头/尾=="></a>==查看文件头/尾==</h4><pre><code class="lang-shell">head/tail [options] fileNameoptions:    -c number:只查看前/后number个字符</code></pre><h4 id="查看文件尾"><a href="#查看文件尾" class="headerlink" title="==查看文件尾=="></a>==查看文件尾==</h4><p>在屏幕上显示指定文件的末尾若干行</p><p><strong>tail 命令</strong> 用于输入文件中的尾部内容。</p><ul><li><p>默认在屏幕上显示指定文件的末尾 10 行。</p></li><li><p>处理多个文件时会在各个文件之前附加含有文件名的行。</p></li><li><p>如果没有指定文件或者文件名为<code>-</code>，则读取标准输入。</p></li><li><p>如果表示字节或行数的<code>NUM</code>值之前有一个<code>+</code>号，则从文件开头的第<code>NUM</code>项开始显示，而不是显示文件的最后<code>NUM</code>项。</p></li><li><p><code>NUM</code>值后面可以有后缀：</p><ul><li><code>b</code> : 512</li><li><code>kB</code> : 1000</li><li><code>k</code>: 1024</li><li><code>MB</code> : 1000 * 1000</li><li><code>M</code>: 1024 * 1024</li><li><code>GB</code> : 1000 <em> 1000 </em> 1000</li><li><code>G</code>: 1024 <em> 1024 </em> 1024</li><li><code>T</code>、<code>P</code>、<code>E</code>、<code>Z</code>、<code>Y</code>等以此类推。</li></ul></li></ul><p><strong>语法</strong></p><pre><code class="lang-shell">tail (选项) fileName选项:    -c, --bytes=NUM                 输出文件尾部的NUM（NUM为整数）个字节内容。    -f, --follow[=&#123;name|descript&#125;]  显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。    -F                              与 “--follow=name --retry” 功能相同。    -n, --line=NUM                  输出文件的尾部NUM（NUM位数字）行内容。    --pid=&lt;进程号&gt;                  与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令。    -q, --quiet, --silent           当有多个文件参数时，不输出各个文件名。    --retry                         即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“--follow=name”连用。    -s, --sleep-interal=&lt;秒数&gt;      与“-f”选项连用，指定监视文件变化时间隔的秒数。    -v, --verbose                   当有多个文件参数时，总是输出各个文件名。    --help                          显示指令的帮助信息。    --version                       显示指令的版本信息。</code></pre><p><strong>实例</strong></p><pre><code class="lang-shell">tail file #（显示文件file的最后10行）tail -n +20 file #（显示文件file的内容，从第20行至文件末尾）tail -c 10 file #（显示文件file的最后10个字节）tail -25 mail.log # 显示 mail.log 最后的 25 行tail -f mail.log # 等同于--follow=descriptor，根据文件描述符进行追踪，当文件改名或被删除，追踪停止tail -F mail.log # 等同于--follow=name --retry，根据文件名进行追踪，并保持重试，即该文件被删除或改名后，如果再次创建相同的文件</code></pre><p><strong>拓展</strong>:</p><p><strong>tailf</strong>命令</p><p>在屏幕上显示指定文件的末尾若干行内容，通常用于日志文件的跟踪输出</p><p><strong>补充说明</strong></p><p>tailf 命令几乎等同于<code>tail -f</code>，严格说来应该与<code>tail --follow=name</code>更相似些。当文件改名之后它也能继续跟踪，特别适合于日志文件的跟踪（follow the growth of a log file）。与<code>tail -f</code>不同的是，如果文件不增长，它不会去访问磁盘文件。tailf 特别适合那些便携机上跟踪日志文件，因为它能省电，因为减少了磁盘访问。tailf 命令不是个脚本，而是一个用 C 代码编译后的二进制执行文件，某些 Linux 安装之后没有这个命令。</p><p>tailf 和 tail -f 的区别</p><ol><li>tailf 总是从文件开头一点一点的读， 而 tail -f 则是从文件尾部开始读</li><li>tailf check 文件增长时，使用的是文件名， 用 stat 系统调用；而 tail -f 则使用的是已打开的文件描述符； 注：tail 也可以做到类似跟踪文件名的效果； 但是 tail 总是使用 fstat 系统调用，而不是 stat 系统调用；结果就是：默认情况下，当 tail 的文件被偷偷删除时，tail 是不知道的，而 tailf 是知道的。</li></ol><p><strong>语法</strong></p><pre><code class="lang-shell">tailf logfile # 动态跟踪日志文件logfile，最初的时候打印文件的最后10行内容。</code></pre><p><strong>选项</strong></p><pre><code class="lang-shell">-n, --lines NUMBER  # 输出最后数行-NUMBER             # 与NUMBER相同 `-n NUMBER&#39;-V, --version       # 输出版本信息并退出-h, --help          # 显示帮助并退出</code></pre><p><strong>参数</strong></p><p>目标：指定目标日志。</p><p><strong>实例</strong></p><pre><code class="lang-shell">tailf log/WEB.LOGtailf -n 5 log2014.log   # 显示文件最后5行内容</code></pre><h3 id="统计文件行数-单词数-字节数"><a href="#统计文件行数-单词数-字节数" class="headerlink" title="统计文件行数/单词数/字节数"></a>统计文件行数/单词数/字节数</h3><pre><code class="lang-shell">wc [options] fileNameoptions:    -l:仅查看行数    -w:仅查看单词数    -c:仅查看bytes数</code></pre><h3 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h3><h4 id="创建文件-修改文件修改时间"><a href="#创建文件-修改文件修改时间" class="headerlink" title="创建文件/修改文件修改时间"></a>创建文件/修改文件修改时间</h4><pre><code class="lang-shell">touch fileName</code></pre><pre><code class="lang-shell">vim [options] path fileName有该文件则编辑,无该文件则创建options:    +:进入vim后直接定位到文件的最后一行    &quot;+&quot;+number:定位到第number行按I进入插入模式按ESC退出插入模式,进入命令模式:x 保存退出:w 保存:q 退出dd 删除光标所在的一行:number 定位到第number行:set nu 显示行号</code></pre><h3 id="文件的归档"><a href="#文件的归档" class="headerlink" title="文件的归档"></a>文件的归档</h3><h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><pre><code class="lang-shell">gzip [options] [&lt;压缩效率&gt;] [--best/fast] [文件/目录]options:    -d:(decompress/uncompress)解开压缩文件。    -f:(force)强行压缩文件,不理会文件名称或硬链接是否存在,以及改文件是否为符号连接    -l:(list)列出压缩文件的相关信息    -n:(no-name)压缩文件时，不保存原来的文件名称及时间戳记。    -N:(name)压缩文件时，保存原来的文件名称及时间戳记。    -r:(recursive)递归处理，将指定目录下的所有文件及子目录一并处理。注意他的递归是把单个文件压缩,而不是一个整包    -v:(verbose)显示指令执行过程#压缩效率    压缩效率是一个介于1~9的数值,预设值为`6`,指定越大的数,压缩程度越高,速度越慢</code></pre><h4 id="tar"><a href="#tar" class="headerlink" title="==tar=="></a>==tar==</h4><pre><code class="lang-shell">tar [options] fileNameoptions:    -z:使用gzip处理压缩文件    -x:(extract)从压缩文件中还原文件    -v:(verbose)显示指令执行过程    -j: 支持bzip2解压文件    -f:指定归档文件名称    在参数 f 之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加 z 参数，则以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar包； 如果加 j 参数，则以 .tar.bz2 来作为tar包名。    -c:(create)建立新的归档文件。    -t:显示tar包中的文件列表</code></pre><h2 id="文本的操作"><a href="#文本的操作" class="headerlink" title="==文本的操作=="></a>==文本的操作==</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="元字符集"><a href="#元字符集" class="headerlink" title="元字符集"></a>元字符集</h4><div class="table-container"><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>只匹配行首</td></tr><tr><td>$</td><td>只匹配行尾</td></tr><tr><td>.</td><td>匹配任意字符串</td></tr><tr><td>[]</td><td>匹配[]内字符.可以是一个单字符串符，也可以是字符序列。可以使用-表示[ ]内字符序 列范围，如用[1-5]代替[12345]。[A-Z]</td></tr><tr><td>\</td><td>转义字符，因为有时在 Linux 中一些元字符有特殊含义。”\“可以使其失去应有意 义。</td></tr></tbody></table></div><h3 id="grep"><a href="#grep" class="headerlink" title="==grep=="></a>==grep==</h3><p>grep(全局正则表达式)</p><pre><code class="lang-shell">grep [OPTIONS] PATTERN [FILE...]OPTIONS:    -c：只输出匹配行的计数。    -i：不区分大小写（只适用于单字符）。    -h：查询多文件时不显示文件名。    -l：查询多文件时只输出包含匹配字符的文件名。    -n：显示匹配行及行号。    -s：不显示不存在或无匹配文本的错误信息。    -v：显示不包含匹配文本的所有行。</code></pre><h4 id="pattern-正则表达式主要参数"><a href="#pattern-正则表达式主要参数" class="headerlink" title="pattern 正则表达式主要参数"></a>pattern 正则表达式主要参数</h4><div class="table-container"><table><thead><tr><th>pattern</th><th>含义</th></tr></thead><tbody><tr><td>\</td><td>忽略正则表达式中特殊字符的原有含义，用于转义</td></tr><tr><td>^</td><td>匹配正则表达式的开始行。</td></tr><tr><td>$</td><td>匹配正则表达式的结束行。</td></tr><tr><td>\&lt;</td><td>从匹配正则表达式的开始。</td></tr><tr><td>></td><td>到匹配正则表达式的结束。</td></tr><tr><td>[]</td><td>单个字符，如[A]即 A 符合要求 。</td></tr><tr><td>[-]</td><td>范围，如[A-Z]，即 A、B、C 一直到 Z 都符合要求 。</td></tr><tr><td>.</td><td>所有的单个字符。</td></tr><tr><td>*</td><td>有字符，长度可以为 0。</td></tr></tbody></table></div><h4 id="双引号引用"><a href="#双引号引用" class="headerlink" title="双引号引用"></a>双引号引用</h4><p>在 grep 命令中输入字符串参数时，最好将其用双引号括起来。例如：“mystring”。这样做有两 个原因，一是以防被误解为 shell 命令，二是可以用来查找多个单词组成的字符串，例如：“my string”，如果不用双引号将其括起来，那么单词 string 将被误认为是一个文件，查询结果将返回 “文件不存在”的错误信息。</p><h4 id="查询多个文件"><a href="#查询多个文件" class="headerlink" title="查询多个文件"></a>查询多个文件</h4><p>如果要在当前目录下所有. txt 文件中查找字符串“test”，我们可以使用通配符，方法如下：</p><pre><code class="lang-shell">grep &quot;test&quot; *.txt</code></pre><h4 id="行匹配数"><a href="#行匹配数" class="headerlink" title="行匹配数"></a>行匹配数</h4><p>我们可以使用”-c“来查询匹配到的行数据。</p><p>案例：查询 data.txt 文件中出现 48 的行数。</p><pre><code class="lang-shell">grep -c &quot;48&quot; data.txt</code></pre><h4 id="显示行数据"><a href="#显示行数据" class="headerlink" title="显示行数据"></a>显示行数据</h4><p>显示满足匹配模式的所有行行数。</p><p>案例：查询 data.txt 文件中出现 48 的行的数据</p><pre><code class="lang-shell">grep -n &quot;48&quot; data.txt</code></pre><h4 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h4><p>在上一例中，抽取字符串“48”，返回结果包含诸如 484 和 483 等包含“48”的 其他字符串，实际上应精确抽取只包含 48 的各行。注意在每个匹配模式中抽取字符串后有一个 Tab 键，所以应操作如下：</p><pre><code class="lang-shell"># 使用grep抽取精确匹配的方式是在抽取字符串后加”\&gt;”。grep &quot;48\&gt;&quot; data.txt</code></pre><h4 id="模式出现机率"><a href="#模式出现机率" class="headerlink" title="模式出现机率"></a>模式出现机率</h4><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/X[RQMCV9S8`UK%MU6I9N0LO.png" alt></p><p>抽取包含数字 4 至少重复出现两次的所有行</p><pre><code class="lang-shell"># 以前可以这么写grep &#39;44&#39; data.txt# 也可以这么写。grep &#39;4\&#123;2,\&#125;&#39; data.txt</code></pre><h4 id="与-或模式"><a href="#与-或模式" class="headerlink" title="与/或模式"></a>与/或模式</h4><p>grep 命令加-E 参数，这一扩展允许使用扩展模式匹配。</p><p>案例：要获取城市代码为 219 或 216。</p><pre><code class="lang-shell"># 这么写不行。grep &quot;[219][216]&quot; data.txt#grep -E &#39;219|216&#39; data.txt</code></pre><h4 id="查询文件名"><a href="#查询文件名" class="headerlink" title="查询文件名"></a>查询文件名</h4><p>有时候按照一定个格式去查找对应的文件，是一件很常用的使用场景，比如我们只是依稀记得 文件名，但是不知道它在哪里，这个时候就可以结合 grep 来进行查找。</p><p>案例 1：查找系统中所有的文件，并且这些文件的文件名要求：”以小写字母开头，然后接数字者 字母最多十位，然后一个点，文件的后缀是 2 到 4 位的小字母“，比如”test1.docx“</p><pre><code class="lang-shell"># 第一步：查询到文件find / -type f# 第二步：获取文件的文件名find / -type f -exec basename &#123;&#125; \;# 第三步：进行文件名的过滤。find / -type f -exec basename &#123;&#125; \; | grep &#39;[a-z][a-zA-Z0-9]\&#123;1,9\&#125;\.[a-z]\&#123;2,4\&#125;&#39;# 第4步：进行前后的限定。find / -type f -exec basename &#123;&#125; \; | grep &#39;^[a-z][a-zA-Z0-9]\&#123;1,9\&#125;\.[a-z]\&#123;2,4\&#125;$&#39;</code></pre><h4 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h4><p>我们上面查找文件的时候，文件名可以是数字或者大小写字母，我们写的正则表达式是”[a-zA-Z0-9]“，这种写法其实是比较麻烦的，grep 允许使用国际字符模式匹配或匹配模式的类名形式。</p><h5 id="类名及其等价的正则表达式"><a href="#类名及其等价的正则表达式" class="headerlink" title="类名及其等价的正则表达式"></a>类名及其等价的正则表达式</h5><div class="table-container"><table><thead><tr><th style="text-align:center">类</th><th style="text-align:center">等价的正则表达式</th></tr></thead><tbody><tr><td style="text-align:center">[[:upper:]]</td><td style="text-align:center">[A-Z]</td></tr><tr><td style="text-align:center">[[:lower:]]</td><td style="text-align:center">[a-z]</td></tr><tr><td style="text-align:center">[[:digit:]]</td><td style="text-align:center">[0-9]</td></tr><tr><td style="text-align:center">[[:alnum:]]</td><td style="text-align:center">[0-9a-zA-Z</td></tr><tr><td style="text-align:center">[[:alpha:]]</td><td style="text-align:center">[a-zA-Z]</td></tr><tr><td style="text-align:center">[[:space:]]</td><td style="text-align:center">空格或 tab 键</td></tr></tbody></table></div><h4 id="grep-命令的应用"><a href="#grep-命令的应用" class="headerlink" title="grep 命令的应用"></a>grep 命令的应用</h4><p>要查询其他用户和其他用户组成员有可执行权限的文件集合。</p><pre><code class="lang-shell">ls -al | grep &#39;^\-.....x..x&#39;</code></pre><h3 id="awk"><a href="#awk" class="headerlink" title="==awk=="></a>==awk==</h3><p>awk 是所有 shell 文本过滤工具</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre><code class="lang-shell">awk [OPTION] &#39;script&#39; var=value file(s) [&gt; filename]或awk [OPTION] -f scriptfile var=value file(s) [&gt; filename]OPTION:    -F fs:指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。    -v var=value:赋值一个用户定义变量。    -f scripfile:从脚本文件中读取awk命令。    -W re-interval:允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]    file(s):可以是一个文件,也可以是多个文件    [&gt; filename]:将前面输出在控制台的内容存入指定文件中</code></pre><p>如果设置了 <code>-F</code> 选项，则 awk 每次读一条记录或一行，并使用指定的 <code>分隔符</code> 分隔指定域，如果未设 置-F 选项，awk 假定 <code>空格</code> 为域分隔符，以这种格式读取数据，一直这么读取数据一直到文件末尾。</p><pre><code class="lang-shell">48 Dec 3BC1997 LPSX 68.00 LVX2A 138483 Sept 5AP1996 USP 65.00 LVX2c 18947 Oct 3ZL1998 LPSX 43.00 KVM9D 512219 dec 2CC1999 CAD 23.00 PLV2C 68484 nov 7PL1996 CAD 49.00 PLV2C 234483 may 5PA1998 USP 37.00 KVM9D 644216 sept 3ZL1998 USP 86.00 KVM9E 234</code></pre><p>参照上表，awk 每次在文件中读一行，找到域分隔符（这里是符号 <code>&#39;\t&#39;</code> ），设置其为域 n，直至一 新行（这里是缺省记录分隔符），然后，划分这一行作为一条<code>记录</code>，接着 awk 再次启动下一行读进程。</p><h4 id="模式和动作"><a href="#模式和动作" class="headerlink" title="模式和动作"></a>模式和动作</h4><p>awk 语句都由<code>模式</code> 和<code>动作</code> 组成。在一个 awk 脚本中可能有许多语句，模式部分决定动作语句何时 触发，模式部分可以省略。处理即对数据进行的操作。</p><p>模式可以是任何条件语句或复合语句或正则表达式。模式包括两个特殊字段 <code>BEGIN</code>和 <code>END</code> 。使用 BEGIN 语句设置<code>计数</code> 和 <code>打印头</code> 。BEGIN 语句使用在任何文本浏览动作之前，之后文本浏览动作依据 输入文件开始执行。END 语句用来在 awk 完成文本浏览动作后 <code>输出文本总数</code> 和 <code>结尾状态标志</code> 。如果 不特别指明模式， awk 总是匹配或打印行数。</p><p>实际动作在大括号 <code>&#123;&#125;</code>内指明。动作大多数用来打印，但是还有些更长的代码诸如 if 和循环 （looping）语句及循环退出结构。如果不指明采取动作，awk 将打印出所有浏览出来的记录。</p><h4 id="域和记录"><a href="#域和记录" class="headerlink" title="域和记录"></a>域和记录</h4><p>awk 执行时，其浏览域标记为 $1，$2…$n。这种方法称为域标识。使用这些域标识将更容易对域 进行进一步处理。使用$1,$2 表示参照第 1 和第 2 域，注意这里用逗号做域分隔。如果希望打印一个有 7 个域的记录的所有域，不必指明$1, $2, $3, $4, $5, $6, $7，可使用$0 即所有域。</p><p>如果要打印一个域或所有域，使用 print 命令，其这是一个 awk 动作（动作语法用大括号‘{}’括起 来）。</p><pre><code class="lang-shell">#以tab来切割data.txt，然后获取第1个域的值awk -F &#39;\t&#39; &#39;&#123;print $1&#125;&#39; data.txt#由于tab其实也是空格，所以我们不指定-F也行，所以也可以这么写。awk -F &#39;&#123;print $1&#125;&#39; data.txt#在上面的例子为基础进行修改，我们取第一，第二，第三个域。awk &#39;&#123;print $1,$2,$3&#125;&#39; data.txtps:$0表示所有域</code></pre><h5 id="头部与尾部"><a href="#头部与尾部" class="headerlink" title="头部与尾部"></a>头部与尾部</h5><p>我们上面使用了 TAB 来进行域之间的分隔，也可以为输出文本加入信息头与尾信息，打印信息头放 置在 BEGIN 模式部分，因为打印信息头被界定为一个动作，必须用大括号括起来。如果要打印尾部信 息我们可以使用 END 语句。END 语句在所有文本处理动作执行完之后才被执行。</p><pre><code class="lang-shell">#打印月份与价格的域信息，并且添加头与尾部的信息awk &#39;BEGIN &#123;print &quot;Month\tPrice&quot;&#125; &#123;print $2&quot;\t&quot;$5&#125;&#39; data.txt#加入尾部信息：awk &#39;BEGIN &#123;print &quot;Month\tPrice&quot;&#125; &#123;print $2&quot;\t&quot;$4&#125; END &#123;print &quot;end...&quot;&#125;&#39; data.txt</code></pre><p>当第一次使用 awk 时，如果出现错误可能不知所措，但是使用久了就会发现，可总结出以下规则， 可以帮助我们减少错误的出现。</p><ol><li>确保整个 awk 命令用单引号括起来。</li><li>确保命令内所有引号成对出现。</li><li>确保用花括号括起动作语句，用圆括号括起条件语句。</li></ol><h4 id="AWK-中的正则表达式"><a href="#AWK-中的正则表达式" class="headerlink" title="AWK 中的正则表达式"></a>AWK 中的正则表达式</h4><h5 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h5><p>awk 中正则表达式匹配操作中经常用到的字符，这些字符是有特殊含义的，</p><pre><code class="lang-shell">\ ^ $ . [] | () * + ?</code></pre><p>这里有两个字符前面的章节提到过讲到，注意它们只适用于 awk。</p><div class="table-container"><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:center">使用+匹配一个或多个字符。</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">匹配模式出现频率。例如使用/XY?Z/匹配 XYZ 或 XZ。</td></tr></tbody></table></div><h5 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h5><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center">~</td><td style="text-align:center">匹配正则表达式</td></tr><tr><td style="text-align:center">!~</td><td style="text-align:center">不匹配正则表达式(与上面条件相反)</td></tr></tbody></table></div><p>为使域匹配正则表达式，使用符号‘～’后紧跟正则表达式，也可以用 i f 语句。awk 中 if 后面的条件用 ()括起来。</p><p>案例：查询月份为”sept“的行信息。</p><pre><code class="lang-shell">awk &#39;&#123; if($2~/sept/) print $0 &#125;&#39; data.txt</code></pre><p>精确匹配 48，使用等号==，并用单引号括起条件。例如$3 == “48”，这样确保只有 48 号得以匹 配，其余则不行</p><pre><code class="lang-shell">awk &#39;&#123; if($1==&quot;48&quot;) print $0 &#125;&#39; data.txt或awk &#39;$1==&quot;48&quot; &#123; print $0 &#125;&#39; data.txt</code></pre><p>上面我们通过/[Ss]ept/实现了 Sept 与 sept 的匹配，我们其实也可以使用 <code>或</code>关系匹配 ，使用竖线 符<code>|</code>，意为匹配<code>|</code> 两边模式之一。<strong><em>注意：使用竖线符时，语句必须用圆括号括起来。</em></strong></p><pre><code class="lang-shell">awk &#39;&#123; if($2~/(Sept|sept)/) print $0 &#125;&#39; data.txt# 或者awk &#39;$2~/(Sept|sept)/&#39; data.txt# 或者awk &#39;&#123; if($2 == &quot;Sept&quot; || $2 == &quot;sept&quot;) print $0 &#125;&#39; data.txt# 或者awk &#39;$2 == &quot;Sept&quot; || $2 == &quot;sept&quot;&#39; data.txt//不加任何动作默认输出所有匹配</code></pre><p>匹配价格大于 50 的，并且库存大于 200 的。</p><pre><code class="lang-shell">awk &#39;&#123; if($5 &gt; 50 &amp;&amp; $7 &gt; 200) print $0 &#125;&#39; data.txt# 或者awk &#39;$5 &gt; 50 &amp;&amp; $7 &gt; 200&#39; data.txt</code></pre><h5 id="awk-内置变量"><a href="#awk-内置变量" class="headerlink" title="awk 内置变量"></a>awk 内置变量</h5><div class="table-container"><table><thead><tr><th style="text-align:center">变量名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">ARGC</td><td style="text-align:center">命令行参数个数</td></tr><tr><td style="text-align:center">ARGV</td><td style="text-align:center">命令行参数排列</td></tr><tr><td style="text-align:center">ENVIRON</td><td style="text-align:center">支持队列中系统环境变量的使用</td></tr><tr><td style="text-align:center">FILENAME</td><td style="text-align:center">awk 浏览的文件名</td></tr><tr><td style="text-align:center">FNR</td><td style="text-align:center">浏览文件的记录数</td></tr><tr><td style="text-align:center">FS</td><td style="text-align:center">设置输入域分隔符，等价于命令行-F 选项</td></tr><tr><td style="text-align:center">NF</td><td style="text-align:center">浏览记录的域个数(总共多少列)</td></tr><tr><td style="text-align:center">NR</td><td style="text-align:center">已读的记录数(当前行号)</td></tr><tr><td style="text-align:center">OFS</td><td style="text-align:center">输出域分隔符</td></tr><tr><td style="text-align:center">ORS</td><td style="text-align:center">输出记录分隔符</td></tr><tr><td style="text-align:center">RS</td><td style="text-align:center">控制记录分隔符</td></tr></tbody></table></div><ul><li>ARGC 支持命令行中传入 awk 脚本的参数个数。ARGV 是 ARGC 的参数排列数组，其中每一元素表 示为 ARGV[n]，n 为期望访问的命令行参数。</li><li>ENVIRON 支持系统设置的环境变量，要访问单独变量，使用实际变量名，例如： ENVIRON[“EDITOR”] =“Vi”。</li><li>FILENAME 支持 awk 脚本实际操作的输入文件。因为 awk 可以同时处理许多文件，因此如果访问 了这个变量，将告之系统目前正在浏览的实际文件。</li><li>FNR 支持 awk 目前操作的记录数。其变量值小于等于 NR。如果脚本正在访问许多文件，每一新 输入文件都将重新设置此变量。</li><li>FS 用来在 awk 中设置域分隔符，与命令行中-F 选项功能相同。缺省情况下为空格。如果用逗号来 作域分隔符，设置 FS=”,”。</li><li>NF 支持记录域个数，在记录被读之后再设置。</li><li>OFS 允许指定输出域分隔符，缺省为空格。如果想设置为#，写入 OFS=”#”。</li><li>ORS 为输出记录分隔符，缺省为新行（\n）。</li><li>RS 是记录分隔符，缺省为新行(\n)。</li></ul><p>测试 NR, NF, FILENAME 这几个内置变量的使用。</p><pre><code class="lang-shell">awk &#39;&#123; print NR, NF, $0&#125; END&#123; print FILENAME &#125;&#39; data.txt</code></pre><p><img src="/2023/07/18/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/Snipaste_2023-03-16_18-00-06.png" alt></p><p>之前有个案例是匹配价格大于五十的数据，具体如下：</p><pre><code class="lang-shell">awk &#39;&#123; if($5 &gt; 50) print $0 &#125;&#39; data.txt</code></pre><p>有的时候有这一种情况，那就是如果由于数据不完整，某一行没有五个域，这个时候就会有问题， 这个时候我们就可以先通过 NF 来进行判断，代码可以改成这样：</p><pre><code class="lang-shell">awk &#39;&#123; if(NF &gt; 5 &amp;&amp; $5 &gt; 50) print $0 &#125;&#39; data.txt或awk &#39;NF &gt; 5 &amp;&amp; $5 &gt; 50&#39; data.txt</code></pre><h5 id="awk-操作符"><a href="#awk-操作符" class="headerlink" title="awk 操作符"></a>awk 操作符</h5><p>在 awk 中使用操作符，基本表达式可以划分为数字型、字符串型、变量型、域及数组元素</p><p><strong>数据准备</strong>：雇员(emp)信息，由于上面的案例数据有的力不从心，我们引入以前数据库里面的一份数据。</p><div class="table-container"><table><thead><tr><th style="text-align:center">NO</th><th style="text-align:center">列名</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">empno</td><td style="text-align:center">int</td><td style="text-align:center">雇员编号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">ename</td><td style="text-align:center">varchar(10)</td><td style="text-align:center">雇员姓名</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">job</td><td style="text-align:center">varchar(9)</td><td style="text-align:center">职位</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">mgr</td><td style="text-align:center">int</td><td style="text-align:center">雇员直属上司</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">hiredate</td><td style="text-align:center">date</td><td style="text-align:center">雇员雇佣日期</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">sal</td><td style="text-align:center">decimal(7,2)</td><td style="text-align:center">雇员的薪水，有五位整数两位小数组成</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">comm</td><td style="text-align:center">decimal(7,2)</td><td style="text-align:center">雇员的佣金(提成)，有五位整数两位小数组成</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">deptno</td><td style="text-align:center">int</td><td style="text-align:center">雇员所属的部门号</td></tr></tbody></table></div><p><strong>数据:</strong></p><pre><code class="lang-shell">7369,SMITH,CLERK,7902,1980-12-17,800.00,0,207499,ALLEN,SALESMAN,7698,1981-02-20,1600.00,300.00,307521,WARD,SALESMAN,7698,1981-02-22,1250.00,500.00,307566,JONES,MANAGER,7839,1981-04-02,2975.00,0,207654,MARTIN,SALESMAN,7698,1981-09-28,1250.00,1400.00,307698,BLAKE,MANAGER,7839,1981-05-01,2850.00,0,307782,CLARK,MANAGER,7839,1981-06-09,2450.00,0,107788,SCOTT,ANALYST,7566,1987-04-19,3000.00,0,207839,KING,PRESIDENT,,1981-11-17,5000.00,0,107844,TURNER,SALESMAN,7698,1981-09-08,1500.00,0.00,307876,ADAMS,CLERK,7788,1987-05-23,1100.00,0,207900,JAMES,CLERK,7698,1981-12-03,950.00,0,307902,FORD,ANALYST,7566,1981-12-03,3000.00,0,207934,MILLER,CLERK,7782,1982-01-23,1300.00,0,10</code></pre><p><strong>设置域到域变量名</strong></p><p>在 awk 中，设置有意义的域名是一种好习惯，在进行模式匹配或关系操作时更容易理解。一般的变 量名设置方式为 name=$n，这里 name 为引用的域变量名，n 为实际域号。例如设置学生域名为 name，年龄的域名为 age，操作为 name=$1; age=$2。注意分号的使用，它分隔 awk 命令。下面例 子中，重新赋值月份名域为 month，价格域为 price。查询价格大于 50 的记录，并最终打印月份和价格。</p><pre><code class="lang-shell">awk &#39;&#123;if($5&gt;50) print $2, $5 &#125;&#39; data.txt#awk &#39;&#123;month=$2; price=$5; if(price&gt;50) print month, price &#125;&#39; data.txt</code></pre><p>也可以在 BEGIN 部分给变量赋值，然后再后面使用：</p><pre><code class="lang-shell">awk &#39;&#123; if($5 &gt; 50) print $0 &#125;&#39; data.txtawk &#39;BEGIN &#123; PRICE = 50 &#125; &#123; if($5 &gt; PRICE) print $0 &#125;&#39; data.txt</code></pre><p><strong>修改数值域取值</strong></p><p>当在 awk 中修改任何域时，重要的一点是要记住实际输入文件是不可修改的，修改的只是保存在缓 存里的 awk 复本。awk 会在变量 NR 或 NF 变量中反映出修改痕迹。为修改数值域，简单的给域标识重 赋新值，如：$1=$1+5，会将域$1 数值加 5</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort 命令用于对文件内容进行排序，我们可以可以指定按指定的域来进行排序，也可以通过参 数来控制排序的规则。</p><pre><code class="lang-shell">sort [选项] 文件参数：-b：忽略每行前面开始出的空格字符。-c：检查内容有没有排序，没有输出意味着已经排序了。-d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符。-M：将前面3个字母依照月份（比如：JAN）的缩写进行排序。-m：将几个排序好的文件进行合并。-n：按照数值的大小进行排序-o：&lt;输出文件&gt; 将排序后的结果存入指定的文件。-r：以倒序的形式来进行排序。-t：&lt;分隔字符&gt; 指定排序时所用的域的分隔符（默认是空格）。-h：以人类可视化的单位来进行排序（针对于文件大小单位：kB, MB, GB等）[-k field1[, field2]]：按指定的列进行排序。</code></pre><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h3 id="HDFS-的基本操作"><a href="#HDFS-的基本操作" class="headerlink" title="HDFS 的基本操作"></a>HDFS 的基本操作</h3><h4 id="开启-关闭分布式"><a href="#开启-关闭分布式" class="headerlink" title="开启/关闭分布式"></a>开启/关闭分布式</h4><pre><code class="lang-shell">start-dfs.shstop-dfs.sh</code></pre><h4 id="在分布式文件系统中创建映射文件夹"><a href="#在分布式文件系统中创建映射文件夹" class="headerlink" title="在分布式文件系统中创建映射文件夹"></a>在分布式文件系统中创建映射文件夹</h4><pre><code class="lang-shell">hdfs dfs -mkdir Mapping_Folder_Path</code></pre><h4 id="在分布式文件系统中创建文件"><a href="#在分布式文件系统中创建文件" class="headerlink" title="在分布式文件系统中创建文件"></a>在分布式文件系统中创建文件</h4><pre><code class="lang-shell">hdfs dfs -touchz Mapping_Folder_Path/file_Name</code></pre><h4 id="查询文件列表"><a href="#查询文件列表" class="headerlink" title="查询文件列表"></a>查询文件列表</h4><pre><code class="lang-shell">hdfs dfs -ls Mapping_Folder_Path</code></pre><h4 id="查找文件-1"><a href="#查找文件-1" class="headerlink" title="查找文件"></a>查找文件</h4><pre><code class="lang-shell">hdfs dfs -find Mapping_Folder_Path -name 表达式例:hdfs dfs -find /input -name wc*   -- input映射文件夹中名字中带有wc的文件</code></pre><h4 id="打印文件"><a href="#打印文件" class="headerlink" title="打印文件"></a>打印文件</h4><pre><code class="lang-shell">hdfs dfs -cat Mapping_Folder_Path/file_name</code></pre><h4 id="移动文件夹-文件"><a href="#移动文件夹-文件" class="headerlink" title="移动文件夹/文件"></a>移动文件夹/文件</h4><pre><code class="lang-shell">hdfs dfs -mv Source_Mapping_Folder_Path  target_Mapping_Folder_Path</code></pre><h4 id="删除文件夹-文件-1"><a href="#删除文件夹-文件-1" class="headerlink" title="删除文件夹/文件"></a>删除文件夹/文件</h4><pre><code class="lang-shell">hdfs dfs -rm &lt;-r&gt; &lt;-skipTrash&gt; Mapping_Folder_Path/file_name-r 递归删除-skipTrash 彻底删除(不进垃圾桶)</code></pre><h4 id="把本地文件追加到映射文件末尾"><a href="#把本地文件追加到映射文件末尾" class="headerlink" title="把本地文件追加到映射文件末尾"></a>把本地文件追加到映射文件末尾</h4><pre><code class="lang-shell">hdfs dfs -appendToFile localfile_Path/file_name Mapping_Folder_Path/file_name</code></pre><h4 id="上传文件到分布式文件系统的映射文件夹"><a href="#上传文件到分布式文件系统的映射文件夹" class="headerlink" title="上传文件到分布式文件系统的映射文件夹"></a>上传文件到分布式文件系统的映射文件夹</h4><pre><code class="lang-shell">hdfs dfs -put file_Name/file_Path Mapping_Folder_Path --本地文件复制上传hdfs dfs -movefromLocal file_Name/file_Path Mapping_Folder_Path  --本地文件删除上传例: hdfs dfs -put hello.txt /input</code></pre><h4 id="从分布式文件系统的映射文件夹下载文件到本地路径"><a href="#从分布式文件系统的映射文件夹下载文件到本地路径" class="headerlink" title="从分布式文件系统的映射文件夹下载文件到本地路径"></a>从分布式文件系统的映射文件夹下载文件到本地路径</h4><pre><code class="lang-shell">hdfs dfs -get Mapping_Folder_Path file_Name/file_Path --映射文件复制到本地路径</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker的基本使用</title>
      <link href="/2023/07/18/docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/07/18/docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker的基本使用"><a href="#Docker的基本使用" class="headerlink" title="Docker的基本使用"></a>Docker的基本使用</h1><p>docker的意思是容器,是基于Go语言的轻量级的虚拟机</p><h3 id="Ubuntu安装Docker"><a href="#Ubuntu安装Docker" class="headerlink" title="Ubuntu安装Docker"></a>Ubuntu安装Docker</h3><pre><code class="lang-bash">sudo apt install docker.io#也可以使用wget使用官方脚本来进行安装curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code></pre><h4 id="检查docker是否安装成功"><a href="#检查docker是否安装成功" class="headerlink" title="检查docker是否安装成功"></a>检查docker是否安装成功</h4><pre><code class="lang-shell">docker version</code></pre><p><img src="/2023/07/18/docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/20190328162445806.jpg" alt="img"></p><p>注意这里只显示了Client的信息，下面有一个报错: persission denied…，这个是因为我们安装的时候是用的sudo安装，在这里是没有权限连接docker的服务端，解决办法是把当前用户加入到docker组里面去。</p><p>首先新建一个docker组</p><pre><code>sudo groupadd docker</code></pre><p>但是很可能已经有了docker组了，已有的话就不用管了，继续下一步<br><img src="/2023/07/18/docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/20190328164344428.png" alt="img"><br>然后把当前用户加入docker组</p><pre><code>sudo gpasswd -a $&#123;USER&#125; docker</code></pre><p>重启docker</p><pre><code class="lang-shell">sudo service docker restart</code></pre><p>切换当前会话到新 group</p><pre><code class="lang-shell">newgrp - docker</code></pre><p>最后一步是必须的，如果不切换，组信息不会立刻生效的。</p><p>最后测试下效果</p><pre><code class="lang-shell">docker version</code></pre><p><img src="/2023/07/18/docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/1.png" alt="img"></p><p>最后的最后，因为国内网速问题，下载镜像比较慢所以可以使用国内大厂提供的加速器，我这里使用的是阿里云提供的加速器，使用镜像加速必须得改一下docker的配置文件 /etc/docker/daemon.json</p><pre><code class="lang-shell">#没有则新建sudo vim /etc/docker/daemon.json#在里面加入阿里云镜像加速器地址&#123;  &quot;registry-mirrors&quot;: [&quot;https://4m0bchll.mirror.aliyuncs.com&quot;]&#125;</code></pre><p>刷新设置,重启docker</p><pre><code class="lang-shell">sudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><h4 id="设置docker开机自启"><a href="#设置docker开机自启" class="headerlink" title="设置docker开机自启"></a>设置docker开机自启</h4><pre><code class="lang-bash">systemctl enable docker</code></pre><h3 id="Docker的基本指令"><a href="#Docker的基本指令" class="headerlink" title="Docker的基本指令"></a>Docker的基本指令</h3><h4 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h4><pre><code class="lang-shell">docker version</code></pre><h4 id="查看docker信息"><a href="#查看docker信息" class="headerlink" title="查看docker信息"></a>查看docker信息</h4><pre><code class="lang-shell">docker info</code></pre><h4 id="查询镜像信息"><a href="#查询镜像信息" class="headerlink" title="查询镜像信息"></a>查询镜像信息</h4><pre><code class="lang-shell">docker search mirrorName例子docker search nginx</code></pre><p>镜像给我的感觉就像是安装包</p><h4 id="查询镜像-容器元数据"><a href="#查询镜像-容器元数据" class="headerlink" title="查询镜像/容器元数据"></a>查询镜像/容器元数据</h4><pre><code class="lang-shell">docker inspect [OPTIONS] NAME/ID [NAME/ID...]OPTIONS：    -f :指定返回值的模板文件。    -s :显示总的文件大小。    --type :为指定类型返回JSON。#获取镜像mysql:5.6的元信息docker inspect mysql:5.6</code></pre><h4 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h4><pre><code class="lang-shell">docker pull mirrorName[:versionNumber][]里为可选不加具体版本的话默认下载最新版本</code></pre><h4 id="查看本地镜像列表"><a href="#查看本地镜像列表" class="headerlink" title="查看本地镜像列表"></a>查看本地镜像列表</h4><pre><code>docker images</code></pre><h4 id="给镜像打标签"><a href="#给镜像打标签" class="headerlink" title="给镜像打标签"></a>给镜像打标签</h4><pre><code class="lang-shell">docker tag source_image[:tag](就是image查询种对应镜像的id) tartget_image[:tag]镜像结构 registryname/respositoryname(仓库名)/imagename(镜像名):tagname(标签名)</code></pre><h4 id="登录docker"><a href="#登录docker" class="headerlink" title="登录docker"></a>登录docker</h4><pre><code class="lang-shell">docker login#登录后的用户信息会保存在 ~/.docker/config.json种</code></pre><h4 id="将镜像发布到远程"><a href="#将镜像发布到远程" class="headerlink" title="将镜像发布到远程"></a>将镜像发布到远程</h4><pre><code class="lang-shell">docker push userName/imageName:versionTag</code></pre><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><pre><code class="lang-shell">#删除标签(删除指定版本的镜像)docker rmi repository[:tag]#强制删除docker rmi -f imageID</code></pre><h4 id="运行镜像-创建容器"><a href="#运行镜像-创建容器" class="headerlink" title="运行镜像(创建容器)"></a>运行镜像(创建容器)</h4><pre><code class="lang-shell">docker run [options] image [command] [arguments]options:    -i:表示启动一个可交互的容器,并持续打开标准输入,通常与 -t 同时使用    -t:为容器重新分配一个伪输入终端，通常与 -i 同时使用    -d:表示容器放置后台运行    -p: 指定端口映射，格式为：主机(宿主)端口:容器端口    -m :设置容器使用内存最大值；    -h &quot;mars&quot;: 指定容器的hostname    -v 容器外部目录:容器内部目录 -&gt;绑定一个卷(将容器外部目录映射到容器外部目录)    如果不写容器外部目录,则是匿名挂载    --volumes-from container1 :将容器名为container1的数据卷共享给当前run指令创建的容器    --rm:表示退出后即删除容器    --name:表示定义容器的唯一名称,不指定docker默认分配    --expose=[]: 开放一个端口或一组端口    --cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定CPU运行    --dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；    --dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；    --restart= 后接1个参数(always:容器退出时总是重启;                           on-failure:number :若容器的退出状态非0，则docker自动重启容器，还可以指定重启次数，若超过指定次数未能启动容器则放弃;                           no: 默认值，表示容器退出时，docker不自动重启容器;                           )    image:表示要运行的镜像    command:表示启动容器时要运行的命令#启动一个交互式容器    docker run -it hello-world</code></pre><h5 id="更新容器参数"><a href="#更新容器参数" class="headerlink" title="更新容器参数"></a>更新容器参数</h5><p>若在docker run 创建容器时未指定某些参数,可以通过docker update 命令进行更新一个或多个容器</p><pre><code class="lang-shell">docker update [...options] CONTAINER_ID/CONTAINER_NAME [...CONTAINER_ID/CONTAINER_NAME]OPTIONS:    --cpu-shares :更新 cpu-shares。    --kernel-memory :更新内核内存限制。    --memory :更新内存限制。    --restart :更新重启策略。</code></pre><h5 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h5><pre><code class="lang-shell">exit :容器停止并退出ctrl+p+q: 容器不停止退出</code></pre><h4 id="查看正在运行的容器列表"><a href="#查看正在运行的容器列表" class="headerlink" title="查看正在运行的容器列表"></a>查看正在运行的容器列表</h4><pre><code class="lang-shell">docker ps [options]options:    -a:查询所有容器,包括已经停止的或正在运行的(不加默认列出正在运行种的)    -f:filter filter根据所提供的条件过滤输出        format string使用Go模板漂亮打印容器    -n:last int显示n个最近创建的容器(包括所有状态)(默认为-1)    -l:latest显示最新创建的容器(包括所有状态)    ——no-trunc不要截断输出    -q:quiet只显示容器id    -s:size显示文件总大小#列出已经关闭的容器列表docker ps -f STATUS=exited</code></pre><h4 id="进入后台容器"><a href="#进入后台容器" class="headerlink" title="进入后台容器"></a>进入后台容器</h4><h5 id="exec进入"><a href="#exec进入" class="headerlink" title="exec进入"></a>exec进入</h5><pre><code class="lang-shell">docker exec [options] container(ID/Name) command [args...]options:    -d :分离模式: 在后台运行    -i :即使没有附加也保持STDIN(标准输入)打开    -t :分配一个伪终端每次连接到容器,相当于重新创建一个终端</code></pre><h5 id="attach进入"><a href="#attach进入" class="headerlink" title="attach进入"></a>attach进入</h5><pre><code class="lang-shell">docker attach container#但在，使用该命令有一个问题。当多个窗口同时使用该命令进入该容器时，所有的窗口都会同步显示。如果有一个窗口阻塞了，那么其他窗口也无法再进行操作。</code></pre><p>因为这个原因，所以docker attach命令不太适合于生产环境，平时自己开发应用时可以使用该命令。</p><p>区别:</p><p>docker exec: 进入容器就开启一个新的终端(常用),执行exit时不会停止容器</p><p>docker attach:进入容器正在执行的终端 exit退出会停止容器</p><h4 id="启动已经停止的容器"><a href="#启动已经停止的容器" class="headerlink" title="启动已经停止的容器"></a>启动已经停止的容器</h4><pre><code class="lang-shell">docker start container(ID/name)</code></pre><h4 id="停止正在运行的容器"><a href="#停止正在运行的容器" class="headerlink" title="停止正在运行的容器"></a>停止正在运行的容器</h4><pre><code class="lang-shell">docker stop container(ID/name)</code></pre><h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4><pre><code class="lang-shell">docker restart container(ID/name)</code></pre><h4 id="删除已经停止的容器"><a href="#删除已经停止的容器" class="headerlink" title="删除已经停止的容器"></a>删除已经停止的容器</h4><pre><code class="lang-shell">docker rm [OPTIONS] container(ID/name)OPTIONS:    --force , -f:强制删除正在运行的容器（使用 SIGKILL）    --link , -l:删除指定的链接    --volumes , -v:删除与容器关联的匿名卷#删除所有已经停止的容器docker rm $(docker ps -qf status=exited)</code></pre><h4 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h4><pre><code class="lang-shell">docker logs [options] container(ID/name)options:    -f:跟踪日志输出    --since:显示某个开始时间的所有日志    -t:显示时间戳    --tail:仅列出最新n条容器内容#跟踪查看容器mynginx的日志输出。 docker logs -f mynginx#查看容器mynginx从2016年7月1日后的最新10条日志。docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginx</code></pre><h4 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h4><h5 id="将容器制作成镜像"><a href="#将容器制作成镜像" class="headerlink" title="将容器制作成镜像"></a>将容器制作成镜像</h5><pre><code class="lang-shell">docker commit [options] container(ID/name) [REPOSITORY[:TAG]]options:    -a :提交的镜像作者；    -c :使用Dockerfile指令来创建镜像；    -m :提交时的说明文字；    -p :在commit时，将容器暂停。</code></pre><h5 id="将指定docker对象保存成归档文件"><a href="#将指定docker对象保存成归档文件" class="headerlink" title="将指定docker对象保存成归档文件"></a>将指定docker对象保存成归档文件</h5><h6 id="基于save保存镜像与基于load加载镜像"><a href="#基于save保存镜像与基于load加载镜像" class="headerlink" title="基于save保存镜像与基于load加载镜像"></a>基于save保存镜像与基于load加载镜像</h6><p><strong>将指定<code>镜像</code>保存为归档文件</strong></p><pre><code class="lang-shell">docker save [options] image [image...]options:    -o:输出到的文件#将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档1.docker save -o my_ubuntu_v3.tar runoob/ubuntu:v32.docker save runoob/ubuntu:v3 &gt; my_ubuntu_v3.tar</code></pre><p><strong>归档文件解压成镜像</strong></p><pre><code class="lang-shell">docker load [options]options:    -i : 指定导入的文件，代替 STDIN。    -q : 精简输出信息。docker load &lt; busybox.tar.gzdocker load -i fedora.tar</code></pre><h6 id="导入导出容器"><a href="#导入导出容器" class="headerlink" title="导入导出容器"></a>导入导出容器</h6><p><strong>将指定容器导出为归档文件</strong></p><pre><code class="lang-shell">docker export [OPTIONS] CONTAINEROPTIONS:    --output , -o: 输出到的文件docker export -o busybox.tar busyboxContainer docker export busyboxContainer &gt; busybox.tar</code></pre><p><strong>将归档文件导入并命名为指定镜像</strong></p><pre><code class="lang-shell">docker import fileUrl imageNamedocker import busybox.tar busyboxContainer:v1</code></pre><h5 id="docker-export和docker-save的区别"><a href="#docker-export和docker-save的区别" class="headerlink" title="docker export和docker save的区别"></a>docker export和docker save的区别</h5><p>首先，两者的操作对象不同。<code>docker save</code>是将一个镜像保存为一个<code>tar</code>包，而<code>docker export</code>是将一个容器快照保存为一个<code>tar</code>包。</p><p>然后，<code>docker export</code>导出的容器快照文件将丢弃所有的历史记录和元数据信息，即仅保存容器当时的快照状态；而<code>docker save</code>保存的镜像存储文件将保存完整记录，体积也要大。下图就能够很好的说明，<code>ubuntu:test</code>仅仅占<code>97.8MB</code>而<code>ubuntu:latest</code>却占了<code>120MB</code>。</p><p><img src="/2023/07/18/docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20230606083054790.png" alt="image-20230606083054790"></p><h5 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h5><p>使用<code>commit</code>构建一个镜像，由于<code>commit</code>在构建镜像时，很容易将无关内容添加到镜像且维护起来十分困难。所以不推荐使用<code>commit</code>来构建一个镜像。官方推荐使用<code>Dockerfile</code>来构建一个镜像</p><h6 id="Dockerfile简介"><a href="#Dockerfile简介" class="headerlink" title="Dockerfile简介"></a>Dockerfile简介</h6><p>镜像的定制实际上就是定制每一层所添加的配置、文件。那么如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是<code>Dockerfile</code>。</p><p><code>Dockerfile</code>描述了组装镜像的步骤，其中每一条命令都是单独执行的，除了<code>FROM</code>指令外，其他每一条指令都在上一条指定所生成的镜像基础上执行，执行完会生成一个新的镜像层，新的镜像层覆盖在原来的镜像层之上，从而形成了新的镜像。<code>Dockerfile</code>所生成的最终镜像就是在基础叠加镜像上一层层的镜像层组成的。</p><p>在<code>Dockerfile</code>中，指令不区分大小写，但是为了与参数区分，推荐大写。<code>Docker</code>会顺序执行<code>Dockerfile</code>中的指令，第一条必须是<code>FROM</code>指令，它用于指定构建镜像的基础镜像。在<code>Dockerfile</code>中，以<code>#</code>开头的行是注释。</p><h6 id="FROM指令和RUN指令"><a href="#FROM指令和RUN指令" class="headerlink" title="FROM指令和RUN指令"></a>FROM指令和RUN指令</h6><p>●<code>FROM</code>指定基础镜像； 格式：<code>FROM &lt;image&gt;</code>或 <code>FROM &lt;image&gt;:&lt;tag&gt;</code>。</p><p><code>FROM</code>指令的功能是为后面的指令提供基础镜像，因此一个有效的<code>Dockerfile</code>必须以<code>FROM</code>指令作为第一条非注解指令。若<code>FROM</code>指令中<code>tag</code>参数为空，则<code>tag</code>默认为<code>latest</code>；若参数<code>image</code>或<code>tag</code>指定镜像不存在，则返回错误。</p><p>●<code>RUN</code>执行命令； 格式：<code>RUN &lt;command&gt;</code>（<code>shell</code>格式）或<code>RUN [“executable”, “param1“, “param2”]</code>（<code>exec</code>格式，非常推荐）。</p><p><code>RUN</code>指令是用来执行命令行命令的。<code>RUN</code>指令会在前一条命令创建出的镜像的基础上创建一个容器，并在容器中运行命令。在命令结束运行后提交新容器为新镜像，新镜像被<code>Dockerfile</code>的下一条指令使用。</p><p>之前说过，<code>Dockerfile</code>中每一个指令都会建立一个镜像层，<code>RUN</code>也不例外。每一个<code>RUN</code> 的行为，就和之前学习的<code>docker commit</code>定制镜像的过程一样：在之前镜像的基础上创建一个容器，在其上执行这些命令，执行结束后，最后 <code>commit</code> 这一层的修改，构成新的镜像。</p><p>下面举一个实例，使用<code>Dockerfile</code>构建一个名为<code>testimage</code>的镜像，该镜像具备<code>ubuntu:latest</code>的运行环境，而且在镜像的/目录下创建了一个<code>dir1</code>文件夹。</p><pre><code class="lang-shell">#先创建一个新的空文件夹mkdir newdir#进入这个新文件夹中cd newdir#创建一个Dockerfile文件touch Dockerfile#补全Dockerfile的内容（为了方便展示，这里用的是echo向Dockerfile中输入内容）echo &quot;FROM ubuntu:latest&quot; &gt; Dockerfileecho &quot;RUN mkdir /dir1&quot; &gt;&gt; Dockerfile#使用该Dockerfile构建一个名为testimage的镜像docker build -t testimage .</code></pre><p><strong>Dockerfile构建镜像的过程详解</strong></p><p>上面的实例创建了一个<code>Dockerfile</code>文件，<code>Dockerfile</code>的内容如下：</p><pre><code class="lang-shell">FROM ubuntu:latestRUN mkdir /dir1</code></pre><p>执行<code>docker build</code>命令，指定使用<code>Dockerfile</code>构建一个镜像。执行结果如下所示：</p><pre><code class="lang-shell">[root@localhost newdir]# docker build -t testimage .Sending build context to Docker daemon 2.048 kBStep 1/2 : FROM ubuntu  ---&gt; 14f60031763dStep 2/2 : RUN mkdir dir1  ---&gt; Running in c5117d908931  ---&gt; cb0193727724Removing intermediate container c5117d908931Successfully built cb0193727724</code></pre><p><code>Docker</code>指令是从上到下一层一层执行的，所以在使用这个<code>Dockerfile</code>构建镜像时，首先执行<code>FROM ubuntu:latest</code>这条指令。</p><p><code>FROM ubuntu:latest</code>指定<code>ubuntu:latest</code>作为基础镜像，也就是将<code>ubuntu:latest</code>镜像的所有镜像层放置在<code>testimage</code>镜像的最下面。</p><p>然后执行<code>RUN mkdir dir1</code>指令，前面我们说过，执行<code>RUN</code>指令时，会在之前指令创建出的镜像的基础上创建一个临时容器，在这里的容器<code>Id</code>为<code>c5117d908931</code>，并在容器中运行命令。在命令结束运行后提交新容器为新镜像，并删除临时创建的容器<code>c5117d908931</code>。</p><p>在<code>Dockerfile</code>的所有指令执行完后，新镜像就构建完成了</p><p> <strong><em>注意事项，谨慎使用RUN</em></strong></p><p> <strong>修改前的Dokcerfile文件</strong></p><p>既然<code>RUN</code>就像 <code>Shell</code> 脚本一样可以执行命令，那么是否就可以像<code>Shell</code> 脚本一样把每个命令对应一个<code>RUN</code>呢？比如这样：</p><pre><code class="lang-shell">FROM debian:jessieRUN apt-get updateRUN apt-get install -y gcc libc6-dev makeRUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install</code></pre><p>上面这个<code>Dockerfile</code>是为了编译、安装 <code>redis</code>可执行文件。虽然它能够完成了所需的功能，但是正如之前说过，<code>Dockerfile</code>中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个<code>RUN</code>的行为，都会创建一个新的镜像层。</p><p>而上面的这种写法，创建了<code>8</code>层镜像（<code>1</code>层基础镜像<code>+7</code>层由<code>RUN</code>执行创建的镜像）。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。</p><p><strong>修改后的Dockerfile文件</strong></p><p>因为之前所有的命令只有一个目的，就是编译、安装 <code>redis</code> 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，修改之后的<code>Dockerfile</code>文件并没有使用很多个<code>RUN</code>指令，而仅仅使用一个<code>RUN</code> 指令，并使用 <code>&amp;&amp;</code>将各个命令串联起来。除此以外，把redis的编译环境、更新的软件包也通通清除掉了，减少镜像占用的存储空间。如下所示，修改之后的<code>Dockerfile</code>构建完成后是就只会有<code>2</code>层镜像了（<code>1</code>层基础镜像<code>+1</code>层由<code>RUN</code>执行创建的镜像）。</p><pre><code class="lang-shell">FROM debian:jessieRUN buildDeps=&#39;gcc libc6-dev make&#39; \&amp;&amp; apt-get update \&amp;&amp; apt-get install -y $buildDeps \&amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \&amp;&amp; mkdir -p /usr/src/redis \&amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \&amp;&amp; make -C /usr/src/redis \&amp;&amp; make -C /usr/src/redis install \&amp;&amp; rm -rf /var/lib/apt/lists/* \&amp;&amp; rm redis.tar.gz \&amp;&amp; rm -r /usr/src/redis \&amp;&amp; apt-get purge -y --auto-remove $buildDeps</code></pre><p>在<code>Dockerfile</code>的编写过程中一定要牢记一点：镜像的每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。</p><h6 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h6><p><code>Dockerfile</code>创建完成后，可以使用<code>docker build</code>命令根据<code>Dockerfile</code>构建一个镜像。</p><pre><code class="lang-shell">docker build [OPTIONS] 上下文路径|URLOPTIONS:    -f:显示指定Dockerfile,如果不使用-f，则默认将上下文路径下的名为Dockerfile的文件认为是构建镜像的“Dockerfile”    -t:指定镜像名称    上下文路径|URL： 指定构建镜像的上下文的路径，构建镜像的过程中，可以且只可以引用上下文中的任何文件。</code></pre><p>现在让我们在看看<code>docker build -t myimage .</code>这条命令，在这条命令中，使用<code>-t</code>指定了镜像名为<code>myimage</code>，由于没有使用<code>-f</code>指令，所以默认使用上下文路径下名为<code>Dockerfile</code>的文件认为是构建镜像的“<code>Dockerfile</code>”。最后指定上下文路径，在这条命令中，上下文路径是<code>.</code>。</p><p><code>.</code>代表着当前目录。所以<code>docker build -t myimage .</code>中小数点<code>.</code>其实就是将当前目录设置为上下文路径。</p><p>执行<code>docker build</code>后，会首先将上下文目录的所有文件都打包，然后传给<code>Docker daemon</code>，这样<code>Docker daemon</code>收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如下图所示，在执行完<code>docker build</code>后，会首先<code>sending build context to Deckor daemon</code>，也就是将上下文目录下所有文件打包发给<code>Docker daemon</code>。所以在使用<code>Dockerfile</code>文件时构建镜像时，一般将它放在一个空文件夹下，就是为了防止将其他多余的文件传出去。然后依次执行<code>Dockerfile</code>的指令，如果指令正确执行，则继续执行下一条，直到所有指令执行正确完毕，镜像构建完成；如果指令执行出错，终止镜像构建。</p><p><img src="/2023/07/18/docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/image-20230606092243574.png" alt="image-20230606092243574"></p><h3 id="主机和docker的交互"><a href="#主机和docker的交互" class="headerlink" title="主机和docker的交互"></a>主机和docker的交互</h3><h4 id="主机和docker文件中的相互拷贝"><a href="#主机和docker文件中的相互拷贝" class="headerlink" title="主机和docker文件中的相互拷贝"></a>主机和docker文件中的相互拷贝</h4><pre><code class="lang-shell">#容器-&gt;主机docker cp [options] container(ID\name):source_path 主机path#主机-&gt;容器docker cp [options] 主机path container(ID\name):source_path options:    -L:保持源目标中的链接#将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。docker cp /www/runoob 96f7f14e99ab:/www/#将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。docker cp /www/runoob 96f7f14e99ab:/www#将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。docker cp  96f7f14e99ab:/www /tmp/</code></pre><h4 id="将主机中的目录映射到容器中"><a href="#将主机中的目录映射到容器中" class="headerlink" title="将主机中的目录映射到容器中"></a>将主机中的目录映射到容器中</h4><pre><code class="lang-shell">docker volume COMMANDCommands:  create:挂载数据卷      Options:      -d, --driver string   Specify volume driver name (default &quot;local&quot;)      --label list      Set metadata for a volume      -o, --opt map         Set driver specific options (default map[])  inspect [options]: 查看volume数据卷的详细信息(挂载点等等)。      Options:          -f, --format string   Format the output using the given Go template  ls [options]:查看本地所有数据卷(volume)      Options:          -f, --filter filter   Provide filter values (e.g. &#39;dangling=true&#39;)          --format string   Pretty-print volumes using a Go template         -q, --quiet:只需要展示数据卷的名称  prune [options]:移除未使用的数据卷。       Options:           --filter :filter   Provide filter values (e.g. &#39;label=&lt;label&gt;&#39;)          -f, --force :Do not prompt for confirmation  rm [OPTIONS] VOLUME [VOLUME...]:移除一个或多个数据卷，不能移除被容器使用的数据卷。      Options:           -f, --force:Force the removal of one or more volumes  #输出容器container1创建的数据卷的名字  docker inspect --type container --format=&#39;&#123;&#123;range .Mounts&#125;&#125;&#123;&#123;.Name&#125;&#125;&#123;&#123;end&#125;&#125;&#39; container1</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程基础</title>
      <link href="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><h2 id="软件工程的概念和思想"><a href="#软件工程的概念和思想" class="headerlink" title="软件工程的概念和思想"></a>软件工程的概念和思想</h2><h3 id="何为软件工程"><a href="#何为软件工程" class="headerlink" title="何为软件工程"></a>何为软件工程</h3><pre><code class="lang-css">1968年,北大西洋公约组织(NATO)科学委员会在西德召开的研讨会上着重讨论如何应对软件危机,会上人们首次提出&quot;软件工程&quot;概念,进而开启了软件工程的研究与实践根据IEEE给出的定义,软件工程是指:①将系统的、规范的、可量化的方法应用于软件开发、运行和维护的过程②以及以上方法的研究</code></pre><p>这一概念定义给出了软件工程的两个方面的内涵,以是软件工程要提供系统的、规范的、可量化的方法来指导软件的开发、运行和维护,而是软件工程要研究方法本身</p><h3 id="软件工程的三要素"><a href="#软件工程的三要素" class="headerlink" title="软件工程的三要素"></a>软件工程的三要素</h3><p>软件工程的三方面的核心要素是:==过程==、==方法学==和==工具==</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>该要素主要是从管理的视角,回答软件开发、运行和维护需要做哪些工作、如何管理好这些工作等问题,关注软件项目的规范化组织和可量化实施</p><p>至今,软件工程已提出了诸多软件开发过程模型,包括<code>瀑布模型</code>、<code>增量模型</code>、<code>原型模型</code>、<code>迭代模型</code>、<code>螺旋模型</code>。每一种模型都反映了软件开发的不同理解和认识,进而采用不同的过程。此外,软件工程还提供了一组开发方法,如<code>敏捷方法(agile method)</code>、<code>群体化开发方法(crowd-based development)</code>、<code>DevOps方法</code>等。他们为软件开发过程中的开发和维护活动、软件制品的交付方式、软件开发人员的组织和协同等提供指导思想、原则和策略</p><h4 id="方法学"><a href="#方法学" class="headerlink" title="方法学"></a>方法学</h4><pre><code class="lang-css">该要素主要是从技术的视角,回答软件开发、运行和维护如何做的问题。方法学旨在为软件开发过程中的各项开发和维护活动提供系统、规范的技术支持,包括:如何理解和认识软件模型,如何用不同抽象层次的模型描述不同开发活动所产生的软件制品,采用什么样的建模语言描述软件模型,提供什么样的编程语言实现软件模型,提供什么样的策略和原则指导各项活动的开展,如何确保开发活动、维护活动和软件制品的质量等。至今,软件工程已提出诸多人软件开发方法学,如`结构化软件开发方法学`、`面向对象软件开发方法学`、`基于构件的软件开发方法学`、`面向主体的软件开发方法学`。</code></pre><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>该要素主要是从工具辅助的视角,回答如何借助工具来辅助软件开发、运行和维护的问题</p><h3 id="软件工程的目标"><a href="#软件工程的目标" class="headerlink" title="软件工程的目标"></a>软件工程的目标</h3><p>软件工程的整体目标是在成本、进度、资源等约束下,帮助软件开发人员开发出满足用户要求的足够好的软件系统。软件开发、运行和维护是一项极为复杂的工作,涉及多方的利益相关者,包括客户、用户、开发者、维护者、管理者等,他们会从各自的角度提出各自的诉求。软件工程就是要站在这些利益相关者的角度实现以下目标:</p><p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/image-20230617101440688.png" alt="image-20230617101440688"></p><ol><li>指导开发、运行和维护</li><li>满足工程约束</li><li><p>确保软件质量</p><pre><code class="lang-css">对软件客户、用户而言,所谓的足够好是指软件具有正确性、友好性、可靠性、易用性等特点;而对于软件开发者、维护者、管理者而言,所谓的足够好是指软件具有可维护性、可理解性、可重用性,互操作性等</code></pre></li></ol><h3 id="软件工程的原则"><a href="#软件工程的原则" class="headerlink" title="软件工程的原则"></a>软件工程的原则</h3><ol><li>抽象和建模</li><li>模块化</li><li>软件重用</li><li>信息隐藏</li><li>关注点分离</li><li>分治</li><li>双向追踪</li><li>工具辅助</li></ol><h2 id="开源软件"><a href="#开源软件" class="headerlink" title="开源软件"></a>开源软件</h2><h3 id="何为开源软件"><a href="#何为开源软件" class="headerlink" title="何为开源软件"></a>何为开源软件</h3><p>开源软件是一种源代码可以自由获取和传播的计算机软件,其拥有者通过开源许可证赋予被许可人对软件进行使用、修改和传播的权利。开源软件采用群体化的思想和理念,代表了一种新的软件开发方法</p><h3 id="开源软件实践"><a href="#开源软件实践" class="headerlink" title="开源软件实践"></a>开源软件实践</h3><p>第一次重大变化发生在新闻组出现之后。</p><p>第二次重大变化是发生在万维网技术出现之后。许多开源软件分别建立了各自独立的开发社区,如 Linux、Apache、Eclipse 以及 Mozilla 等</p><p>第三次变化以 SourceForge 平台上线为标志。它极大的降低了开源软件开发者的参与门槛,使软件开源开发从面向技术精英逐步扩展到所有感兴趣的开发者,极大的激励发了广大软件开发者参与开源实践的创作激情</p><p>第四次变化以 GitHub、Stack Overflow 等独立功能平台上线为标志。2008 年 GitHub 开始投入运营,以托管软件开源项目、辅助群体化的分布式协同开发。同年 Stack Overflow 投入运营以支持开发者群体交流和分享软件开发知识,如讨论开发问题,交流开发经验等</p><h4 id="政府组织"><a href="#政府组织" class="headerlink" title="政府组织"></a>政府组织</h4><h4 id="开源组织"><a href="#开源组织" class="headerlink" title="开源组织"></a>开源组织</h4><p>①Apache 基金会。该组织成立于 1999 年</p><p>②Linux 基金会。该组织成立于 2007 年</p><p>③Eclipse 基金会。该组织成立于 2004 年</p><p>④Open Source Initiative。该组织成立于 1998 年</p><p>⑤ 开放原子开源基金会。该组织与 2020 年 6 月在我国登记注册</p><h4 id="企业开发者"><a href="#企业开发者" class="headerlink" title="企业开发者"></a>企业开发者</h4><h4 id="个人开发者"><a href="#个人开发者" class="headerlink" title="个人开发者"></a>个人开发者</h4><h3 id="开源软件的优势"><a href="#开源软件的优势" class="headerlink" title="开源软件的优势"></a>开源软件的优势</h3><ol><li>采购和开发成本更低</li><li>软件质量更高、更安全</li><li>软件研制和交付更快</li><li>软件功能更全面,更具创新性</li></ol><h3 id="开源许可证"><a href="#开源许可证" class="headerlink" title="开源许可证"></a>开源许可证</h3><h4 id="宽松式开源许可证"><a href="#宽松式开源许可证" class="headerlink" title="宽松式开源许可证"></a>宽松式开源许可证</h4><p>特点:代码使用没有任何限制,用户自己承担代码质量的风险,用户使用开源软件时必须披露原作者。BSD、Apache、MIT 等都属于这一类许可证</p><h4 id="Copyleft-开源许可证"><a href="#Copyleft-开源许可证" class="headerlink" title="Copyleft 开源许可证"></a>Copyleft 开源许可证</h4><p>指可不经允许随意复制,特点有许多,如分发二进制代码时必须提供源代码,修改后所产生的开源软件须与修改前全检保持一致的许可证,不得在原始许可证以外附加其他限制等。GPL、MPL 等属于这一类许可证。</p><p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/59CD530235A02AB899E6562117DD5A55.jpg" alt="img"></p><h3 id="开源软件的利用"><a href="#开源软件的利用" class="headerlink" title="开源软件的利用"></a>开源软件的利用</h3><ol><li>学习开源软件</li><li>参与开源建设,掌握开源技术,理解开源文化</li><li>重用开源代码</li></ol><h2 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h2><h3 id="代表性的软件过程模型"><a href="#代表性的软件过程模型" class="headerlink" title="代表性的软件过程模型"></a>代表性的软件过程模型</h3><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><pre><code class="lang-css">瀑布模型将软件开发过程分为若干步骤和活动,包括`需求分析`、`软件设计`、`编码实现`、`软件测试`和`运行维护`。这些步骤严格按照先后次序和逻辑关系来组织,每个阶段的末尾需要对该阶段产生的软件制品(文档、模型和代码等)进行评审,以发现和纠正软件制品中的问题和缺陷,以防有问题的软件制品进入下一步骤。该模型适合那些需求易于定义、不易变动的软件系统的开发</code></pre><p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/F38AC7974AC4D5E8ACAFDC9B399FD9F3.jpg" alt="img"></p><p>瀑布模型及其改进模型还有一个不足,,软件开发人员要等后期阶段才能产生可运行的软件系统,此时用户才可以接触和使用可运行软件,了解软件的功能和行为,发现软件中存在的质量问题,如果用户界面不太友好,实现功能与需求不太一致,反应速度太慢等如果此时用提出软件改进要求将会对软件开发和管理带来很大的冲击</p><h4 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h4><pre><code class="lang-css">在日常生活和工作中,人们经常会构造一些系统的原型,以便为用户直观地展示所关心的内容。所谓原型,是指产品开发前期所产生的产品雏形或仿真产品。相较于实际产品,原型具有可直观展示产品的特性、贴近业务应用、能自然地反映产品需求等特点。基于原型的上述特点,人们将原型思想引入软件工程领域,在软件开发早期(通常在需求分析阶段)根据用户的初步需求构件软件原型并将其交给用户使用,获得用户的评价和反馈,帮助用户导出软件需求、发现开发人员与用户之间的需求认识偏差,进而有效地支持软件需求分析。这一过程即为原型模型</code></pre><p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/9C3256091F06026626DA6C4DBA12D019-1686982122509-4.jpg" alt="9C3256091F06026626DA6C4DBA12D019"></p><p>原型模型适合于那些软件需求难以导出、不易确定且持续变动的软件系统。由于软件原型的修改和完善,需要多次和迭代进行,这一开发模型给软件项目的管理带来了一定的困难</p><h4 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h4><pre><code class="lang-css">瀑布模型要等到软件开发后期才能给用户提供可运行的软件系统,这一点往往不利于用户使用。此外,滞后的软件交付和使用必然会导致软件缺陷和问题的滞后发现,加大软件开发的成本和工作量,影响软件质量,出现这一状况的根本原因在于,获取软件需求后瀑布模型要求一次性实现所有软件需求,这势必导致软件设计和实现的工作量大,开发周期长,使软件交付延后针对这一问题,增量模型做了适当的改进骂他不在要求软件开发人员一次性实现所有的软件需求,而是在软件需求和总体设计确定好后,采用增量开发的模式渐进式地实现软件系统的所有功能**增量模型的一个显著的优点是允许软件开发人员平行地开发软件、实现软件系统的各个独立模块,从而提高软件开发效率,加快交付目标软件系统的进度**</code></pre><p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/image-20230617142624260.png" alt="image-20230617142624260"></p><h4 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h4><p>不要求一次性地开发出完整的软件系统，将软件<br>开发视为一个逐步获取用广需求、完善软件产品的过程</p><p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/image-20230617142824216.png" alt="image-20230617142824216"></p><p>适用于需求难以确定、不断变更的软件系统</p><p><strong>增量模型和迭代模型的区别与联系</strong>：</p><p>增量通常和迭代混为一谈，但是其实两者是有区别的。</p><p>增量是逐块建造的概念，例如画一幅人物画，我们可以先画 人的头部，再画身体，再画手脚……</p><p>迭代是反复求精的概念，同样是画人物画，我们可以采用先画整体轮廓，再勾勒出基本雏形，再细化、着色。</p><h4 id="基于构件的过程模型"><a href="#基于构件的过程模型" class="headerlink" title="基于构件的过程模型"></a>基于构件的过程模型</h4><p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/E8074AF44E51A4F22B798D09B08563DA.jpg" alt="img"></p><h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/1AA63863052625C5CD6AA7FCAF0B6780.jpg" alt="img"></p><h4 id="UP-模型"><a href="#UP-模型" class="headerlink" title="UP 模型"></a>UP 模型</h4><p>UP 模型是一种用例驱动、以体系结构为核心、借助 UML 语言的迭代式软件过程模型</p><p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/image-20230617144930654.png" alt="image-20230617144930654"></p><p>在 UP 模型中同一个工作流在不同阶段任务强度是不一样的</p><div class="table-container"><table><thead><tr><th>模型名称</th><th>指导思想</th><th>关注点</th><th>适用软件</th><th>管理难度</th></tr></thead><tbody><tr><td>瀑布模型</td><td>为软件开发提供系统性的指导</td><td>与软甲生存周期相一致的软件开发过程</td><td>需求变动不大、较为明确、可预先定义的应用</td><td>易</td></tr><tr><td>原型模型</td><td>以原型为媒介指导用户的需求导出和评价</td><td>需求获取、导出和确认</td><td>需求难以表述清楚、不易导出和获取的应用</td><td>易</td></tr><tr><td>增量模型</td><td>快速交付和并行开发软件系统</td><td>软件详细设计、编码和测试的增量完成</td><td>需求变动不大、较为明确、可预先定义的应用</td><td>易</td></tr><tr><td>迭代模型</td><td>多次迭代，每次仅针对部分明确的软件需求</td><td>分多次迭代来开发软件,每次仅关注部分需求</td><td>软件需求变动大,难以一次说清楚的应用</td><td>中等</td></tr><tr><td>基于构件的过程模型</td><td>基于和构建重用来开发软件</td><td>构件的搜索、选择、构件和组装</td><td>需求明确,具有丰富构件库的应用</td><td>中等</td></tr><tr><td>螺旋模型</td><td>集成迭代模型和原型模型，引入风险分析等管理活动</td><td>软件计划制定和实施，软件风险管理,基于原型的迭代式开发</td><td>开发风险大,需求难以明确的应用</td><td>难</td></tr><tr><td>UP 模型</td><td>集成迭代过程模型和面向对象最佳实践</td><td>参考最佳实践，借助面向对象最佳实践来指导迭代开发</td><td>软件需求不明确且经常变化的应用</td><td>难</td></tr></tbody></table></div><h2 id="软件开发方法"><a href="#软件开发方法" class="headerlink" title="软件开发方法"></a>软件开发方法</h2><h3 id="敏捷方法"><a href="#敏捷方法" class="headerlink" title="敏捷方法"></a>敏捷方法</h3><h4 id="何为敏捷方法"><a href="#何为敏捷方法" class="headerlink" title="何为敏捷方法"></a>何为敏捷方法</h4><p>敏捷方法时一类软件开发方法的总称,他们主张软件开发要以代码为中心,快速,轻巧和主动应对需求变化,持续、及时交付可运行的软件系统</p><h4 id="敏捷开发的理念和价值观"><a href="#敏捷开发的理念和价值观" class="headerlink" title="敏捷开发的理念和价值观"></a>敏捷开发的理念和价值观</h4><p>① 较之于过程和工具,应更加重视人和交互的价值。</p><p>② 较之于面面俱到的文档,应更加重视可运行软件的价值</p><p>③ 较之于合同谈判,应更加重视用户合作的价值</p><p>④ 较之于遵循计划,应更加重视响应用户需求的变化的价值</p><p>概括起来敏捷方法具有以下特点:</p><p>① 更加重视可运行软件系统,即代码,弱化软件文档,以可运行软件系统为中心来开展软件开发</p><p>② 以适应变化为目的来推进软件开发,鼓励和支持软件需求的变化,针对变化不断优化和调整软件卡法计划,及时交付软件产品</p><p>③ 软件开发要以人为本,敏捷软件开发是面向人的而不是面向过程的,让方法、技术、工具、过程等来适应人,而不是让人来适应它们</p><h4 id="敏捷方法的实施原则"><a href="#敏捷方法的实施原则" class="headerlink" title="敏捷方法的实施原则"></a>敏捷方法的实施原则</h4><p><strong>12 条敏捷开发原则</strong></p><p>① 尽早和持续地交付有价值的软件,以确保客户满意度</p><p>② 支持客户需求变化,即使到了软件开发后期</p><p>③ 每隔几周或一两个月就须向客户交付可运行软件,交付周期宜短不宜长</p><p>④ 在软件开发全过程,业务人员和开发人员须每天在一起工作</p><p>⑤ 由积极主动的人来承担项目开发,支持和信任他们并提供所需的环境</p><p>⑥ 面对面交谈是团队内部最有效和高效的传递方式</p><p>⑦ 交付可运行软件你作为衡量开发进度的首要衡量标准</p><p>⑧ 项目负责人、开发方和用户方应保持长期、稳定和可持续的开发速度</p><p>⑨ 追求卓越的开发技术和良好的软件设计,增强团队和个体的敏捷能力</p><p>⑩ 在保证质量的前提下采用简单的方法来完成开发任务</p><p>⑪ 组建自组织的开发团队,以出色地完成软件架构、需求和设计等工作</p><p>⑫ 团队应反思如何提高工作效率,并以此调整个体和团队的行为</p><h4 id="支持敏捷方法的开发技术和管理手段"><a href="#支持敏捷方法的开发技术和管理手段" class="headerlink" title="支持敏捷方法的开发技术和管理手段"></a>支持敏捷方法的开发技术和管理手段</h4><p>从管理的角度来看,敏捷开发方法的应用对软件项目管理提出以下一组要求:</p><p>① 管理软件需求,支持需求的变化和跟踪</p><p>② 选择和构件合适的软件开发过程,支持迭代式软件开发和持续性软件交付</p><p>③ 管理开发团队,加强开发人员之间、开发人员与用户之间的交流、沟通和反馈</p><p>④ 开发人员和用户一起参与项目计划的制定和实施</p><p>⑤ 加强跟踪和监督,及时化解软件风险</p><h4 id="极限编程"><a href="#极限编程" class="headerlink" title="极限编程"></a>极限编程</h4><p>极限编程是由 Kent Beck 提出的一种特殊的敏捷方法,与敏捷方法相比较,极限编程的核心理念和价值观更为具体明确:</p><p>① 交流。交流对于软件开发非常重要,鼓励基于口头、直接和平等的交流</p><p>② 反馈。从团队内外获得持续和明确的反馈,获得软件及其开发状态,它对软件项目的成功实施至关重要</p><p>③ 简单。用尽可能简单的过程和技术来指导开发、解决开发问题</p><p>④ 勇气。勇于制定个体决策、快速开发,并在必要时具有重新开发的信心</p><p>在上述价值观和理念的基础上极限编程制定了一组更具体,更易于操作的实施原则,以指导其应用:</p><p>① 计划游戏。计划游戏旨在帮助开发团队快速制定下次迭代的软件开发计划</p><p>② 隐喻。简单而言,隐喻是指用业务相关的术语来描述和交流软件需求促使软件开发人员和业务人员就软件需求达成共同一致的理解</p><p>③ 小型发布。经常给用户发布可运行的软件系统,每次发布的软件仅增加少量的功能</p><p>④ 简单设计。所谓的简单设计是指保持软件设计方案的简单性,不添加任何不必要的设计元素。</p><p>⑤ 测试驱动开发。采用测试驱动的方法来开发软件和测试程序</p><p>⑥ 重构。重构是指在不改变程序代码功能的前提下,改进代码设计和结构,使程序代码具有更高的质量,如更加简单、易于拓展、更加健壮</p><p>⑦ 结对编程</p><p>⑧ 集体拥有代码。</p><p>⑨ 持续集成。新代码一旦经过验证后就可集成到整个软件系统之中,代码集成应经常进行,周期尽可能短</p><p>⑩ 每周 40 小时工作日。</p><p>⑪ 现场用户。让用户和业务人员成为团队成员参与软件开发的全过程</p><p>⑫ 编码标准。依据行业或组织的编码标准来编写程序代码,力求代码遵循编码风格,具有良好的可读性、可理解性和可维护性</p><h4 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h4><h2 id="软件需求工程基础"><a href="#软件需求工程基础" class="headerlink" title="软件需求工程基础"></a>软件需求工程基础</h2><h3 id="面相对象的需求分析方法学"><a href="#面相对象的需求分析方法学" class="headerlink" title="面相对象的需求分析方法学"></a>面相对象的需求分析方法学</h3><h4 id="基本概念和思想"><a href="#基本概念和思想" class="headerlink" title="基本概念和思想"></a>基本概念和思想</h4><pre><code class="lang-css">面向对象的软件工程认为,无论是现实世界(应用问题)还是计算机世界(软件系统),他们都是由多样化的对象所构成的,每个对象都有其状态并可提供功能和服务,不同对象之间通过交互来开展协作、展示行为、实现功能和提供服务。具体地,面向对象的需求分析方法学提供了以下一组的核心概念:</code></pre><h5 id="对象-object"><a href="#对象-object" class="headerlink" title="对象(object)"></a>对象(object)</h5><pre><code class="lang-css">对象既可以表示现实世界中的个体、事物或者实体,也可以表示在计算机软件中的某个运行元素或单元(如运行实例)。每个对象都有其属性和方法,属性表示对象的性质,属性的值定义了对象的状态;方法表示对象所能提供的服务,它定义了对象的行为。对象的方法作用于对象的属性之上,使得属性的取值发生变化,导致对象状态发生变化</code></pre><h5 id="类-class"><a href="#类-class" class="headerlink" title="类(class)"></a>类(class)</h5><p>顾名思义,类是一种分类和组织机制。它是对一组具有相同特征对象的抽象。通俗地将,通过类可以将不同的对象进行分类</p><h5 id="消息-message"><a href="#消息-message" class="headerlink" title="消息(message)"></a>消息(message)</h5><p>每个对象都不应是孤立的,他们之间需要进行交互以获得对方的服务,通过相互协作来共同解决问题。对象之间通过消息传递进行交互,消息传递是对象间的唯一通信方式,一个对象通过向另一个对象发送消息,从而请求相应的服务</p><h5 id="继承-inheritance"><a href="#继承-inheritance" class="headerlink" title="继承(inheritance)"></a>继承(inheritance)</h5><p>继承描述了类与类之间的一般与特殊关系,它本质上是对现实世界不同实体间遗传关系的一种直观表示,也是对计算机软件中不同类进行层次化组织的一种机制</p><h5 id="关联-association"><a href="#关联-association" class="headerlink" title="关联(association)"></a>关联(association)</h5><p>描述了类与类之间的关系,他有多种形式,如聚合、组合等</p><h5 id="多态-polymorphism"><a href="#多态-polymorphism" class="headerlink" title="多态(polymorphism)"></a>多态(polymorphism)</h5><p>多态是针对类的方法而言的,它是指同一个方法作用于不同的对象上可以有不同的解释,并产生不同的执行结果。</p><h5 id="覆盖-override"><a href="#覆盖-override" class="headerlink" title="覆盖(override)"></a>覆盖(override)</h5><p>一个子类可以通过继承来获得父类的属性和方法。当然子类也可以在自己的类中增加或者重新定义所继承的属性和方法,从而用新定义的属性和方法来覆盖所继承的来自父类的属性或方法</p><h5 id="重载-overload"><a href="#重载-overload" class="headerlink" title="重载(overload)"></a>重载(overload)</h5><p>一个类中允许有多个名称相同但是参数不同的方法,由于这些方法在具体的参数数目及类型上有所区别,因而系统将根据收到的消息的实参来引用不同的方法</p><h4 id="面相对象建模语言-UML"><a href="#面相对象建模语言-UML" class="headerlink" title="面相对象建模语言 UML"></a>面相对象建模语言 UML</h4><p>本质上 UML 是一种可视化的建模语言,它提供了图形化的语言机制,包括语法、语义和语用</p><p>以及相应的规则、约束和拓展机制。</p><p>UML 的主要视图</p><div class="table-container"><table><thead><tr><th style="text-align:center">视点</th><th style="text-align:center">视图</th><th>建模内容</th><th>支持的开发阶段</th></tr></thead><tbody><tr><td style="text-align:center">结构</td><td style="text-align:center">包图</td><td>系统高层结构</td><td>需求分析、软件设计</td></tr><tr><td style="text-align:center">结构</td><td style="text-align:center">类图</td><td>系统类结构</td><td>需求分析、软件设计</td></tr><tr><td style="text-align:center">结构</td><td style="text-align:center">对象图</td><td>系统在特定时刻的对象结构</td><td>需求分析、软件设计</td></tr><tr><td style="text-align:center">结构</td><td style="text-align:center">构件图</td><td>系统构件组成</td><td>软件设计</td></tr><tr><td style="text-align:center">行为</td><td style="text-align:center">状态图</td><td>对象状态及其变化</td><td>需求分析、软件设计</td></tr><tr><td style="text-align:center">行为</td><td style="text-align:center">活动图</td><td>系统为完成某项功能而事实的操作</td><td>需求分析、软件设计</td></tr><tr><td style="text-align:center">行为</td><td style="text-align:center">交互图</td><td>系统中的对象间如何通过消息传递来实现系统功能</td><td>需求分析、软件设计</td></tr><tr><td style="text-align:center">部署</td><td style="text-align:center">部署图</td><td>软件系统制品及其运行环境</td><td>软件设计、部署和运行</td></tr><tr><td style="text-align:center">用例</td><td style="text-align:center">用例图</td><td>软件系统的功能</td><td>需求分析</td></tr></tbody></table></div><h2 id="软件设计基础"><a href="#软件设计基础" class="headerlink" title="软件设计基础"></a>软件设计基础</h2><h3 id="面向对象的软件设计方法学"><a href="#面向对象的软件设计方法学" class="headerlink" title="面向对象的软件设计方法学"></a>面向对象的软件设计方法学</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p><strong>面向对象的软件设计过程</strong></p><pre><code class="lang-css">面向对象的软件设计遵循先整体后局部,先抽象后具体的设计原则,借助模块化软件设计的基本思想和策略,先展开软件体系结构设计,明确软件系统的整体架构,在此基础上开展用户界面设计。上述两项设计完成后,将开展一系列详细设计工作,包括用例设计、构件/子系统设计、数据设计、类设计等,最终将这些设计进行整合,形成完整的软件设计方案</code></pre><p><strong>面向对象的软件设计建模语言</strong></p><p>UML</p><h4 id="面向对象的软件设计原则"><a href="#面向对象的软件设计原则" class="headerlink" title="面向对象的软件设计原则"></a>面向对象的软件设计原则</h4><pre><code class="lang-css">面向对象的软件设计方法学提供了一组原则以指导软件设计,提高设计水平,产生高质量的软件设计模型</code></pre><h5 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h5><pre><code class="lang-css">单一职责原则要求每个类值承担一项责任,也即类的职责要单一化,它充分体现了软件模块化设计的思想。该原则有助于控制类的粒度大小,提高类设计的模块化程度以及类的内聚性,降低类实现的规模和复杂性,减少类变更的因素和频率</code></pre><h5 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h5><pre><code class="lang-css">开闭原则要求每个类对于扩展是开放的,对于修改时封闭的。所谓的&quot;拓展的开放性&quot;是指类的功能是可拓展的。该设计原则有助于提高软件设计的灵活性、可重用性和可维护性。但是,该原则的应用也必然会给软件设计带来额外的抽象和设计成本</code></pre><h5 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h5><pre><code class="lang-css">确保父类所拥有的性质在子类中仍成立,或者说,对于父类在软件中出现的所有地方,均可由子类进行替代,反之则不成立。这项原则是面向对象程序设计语言中继承机制的理论基础,也是遵循开闭原则的前提条件。这一原则要求子类可以拓展父类功能,但不能改变父类原有功能。这就要求子类继承父类时除了添加新的方法完成新增功能外,尽量不要重写父类的方法。</code></pre><h5 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h5><pre><code class="lang-css">基本思想是尽量将臃肿庞大的接口拆分成更小和更具体的接口,让接口中只包含使用者感兴趣的方法,即根据使用者的需要定义接口</code></pre><h5 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h5><pre><code class="lang-css">基本思想是:高层模块不应该依赖底层模块,两者都应该其抽象;抽象不应该依赖细节,细节应该依赖抽象。这里的抽象是指面向对象设计中的接口或抽象类,他们均不能直接实例化,细节是指具体的类。因此,依赖倒置原则更为直接的描述为:高层的类不应该依赖底层的类,接口或抽象类不应该依赖具体的实现类,具体的实现类应依赖接口或抽象类。该原则有助于降低变化带来的影响,同时该原则提高了高层模块的可重用性、可拓展性,减少了类之间的耦合度,是软件系统的稳定性得到提升,并提高了代码的可理解性和可维护性</code></pre><h5 id="最少知识原则"><a href="#最少知识原则" class="headerlink" title="最少知识原则"></a>最少知识原则</h5><pre><code class="lang-css">基本思想:只与你的直接朋友交谈,不与陌生人说话。也即一个类只对与自己存在耦合关系的类进行狡猾,尽可能少的与其他不相关的类发生交互。这意味着一个类应该为与其发生交互关系的其他类提供最少的知识最少知识原则有助于实现类间解耦,使每个类与其他类是弱耦合甚至无耦合,从而提高类的可重用性。但这势必会提高软件系统带来的复杂性,给软件维护带来难度</code></pre><h4 id="面向对象的软件设计优势"><a href="#面向对象的软件设计优势" class="headerlink" title="面向对象的软件设计优势"></a>面向对象的软件设计优势</h4><ol><li>高层抽象和自然过渡</li><li>多种形式和粗粒度的软件重用</li><li>系统化的软件设计</li><li>支持软件的拓展和变更</li></ol><h2 id="软件体系结构设计"><a href="#软件体系结构设计" class="headerlink" title="软件体系结构设计"></a>软件体系结构设计</h2><h3 id="软件体系结构模型的表示方法"><a href="#软件体系结构模型的表示方法" class="headerlink" title="软件体系结构模型的表示方法"></a>软件体系结构模型的表示方法</h3><h4 id="包图"><a href="#包图" class="headerlink" title="包图"></a>包图</h4><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><h3 id="软件测试过程"><a href="#软件测试过程" class="headerlink" title="软件测试过程"></a>软件测试过程</h3><p>单元测试</p><p>集成测试</p><p>确认测试</p><p>系统测试</p><h3 id="软件测试技术"><a href="#软件测试技术" class="headerlink" title="软件测试技术"></a>软件测试技术</h3><h4 id="黑盒测试技术"><a href="#黑盒测试技术" class="headerlink" title="黑盒测试技术"></a>黑盒测试技术</h4><pre><code class="lang-css">该测试技术的前提是已知软件模块的功能,但是不知道该软件模块的内部实现细节(如其内部的控制流程和实现算法)这种情况下针对该软件模块设计和运行测试用例,测试软件模块的运行是否正常,测试软件模块的运行是否正常,能否满足用户的需求。通常,`集成测试`和`确认测试`大多采用黑盒测试技术,典型的黑盒测试技术包括`等价分类法`和`边界取值法`软件测试不仅要进行功能测试,如单元测试、集成测试和确认测试等,而且还需要进行非功能测试,如压力测试、兼容性测试、可靠性测试、容量测试。在软件测试的过程中,为了尽可能发现软件系统中潜在的缺陷和错误,软件测试应应对不同测试目的,遵循以下原则来设计测试用例。①需求(功能)覆盖。确保软件系统的所有需求或功能都被测试用例覆盖到。某个测试用例覆盖了某项功能,是指该测试数据的输入导致被测试的对象运行了实现某项功能的程序代码②模块覆盖。确保软件系统的所有程序模块(如过程、函数)都被测试用例覆盖到③语句覆盖。确保软件系统的所有程序语句都被测试用例覆盖到。④分支覆盖。程序中的控制结构(如 if语句或者while语句)通常具有多个不同的执行分支,分支覆盖是要确保待测试对象的所有分支都被测试用例覆盖到⑤条件覆盖。程序中控制结构的逻辑表达式即可取TRUE,也可取FALSE。条件覆盖是要确保控制结构中逻辑表达式的所有取值都被测试到⑥多条件覆盖。确保程序中所有控制结构的逻辑表达式中,每个子表达式取值的组合都被测试用例覆盖到⑦条件/分支覆盖。该原则是由条件覆盖和分支覆盖组合而成⑧路径覆盖。程序模块中的一条路径是指从入口语句(该模块的第一条执行语句)到出口语句(该模块的最后一条语句,如return语句)的语句序列。路径覆盖是要确保模块中的每一天路径都被测试用例覆盖到⑨基本路径覆盖。基本路径是指至少引入一个新语句或者新判断的路径。基本路径覆盖是要确保模块中的每一条基本路径都被测试用例覆盖到。</code></pre><h4 id="白盒测试技术"><a href="#白盒测试技术" class="headerlink" title="白盒测试技术"></a>白盒测试技术</h4><p>白盒测试的前提是已知程序的内部控制结构,以此作为依据来设计软件测试用例下面基本路径测试技术来介绍白盒测试技术</p><pre><code class="lang-c">void Func(int nPosX, int nPosY)&#123;    while(nPosX &gt; 0)&#123;        int nSum = nPosX + nPosY;        if(nSum &gt; 1)&#123;            nPosX--;            nPosY--;        &#125;else&#123;            if(nSum &lt; -1)&#123;                nPosX -= 2;            &#125;else&#123;                nPosX -= 4;            &#125;        &#125;    &#125;&#125;</code></pre><p>1.根据模块详细设计绘出模块的流程图</p><p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/流程图.svg" alt="流程图"></p><p>2.将流程图转换为流图</p><pre><code>①增加控制结构,将流程图中的结合点转换为流图中的一个节点。所谓的结合点是指条件语句的汇聚点。如上图中的9号和10号位置就是结合点②讲流程图中的过程块合并为流图中的一个节点。所谓&quot;过程块&quot;是指一组必然会顺序执行的语句集。例如上图中的2号和3号,4号和5号分别构成了一个过程块</code></pre><p>经过上述转换,可得以下流图</p><p><img src="/2023/07/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/流图-1687067591618-5.svg" alt="流图"></p><p>3.确定基本路径集合</p><p>针对转换得到的流图,计算该图的复杂度为</p><pre><code>复杂度 = Edge(D) - Node(D) + 2</code></pre><p>所得的复杂度就是该图所具有的基本路径数量</p><p>所以上图中的复杂度为 11 - 9 + 2 = 4</p><p>基于上图的理解,该模块基本路径如下:</p><p>基本路径 1:1→11</p><p>基本路径 2:1→2,3→6→7→9→10→1→11</p><p>基本路径 3:1→2,3→6→8→9→10→1→11</p><p>基本路径 4:1→2,3→6→4,5→10→11</p><p>软件的维护演化</p><h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><p><strong>1.软件工程的”工程”指的是什么含义?他反映了软件工程具有什么样的基本理念和思想?</strong></p><pre><code>①将系统的、规范的、可量化的方法应用于软件开发、运行和维护的过程②以及上述方法的研究</code></pre><p>基本理念和思想:一是软件工程要提供系统的、规范的可量化的的方法来指导软件的开发、运行和维护,二是研究方法本身</p><p><strong>2.软件工程要为软件开发和运维提供系统的可量化的、规范的方法。请诠释”系统的可量化的、规范的”有何含义</strong></p><pre><code>系统的。是指软件工程关心的是软件全声明周期的开发问题</code></pre><p>规范的。是指软件工程所提供的方法可为软件开发活动及其所产生的软件制品提供可准确描述的、标准化的指南</p><p>可量化的。软件工程采用可量化的手段,基于定量的数据来支持软件的开发</p><p><strong>3.软件工程三要素存在什么样的关系?说明面向对象工程的三个构成要素的具体内涵</strong></p><pre><code>这些要素从不同的工程视角关注软件的开发、运行和维护的问题,为软件质量保证提供了不同的支持,构成了&quot;系统、规范和可量化&quot;的方法*过程*:    从管理的视角,回答软件开发、运行和维护需要做哪些工作、如何管理好这些工作,关注软件的规范化组织和可量化实施*方法学*:    从技术的视角,回答软件开发、运行和维护如何做的问题。*工具*:    从工具辅助的视角,回答如何借助工具来辅助软件开发、运行和维护的问题</code></pre><p><strong>4.面向对象程序设计体现了哪些软件工程的基本原则?请举例说明</strong></p><pre><code>抽象和建模：面向对象程序设计通过抽象和建模来描述和解决问题。它将现实世界的事物抽象为类和对象，并定义它们之间的关系和行为。这样可以更好地理解问题领域，使设计更符合实际需求。模块化：面向对象的程序设计鼓励将代码组织成模块化的、可重用的单元，即类。每个类都封装了相关的数据和方法，提供了一种结构化的方式来组织代码。这符合软件工程中的模块化原则，将系统划分为相互独立且可测试的模块，提高代码的可维护性和可重用性。软件重用：面向对象程序设计通过继承、组合和接口等机制来实现代码的重用。通过定义通用的类和接口，可以在不同的项目中重用已有的代码，提高开发效率和代码质量。信息隐藏：面向对象程序设计通过封装来隐藏类的内部实现细节，仅暴露必要的接口给其他模块使用。这样的信息隐藏有助于提高系统的可维护性和可扩展性，同时保护了数据的完整性。</code></pre><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><p><strong>1.软件过程模型和软件生存周期这两个概念有何区别和联系？</strong></p><pre><code>软件生存周期是针对软件而言的，它是指软件从提出开发开始到最终退役所经历的阶段软件过程模型是针对软件开发而言的，他关注的是指导软件开法的相关步骤和活动</code></pre><p><strong>2.对比分析迭代模型、增量模型、螺旋模型、UP 模型之间的差异性</strong></p><div class="table-container"><table><thead><tr><th>模型名称</th><th>指导思想</th><th>关注点</th><th>适用软件</th><th>管理难度</th></tr></thead><tbody><tr><td>瀑布模型</td><td>为软件开发提供系统性的指导</td><td>与软件生存周期相一致的软件开发过程</td><td>需求变动不大、较为明确、可预先定义的应用</td><td>易</td></tr><tr><td>原型模型</td><td>以原型为媒介指导用户的需求导出和评价</td><td>需求获取、导出和确认</td><td>需求难以表述清楚、不易导出和获取的应用</td><td>易</td></tr><tr><td>增量模型</td><td>快速交付和并行开发软件系统</td><td>软件详细设计、编码和测试的增量完成</td><td>需求变动不大、较为明确、可预先定义的应用</td><td>易</td></tr><tr><td>迭代模型</td><td>多次迭代，每次仅针对部分明确的软件需求</td><td>分多次迭代来开发软件,每次仅关注部分需求</td><td>软件需求变动大,难以一次说清楚的应用</td><td>中等</td></tr><tr><td>基于构件的过程模型</td><td>基于和构建重用来开发软件</td><td>构件的搜索、选择、构件和组装</td><td>需求明确,具有丰富构件库的应用</td><td>中等</td></tr><tr><td>螺旋模型</td><td>集成迭代模型和原型模型，引入风险分析等管理活动</td><td>软件计划制定和实施，软件风险管理,基于原型的迭代式开发</td><td>开发风险大,需求难以明确的应用</td><td>难</td></tr><tr><td>UP 模型</td><td>集成迭代过程模型和面向对象最佳实践</td><td>参考最佳实践，借助面向对象最佳实践来指导迭代开发</td><td>软件需求不明确且经常变化的应用</td><td>难</td></tr></tbody></table></div><p><strong>3.开发一个软件项目为什么需要软件过程模型？如果没有过程模型的指导，会产生什么样的情况？</strong></p><pre><code>软件过程定义了软件开发和维护的一组有序活动集合，它为相关人员参与软件开发、完成开发任务提供了规范化路线</code></pre><p>没有过程模型的指导，会产生</p><p>1）不可预测的开发过程</p><p>2）风险无法控制</p><p>3）低质量的交付</p><p><strong>4.当开发一个软件项目时，应考虑哪些方面的因素来选择或指定合适的软件过程模型</strong></p><p>考虑软件项目的特点</p><p>考虑软件项目开发的风险</p><p>考虑团队的经验水平</p><p><strong>5.如果要开发一个军用软件项目，用户方有明确的需求，对软件质量提出非常高的要求，请问采用哪种开发过程模型和方法较为适合？为什么？</strong></p><ol><li>瀑布模型：瀑布模型是一种线性顺序的开发过程模型，包括需求定义、系统设计、编码、测试和部署等阶段。对于军用软件项目，明确的需求和高软件质量要求可以与瀑布模型的严格阶段性和文档化要求相匹配。瀑布模型有助于详尽地定义和分析需求，进行全面的系统设计和严格的软件测试，从而提供高质量和可靠的软件交付。</li></ol><p>2) 增量模型：增量模型强调在迭代和增量的基础上进行软件开发。每个增量都是一个完整的软件版本，包括设计、编码、测试和部署等活动。这种模型可以快速交付部分功能，以便用户方早期验证和反馈。对于军用软件项目，采用增量模型可以确保及时响应用户需求、减少风险和提供高质量的软件交付。</p><p>任选其一</p><p><strong>6.如果要开发一个业务信息系统项目，系统的需求来自一线业务工作人员，需要不断进行及交流和反馈，请问采用哪种开发过程模型和方法较为适合？为什么？</strong></p><ol><li>敏捷方法（如 Scrum）：敏捷方法适合需要灵活性、快速反馈和持续交付的项目。由于业务信息系统项目的需求可能会频繁变化和调整，采用敏捷方法可以通过短期迭代和增量交付的方式，不断进行交流和反馈。敏捷方法强调与业务工作人员的紧密合作，他们可以参与到项目开发中，提供及时的需求反馈和验证，从而确保系统符合业务需求。</li><li>增量模型：增量模型适合需要快速交付可用功能的项目。对于业务信息系统项目，用户对系统功能的反馈和验证非常重要。采用增量模型可以在每个增量中交付一部分功能，使业务工作人员能够及时使用并提供反馈。这样可以确保系统开发的正确性和符合业务需求，同时减少开发过程中的风险。</li><li>迭代模型：迭代模型强调通过反复迭代的方式逐步完善系统。业务信息系统项目通常具有复杂的需求和较长的生命周期，通过采用迭代模型，可以在每个迭代中集中精力开发和验证一部分功能。业务工作人员可以参与每个迭代的需求讨论和验证过程，确保系统开发与业务需求保持一致。</li><li>原型模型：原型模型适合在项目初期需要进行需求探索和验证的情况。通过快速构建原型，与业务工作人员进行交流和演示，可以及时捕捉需求细节和调整。原型模型有助于提高业务工作人员对系统的理解和参与度，从而确保系统满足其实际需求。</li></ol><p>任选其一</p><p><strong>7.软件开发方法与软件过程模型二者有何差别?请结合迭代模型和敏捷方法,说明他们之间的区别的和联系</strong></p><p><strong>8.为什么说传统的软件过程模型是重型的,体现在哪里?为什么说敏捷方法是轻型的,体现在哪里?</strong></p><p>传统的软件过程模型他们都以文档为中心指导软件开发</p><p>体现在:软件开发和运维的大量工作用于撰写和评审文档而非编写程序代码</p><pre><code>软件需要变化是常态,一旦需求发生变化,开发人员不得不首先去修改软件需求文档,并据此来调整其它文档,最后再根据修改后的文档来修改程序代码</code></pre><p>敏捷方法以代码为中心,快速、轻巧和主动应对需求变化,持续、及时交付可运行的软件系统,体现在:</p><p>① 较之于过程和工具,应更加重视人和交互的价值。</p><p>② 较之于面面俱到的文档,应更加重视可运行软件的价值</p><p>③ 较之于合同谈判,应更加重视用户合作的价值</p><p>④ 较之于遵循计划,应更加重视响应用户需求的变化的价值</p><h3 id="第十五章"><a href="#第十五章" class="headerlink" title="第十五章"></a>第十五章</h3><p><strong>1.何为软件维护,何为软件演化?这两个概念有何区别和联系?</strong></p><pre><code>软件维护是指软件交付给用户使用后修改软件系统及其他部件的过程,以修复缺陷,提高性能或者其他属性,增强软件功能以及适应变化的环境。软件演化是指针对软件的大规模功能增强和结构调整,以实现变化的软件需求或者提高软件系统的质量。交付后的软件依然还会经历变更,而其中仅有少数变更属于真正意义上的&quot;软件维护&quot;范畴,更多的变更则属于&quot;软件演化&quot;的范畴</code></pre><p><strong>2.软件维护有哪几种形式</strong></p><div class="table-container"><table><thead><tr><th>类别</th><th>起因</th><th>目的</th><th>维护行为</th></tr></thead><tbody><tr><td>纠正性维护</td><td>软件存在缺陷</td><td>诊断、纠正和修复软件缺陷</td><td>修改代码和调整文档</td></tr><tr><td>改善性维护</td><td>增强软件的功能和服务</td><td>满足用户增长和变化的软件需求</td><td>编写代码和撰写文档</td></tr><tr><td>适应性维护</td><td>软件运行所依赖的环境发生了变化</td><td>适应软件运行的变化和发展</td><td>编写代码和撰写文档</td></tr><tr><td>预防性维护</td><td>软件质量出现了下降</td><td>提高软件系统的质量,尤其是内部质量</td><td>重组代码和撰写文档</td></tr></tbody></table></div><p><strong>3.软件维护通常会面临哪些困难和挑战</strong></p><p>同步性</p><p>周期长</p><p>费用高</p><p>难度大</p><p><strong>4.为什么软件不会有物理层面的老化现象,但会出现逻辑层面的老化现象?请举例说明</strong></p><p>软件部署在某个计算环境下运行,运行次数和运行持续时间不会对软件系统的物理特性产生影响,所以不会产生物理层面的老化现象,而随着软件在维护和演化的过程中出现用户满意度降低、质量逐渐下降、变更成本不断上升等现象,这种现象发生在逻辑层面而不在物理层面</p><p><strong>5.为什么说软件逻辑老化不可避免,只要有维护就必然会导致软件逻辑老化?能否通过软件维护来解决软件逻辑老化的问题?</strong></p><p>软件维护虽然可以解决软件中潜藏的某些缺陷,但也会引入新的缺陷,在对软件进行改善性维护的同时,尽管增加了新的功能,但也会破坏软件架构,引入新的软件问题,使得整个软件不易于维护.软件架构变得脆弱。因此,随着对软件的不断维护,必然会导致整个软件逻辑老化</p><p>能,基于软件系统的可维护性以及软件系统的价值,采取以下 4 种方式和策略来应对</p><pre><code>维护。如果软件系统的价值较低,但是软件系统的可维护性较好,软件维护团队可以对软件系统进行有限的维护工作抛弃。如果软件系统的价值较低,且软件系统的可维护性低,软件团队可以逐步抛弃对软件系统的维护再工程。如果软件系统的价值较高,但软件系统的可维护性低,此时软件维护团队可以主动采取再工程的为胡策略。如对软件系统进行重组演化。如果软件系统的价值较高,可维护性好,软件维护团队可以采取积极和主动的演化策略</code></pre><p><strong>6.软件重构、重组、逆向工程和再工程有何区别?请举例说明</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理基础</title>
      <link href="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="ji-suan-ji-de-xi-tong-gai-shu">计算机的系统概述</h1><h2 id="ji-suan-ji-de-ceng-ci-jie-gou">计算机的层次结构</h2><h3 id="ji-suan-ji-xi-tong-de-zu-cheng">计算机系统的组成</h3><p><strong>硬件系统</strong>和<strong>软件系统</strong>共同构成了一个完整的计算机系统。硬件是指有形的物理设备,是计算机系统重实际物理装置的总称。软件是指在硬件上运行的程序和相关的数据及文档</p><h3 id="ji-suan-ji-ying-jian">计算机硬件</h3><h4 id="feng-nuo-yi-man-ji-de-ji-ben-si-xiang">冯诺依曼机的基本思想</h4><p>冯诺依曼在研究 EDVAC 机时提出了<code>&quot;存储程序&quot;</code>的概念,存储程序的思想奠定了现代计算机的基本结构,以此概念为基础的各类计算机通称为冯诺依曼机其特点如下 👇:</p><ol><li class="lvl-3"><p>采用<code>&quot;存储程序&quot;</code>的工作方式,基本工作方式为**<code>控制流驱动方式</code>**</p></li><li class="lvl-3"><p>计算机硬件系统由<strong>运算器</strong>、<strong>存储器</strong>、<strong>控制器</strong>、<strong>输入设备</strong>和<strong>输出设备</strong>5 大部件组成</p></li><li class="lvl-3"><p><code>指令</code>和<code>数据</code>以同等地位存储中,形式上没有区别,但计算机等区分他们</p></li><li class="lvl-3"><p><code>指令</code>和<code>数据</code>均用<strong>二进制代码</strong>表示。<code>指令</code>由<strong>操作码</strong>和<strong>地址码</strong>组成,操作码指出操作的类型,地址码指出操作数的地址</p></li></ol><blockquote><p>🙋‍♂️<strong>存储程序的基本思想是</strong>:</p><p>将事先编写好的程序和原始数据送入主存后才能执行,一旦程序成功执行,就无须操作人员干预,计算机会自动逐条执行指令,直至程序执行结束</p></blockquote><h4 id="ji-suan-ji-de-gong-neng-bu-jian">计算机的功能部件</h4><p>后面详细介绍</p><p><strong>输入设备</strong></p><p><strong>输出设备</strong></p><p><a href="##%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0"><strong>存储器</strong></a></p><p><a href><strong>运算器</strong></a></p><p><a href="##%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><strong>控制器</strong></a></p><p>冯诺依曼结构的模型机示意图 👇</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%9C%BA.svg" alt="冯诺依曼机"></p><h3 id="ji-suan-ji-ruan-jian">计算机软件</h3><h4 id="xi-tong-ruan-jian-he-ying-yong-ruan-jian">系统软件和应用软件</h4><p>软件按其功能分类,可分为<strong>系统软件</strong>和<strong>应用软件</strong></p><p><em>系统软件</em>是一组保证计算机系统高效、正确运行的基础软件,通常作为系统资源提供给用户使用</p><p>系统软件主要有:</p><p><code>操作系统(OS)</code>、<code>数据库管理系统(DBMS)</code>、<code>语言处理程序</code>、<code>分布式软件系统</code>、<code>网络软件系统</code>、<code>标准库程序</code>、<code>服务性程序</code></p><p><em>应用软件</em>是指用户为解决某个应用领域中的各类问题而编制的程序,如各种科学计算类程序、工业设计类程序、数据统计与处理程序</p><h4 id="san-ge-ji-bie-de-yu-yan">三个级别的语言</h4><p>1️⃣<strong>机器语言</strong></p><p>二进制代码语言。<mark>机器语言是计算机唯一可以直接识别和执行的语言</mark></p><p>2️⃣<strong>汇编语言</strong></p><p>汇编语言用英文单词或其缩写替代二进制指令代码,更容易为人们记忆和理解.使用汇编语言编写的那些的程序,必须经过一个称为汇编程序的系统软件的翻译,将其转换为机器语言程序后,才能在计算机的硬件系统上执行</p><p>3️⃣<strong>高级语言</strong></p><p>高级语言需要经过汇编程序编译成汇编语言程序,然后经过汇编操作得到机器语言程序,或直接由高级语言翻译成机器语言程序</p><p>由于计算机无法直接理解和执行高级语言程序,需要将高级语言程序转化为机器语言程序,通常把进行这种转换的软件统称为翻译程序。翻译程序由以下三类 👇:</p><ol><li class="lvl-3"><p><strong>汇编程序(汇编器)</strong>。将汇编语言程序翻译成机器语言程序。</p></li><li class="lvl-3"><p><strong>解释程序(解释器)</strong>。将源程序中的语句按执行顺序逐条翻译成机器指令并立即执行</p></li><li class="lvl-3"><p><strong>编译程序(编译器)</strong>。将高级语言程序翻译成汇编语言或机器语言程序</p></li></ol><blockquote><p>🙋‍♂️<strong>硬件和软件的逻辑功能等价性</strong>即对某一功能来说,既可以由硬件实现,又可以用软件实现</p><p>硬件实现具有更高的执行速度,软件实现具有更好的灵活性,执行频繁、硬件实现代价不是很高的功能通常由硬件实现</p></blockquote><h3 id="ji-suan-ji-de-ceng-ci-jie-gou-1">计算机的层次结构</h3><p><strong>计算机是一个硬软件组成的综合体</strong>。由于软/硬件的设计者和使用者从不同的角度、用不同的语言来对待同一个计算机系统,因此他们看到的计算机系统的属性,对计算机系统提出的要求也就各不相同。</p><p>以下是计算机系统的多级层次机构示意图 👇:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.svg" alt="层次结构"></p><p>第 1 级是<strong>微程序机器层</strong>,这是一个实在的硬件层,它由机器硬件直接执行微指令</p><p>第 2 级是<strong>传统机器语言层</strong>,它也是一个实在的硬件层,它由微程序解释机器指令系统</p><p>第 3 级是<strong>操作系统层</strong>,它由操作系统程序实现。操作系统程序是由机器指令和广义指令组成的,所以这一层也被称为<code>混合层</code></p><p>第 4 级是<strong>汇编语言层</strong>,它为用户提供一种符号化的语言,借此可编写汇编语言源程序。这一层由汇编程序支持和执行</p><p>第 5 级是<strong>高级语言层</strong>,它是面向用户的,是为了方便用户编写以应用程序而设置的,该层由各种高级语言编译程序支持和执行</p><p>高级语言层之上还可以由应用程序层,它由解决实际问题和应用问题的处理程序组成,如文字处理软件、数据库软件、多媒体处理软件和办公自动化软件</p><p>没有配备软件的纯硬件系统称为<code>裸机</code>。第 3 层~第 5 层称为<code>虚拟机</code>,简单来说就是软件实现的机器,虚拟机只对该层的观察者存在</p><p>层次之间关系紧密,下层是上层的基础,上层是下层的拓展</p><blockquote><p>🙋‍♂️<em>计算机组成原理主要讨论传统机器 M1 和微程序机器 M0 的组成原理和设计思想</em></p></blockquote><h2 id="ji-suan-ji-de-xing-neng-zhi-biao">计算机的性能指标</h2><h3 id="ji-suan-ji-de-zhu-yao-xi-tong-zhi-biao">计算机的主要系统指标</h3><p>🥖<strong>字长</strong></p><p>指计算机进行一次整数运算(即定点整数运算)所能处理的二进制数据的位数,通常与 CPU 的寄存器位数、加法器有关。因此字长一般等于内部寄存器的大小,字长越长,数的表示范围越大,计算精度越高。计算机字长通常选定为字节(8 位)的整数倍</p><blockquote><p>🤔<a name="字、字长、机器字长、指令字长、存储字长的区别和联系是什么?"><strong>字、字长、机器字长、指令字长、存储字长的区别和联系是什么?</strong></a></p><p>在通常所说的<code>&quot;某32位或64位机器&quot;</code>中,32、64 指的是字长,也称机器字长。所谓字长,通常是指 CPU 内部用于证书运算的数据通路的宽度,<strong>因此字长等于 CPU 内部用于整数运算的运算器位数和通用寄存器宽度</strong>,它反应了计算机处理信息的能力。字和字长概念不同。字用来表示被处理信息的单位,用来度量数据类型的宽度,如 x86 机器中将一个字定义为 16 位</p><p><strong>指令字长</strong>:一个指令字中包含的二进制代码的位数</p><p><strong>存储字长</strong>:一个存储单元存储的二进制代码的长度</p><p>指令字长一般取存储字长的整数倍,若指令字长等于存储字长的 2 倍,则需要两个存储周期来取出一条指令;若指令字长等于存储字长,则取指周期等于机器周期</p><p><strong>他们必须是字节的整数倍</strong></p></blockquote><p>📼<strong>数据通路带宽</strong></p><p>数据带宽是指数据总线一次所能并行传送信息的位数。这里说的数据通路宽度是指外部数据总线的宽度,它与 CPU 内部的数据总线的宽度(内部寄存器的大小)有可能不同</p><blockquote><p>🙋‍♂️ 各个子系统通过数据总线连接形成的数据传送路径称为数据通路</p></blockquote><p>🍼<strong>主存容量</strong></p><p>主存容量是指主存储器所能存储信息的最大容量,通常以字节来衡量,也可以用字数 × 字长(如 512K×16 位)来表示存储容量。其中 MAR 的位数反映存储单元可寻址范围的最大值(而不一定是实际存储器的存储容量)</p><blockquote><p>例如,MAR 为 16 位,表示 2<sup>16</sup>=65536,即此存储体内有 65536 个存储单元(可称为 64K 内存,1K=1024)</p></blockquote><p>🚅<strong>运算速度</strong></p><p><mark>吞吐量和响应时间</mark></p><ul class="lvl-0"><li class="lvl-2"><p>吞吐量</p></li></ul><p>系统在单位时间内处理请求的数量。它取决于信息能多快地输入内存,CPU 能多快地取指令,数据能多快地动内存取出或读入,以及所得结果能多快地从内存送给一台外部设备。每一步都涉及主存。因此<strong>系统吞吐量主要取决于主存的存取周期</strong></p><ul class="lvl-0"><li class="lvl-2"><p>响应时间</p></li></ul><p>指从用户向计算机发送一个请求,到系统对该请求做出的响应并获得所需结果的等待时间。通常包括 CPU 时间(运行一个程序所花费的时间)与等待时间(用于磁盘访问、存储器访问、I/O 访问、操作系统开销等的时间)</p><p><mark>主频和 CPU 时钟周期</mark></p><ul class="lvl-0"><li class="lvl-2"><p>CPU 时钟周期</p></li></ul><p>通常为节拍脉冲(被称之为<code>节拍</code>或者<code>拍</code>)或者 T 周期,即主频的倒数,它是 CPU 中最小的时间单位,执行指令的每个动作至少需要 1 个时钟周期</p><ul class="lvl-0"><li class="lvl-2"><p>主频(CPU 时钟频率)</p></li></ul><p>机器内部主时钟的频率,是衡量机器速度的重要参数。对于同一个型号的计算机,其主频越高完成一个执行步骤的时间越短</p><blockquote><p>🙋‍♂️CPU 时钟周期 = 1/主频,主频通常以 Hz 时(赫兹)为单位,1Hz 表示每秒一次</p></blockquote><blockquote><p>🤔<strong>时钟周期、机器周期与指令周期的概念与联系是什么?</strong></p><p><strong>指令周期</strong>:</p><p>CPU 从存储器中<strong>取出并执行一条指令所需的全部时间</strong>称之为指令周期。</p><p>计算机每执行一条指令的过程，可分解为如下步骤：</p><ol><li class="lvl-3"><p><strong>Instruction Fetch（取指令</strong>：指令放在存储器，通过 PC 寄存器和指令寄存器取出指令的过程，由控制器（Control Unit）操作。 从 PC 寄存器找到对应指令地址，据指令地址从内存把具体指令加载到指令寄存器，然后 PC 寄存器自增；</p></li><li class="lvl-3"><p><strong>Instruction Decode（译码</strong>：据指令寄存器里面的指令，是哪一种类型的指令，解析成要进行什么操作，具体要操作哪些寄存器、数据或内存地址。该阶段也是由控制器执行；</p></li><li class="lvl-3"><p><strong>Execute（执行）</strong>：实际执行算术逻辑操作、数据传输或者直接的地址跳转操作。无论是算术操作、逻辑操作的指令，还是数据传输、条件分支的指令，都由算术逻辑单元（ALU）操作，即由运算器处理。如果是一个简单的无条件地址跳转，那可直接在控制器里完成，无需运算器</p></li></ol><p>重复 1 ～ 3 的过程，这个循环完成的时间即指令周期。</p><p><strong>机器周期</strong>:</p><p>又称为<strong>CPU 周期（CPU Cycle）</strong>。一个机器周期内包含若干时钟周期，包含时钟周期的个数称之为机器周期的<strong>时间宽度</strong>。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230703222734882.png" alt="image-20230703222734882"></p><p><strong>总结</strong>:</p><p><strong><mark>一个指令周期包含多个机器周期，而一个机器周期包含多个时钟周期</mark></strong></p></blockquote><p><mark>CPI</mark></p><p>CPI(Clock cycle Per Instruction),即执行一条指令所需要的时钟周期数</p><blockquote><p>🙋‍♂️ 不同指令的时钟周期数可能不同,因此对于一个程序或一台机器来说,其 CPI 是指该程序或机器啊指令集中所有指令执行所需的平均时钟周期数,此时 CPI 是一个平均值</p></blockquote><p><mark>CPU 执行时间</mark></p><p>指运行一个程序所要花费的时间</p><pre><code class="language-css">CPU执行时间 = CPU时钟周期数/主频 = (指令条数×CPI)/主频</code></pre><blockquote><p>🙋‍♂️ 上式表 CPU 性能(CPU 执行时间)取决于三个要素:① 主频(时钟频率);② 每条指令执行所用的时钟周期数;③ 指令条数</p><p>主频、CPI 和指令条数时相互制约的,例如,更改指令集可以减少程序所含指令的条数,但可能会引起 CPU 结构的调整,从而可能会增加时钟周期的宽度(降低主频)</p></blockquote><p><mark>MIPS</mark></p><p>每秒执行多少百万条指令</p><p><mark>MFLOPS、GFLOPS、TFLOPS、PFLOPS、ZFLOPS 和 EFLOPS</mark></p><p>每秒执行多少百万、千万…条浮点指令</p><blockquote><p>🚨 在描述容量存储容量、文件大小等时,K、M、G、T 通常用 2 的幂次来表示,例如 1Kb = 2<sup>10</sup>b;</p><p>在描述速率、频率等时 k、M、G、T 通常用 10 的幂次方表示,如 1kb/s = 10<sup>3</sup>b/s。通常前者用大写的 K,后者用小写的 k,但其他前缀均为大写,表示含义取决于所用场景</p></blockquote><p>👨‍💻<strong>基准程序</strong></p><p>基准程序是专门用来进行性能评价的一组程序,能够很好的反映机器在运行实际负载时的性能,可以通过在不同机器上运行相同的基准程序来比较在不同机器上的运行时间,从而评价其性能</p><h3 id="ji-ge-zhuan-ye-zhu-yu">几个专业术语</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>系列机</strong>:具有基本相同的体系结构,使用相同的基本指令系统的多个不同型号的计算机组成的一个产品系列。</p></li><li class="lvl-2"><p><strong>兼容</strong>:指软件或硬件的通用性,即运行在某个型号的计算机系统重的硬件/软件也应用于另一个型号的计算机系统时,称这两台计算机在硬件或软件上存在兼容性</p><ul class="lvl-2"><li class="lvl-4"></li></ul></li><li class="lvl-2"><p><strong>软件可移植性</strong>:指把某个系列计算机中的软件直接或进行很少的修改就能运行在另一个系列计算机中的可能性</p></li><li class="lvl-2"><p><strong>固件</strong>:将程序固话在<code>ROM</code>中组成的部件称为固件。固件是一种具有软件特性的硬件,吸收了软/硬件各自的优点,其执行速度快于软件,灵活优于硬件,是软/硬结合的产物</p></li><li class="lvl-2"><p><strong>透明性</strong>:在计算机领域中,站在某类用户的角度,若感觉不到某个事物或者属性的存在,即&quot;看&quot;不到某个事物或者属性,则称为&quot;对该用户而言,某个事物或属性是透明的&quot;,这与日常生活中&quot;透明&quot;的概念(公开、看得见)正好相反</p></li></ul><p>例如:对于高级语言程序员来说,浮点数格式、乘法指令等这些指令的格式、数据如何在运算器中运算等都是透明的,而对于机器语言或者汇编语言程序员来说,指令的格式、机器结构、数据格式等则不是透明的</p><p>在 CPU 中<code>IR</code>、<code>MAR</code>和<code>MDR</code>对各类程序员都是透明的</p><blockquote><p>🤔<strong>计算机体系结构和计算机组成的区别是和联系是什么?</strong></p><p>计算机体系结构是指机器语言或汇编语言程序员所看到的传统机器的属性,包括指令集、数据类型、存储器寻址技术等,大多都属于抽象的属性。</p><p>计算机组成是指如何实现计算机体系结构所体现的属性,它包含对许多程序员类说透明的硬件细节。</p><p>例如:指令系统属于结构的问题,但指令的实现即如何取指令、分析指令、如何运算等都属于组成的问题。因此,当两台机器指令系统相同时,只能认为他们具有相同的结构,至于这两台机器如何实现其指令,完全可以</p></blockquote><h1 id="shu-ju-de-biao-shi-he-yun-suan">数据的表示和运算</h1><h2 id="mark-shu-zhi-yu-bian-ma-mark"><mark>数制与编码</mark></h2><h3 id="jin-wei-ji-shu-zhi-ji-qi-xiang-hu-zhuan-huan">进位计数制及其相互转换</h3><h4 id="jin-wei-ji-shu-fa">进位计数法</h4><p>常用的进位计数法有十进制、二进制、八进制、十六进制等</p><p>一个<code>r进制数</code>(K<sub>n</sub>K<sub>n-1</sub>…K<sub>0</sub>K<sub>-1</sub>…K<sub>-m</sub>)的数值可表示为:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>n</mi></msub><msup><mi>r</mi><mi>n</mi></msup><mo>+</mo><msub><mi>K</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mi>r</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>K</mi><mn>0</mn></msub><msup><mi>r</mi><mn>0</mn></msup><mo>+</mo><msub><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msub><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>K</mi><mrow><mo>−</mo><mi>m</mi></mrow></msub><msup><mi>r</mi><mrow><mo>−</mo><mi>m</mi></mrow></msup><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>n</mi></mrow><mrow><mo>−</mo><mi>m</mi></mrow></msubsup><msub><mi>K</mi><mi>i</mi></msub><msup><mi>r</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">K_n r^n+K_{n-1} r^{n-1}+\cdots+K_0 r^0+K_{-1} r^{-1}+\cdots+K_{-m} r^{-m}=\sum_{i=n}^{-m} K_i r^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.824664em;"></span><span class="strut bottom" style="height:1.101528em;vertical-align:-0.276864em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="minner">⋯</span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="minner">⋯</span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord">−</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord">−</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mop"><span class="op-symbol small-op mop" style="top:-0.0000050000000000050004em;">∑</span><span class="vlist"><span style="top:0.276864em;margin-left:0em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathit">n</span></span></span></span><span style="top:-0.403131em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord">−</span><span class="mord mathit">m</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p><p>其中<code>r</code>是<mark>基数</mark>;r<sup>i</sup>是第 i 位的位权(整数位最低位规定为第 0 位);K<sub>i</sub>的取值可以是 0,1,…,r-1 共 r 个数码中的任意一个</p><p>数制的表示有 2 种方法，一种表示方法是<code>数字下标法</code>，对于不同进制的数可以将它们加上括号再用数字下标表示进制：</p><p>例如：（110010011111）2 代表二进制数 ； （6137）8 代表八进制数</p><p>另一种是用<code>后缀字母表示进制</code>：</p><p>二进制 <code>B</code> (binary)<br>八进制 <code>O</code> (octal)<br>十进制 <code>D</code> (decimal)<br>十六进制 <code>H</code> (hexadecimal)</p><p>例如：（3AB）H 代表十六进制数；（2654）O 代表八进制数</p><blockquote><p>当没有下标或后缀时默认为十进制数。</p></blockquote><ol><li class="lvl-3"><p><em>二进制</em>。计算机中用得最多的是基数为 2 的计数制,即 2 进制</p></li><li class="lvl-3"><p><em>八进制</em>。只有 0~7 共 8 位数字,计数&quot;逢八进一&quot;,因为 r = 2<sup>3</sup>所以只要把二进制中的 3 位数码编为一组就是一位八进制数</p></li></ol><p>举个 🌰:将二进制数 1111000010.011101 转为 8 进制数</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E4%BA%8C%E8%BD%AC%E5%85%AB-1688436552298-4.svg" alt="二转八"></p><p>所以对应的 8 进制数为(1702.32)<sub>8</sub></p><ol start="3"><li class="lvl-3"><p><em>十六进制数</em>。也是二进制的一种常用的书写方式,其基数为 16,“逢十六进一”。每个十六进制数位可以取 0~9、A、B、C、D、E、F,A~F 表示 10~15。因为 r = 16 = 2<sup>4</sup>,所以只要把二进制中的 4 位数码编写为一组就是一位十六进制数</p></li></ol><p>举个 🌰:将二进制数 1111000010.011101 转为 16 进制数</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E4%BA%8C%E8%BD%AC%E5%8D%81%E5%85%AD.svg" alt="二转十六"></p><p>所以对应的 16 进制数为(3C2.68)<sub>16</sub></p><p><strong>将任意进制数转换为十进制数</strong></p><p>将任意一个进制数的各位数码与他们的权值相乘,再把乘积相加,就得到了一个十进制数。这种方法称为<code>按权展开相加法</code></p><p>举个 🌰:将二进制数 11011.1 转为 10 进制数</p><p>(11011.1)<sub>2</sub> = 1×2<sup>4</sup> + 1×2<sup>3</sup> + 1×2<sup>1</sup> + 1×2<sup>0</sup> + 1×2<sup>-1</sup> = 27.5</p><p><strong>将十进制数转换为任意进制数</strong></p><p>一个十进制数转换为任意进制数,其整数部分常采用**<code>除基取余法</code><strong>,余数部分常采用</strong><code>乘基取余法</code>**</p><p><mark>除基取余法</mark></p><p>整数部分除基取余,最先取得的余数为数的最低位,最后取得的余数为数的最高位,商为 0 时结束</p><p><mark>乘基取整法</mark></p><p>小数部分乘基取整,最先取得的整数为数的最高位,最后取得的整数为数的最低位,乘积为 1.0(或满足精度要求)时结束</p><p>举个 🌰:将十进制数 123.6875 转为 2 进制数</p><p><strong>整数部分</strong>:<code>除基取余</code></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E9%99%A4%E5%9F%BA%E5%8F%96%E4%BD%99.svg" alt="除基取余"></p><p><strong>小数部分</strong>:<code>乘基取整</code></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E4%B9%98%E5%9F%BA%E5%8F%96%E6%95%B4.svg" alt="乘基取整"></p><p>所以(123.6875)<sub>10</sub> = (1111011.1011)<sub>2</sub></p><blockquote><p>🚨 在计算机中,小数和整数不一样,整数可以连续表示,但小数是离散的,所以并不是每一个十进制小数都可以准确地用二进制表示。例如 0.3。但任意一个二进制小数都可以用十进制小数表示</p></blockquote><p><strong>真值和机器数</strong></p><p>在计算机中,通常将数的符号和数值部分一起编码,将数据的符号数字化,通常使用<code>&quot;0&quot;</code>表示<code>&quot;正&quot;</code>,用<code>&quot;1&quot;</code>表示<code>&quot;负&quot;</code>。这种把符号&quot;数字化&quot;的数称为<code>机器数</code>。常用的有原码、补码和反码表示法。如 0,101(这里的逗号&quot;,&quot;仅为区分符号位与数值位)表示+5</p><h3 id="ding-dian-shu-de-bian-ma-biao-shi">定点数的编码表示</h3><p>根据小数点的位置是否固定,在计算机中有两种数据格式:<mark>定点表示</mark>和<mark>浮点表示</mark>。在现代计算机中,通常用定点补码整数表示整数,用定点原码小数表示浮点数的尾数部分,用移码表示浮点数的阶码部分。</p><h4 id="ji-qi-shu-de-ding-dian-biao-shi">机器数的定点表示</h4><p><strong>定点小数</strong>:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B0.svg" alt="定点小数"></p><p><strong>定点整数</strong>:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AE%9A%E7%82%B9%E6%95%B4%E6%95%B0-1688458349449-11.svg" alt="定点整数"></p><blockquote><p>🙋‍♂️ 上图中的小数点其实并不真实存在,而是隐含位,是由计算机硬件进行处理的</p></blockquote><p><code>定点数编码表示法</code>主要有以下 4 种:<mark>原码</mark>、<mark>补码</mark>、<mark>反码</mark>和<mark>移码</mark></p><h4 id="yuan-ma-bu-ma-fan-ma-yi-ma">原码、补码、反码、移码</h4><h5 id="yuan-ma-biao-shi-fa">原码表示法</h5><ul class="lvl-0"><li class="lvl-2"><p><em>纯小数原码定义</em></p></li></ul><p>[x]_{\text{原}} = \begin{cases} x & 1 > x \geq 0 \\ 1 - x = 1 + | x | & 0 \geq x > - 1 \end{cases} ( [ x ] _ { 原 }\text{是原码机器数,x 是真值})</p><p>例如,若 x<sub>1</sub> = +0.1101, x<sub>2</sub> = -0.1101,字长为 8 位,则其原码表示为[x<sub>1</sub>]<sub>原</sub> = <strong>0</strong>.1101000,[x<sub>2</sub>]<sub>原</sub> = <strong>1</strong>.1101000</p><p>若字长为 n+1,则原码小数的表示范围为 -(1-2<sup>-n</sup>) &lt;= x &lt;= 1-2<sup>-n</sup>(关于原点对称)</p><ul class="lvl-0"><li class="lvl-2"><p><em>纯整数原码定义<sup>*</sup></em></p></li></ul><p>[x]_\text{原}=\begin{cases}0,x&2^n>x\geq0\\2^n-x=2^n+|x|&0\geq x>-2^n\end{cases}(x+\text{是真值,}n\text{ 是整数位数)}</p><blockquote><p>🚨 真值零的原码表示有正零和负零两种形式,即[+0]<sub>原</sub> = <strong>0</strong>0000 和[-0]<sub>原</sub> = <strong>1</strong>0000</p></blockquote><p>原码的优点是 与真值的对应关系简单、直观,与真值的转换简单,并且用原码实现乘除运算比较简单。</p><p>缺点是,0 的表示不唯一,更重要的是原码加减运算比较复杂(其复杂体现在对于两个不同符号数的加法(或同符号数的减法),先要比较两个数绝对值大小,再用绝对值大的数减去绝对值小的数,最后还要给结果选择合适的符号)</p><h5 id="bu-ma-biao-shi-fa">补码表示法</h5><p>补码的加减运算同一用加法操作实现</p><ul class="lvl-0"><li class="lvl-2"><p>纯小数补码定义(了解)</p></li></ul><p>[x]_{\text{补}}=\begin{cases}x&1>x\geq0\\2+x=2-\mid x\mid&0>x\geq-1\end{cases}({\mathrm{mod}}2)</p><p>若字长为 n+1,则补码表示范围为-1 &lt;= x &lt;= 1-2<sup>-n</sup> (比原码多表示-1)</p><ul class="lvl-0"><li class="lvl-2"><p>纯整数的补码定义</p></li></ul><p>[x]_\text{补}=\begin{cases}0,x&2^n>x\geq0\\2^{n+1}+x=2^{n+1}-\mid x\mid&0\geq x\geq-2^n\end{cases}\pmod{2^{n+1}}</p><p>若字长为 n+1,则补码的表示范围为-2<sup>n</sup> &lt;= x &lt;= 2<sup>n-1</sup> (比原码多-2<sup>n</sup>)</p><p><strong>补码计算法定义：非负数的补码是其原码本身；负数的补码是其绝对值的原码最高位符号位不变，其它位取反，再加 1。</strong></p><p>一个字节 8 位，如果采用原码表示正整数（含 0），可以表达 0-255，即 2<sup>8</sup>=256，一共 256 种状态，从全 0 到全 1 的各种排列组合。如果要表示负数，则符号位需要占用一位（最高位，1 代表负数，0 代表正数），因此其绝对值最大范围为 0-127，即 2<sup>7</sup>=128，一共正负各 128 种状态，如果不采用特殊处理，这时候 0 占用 2 个编码（10000000 和 00000000），数据表示范围为-127 到-0 及+0 到 127，这样总体上一个字节只有 255 种状态，因为其中 0 具有正 0 和负 0 之分，这不符合数学意义也浪费一个编码。</p><pre><code class="language-css">  除了以上的弊端，还有个原因是，早期硬件很昂贵，一位或者一个编码的浪费都是不可饶恕的，因此人们想到了另一种编码把负0利用起来，即当遇到负数时，采用补码来表示就可以解决这个问题，而遇到正数或0时还是保留原码表示。因此这个负0通过补码算法处理后自然而然地被利用起来，用来表示-128.补码的算法为：绝对值的原码各位取反后加1.例1：负1的补码：    绝对值的8位原码为00000001    取反：11111110    加1 ：11111111    此时最高位被处理为1，满足高位为1代表负数的定义。例2：负128的补码：    绝对值的8位原码为10000000    取反：01111111    加1 ：10000000</code></pre><p>此时同样的最高位被置为 1，同样满足高位为 1 代表负数的定义,同时原先表示负 0 的编码被利用起来表示-128。因此一个字节的有符号整数范围为-128 到 127。</p><p>综上为：</p><pre><code class="language-css"> 原码+反码：8位原码和反码能够表示数的范围是-127~127； 补码：8位补码能够表示数的范围是 -128~127。（在补码中用(-128)代替了(-0)，所以补码的表示范围为：(-128~0~127)共256个）</code></pre><ul class="lvl-0"><li class="lvl-2"><p>变形补码</p></li></ul><p>变形补码,又称模 4 补码,双符号位的补码小数</p><p>概念:</p><p>用两个二进制位来表示符号位，其余位与补码相同，【例如模 2 补码的-3 为 1101,模 2 用 1 位，这里是最高位表示符号位，剩下 3 位是 3 的补码，同样模 4 补码表示-3 为 11_101,模 4 用两位表示符号位，这里是最高两位 11，其余 3 位为 3 的补码】总的说来就是符号位左边那一位表示正确的符号(这就说明了选择题里面存储模 4 补码只需要一个符号位是正确的，因为任意一个正确的数值，模 4 补码的符号位两个都是一样的，只需存储一个就行了)，0 为正，1 为负；右边那一位如果和左边的相同，如 &quot;00”表示正且无溢出，&quot;11&quot;表示负且无溢出。如果右边那一位与左边那一位不一样，则表示有溢出。</p><h5 id="fan-ma-biao-shi-fa">反码表示法</h5><p>反码表示法的定义就是,负数补码的最后一位减 1,整正数反码的的定义与相应的补码(或原码)表示相同</p><p>0 的表示不唯一</p><h5 id="yi-ma-biao-shi-fa">移码表示法</h5><p>移码常用来表示浮点数的阶码,他只能表示整数</p><p>移码就是真值 X 上加上一个常数(偏置值),通常这个常数取 2<sup>n</sup>,相当于 X 在数轴上正方向偏移了若干单位,这就是&quot;移码&quot;一词的由来。</p><p>移码的定义为:</p><p>[x]_{移}=2^{n}+x(2^{n}>x\geq-2^{n},\text{ 其中机器字长为 }n+1)</p><p>若正数 x<sub>1</sub> = +10101,x<sub>2</sub> = -10101,字长为 8 位则其移码表示为 x~1 移~ = 2<sup>7</sup>+10101 =&gt; 1,0010101 ;x~2 移~ = 2<sup>7</sup>+(-10101) =&gt; 0,1101011</p><p>一个真值的移码与补码仅差一个符号位,[x]<sub>补</sub>的符号位取反即得[x]<sub>移</sub></p><p>移码中零的表示唯一</p><p>移码全 0,对应真值的最小值-2<sup>n</sup>;移码全 1 时,对应真值最大值 2<sup>n</sup>-1</p><h2 id="yun-suan-fang-fa-he-yun-suan-dian-lu">运算方法和运算电路</h2><h3 id="ji-ben-yun-suan-bu-jian">基本运算部件</h3><p>在计算机中,运算器由算数逻辑单元(Arithmetic Logic Unit, ALU)、移位器、状态寄存器和通用寄存器等组成的。运算器的基本功能包括加减乘除四则运算,与、或、非、异或等逻辑运算,以及移位、求补等操作。<code>ALU</code>的核心部件是<code>加法器</code></p><p><strong>以下是一些常用的逻辑符号</strong>👇:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7.svg" alt="逻辑符号"></p><h4 id="strong-gong-shi-he-ding-li-strong"><strong>公式和定理</strong>👨‍🏫</h4><p><em>常量之间的关系</em>:</p><p>\begin{aligned}&\text{公式1} && 0 \cdot 0 = 0 \\&\text{公式}1' && 1 + 1 = 1 \\&\text{公式2} && 0 \cdot 1 = 0 \\&\text{公式}2' && 1 + 0 = 1 \\&\text{公式3} && 1 \cdot 1 = 1 \\&\text{公式}3' && 0 + 0 = 0 \\&\text{公式4} && \overline{0} = 1 \\&\text{公式}4' && \overline{1} = 0 \\\end{aligned}</p><p><em>常量与变量的关系</em></p><p>\begin{aligned}&\text{公式5} && A\cdot1=A \\&\text{公式}5' &&  A+0=A \\&\text{公式6} && A\cdot0=0 \\&\text{公式}6' && A+1=1 \\&\text{公式7} && A\cdot\overline{A}=0 \\&\text{公式}7' && A+\overline{A}=1 \end{aligned}</p><p><em>与普通代数相似的定理</em></p><p>\begin{aligned}&\textbf{交换律} \\&\text{公式8}&& A\cdot B=B\cdot A  \\&\text{公式8}'&& A+B=B+A  \\&\textbf{结合律} \\&\text{公式9}&& \left(A\cdot B\right)\cdot C=A\cdot\left(B\cdot C\right)  \\&\text{公式}9'&& \left(A+B\right)+C=A+\left(B+C\right)  \\&\textbf{分配律} \\&\text{公式10}&& A\cdot\left(B+C\right)=A\cdot B+A\cdot C  \\&公式10^{\prime}&& A+B\cdot C=\left(A+B\right)\cdot\left(A+C\right) \end{aligned}</p><p><em>逻辑代数的一些特殊定理</em></p><p>\begin{aligned}&\textbf{同一律} \\&\text{公式 11}&& A\cdot A=A  \\&\text{公式 11}'&& A+A=A  \\&\textbf{德·摩根定理} \\&\text{公式 12}&& \overline{A\cdot B}=\overline{A}+\overline{B}  \\&\text{公式 12}'&& \overline{A+B}=\overline{A}\cdot\overline{B}  \\&\textbf{还原律} \\&\text{公式13}&& \overline{\overline{A}}=A \end{aligned}</p><p><em>若干常用公式</em></p><p>\begin{aligned} &\text{公式14} && A \cdot B + A \cdot \overline{B} = A \\ &\text{公式15} && A + A \cdot B = A \\ &\text{公式16} &&A+\overline{A}\cdot B=A+B\end{aligned}</p><h4 id="luo-ji-han-shu-de-gong-shi-hua-jian-fa">逻辑函数的公式化简法</h4><p><strong>一、并项法</strong></p><p>利用公式 14 把两个乘积项合并起来,消除一个变量。</p><p>🌰:化简函数 Y = ABC + AB┐C+ ┐AB</p><pre><code class="language-css">AB C + AB ┐C =&gt; ABAB + ┐AB =&gt; B</code></pre><p><strong>二、吸收法</strong></p><p>利用公式 15,吸收掉多余的乘积项</p><p>🌰:化简函数 Y =┐(AB) + ┐AD+ ┐BE</p><pre><code class="language-css">利用摩根公式┐(AB) = ┐A + ┐B┐A + ┐AD =&gt; ┐A┐B + ┐BE =&gt; ┐B=&gt; ┐A + ┐B</code></pre><p><strong>三、消去法</strong></p><p>利用公式 16 消去乘积中多余的乘积项</p><p>🌰:化简函数 Y = ┐(AB) + AC+ BD</p><pre><code class="language-css">利用摩根公式┐(AB) = ┐A + ┐B=&gt; ┐A + ┐B + C + D</code></pre><h4 id="luo-ji-han-shu-de-tu-xing-hua-jian-fa">逻辑函数的图形化简法</h4><p>用卡诺图化简逻辑函数,求最简与或表达式的方式被称为图形化简法。图形化简法有较明确的步骤可以遵循,但是变量超过 6 个以上的时候就没什么实用价值了</p><p><strong>卡诺图化简法</strong></p><p>卡诺图是一种最小项方块图,卡诺图的特点是用几何相邻形象地表示各变量各个最小项在逻辑上的相邻性</p><p>下图为变量 AB 的卡诺图:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/2%E5%8D%A1%E8%AF%BA%E5%9B%BE.svg" alt="2卡诺图"></p><blockquote><p>🚨 上图中 ┐A┐B 不能画作 ┐(AB)只是画图时连接在了一起,二者并不等价</p><p>之后的图省略 ┐A┐B 等为 0 或 1,在逻辑函数中的最小项有 ┐A┐B 则在 卡诺图中 00 位置 填 1</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/test1.svg" alt="test1"></p></blockquote><p>三变量的卡诺图:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/3%E5%8D%A1%E8%AF%BA%E5%9B%BE.drawio.svg" alt="3卡诺图.drawio"></p><p>下图为四变量的卡诺图:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/4%E5%8D%A1%E8%AF%BA%E5%9B%BE.svg" alt="4卡诺图"></p><p>五变量的卡诺图:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/5%E5%8D%A1%E8%AF%BA%E5%9B%BE.drawio.svg" alt="5卡诺图.drawio"></p><p>六变量的卡诺图:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/6%E5%8D%A1%E8%AF%BA%E5%9B%BE.svg" alt="6卡诺图"></p><blockquote><p>🤔<strong>为什么卡诺图中的变量取值是 00 01 11 10 而不是 00 01 10 11?</strong></p><p>因为卡诺图的画法是按循环码排列变量取值顺序。<strong>循环码的特点是相邻编码之间只有 1 位码元不同</strong>,而若是 01 10 则有两位码元相同。变量取值之所以按循环码排列,是因为保证卡诺图中,凡是几何相邻的最小项,在逻辑上是相邻的这一重要特点</p></blockquote><p><strong>卡诺图的化简</strong></p><ul class="lvl-0"><li class="lvl-2"><p><em>几何相邻</em></p><ul class="lvl-2"><li class="lvl-4">相接——紧挨着的方块</li><li class="lvl-4">相对——任一行或者一列的两头</li><li class="lvl-4">相重——对折起来后位置重合</li></ul></li><li class="lvl-2"><p><em>逻辑相邻</em></p></li></ul><p>如果两个最小项,除了一个变量的形式不同以外,其余的都相同,那么这两个最小项就称为在逻辑上相邻</p><p>卡诺图中凡是几何相邻的最小项均可合并,合并时能消除有关变量。两个最小项合并成一项时可以消去一个变量,4 个最小项合并成一项可以消除 2 个变量,8 个最小项合并可以消除 3 个变量。所以一般来说 2<sup>n</sup>个最小项合并时可以消去 n 个变量。(即一次看一列或者一行,若有一个码元发生改变,即消除那个发生改变的码元)</p><p>🌰:用图形化化简函数</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi><mo>=</mo><mover accent="true"><mrow><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mi>C</mi><mi>D</mi><mo>+</mo><mi>B</mi><mover accent="true"><mrow><mi>C</mi></mrow><mo stretchy="true">‾</mo></mover><mo>+</mo><mover accent="true"><mrow><mi>A</mi></mrow><mo stretchy="true">‾</mo></mover><mspace width="0.22222em"></mspace><mover accent="true"><mrow><mi>C</mi></mrow><mo stretchy="true">‾</mo></mover><mi>D</mi><mo>+</mo><mi>A</mi><mover accent="true"><mrow><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mi>C</mi></mrow><annotation encoding="application/x-tex">Y=\overline{B}CD+B\overline{C}+\overline{A}\:\overline{C}D+A\overline{B}C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8833300000000001em;"></span><span class="strut bottom" style="height:0.9666600000000001em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.22222em;">Y</span><span class="mrel">=</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mbin">+</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit">A</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mord mspace mediumspace"></span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mbin">+</span><span class="mord mathit">A</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.07153em;">C</span></span></span></span></p><blockquote><p>┐A┐CD</p></blockquote><p>① 画出函数的卡诺图</p><p>观察函数,发现函数只有 4 个不同的变量 ABCD,画出四变量卡诺图,在图中标出 Y 所包含的全部最小项,如下图<br><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/1testtest.svg" alt="1"></p><p>② 合并最小项</p><p>合并原则是:</p><pre><code class="language-css">- 必须包含函数的所有最小项,并且保证合并后的乘积项的总数最少- 相邻的最小项合并时,蕴含的最小项数越多,则合并后的乘积因子最少- 每次合并时,为了消去更多变量,可以重复使用函数的最小项,但是必须保证至少包含1个新的最小项(未被重复使用过),以避免冗余项的出现</code></pre><p><strong>圈要少、圈最大（先少后大）</strong></p><p>化简中注意的问题:</p><p>➢ 每一个标 1 的方格必须至少被圈一次;</p><p>➢ 每个圈中包含的相邻小方格数,必须为 2 的整数次幂;</p><p>➢ 为了得到尽可 能大的圈，圈与圈之间可以重叠;</p><p>➢ 若某个圈中的标 1 方格,已经完全被其它圈所覆盖,则该圈为多余的。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%8C%96%E7%AE%80.svg" alt="化简"></p><p>结果为:Y = B┐C + ┐A┐BD + A┐BC</p><p><strong>五变量化简卡诺图</strong></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/5%E5%8C%96%E7%AE%80.svg" alt="5化简"></p><p>因为红圈部分为 ┐E 所独有,则在 ┐E 中的化简中 ┐E 不能消除,绿圈中为 ┐E 和 E 图中共有,则消去 E 变量,再把二图中的所得结果相与则可得出最终答案</p><h4 id="yi-wei-quan-jia-qi">一位全加器</h4><p>全加器(FA)是最基本的加法单元,有加数 A<sub>i</sub>、加数 B<sub>i</sub>与低位传来的进位 C<sub>i-1</sub>共三个输入,有本位和 S<sub>i</sub>与向高位的进位 C<sub>i</sub>共两个输出。</p><p>其真值表为:</p><table><thead><tr><th style="text-align:center">A<sub>i</sub>(加数)</th><th style="text-align:center">B<sub>i</sub>(加数)</th><th style="text-align:center">C<sub>i-1</sub>(低位进位)</th><th style="text-align:center">S<sub>i</sub>(本位)</th><th style="text-align:center">C<sub>i</sub>(向高位进位)</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table><p>表中目标值(S<sub>i</sub>、C<sub>i</sub>)为 1 的行保留,其他行舍弃</p><p>可得:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">S</mi><mo>=</mo><mover accent="true"><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><mo stretchy="true">‾</mo></mover><mspace width="0.22222em"></mspace><mover accent="true"><mrow><msub><mi>B</mi><mi>i</mi></msub></mrow><mo stretchy="true">‾</mo></mover><msub><mi mathvariant="normal">C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mover accent="true"><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><mo stretchy="true">‾</mo></mover><msub><mi mathvariant="normal">B</mi><mi>i</mi></msub><mover accent="true"><mrow><msub><mi>C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><mo stretchy="true">‾</mo></mover><mo>+</mo><msub><mi mathvariant="normal">A</mi><mi>i</mi></msub><mover accent="true"><mrow><msub><mi>B</mi><mi>i</mi></msub></mrow><mo stretchy="true">‾</mo></mover><mspace width="0.22222em"></mspace><mover accent="true"><mrow><msub><mi>C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><mo stretchy="true">‾</mo></mover><mo>+</mo><msub><mi mathvariant="normal">A</mi><mi>i</mi></msub><msub><mi mathvariant="normal">B</mi><mi>i</mi></msub><msub><mi mathvariant="normal">C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\mathrm S=\overline{A_i}\:\overline{B_i}\mathrm C_{i-1}+\overline{A_i}\mathrm B_i\overline{C_{i-1}}+\mathrm A_i\overline{B_i}\:\overline{C_{i-1}} +\mathrm A_i\mathrm B_i\mathrm C_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8833300000000001em;"></span><span class="strut bottom" style="height:1.091661em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">S</span><span class="mrel">=</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mord mspace mediumspace"></span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05017em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05017em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mord mspace mediumspace"></span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p><p>由卡诺图化简得:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">S</mi><mo>=</mo><msub><mi mathvariant="normal">A</mi><mi mathvariant="normal">i</mi></msub><mo>⊗</mo><msub><mi mathvariant="normal">B</mi><mi mathvariant="normal">i</mi></msub><mo>⊗</mo><msub><mi mathvariant="normal">C</mi><mrow><mi mathvariant="normal">i</mi><mo>−</mo><mn mathvariant="normal">1</mn></mrow></msub></mrow></mrow><annotation encoding="application/x-tex">\mathrm{S=A_i\otimes B_i\otimes C_{i-1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">S</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">⊗</span><span class="mord"><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">⊗</span><span class="mord"><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">C</mi><mrow><mi mathvariant="normal">i</mi></mrow></msub><mo>=</mo><msub><mi mathvariant="normal">A</mi><mi>i</mi></msub><msub><mi mathvariant="normal">B</mi><mi>i</mi></msub><mo>+</mo><msub><mi mathvariant="normal">B</mi><mi>i</mi></msub><msub><mi mathvariant="normal">C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi mathvariant="normal">C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi mathvariant="normal">A</mi><mi>i</mi></msub><mo>=</mo><msub><mi mathvariant="normal">A</mi><mi>i</mi></msub><msub><mi mathvariant="normal">B</mi><mi>i</mi></msub><mo>+</mo><mo>(</mo><mi mathvariant="normal">A</mi><mo>⊗</mo><mi mathvariant="normal">B</mi><mo>)</mo><msub><mi mathvariant="normal">C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\mathrm C_{\mathrm i}=\mathrm A_i\mathrm B_i+\mathrm B_i\mathrm C_{i-1}+\mathrm C_{i-1}\mathrm A_i=\mathrm A_i\mathrm B_i+(\mathrm A\otimes\mathrm B)\mathrm C_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">i</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathrm">A</span><span class="mbin">⊗</span><span class="mord mathrm">B</span><span class="mclose">)</span><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p><p>可以由此画出一位全加器的逻辑结构为:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%8A%A0%E6%B3%95%E5%99%A8.svg" alt="加法器"></p><p>由此可以得出<strong>N 位串行进位加法器</strong>的结构:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/N-1688645147129-17.svg" alt="N"></p><blockquote><p>🙋‍♂️ 在串行进位加法器的最长运算时间是由产生的进位信号所产生的传递延迟所决定的,位数越多延迟时间越长.所以人们又设计出了并行进位加法器</p></blockquote><p><strong>并行进位加法器</strong></p><p>由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">C</mi><mrow><mi mathvariant="normal">i</mi></mrow></msub><mo>=</mo><msub><mi mathvariant="normal">A</mi><mi>i</mi></msub><msub><mi mathvariant="normal">B</mi><mi>i</mi></msub><mo>+</mo><msub><mi mathvariant="normal">B</mi><mi>i</mi></msub><msub><mi mathvariant="normal">C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi mathvariant="normal">C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi mathvariant="normal">A</mi><mi>i</mi></msub><mo>=</mo><msub><mi mathvariant="normal">A</mi><mi>i</mi></msub><msub><mi mathvariant="normal">B</mi><mi>i</mi></msub><mo>+</mo><mo>(</mo><mi mathvariant="normal">A</mi><mo>⊗</mo><mi mathvariant="normal">B</mi><mo>)</mo><msub><mi mathvariant="normal">C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\mathrm C_{\mathrm i}=\mathrm A_i\mathrm B_i+\mathrm B_i\mathrm C_{i-1}+\mathrm C_{i-1}\mathrm A_i=\mathrm A_i\mathrm B_i+(\mathrm A\otimes\mathrm B)\mathrm C_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">i</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class><span class="mord mathrm">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class><span class="mord mathrm">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathrm">A</span><span class="mbin">⊗</span><span class="mord mathrm">B</span><span class="mclose">)</span><span class><span class="mord mathrm">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,令 G<sub>i</sub>= A<sub>i</sub>B<sub>i</sub>,P<sub>i</sub>=A⊕B,可得 C<sub>i</sub>=G<sub>i</sub>+P<sub>i</sub>C<sub>i-1</sub></p><p>将 G<sub>i</sub>和 P<sub>i</sub>带入前面的 C<sub>1</sub>~C<sub>4</sub>中可得:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mtext><mi mathvariant="normal">C</mi><mn>1</mn></mtext><mo>=</mo><msub><mi>G</mi><mrow><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>1</mn></mrow></msub><msub><mi>C</mi><mrow><mn>0</mn></mrow></msub></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><msub><mi>C</mi><mrow><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>G</mi><mrow><mn>2</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>2</mn></mrow></msub><msub><mi>C</mi><mrow><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>G</mi><mrow><mn>2</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>2</mn></mrow></msub><msub><mi>G</mi><mrow><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>2</mn></mrow></msub><msub><mi>P</mi><mrow><mn>1</mn></mrow></msub><msub><mi>C</mi><mrow><mn>0</mn></mrow></msub></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><msub><mi>C</mi><mrow><mn>3</mn></mrow></msub><mo>=</mo><msub><mi>G</mi><mrow><mn>3</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>3</mn></mrow></msub><msub><mi>C</mi><mrow><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>G</mi><mrow><mn>3</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>3</mn></mrow></msub><msub><mi>G</mi><mrow><mn>2</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>3</mn></mrow></msub><msub><mi>P</mi><mrow><mn>2</mn></mrow></msub><msub><mi>G</mi><mrow><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>3</mn></mrow></msub><msub><mi>P</mi><mrow><mn>2</mn></mrow></msub><msub><mi>P</mi><mrow><mn>1</mn></mrow></msub><msub><mi>C</mi><mrow><mn>0</mn></mrow></msub></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><msub><mi>C</mi><mrow><mn>4</mn></mrow></msub><mo>=</mo><msub><mi>G</mi><mrow><mn>4</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>4</mn></mrow></msub><msub><mi>C</mi><mrow><mn>3</mn></mrow></msub><mo>=</mo><msub><mi>G</mi><mrow><mn>4</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>4</mn></mrow></msub><msub><mi>G</mi><mrow><mn>3</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>4</mn></mrow></msub><msub><mi>P</mi><mrow><mn>3</mn></mrow></msub><msub><mi>G</mi><mrow><mn>2</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>4</mn></mrow></msub><msub><mi>P</mi><mrow><mn>3</mn></mrow></msub><msub><mi>P</mi><mrow><mn>2</mn></mrow></msub><msub><mi>G</mi><mrow><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>P</mi><mrow><mn>4</mn></mrow></msub><msub><mi>P</mi><mrow><mn>3</mn></mrow></msub><msub><mi>P</mi><mrow><mn>2</mn></mrow></msub><msub><mi>P</mi><mrow><mn>1</mn></mrow></msub><msub><mi>C</mi><mrow><mn>0</mn></mrow></msub></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}&amp;\text{C1} =G_{1}+P_{1}C_{0}  \\&amp;C_{2} =G_{2}+P_{2}C_{1}=G_{2}+P_{2}G_{1}+P_{2}P_{1}C_{0}  \\&amp;C_{3} =G_{3}+P_{3}C_{2}=G_{3}+P_{3}G_{2}+P_{3}P_{2}G_{1}+P_{3}P_{2}P_{1}C_{0}  \\&amp;C_{4} =G_{4}+P_{4}C_{3}  =G_{4}+P_{4}G_{3}+P_{4}P_{3}G_{2}+P_{4}P_{3}P_{2}G_{1}+P_{4}P_{3}P_{2}P_{1}C_{0} \end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:2.6500000000000004em;"></span><span class="strut bottom" style="height:4.800000000000001em;vertical-align:-2.1500000000000004em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-1.8100000000000003em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span style="top:-0.6100000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span style="top:0.5900000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span style="top:1.7900000000000003em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="col-align-l"><span class="vlist"><span style="top:-1.8100000000000003em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="text mord textstyle uncramped"><span class="mord mathrm">C</span><span class="mord mathrm">1</span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:-0.6100000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:0.5900000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:1.7900000000000003em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit">G</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">3</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.07153em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></p><p>可知 G<sub>i</sub>在 A<sub>i</sub>B<sub>i</sub>输入时就已得出,唯一需要等待的是 C<sub>0</sub>(因为 C<sub>i</sub>可以用 C<sub>0</sub>推导出)</p><p>所以其他位在 C<sub>0</sub>形成时就可同时生成,但是这样的缺陷是,位数越多,电路越复杂</p><h3 id="ding-dian-shu-de-yun-suan">定点数的运算</h3><h4 id="ding-dian-shu-de-yi-wei-yun-suan">定点数的移位运算</h4><p>移位运算根据操作对象的不同分为<code>算术移位</code>和<code>逻辑移位</code>。<strong>有符号数的移位称为算术移位</strong>，<strong>逻辑移位的操作对象是逻辑代码,可视为无符号数</strong>。</p><h5 id="suan-zhu-yi-wei">算术移位</h5><p>算术移位的对象是有符号数，在移位过程中<code>符号位保持不变</code> 。</p><p>对于正数，由于[x]<sub>原</sub> = [x]<sub>补</sub> = [x]<sub>反</sub> = 真值，因此移位后出现的空位均以 0 添之。对于负数，由与原码，补码，反码的表示形式不同，因此当机器数移位时，对其空位的添补规则也不同</p><blockquote><p>🙋‍♂️ 不论是正数还是负数，移位后其符号位均不变，且移位后都相当于对真值补 0，根据补码、反码的特性，所以在负数时填补代码有区别。</p></blockquote><p>对于原码，左移一位若不产生溢出，相当于乘以 2(与十进制的左移一位相当于乘以 10 类似)，右移一位，若不考虑因移出而舍去的末位尾数，相当于除以 2。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210706102244.png" alt="img"></p><p>由表 2.1👆 可以得出如下结论。</p><p>正数的原码、补码与反码都相同，因此移位后出现的空位均以 0 添之。对于负数，由于原码、补码和反码的表示形式不同，因此当机器数移位时，对其空位的添补规则也不同。</p><ul class="lvl-0"><li class="lvl-2"><p>负数的原码数值部分与真值相同，因此在移位时只要使符号位不变，其空位均添 0。</p></li><li class="lvl-2"><p>负数的反码各位除符号位外与负数的原码正好相反，因此移位后所添的代码应与原码相反，即全部添 1。</p></li><li class="lvl-2"><p>分析由原码得到补码的过程发现，当对其由低位向高位找到第一个“1”时，在此“1”左边的各位均与对应的反码相同，而在此“1”右边的各位（包括此“1”在内）均与对应的原码相同。因此负数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添 0;右移时因空位出现在高位，则添补的代码应与反码相同，即添 1。</p></li></ul><h5 id="luo-ji-yi-wei">逻辑移位</h5><p>逻辑移位将操作数视为无符号数，移位规则:逻辑左移时，高位移丢，低位添 0;逻辑右移时，低位移丢，高位添 0。</p><blockquote><p>🙋‍♂️ 逻辑移位不管是左移还是右移，都添 0。</p></blockquote><p>循环移位分为带进位标志位 CF 的循环移位(大循环）和不带进位标志位的循环移位（小循环)，过程如图 2.7 所示。</p><p>循环移位的主要特点是，移出的数位又被移入数据中，而是否带进位则要看是否将进位标志位加入循环位移。例如，带进位位的循环左移〔见图 2.7(d)]就是数据位连同进位标志位一起左移，数据的最高位移入进位标志位 CF，而进位位则依次移入数据的最低位。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210706102442.png" alt="img"></p><p>循环移位操作特别适合将数据的低字节数据和高字节数据互换。</p><pre><code class="language-css">带进位标志位CF的循环左移（大循环）：假设有一个8位的二进制数：10101010，进位标志位CF的初始值为0。带进位标志位CF的循环左移一位：初始状态：10101010左移一位后，数据位与进位标志位一起左移，数据的最高位移入进位标志位CF，而进位位则依次移入数据的最低位：新状态：01010101，CF=1带进位标志位CF的循环左移三位：初始状态：10101010左移三位后，数据位与进位标志位一起左移，数据的最高位移入进位标志位CF，而进位位则依次移入数据的最低位：新状态：01010101，CF=1不带进位标志位的循环左移（小循环）：假设有一个8位的二进制数：10101010不带进位标志位的循环左移一位：初始状态：10101010左移一位后，数据位循环左移，最高位移入最低位，不涉及进位标志位：新状态：01010101不带进位标志位的循环左移三位：初始状态：10101010左移三位后，数据位循环左移，最高位移入最低位，不涉及进位标志位：新状态：01010101</code></pre><h4 id="yuan-ma-ding-dian-shu-de-jia-jian-fa-yun-suan">原码定点数的加减法运算</h4><p>设[X]_\text{原}=x_s.x_1x_2\cdots x_n和[Y]_\text{原}=y_s.y_1y_2\cdots y_n,进行加减运算的规则如下。</p><p><code>加法规则</code>:先判符号位，若相同，则绝对值相加，结果符号位不变;若不同，则做减法，绝对值大的数减去绝对值小的数，结果符号位与绝对值大的数相同。</p><p><code>减法规则</code>:两个原码表示的数相减，首先将减数符号取反，然后将被减数与符号取反后的减数按原码加法进行运算。</p><blockquote><p>🙋‍♂️ 运算时注意机器字长，当左边位出现溢出时，将溢出位丢掉。</p></blockquote><h4 id="bu-ma-ding-dian-shu-jia-jian-fa-yun-suan">补码定点数加减法运算</h4><p>补码加减运算规则简单，易于实现，因此计算机系统中普遍采用补码加减运算。补码运算的特点如下（设机器字长为 n+1)。</p><ol><li class="lvl-3"><p>参与运算的两个操作数均用补码表示。</p></li><li class="lvl-3"><p>按二进制运算规则运算，逢二进一。</p></li><li class="lvl-3"><p>符号位与数值位按同样规则一起参与运算，符号位运算产生的进位要丢掉，结果的符号位由运算得出。</p></li><li class="lvl-3"><p>补码加减运算依据下面的公式进行。当参加运算的数是定点小数时，模 M= 2;当参加运算的数是定点整数时，模 M = 2<sup>n</sup>+1。</p></li></ol>\begin{cases}{[A+B]_{\text {补 }}=[A]_{\text {补 }}+[B]_{\text {补 }},} & (\bmod M) \\ {[A-B]_{\text {补 }}=[A]_{\text {补 }}+[-B]_补,} & (\bmod M)\end{cases}<blockquote><p>🙋‍♂️mod M 运算是为了将溢出位丢掉。</p></blockquote><p>也就是说，若做加法，则两数的补码直接相加;若做减法，则将被减数与减数的机器负数相加。</p><p><strong>补码运算的结果亦为补码</strong></p><p>设机器字长为 8 位（含 1 位符号位)，A= 15，B=24，求补[A+B]<sub>补</sub>和[A−B]<sub>补</sub>。</p><p>解：</p><p>A=+15=+0001111，B=+24=+0011000;得补[A]<sub>补</sub>= 00001111，[B]<sub>补</sub>=00011000。</p><p>求得[−B]<sub>补</sub> = 11101000。所以</p><p>[A+B]<sub>补</sub>=00001111+ 00011000 = 00100111，其符号位为 0，对应真值为+39。</p><p>[A−B]<sub>补</sub>=[A]<sub>补</sub>+[−B]<sub>补</sub>=00001111 + 11101000= 11110111，其符号位为 1，对应真值为-9。</p><h4 id="fu-hao-kuo-zhan">符号扩展</h4><p>在计算机算术运算中，有时必须把采用给定位数表示的数转换成具有不同位数的某种表示形式。例如，某个程序需要将一个 8 位数与另外一个 32 位数相加，要想得到正确的结果，在将 8 位数与 32 位数相加之前，必须将 8 位数转换成 32 位数形式，这称为“符号扩展”。</p><p>正数的符号扩展非常简单，即原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用 0 进行填充。</p><p>负数的符号扩展方法则根据机器数的不同而不同。原码表示负数的符号扩展方法与正数相同，只不过此时符号位为 1。补码表示负数的符号扩展方法:原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用 1(对于整数）或 0(对于小数）进行填充。反码表示负数的符号扩展方法:原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用 1 进行填充。</p><blockquote><p>正数相当于位数往左边扩展，负数相当于位数往右边扩展</p></blockquote><h4 id="yi-chu-gai-nian-he-pan-bie-fang-fa">溢出概念和判别方法</h4><p>溢出是指运算结果超过了数的表示范围。通常，称大于机器所能表示的最大正数为上溢，称小于机器所能表示的最小负数为下溢。定点小数的表示范围为|x|&lt;1，如图 2.8 所示。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210706143612.png" alt="img"></p><p>仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出，如两个正数相加，而结果的符号位却为 1(结果为负);一个负数减去一个正数，结果的符号位却为 0(结果为正)。定点数加减运算出现溢出时，运算结果是错误的。</p><p>补码定点数加减运算溢出判断的方法有 3 种。</p><p>(1）采用一位符号位</p><p>由于减法运算在机器中是用加法器实现的，因此无论是加法还是减法，只要参加操作的两个数符号相同，结果又与原操作数符号不同，则表示结果溢出。</p><p>设 A 的符号为 A<sub>s</sub>,B 的符号为 B<sub>s</sub>，运算结果的符号为 S<sub>s</sub>,则溢出逻辑表达式为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo>=</mo><msub><mi>A</mi><mi>s</mi></msub><msub><mi>B</mi><mi>s</mi></msub><msub><mover accent="true"><mrow><mi>S</mi></mrow><mo>¯</mo></mover><mi>s</mi></msub><mo>+</mo><msub><mover accent="true"><mrow><mi>A</mi></mrow><mo>¯</mo></mover><mi>s</mi></msub><msub><mover accent="true"><mrow><mi>B</mi></mrow><mo>¯</mo></mover><mi>s</mi></msub><msub><mi>S</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">V=A_sB_s\bar{S}_s+\bar{A}_s\bar{B}_sS_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8201099999999999em;"></span><span class="strut bottom" style="height:0.9701099999999999em;vertical-align:-0.15em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05017em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle cramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span><span style="top:-0.25233em;margin-left:0.16668em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>¯</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle cramped"><span class="mord mathit">A</span></span></span><span style="top:-0.25233em;margin-left:0.27778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>¯</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord accent"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle cramped"><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span><span style="top:-0.25233em;margin-left:0.16668em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="accent-body"><span>¯</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></p><p>若 V = 0，表示无溢出；若 V = 1，表示有溢出</p><p>(2）采用双符号位</p><p>双符号位法也称模 4 补码。运算结果的两个符号位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>s</mi><mn>1</mn></mrow></msub><msub><mi>S</mi><mrow><mi>s</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{s1}S_{s2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>相同，表示未溢出;运算结果的两个符号位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>s</mi><mn>1</mn></mrow></msub><msub><mi>S</mi><mrow><mi>s</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{s1}S_{s2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>不同，表示溢出，此时最高位符号位代表真正的符号。</p><p>符号位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>s</mi><mn>1</mn></mrow></msub><msub><mi>S</mi><mrow><mi>s</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{s1}S_{s2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>的各种情况如下：</p><ul class="lvl-0"><li class="lvl-2"><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>s</mi><mn>1</mn></mrow></msub><msub><mi>S</mi><mrow><mi>s</mi><mn>2</mn></mrow></msub><mo>=</mo><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">S_{s1}S_{s2} = 00</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span>:表示结果为正数，无溢出</p></li><li class="lvl-2"><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>s</mi><mn>1</mn></mrow></msub><msub><mi>S</mi><mrow><mi>s</mi><mn>2</mn></mrow></msub><mo>=</mo><mn>0</mn><mn>1</mn></mrow><annotation encoding="application/x-tex">S_{s1}S_{s2} = 01</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span></span></span></span>:表示结果为正溢出</p></li><li class="lvl-2"><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>s</mi><mn>1</mn></mrow></msub><msub><mi>S</mi><mrow><mi>s</mi><mn>2</mn></mrow></msub><mo>=</mo><mn>1</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">S_{s1}S_{s2} = 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span></span></span></span>:表示结果为负溢出</p></li><li class="lvl-2"><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>s</mi><mn>1</mn></mrow></msub><msub><mi>S</mi><mrow><mi>s</mi><mn>2</mn></mrow></msub><mo>=</mo><mn>1</mn><mn>1</mn></mrow><annotation encoding="application/x-tex">S_{s1}S_{s2} = 11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span></span></span></span>:表示结果为负数，无溢出</p></li></ul><p>即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>s</mi><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>S</mi><mrow><mi>s</mi><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{s1},S_{s2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">2</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>相等，无溢出，不等，溢出</p><h4 id="ding-dian-shu-de-cheng-fa-yun-suan">定点数的乘法运算</h4><p><strong>带符号的阵列乘法器</strong></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230716075309183.png" alt="image-20230716075309183"></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230715210620124.png" alt="image-20230715210620124"></p><blockquote><p>🚨 最后的补级输出是，先加上符号后，再求补</p></blockquote><h5 id="yuan-ma-yi-wei-cheng-fa">原码一位乘法</h5><iframe src="//player.bilibili.com/player.html?bvid=BV1e8411S7os&page=1" width="780" height="480" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" autoplay="0"> </iframe><h4 id="shu-ju-de-cun-chu-he-pai-lie">数据的存储和排列</h4><h5 id="shu-ju-de-da-duan-fang-shi-he-xiao-duan-fang-shi-cun-chu">数据的“大端方式”和“小端方式”存储</h5><p>在存储数据时，数据从低位到高位可以按从左到右排列，也可以按从右到左排列。因此，无法用最左或最右来表征数据的最高位或最低位，通常用<code>最低有效字节(Least Significant Bit,LSB)</code>和<code>最高有效字节(Most Significant Bit,MSB)</code>来分别表示数的低位和高位。例如，在 32 位计算机中，一个 int 型变量 i 的机器数为 0123 4567H，其最高有效字节 MSB= 01H，最低有效字节 LSB=67H。</p><p>现代计算机基本上都采用字节编址，即每个地址编号中存放 1 字节。不同类型的数据占用的字节数不同，int 和 float 型数据占 4 字节，double 型数据占 8 字节等，而程序中对每个数据只给定一个地址。假设变量 i 的地址为 80 00H，字节 01H、23H、45H、67H 应该各有一个内存地址，那么地址 08 00H 对应 4 字节中哪字节的地址呢?这就是字节排列顺序问题。</p><p>多字节数据都存放在连续的字节序列中，根据数据中各字节在连续字节序列中的排列顺序不同，可以采用两种排列方式:<code>大端方式(big endian)</code>和<code>小端方式(little endian)</code>，如图 2.9 所示 👇。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210706152204.png" alt="img"></p><p><code>大端方式</code><strong>按从最高有效字节到最低有效字节的顺序存储数据，即最高有效字节存放在前面</strong>;</p><p><code>小端方式</code><strong>按从最低有效字节到最高有效字节的顺序存储数据，即最低有效字节存放在前面</strong>。</p><p>在检查底层机器级代码时，需要分清各类型数据字节序列的顺序，例如以下是由反汇编器(汇编的逆过程，即将机器代码转换为汇编代码）生成的一行机器级代码的文本表示:</p><p>4004d3:01 05 64 94 04 08 add %eax,0x8049464</p><p>其中，“4004d3”是十六进制表示的地址，“01 05 43 0b 20 00”是指令的机器代码，“add %eax，Ox8049464”是指令的汇编形式，该指令的第二个操作数是一个立即数 0x8049464，执行该指令时，从指令代码的后 4 字节中取出该立即数，立即数存放的字节序列为 64H、94H、04H、08H，正好与操作数的字节顺序相反，即采用的是小端方式存储，得到 08049464H<br>去掉开头的 0，得到值 0x8049464，在阅读小端方式存储的机器代码时，要注意字节是按相反顺序显示的。</p><pre><code class="language-css">【2019统考真题】某计算机采用大端方式，按字节编址。某指令中操作数的机器数为 1234 FF00H，该操作数采用基址寻址方式，形式地址（用补码表示）为 FF12H，基址寄存器的内容为 F000 0000H， 则该操作数的 LSB（最低有效字节）所在的地址是()A.F000 FF12HB.F000 FF15HC.EFFF FF12HD.EFFF FF15H解：由题中给出形式地址由补码表示为FF12H(1111 1111 0001 0010B)，所以由对补码求补可得原码为1000 0000 1110 1110B 可知其真值为一个负数将符号位提出后为000 0000 1110 1110B 转换为16进制可得 0000(补0)0000 1110 1110B =&gt; 00EEH 加上符号位后为 -00EEH由操作数采用基址寻址可知 EA = (BR) + A = 即 F000 0000H - 0000 00EE</code></pre><h5 id="shu-ju-an-bian-jie-dui-qi-fang-shi-cun-chu">数据按“边界对齐”方式存储</h5><p>假设存储字长为 32 位，可按字节、半字和字寻址。对于机器字长为 32 位的计算机，数据以边界对齐方式存放，半字地址一定是 2 的整数倍，字地址一定是 4 的整数倍,这样无论所取的数据是字节、半字还是字，均可一次放存取出。所存储的数据不满足上述要求时，通过填充空白字节使其符合要求。这样虽然浪费了一些存储空间，但可提高取指令和取数的速度。</p><p>数据不按边界对齐方式存储时，可以充分利用存储空间，但半字长或字长的指令可能会存储在两个存储字中，此时需要两次访存，并且对高低字节的位置进行调整、连接之后才能得到所要的指令或数据，从而影响了指令的执行效率。</p><p>例如，“字节 1、字节 2、字节 3、半字 1、半字 2、半字 3、字 1”的数据按序存放在存储器中，按边界对齐方式和不对齐方式存放时，格式分别如图 2.10 和图 2.11 所示。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210706152754.png" alt="img"></p><p>边界对齐方式相对边界不对齐方式是一种空间换时间的思想。RISC 如 ARM 采用边界对齐方式，而 CISC 如 x86 对齐和不对齐都支持。因为对齐方式取指令时间相同，因此能适应指令流水。</p><h2 id="c-yu-yan-xiang-guan">c 语言相关</h2><h4 id="ji-ben-shu-ju-lei-xing-suo-zhan-de-zi-jie-shu">基本数据类型所占的字节数</h4><table><thead><tr><th>数据类型</th><th>32 位环境</th><th>64 位环境</th><th>16 位环境</th></tr></thead><tbody><tr><td>char</td><td>8 位</td><td>8 位</td><td>8 位</td></tr><tr><td>unsigned char</td><td>8 位</td><td>8 位</td><td>8 位</td></tr><tr><td>short</td><td>16 位</td><td>16 位</td><td>16 位</td></tr><tr><td>unsigned short</td><td>16 位</td><td>16 位</td><td>16 位</td></tr><tr><td>int</td><td>32 位</td><td>32 位</td><td>16 位</td></tr><tr><td>unsigned int</td><td>32 位</td><td>32 位</td><td>16 位</td></tr><tr><td>long</td><td>32 位</td><td>64 位</td><td>32 位</td></tr><tr><td>unsigned long</td><td>32 位</td><td>64 位</td><td>32 位</td></tr><tr><td>long long</td><td>64 位</td><td>64 位</td><td>32 位</td></tr><tr><td>unsigned long long</td><td>64 位</td><td>64 位</td><td>32 位</td></tr><tr><td>float</td><td>32 位</td><td>32 位</td><td>32 位</td></tr><tr><td>double</td><td>64 位</td><td>64 位</td><td>32 位</td></tr><tr><td>long double</td><td>96 位</td><td>128 位</td><td>80 位</td></tr></tbody></table><blockquote><p>sizeof(数据类型)会返回字节数 例如 sizeof(double) → 8</p></blockquote><p>2<sup>8</sup> = 256</p><p>2<sup>16</sup> = 65536</p><p>2<sup>32</sup> = 4294967296</p><p>2<sup>64</sup> = 18446744073709551616</p><pre><code class="language-CSS">【2018统考真题】按字节编址的计算机中，某 double 型数组 A 的首地址为 2000H，使用变址寻址和循环结构访问数组 A，保存数组下标的变址寄存器初值为 0，每次循环取一个数组元素，其偏移地址为变址值乘以 sizeof(double)，取完后变址寄存器内容自动加 1。若某次循环所取元素的地址2100H，则进入该次循环时变址寄存器的内容是()A.25B.32C.64D.100sizeof(double) = 82000H + 8*i = 2100H8*i = 100HH表示该数为16进制，所以100H = 2^8 = 256i = 32答案选B</code></pre><h1 id="cun-chu-xi-tong">存储系统</h1><h2 id="cun-chu-qi-gai-shu">存储器概述</h2><h3 id="cun-chu-qi-de-fen-lei">存储器的分类</h3><p><strong>按在计算机中的层次进行分类</strong></p><ul class="lvl-0"><li class="lvl-2"><p>主存</p></li><li class="lvl-2"><p>辅存</p></li><li class="lvl-2"><p>高速缓冲寄存器(cache)</p></li></ul><p><strong>按存储介质分类</strong></p><ul class="lvl-0"><li class="lvl-2"><p>磁表面存储器(磁盘、磁带)</p></li><li class="lvl-2"><p>磁芯存储器</p></li><li class="lvl-2"><p>半导体存储器(MOS 型存储器、双极型存储器)</p></li><li class="lvl-2"><p>光盘存储器(光盘)</p></li></ul><p><strong>按存取方式分类</strong></p><ul class="lvl-0"><li class="lvl-2"><p>随机存储器(RAM)。存储器的任何一个存储单元都可以随机存取,而且存取时间与存储单元的物理位置无关。其优点是读写方便,使用灵活,主要用于主存或者高速缓冲寄存器。RAM 又分<code>静态RAM</code>和<code>动态RAM</code></p></li><li class="lvl-2"><p>只读存储器(ROM)。存储器的内容只能随机读出而不能写入。信息一旦写入存储器就固定不变,即使断电,内容也不会丢失。因此,通常用它来存放固定不变的程序、常数和汉字字库等</p></li></ul><blockquote><p>ROM 和 RAM 的存取方式均为随机存取</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>串行访问存储器。对存取单元进行读写操作时,需按其物理位置的先后顺序寻址,包括<code>顺序存取存储器</code>(磁带 📼),与<code>直接存取存储器</code>(如磁盘 💾、光盘 💿)</p></li></ul><blockquote><p>顺序存储只能按照某种顺序存取,直接存取介于随机存取和顺序存取之间</p></blockquote><p><strong>按信息的可保存性分类</strong></p><ul class="lvl-0"><li class="lvl-2"><p>易失性存储器:断电后,存储信息即消失的存储器,如 RAM</p></li><li class="lvl-2"><p>非易失性存储器:断电后信息仍然保留的存储器</p></li></ul><blockquote><p>🙋‍♂️ 破坏性读出:被读单元原存储信息被破坏</p><p>非破坏性性读出:被读单元原存储信息不被破坏</p><p>具有破坏性读出性能的存储器,每次读出操作后,都必须有再生操作,以便恢复被破坏的信息</p></blockquote><h3 id="cun-chu-qi-de-xing-neng-zhi-biao">存储器的性能指标</h3><h4 id="cun-chu-rong-liang">存储容量</h4><p>存储容量 = 存储字数 × 存储字长 (字数表示存储器的地址空间大小,字长表示一次存取操作的数据量)</p><h4 id="dan-wei-cheng-ben">单位成本</h4><p>每位价格 = 总成本/总容量</p><h4 id="cun-chu-su-du">存储速度</h4><p>存储速度: 数据传输率 = 数据的宽度/存储周期</p><ul class="lvl-0"><li class="lvl-2"><p>存取时间(T<sub>a</sub>):存取时间是指从启动一次存储器操作到完成该操作所经历的时间,分为读取时间和写入时间</p></li><li class="lvl-2"><p>存取周期(T<sub>m</sub>):又称读写周期或访问周期,它是指存储器进行一次完整的读写操作所需的全部时间,即连续两次独立访问存储器操作(读或写操作)之间所需的最小时间间隔</p></li><li class="lvl-2"><p>主存带宽(B<sub>m</sub>):又称数据传输率,表示每秒从主存进出信息的最大数量,单位为字每秒、字节每秒(B/s)或位每秒(b/s)</p></li></ul><blockquote><p>🙋‍♂️ 存储周期通常大于存取时间,因为上面介绍的破坏性读出的机制,存储器需要在信息读出后花费时间来进行再生</p></blockquote><h3 id="duo-ceng-ci-de-cun-chu-xi-tong">多层次的存储系统</h3><p>基本知识点两个图总结完事:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AD%98%E5%82%A8.svg" alt="存储"></p><p>上一级作为低一层存储器的高速缓存,上一层的内容是下一层部分内容的副本</p><h2 id="zhu-cun-chu-qi-mm">主存储器(MM)</h2><p>主存储器由 DRAM 实现,靠处理器的那一层(Cache)则由 SRAM 实现,他们都属于易失性存储器</p><h3 id="sram-he-dram">SRAM 和 DRAM</h3><p>通常把存放一个二进制位的物理器件称为<code>存储元</code>,它是存储器最基本的构件。地址码相同的多个<code>存储元</code>构成一个<code>存储单元</code>。若干<code>存储单元</code>的集合构成<code>存储体</code></p><h4 id="sram">SRAM</h4><p>静态随机存储器(SRAM)的存储元是用<code>双稳态触发器(六晶体管MOS)</code>记忆信息的,因此即使信息被读出后,它仍然保持其状态而不需要再生(<strong>非破坏性读出</strong>)</p><p>SRAM 存储速度快,但集成度低,功耗大,价格昂贵,一般用于高速缓冲存储器</p><h4 id="dram">DRAM</h4><p>动态随机存储器(DRAM)利用存储元电路中的<code>栅极电容</code>上的电荷进行存储信息的,DRAM 的基本存储元通常只使用一个晶体管,所以它比 SRAM 的密度要高得多。相对于 SRAM,DRAM 具有容易集成、位价低、容量大和功耗低等优点,但 DRAM 存取速度比 SRAM 的慢,一般用于大容量主存系统</p><p>DRAM 电容上的电荷一般只能维持 1~2ms,因此即使电源不断电,信息也会自动消失。为此,每个一段时间必须刷新,通常取 2ms,称为<code>刷新周期</code>。常用的刷新方式有 3 种</p><ol><li class="lvl-3"><p><strong>集中刷新</strong>:指在一个刷新周期内,利用好一段固定的时间,依次对存储器所有行进行逐一再生,在此期间停止对存储器的读写操作,称为<code>死时间</code>,又称<code>访存死区</code>。优点是读写操作时不受刷新工作的影响;缺点是在集中刷新期间(死区)不能访问存储器。</p></li><li class="lvl-3"><p><strong>分散刷新</strong>:把对每行的刷新分散到各个工作周期中。这样一个存储器的系统工作周期分为两部分,前半部分用于正常读、写或保持,后半部分用于刷新,优点是没有了死区,缺点是加长了系统的存取周期,降低了整机速度</p></li><li class="lvl-3"><p><strong>异步刷新</strong>:是前两种方法的结合。将刷新周期除以行数,得到两次刷新操作之间的时间间隔 t,利用逻辑电路每隔时间 t 产生一次刷新请求,这样可以避免 CPU 连续等待过长的时间,减少了刷新次数</p></li></ol><h4 id="cun-chu-qi-xin-pian-de-nei-bu-jie-gou">存储器芯片的内部结构</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AD%98%E5%82%A8%E5%99%A8%E8%8A%AF%E7%89%87.svg" alt="存储器芯片"></p><p>DRAM 采用<code>分时复用</code>的技术,当其选择存储元时,不是由上图 X(A<sub>0</sub>~A<sub>5</sub>)Y(A<sub>6</sub>~A<sub>11</sub>)直接得出,而是所有地址线(A<sub>0</sub>~A<sub>11</sub>)作为行/列,分两次输入,所以相同地址线数下 DRAM 容量很大但是速度没有 SRAM 快</p><h3 id="zhi-du-cun-chu-qi">只读存储器</h3><p><strong>制度存储器 ROM 的特点</strong>:</p><ol><li class="lvl-3"><p>结构简单,所以密度比可读写存储器的高</p></li><li class="lvl-3"><p>具有非易失性,所以可靠性高</p></li></ol><p><strong>ROM 的类型</strong>:</p><ul class="lvl-0"><li class="lvl-2"><p><strong>掩模式只读存储器(MROM)</strong>:由半导体制造厂在芯片的制造过程中写入,任何人无法改变其内容,优点:可靠性高,集成度高,价格便宜;缺点是灵活性差</p></li><li class="lvl-2"><p><strong>一次可编程只读存储器(PROM)</strong>:允许用户利用专门的设备(编程器)写入自己的程序,一旦写入,无法改变</p></li><li class="lvl-2"><p><strong>可擦除可编程只读存储器(EPROM)</strong>:光可擦除 E<sup>2</sup>PROM(电擦除) 允许用户对编程器写入的信息重复改写,但是改写速度慢,改写次数有限</p></li><li class="lvl-2"><p><strong>闪存(Flash 存储器)</strong></p></li><li class="lvl-2"><p><strong>固态硬盘(SSD)</strong></p></li></ul><h3 id="duo-mo-kuai-cun-chu-qi">多模块存储器</h3><h4 id="dan-ti-duo-zi-cun-chu-qi">单体多字存储器</h4><p>存储器中只有一个存储体,每个存储单元存储 m 个字,总线宽度也为 m 个字。一次并行读出 m 个字,地址必须顺序排列并处于同一存储器</p><h4 id="strong-duo-ti-bing-xing-cun-chu-qi-strong"><strong>多体并行存储器</strong></h4><h5 id="gao-wei-jiao-cha-bian-zhi-shun-xu-fang-shi">高位交叉编址(顺序方式)</h5><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%88%B6.svg" alt="高位交叉编制"></p><p>高位是存储体体号(M<sub>0</sub>~M<sub>3</sub> =&gt; 0~3),低位是体内地址,访问一串连续的主存地址时,总是先在一个体内访问完后,再转到下一个模块进行访问,所以其本质上还是顺序存储器,存取方式是串行存取,不能提高存储器的吞吐率</p><h5 id="di-wei-jiao-cha-bian-zhi-jiao-cha-fang-shi">地位交叉编址(交叉方式)</h5><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80.svg" alt="低位交叉编址"></p><p>低位地址为体号,高位为体内地址,由十进制内存地址来确定其存储体号可以使用 <code>体号 = 内存地址 mod 模块数</code>来确定体号</p><p>CPU 同时访问四个模块，由存储器控制部件控制它们分时使用数据总线进行信息传递。 这样，对每一个存储模块来说，从 CPU 给出访存命令直到读出信息仍然使用了一个存取周 期时间；而对 CPU 来说，它可以在一个存取周期内连续访问四个模块。各模块的读写过程 将重叠进行(流水线)，所以多模块交叉存储器是一种并行存储器结构。</p><p>下面进行定量分析。设模块字长等于数据总线宽度，又假设模块存取一个字的存储周期为<code> T</code>，总线传送周期为<code>τ</code>，存储器的交叉模块数为<code> m</code>，那么为了实现流水线方式存取，应当满足</p>\textit{T}\leqslant m\mathbb{\tau}<p>即成块传送可按 τ 间隔流水方式进行，也就是每经<code>τ</code>时间延迟后启动下一个模块。图 3.25 示出了 m=4 的流水线方式存取示意图。</p><p><code>m </code>的最小值 <strong>m<sub>min</sub>=T/τ</strong> 称为<code>交叉存取度</code>。<strong>交叉存储器要求其模块数必须大于或等于 m<sub>min</sub></strong>， 以保证启动某模块后经 <code>mτ </code>时间再次启动该模块时，它的上次存取操作已经完成。这样，连续读取 m 个字所需的时间为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>=</mo><mi>T</mi><mo>+</mo><mo>(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">t_1= T+(m-1) \tau </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mord mathit" style="margin-right:0.1132em;">τ</span></span></span></span></span></p><p>而顺序方式存储器连续读取 m 个字所需时间为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>=</mo><mi>m</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">t_2= mT </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit">m</span><span class="mord mathit" style="margin-right:0.13889em;">T</span></span></span></span></span></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230707165249740.png" alt="image-20230707165249740"></p><pre><code class="language-css">🌰设存储器容量为 32 字，字长 64 位，模块数 m=4，分别用顺序方式和交叉方式进行组织。存储周期 T=200ns，数据总线宽度为 64 位，总线传送周期τ=50ns。若连续读出 4 个字，问顺序存储器和交叉存储器的带宽各是多少?解 顺序存储器和交叉存储器连续读出 m=4 个字的信息总量都是q=64bit×4=256bit   顺序存储器和交叉存储器连续读出 4 个字所需的时间分别是t2=mT=4×200ns=800ns=8×10^–7st1=T+(m–1)τ=200ns+3×50ns=350ns=3.5×10^–7s   顺序存储器和交叉存储器的带宽分别是W2=q/t2=256bit÷(8×10–7)s=320Mbit/sW1=q/t1=256bit÷(3.5×10–7)s=730Mbit/s</code></pre><h3 id="zhu-cun-chu-qi-yu-cpu-de-lian-jie">主存储器与 CPU 的连接</h3><h4 id="lian-jie-yuan-li">连接原理</h4><p>主存储器与 CPU 的连接如下图所示 👇:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/CPU%E8%BF%9E%E6%8E%A5.svg" alt="CPU连接"></p><p><code>存储控制器</code>、<code>存储总线</code>和<code>内存条</code>之间的连接关系 👇:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E8%BF%9E%E6%8E%A5%E5%85%B3%E7%B3%BB.svg" alt="连接关系"></p><h4 id="zhu-cun-rong-liang-de-kuo-zhan">主存容量的扩展</h4><h5 id="wei-tuo-zhan-fa">位拓展法</h5><p>若给定的芯片的字数(地指数)符合要求，但位数较短，不满足设计要求的存储器字长， 则需要进行位扩展，让多片给定芯片并行工作。三组信号线中，地址线和控制线公用而数据线单独分开连接。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230707203146542.png" alt="image-20230707203146542"></p><h5 id="zi-tuo-zhan-fa">字拓展法</h5><p>若给定的芯片存储容量较小(字数少)，不满足设计要求的总存储容量，则需要进行字 扩展，让多片给定芯片分时工作。三组信号线中给定芯片的地址总线和数据总线公用，读 写控制信号线公用，由地址总线的高位译码产生片选信号，让各个芯片分时工作</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230707204129727.png" alt="image-20230707204129727"></p><blockquote><p>图中数据总线每个芯片组都是 D<sub>0</sub>~D<sub>7</sub></p></blockquote><blockquote><p><strong>片选有效性</strong>：和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mtext><mi mathvariant="normal">R</mi><mi mathvariant="normal">A</mi><mi mathvariant="normal">S</mi></mtext></mrow><mo stretchy="true">‾</mo></mover><mo>(</mo><mi>R</mi><mi>o</mi><mi>w</mi><mi>A</mi><mi>d</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>S</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>c</mi><mi>t</mi><mo>)</mo><mo separator="true">,</mo><mover accent="true"><mrow><mtext><mi mathvariant="normal">C</mi><mi mathvariant="normal">A</mi><mi mathvariant="normal">S</mi></mtext></mrow><mo stretchy="true">‾</mo></mover><mo>(</mo><mi>C</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>m</mi><mi>n</mi><mi>A</mi><mi>d</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>S</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>c</mi><mi>t</mi><mo>)</mo><mo separator="true">,</mo><mover accent="true"><mrow><mtext><mi mathvariant="normal">W</mi><mi mathvariant="normal">E</mi></mtext></mrow><mo stretchy="true">‾</mo></mover><mo>(</mo><mi>W</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi>E</mi><mi>n</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\overline{\text{RAS}}(Row Address Select) ,\overline{\text{CAS}}(Column Address Select) ,\overline{\text{WE}}(Write Enable) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8833300000000001em;"></span><span class="strut bottom" style="height:1.13333em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="text mord textstyle cramped"><span class="mord mathrm">R</span><span class="mord mathrm">A</span><span class="mord mathrm">S</span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="mord mathit">A</span><span class="mord mathit">d</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="text mord textstyle cramped"><span class="mord mathrm">C</span><span class="mord mathrm">A</span><span class="mord mathrm">S</span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">n</span><span class="mord mathit">A</span><span class="mord mathit">d</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="overline mord"><span class="vlist"><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="mord textstyle cramped"><span class="text mord textstyle cramped"><span class="mord mathrm" style="margin-right:0.01389em;">W</span><span class="mord mathrm">E</span></span></span></span><span style="top:-0.80333em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span><span class="reset-textstyle textstyle uncramped overline-line"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:1em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.13889em;">W</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span><span class="mclose">)</span></span></span></span>一样，<strong>都是低电平有效</strong>。</p></blockquote><h5 id="zi-wei-kuo-zhan">字位扩展</h5><p>若给定的芯片的字数和位数均不符合要求，则需要先进行<code>位扩展</code>，再进行<code>字扩展</code>。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230707175242165.png" alt="image-20230707175242165"></p><h4 id="cun-chu-qi-he-cpu-lian-jie">存储器和 CPU 连接</h4><p>以下是存储器与 CPU 连接时需要注意的原则:</p><ul class="lvl-0"><li class="lvl-2"><p><strong>地址线的连接</strong>:因为存储芯片容量不同,其地址线也不同,而 CPU 的地址线数往往比存储芯片地址线要更多,所以需要注意</p><ul class="lvl-2"><li class="lvl-4">将 CPU 地址线的低位与存储芯片的地址线相连,以选择芯片中的某一单元</li><li class="lvl-4">将 CPU 地址线的高位与译码器相连,以实现芯片(组)间的片选</li></ul></li><li class="lvl-2"><p><strong>数据线的连接</strong>:CPU 的数据线数与存储芯片的数据线数不一定相等,相等时可以直接相连;在不相等时必须对存储芯片扩位,使之与 CPU 数据线数相等</p></li></ul><h2 id="wai-bu-cun-chu-qi">外部存储器</h2><h3 id="ci-pan-cun-chu-qi">磁盘存储器</h3><p>优点:</p><ol><li class="lvl-3"><p>存储容量大,位价格低</p></li><li class="lvl-3"><p>记录介质可重复使用</p></li><li class="lvl-3"><p>记录信息可长时间保存不丢失,甚至可以脱机存档</p></li><li class="lvl-3"><p>非破坏性读出,读出时不需要再生</p></li></ol><p>缺点:</p><p>存取速度慢,机械结构复杂,对工作环境要求较高</p><h4 id="ci-pan-she-bei-de-zu-cheng">磁盘设备的组成</h4><h5 id="ying-pan-cun-chu-qi-de-zu-cheng">硬盘存储器的组成</h5><ul class="lvl-0"><li class="lvl-2"><p>磁盘驱动器。核心部件是磁头组件和盘片组件</p></li><li class="lvl-2"><p>磁盘控制器。硬盘存储器和主机的接口,主流的标准有 IDE、SCSI、SATA 等</p></li></ul><h5 id="cun-chu-qu-yu">存储区域</h5><p>以下是磁盘存储器的主要结构示意图 👇:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E7%A3%81%E7%9B%98-1688740119293-28.svg" alt="磁盘"></p><blockquote><p>扇区是磁盘读写的最小单位,即磁盘按块存取</p><p>由于扇区的 Size 比较小，数目众多时寻址时比较困难，所以在操作系统中就将相邻的扇区组合在一起，形成一个<code>簇</code>，再对块进行整体的操作。</p><p><a href><strong>如何将一个内存中的簇号来转化为磁盘上的物理地址?</strong></a></p></blockquote><h5 id="ci-pan-de-xing-neng-zhi-biao">磁盘的性能指标</h5><ol><li class="lvl-3"><p><strong>记录密度</strong>:记录密度是指盘片单位面积上记录的二进制信息量,通常以<code>道密度</code>,<code>位密度</code>和<code>面密度</code>表示。</p><ol><li class="lvl-6"><code>道密度</code>是沿磁盘半径方向单位长度上的磁道数</li><li class="lvl-6"><code>位密度</code>是磁道单位长度上能记录的二进制代码位数</li><li class="lvl-6"><code>面密度</code>是道密度和位密度的乘积</li></ol></li><li class="lvl-3"><p><strong>磁盘容量</strong>:</p><ol><li class="lvl-6"><code>非格式化容量</code>:指磁记录表面可利用的磁化单元总数,由道密度和位密度计算而来</li><li class="lvl-6"><code>格式化容量</code>:按照某种特定记录格式所能存储的信息总量</li></ol><p><em>格式化后的容量比非格式化容量要小</em></p></li><li class="lvl-3"><p><strong>平均存取时间</strong>。平均存取时间由三部分构成:</p><ol><li class="lvl-6"><code>寻道时间</code>:磁头移动到目的磁道的时间</li><li class="lvl-6"><code>旋转延迟时间</code>:磁头定位道要读写的扇区的时间</li><li class="lvl-6"><code>传输时间</code>:传输数据所花费的时间</li></ol></li><li class="lvl-3"><p><strong>数据传输率</strong>:从盘存储器在单位时间向主机传送数据的字节数</p><p>假设磁盘转速位 r 转/s,每条磁道容量位 N 字节,则数据传输率为: D<sub>r</sub> = rN</p></li></ol><h5 id="ci-pan-di-zhi">磁盘地址</h5><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%9C%B0%E5%9D%80.svg" alt="地址"></p><h5 id="ci-pan-zhen-lie">磁盘阵列</h5><p>RAID(独立冗余磁盘阵列(又称廉价冗余磁盘阵列))是指将多个独立的物理磁盘罪成一个独立的逻辑盘,数据在多个物理盘上分割交叉存储、并行访问,具有更好的存储性能、可靠性和安全性。</p><ul class="lvl-0"><li class="lvl-2"><p>RAID0:无冗余无校验的磁盘阵列(将数据块交叉存放在不同的物理磁盘的扇区中,几个磁盘交叉并行读写)</p></li><li class="lvl-2"><p>RAID1:镜像磁盘阵列(一个使用,一个备份)</p></li><li class="lvl-2"><p>RAID2:采用纠错的海明码的磁盘阵列</p></li><li class="lvl-2"><p>RAID3:位交叉奇偶校验的磁盘阵列</p></li><li class="lvl-2"><p>RAID4:块交叉奇偶校验的磁盘阵列</p></li><li class="lvl-2"><p>RAID5:无独立校验的奇偶校验磁盘阵列</p></li></ul><blockquote><p>还有 RAID01 和 RAID10</p></blockquote><h4 id="gu-tai-ying-pan">固态硬盘</h4><p>是一种基于闪存技术的存储器,与 U 盘并没有本质上的差别,只是容量更大,存取性能更好</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/SSD-1688781567110-32.svg" alt="SSD"></p><p>一个闪存由 B 块组成,每块由 P 页组成。数据是以页为单位读写的。只有在一页所属的块整个被擦除后,才能写这一页。某个块经历了约 10 万次的擦写后,就会损坏,无法使用(坏块),所以闪存翻译层中有一个平均磨损逻辑试图通过将擦除平均分布在所有块上来最大化每个块的寿命</p><p>闪存的随机写很慢,因为首先,擦除块就很慢(1ms 级),比访问页要高一个数量级,其次若要修改一个块中包含数据的一个页,那么就要把这个块中所有含有数据的页复制到一个新(被擦除过的)块中,才能进行对那页的写</p><h2 id="gao-su-huan-chong-chu-cun-qi">高速缓冲储存器</h2><p><strong>程序的局部性原理</strong>:</p><ul class="lvl-0"><li class="lvl-2"><p><mark>空间局部性</mark>:在最近的未来要用的的信息,很可能与正在使用的信息在存储空间上是邻近的,因为指令通常是顺序存放,顺序执行的,数据一本是以向量,数组等形式簇聚地储存在一起的</p></li><li class="lvl-2"><p><mark>时间局部性</mark>:最近未来要使用到的信息,很可能是现在正在使用的信息,因为程序中存在循环</p></li></ul><p>基于上述的程序的局部性原理,人们制造出了 Cache(高速缓冲寄存器)</p><h3 id="cache-de-ji-ben-gong-zuo-yuan-li">Cache 的基本工作原理</h3><p>Cache 是介于 CPU 和主存 之间的小容量存储器，但存取速度比主存快，容量远小于主存。cache 能高速地向 CPU 提供指令和数据，从而加快了程序的执行速 度。从功能上看，它是主存的缓冲存储器，由高速的 SRAM 组成。为追求高速，包括管理 在内的全部功能由硬件实现，因而对程序员是透明的。</p><p>为便于 Cache 和主存交换信息,Cache 和主存都被划分为相等的块,<code>Cache块</code>又称为<code>Cache行</code>,所以 Cache 中的块数要远小于主存中的块数,它仅仅保存主存中最活跃的若干块的副本。</p><p>CPU 与 Cache 之间的数据交换以<code>字</code>为单位,而 Cache 与主存之间的数据交换则以<code>Cache块</code>为单位</p><p>问题也随之而来:</p><ul class="lvl-0"><li class="lvl-2"><p>数据查找。如何快速判断数据是否在 Cache 中</p></li><li class="lvl-2"><p>地址映射。主存块如何存放在 Cache 中,如何将主存地址转换为 Cache 地址</p></li><li class="lvl-2"><p>替换策略。Cache 满了以后,使用何种策略对 Cache 块进行替换或淘汰</p></li><li class="lvl-2"><p>写入策略。如何既保证主存块和 Cache 块的数据一致性,又尽量提升效率</p></li></ul><h3 id="cache-he-zhu-cun-de-ying-she-fang-shi">Cache 和主存的映射方式</h3><p>地址映射方式有全相联方式、直接方式和组相联方式三种，下面分别介绍。</p><h4 id="quan-xiang-lian-ying-she">全相联映射</h4><p>我的理解是主存中的任意一个块,可以映射到 Cache 中的任意一行(块)中</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230708140308405.png" alt="image-20230708140308405"></p><p>CPU 访存指令指定了一个主存地址，为了 快速检索，指令中的块号与 cache 中所有行的标记同时在比较器中进行比较。如果块号命中， 则按字地址从 cache 中读取一个字；如果块号未命中，则按主存地址从主存中读取这个字。 在全相联 cache 中，全部标记用一个相联存储器来实现，全部数据存储用一个普通 RAM 来 实现。全相联方式的主要缺点是高速比较器电路难于设计和实现，因此只适合于小容量 cache 采用。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230708170005023.png" alt="image-20230708170005023"></p><h4 id="zhi-jie-ying-she">直接映射</h4><p>直接映射方式也是一种多对一的映射关系，但一个主存块只能拷贝到 cache 的一个特定 行位置上去。cache 的行号 i 和主存的块号 j 有如下函数关系：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mi>j</mi><mspace width="1em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="1em"></mspace><mi>m</mi></mrow><annotation encoding="application/x-tex">i=j\quad\mathrm{mod}\quad m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit">i</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mord mspace quad"></span><span class="mord displaystyle textstyle uncramped"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span><span class="mord mspace quad"></span><span class="mord mathit">m</span></span></span></span></span></p><p>式中，m 为 cache 中的总行数。显然，主存的第 0 块，第 m 块，第 2m 块，…，第 2s –m 块 只能映射到 cache 的第 0 行；而主存的第 1 块，第 m+1 块，第 2m+1 块，…，第 2s –m+1 块</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230708170627625.png" alt="image-20230708170627625"></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230708170722759.png" alt="image-20230708170722759"></p><p>直接映射方式的优点是硬件简单，成本低，地址变换速度快。缺点是每个主存块只有 一个固定的行位置可存放。如果连续访问块号相距 m 整数倍的两个块，因两个块映射到同 一 cache 行时，就会发生冲突。发生冲突时就要将原先存入的行换出去，但很可能过一段时 间又要换入。频繁的置换会使 cache 效率下降。因此直接映射方式适合于需要大容量 cache 的场合，更多的行数可以减小冲突的机会。</p><h4 id="zu-xiang-lian-ying-she">组相联映射</h4><p>我的理解为组内全相联映射,组间直接映射</p><p>这种方式将 cache 分成 u 组，每组 v 行。主存块存放到哪个组是固定的，取决于主存块 在主存区中是第几块。至于存到该组哪一行是灵活的，即有如下函数关系：</p>\begin{aligned}m&=u\times v\\\text{组号}\quad q&=j\quad\mathrm{mod}\quad u\end{aligned}<p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230708171256557.png" alt="image-20230708171256557"></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230708171327757.png" alt="image-20230708171327757"></p><p>组相联映射方式中的<code>每组行数 v</code> 一般取值较小，典型值是 2、4、8、16。这种规模的<code> v 路</code>比较器容易设计和实现。而块在组中的排放又有一定的灵活性，使冲突减少。为强调比 较器的规模和存放的灵活程度，常称之为 <code>v 路组相联 cache</code>。</p><p>v=4 路组相联的内存地址格式如下所示:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230708172232560.png" alt="image-20230708172232560"></p><h3 id="cache-zhong-zhu-cun-kuai-de-ti-huan-suan-fa">Cache 中主存块的替换算法</h3><ol><li class="lvl-3"><p><strong>随机算法</strong>(RAND)</p></li></ol><p>字面意思</p><ol start="2"><li class="lvl-3"><p><strong>先进先出算法</strong>(FIFO)</p></li></ol><p>字面意思</p><ol start="3"><li class="lvl-3"><p><strong>近期最少使用算法</strong>(LRU)</p></li></ol><p>LRU 算法将近期内长久未被访问过的行换出。为此，每行也设置一个计数器，但它们 是 cache 每命中一次，命中行计数器清零，其他各行计数器增 1。当需要替换时，比较各特 定行的计数值，将计数值最大的行换出。这种算法保护了刚复制到 cache 中的新数据行，符 合 cache 工作原理，因而使 cache 有较高的命中率。</p><ol start="4"><li class="lvl-3"><p><strong>最不经常使用算法</strong>(LFU):</p></li></ol><p>LFU 算法认为应将一段时间内被访问次数最少的那行数据换出。为此，每行设置一个 计数器。新行调入后从 0 开始计数，每访问一次，被访行的计数器增 1。当需要替换时，对 这些特定行的计数值进行比较，将计数值最小的行换出，同时将这些特定行的计数器都清 零。这种算法将计数周期限定在两次替换之间的间隔时间内，因而不能严格反映近期访问情况。</p><p><a href>具体的复习留到操作系统的该知识点</a></p><h3 id="cache-xie-ce-lue">Cache 写策略</h3><p>因为 Cache 中的内容是主存块中的副本,所以当 CPU 对 Cache 中的内容进行更新时,就需要用写策略使 Cache 内容和主存内容保持一致</p><p>对于<code>Cache写命中</code>有两种处理方法</p><ul class="lvl-0"><li class="lvl-2"><p><strong>全写法</strong>:CPU 对 Cache 写命中时,需要把数据同时下写入 Cache 和主存的对应块中</p></li></ul><p>缺点是增加了访存次数,降低了 Cache 的效率</p><p>为了减少(缓解)直接写入主存的时间消耗在主存和 Cache 之间加一个<code>写缓冲器</code>(逻辑上为 FIFO 队列),写缓冲虽然可以解决速度不匹配的问题,但若出现频繁写时,会使写缓冲饱和溢出(Cache 和主存速度不匹配)</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%86%99%E7%BC%93%E5%86%B2.svg" alt="写缓冲"></p><p>增加 L2cache 可以有效避免写缓冲饱和溢出问题</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%86%99%E7%BC%93%E5%86%B2%E6%94%B9%E8%BF%9B-1688820281371-3.svg" alt="写缓冲改进"></p><ul class="lvl-0"><li class="lvl-2"><p><strong>回写法</strong>:每个 Cache 行设置一个修改位(脏位),CPU 对 Cache 写命中时,只需要把数据写入 Cache 中的某一个块中,当这一个块需要被替换时,检查其脏位是否为 1,为 1 则说明被修改过,将其写回内存,反之,无须写回内存</p></li></ul><p>对于<code>Cache写不命中</code>也有两种处理方法</p><ul class="lvl-0"><li class="lvl-2"><p><strong>写分配法</strong>:CPU 将块写入主存中,Cache 从主存中将该块调入 Cache 中</p></li><li class="lvl-2"><p><strong>非写分配法</strong>:只写主存,不调块</p></li></ul><p>非写分配法——全写法 写分配法——回写法 通常是这两个组合</p><h2 id="xu-ni-cun-chu-qi">虚拟存储器</h2><p>主存和辅存共同构成了虚拟存储器,二者在硬件和软件系统共同的管理下工作,对于程序员来而言,虚拟存储器是透明的。虚拟存储器具有主存的速度和辅存的容量</p><p>用户编制程序时使用的地址称为<code>虚地址</code>或<code>逻辑地址</code>，其对应的存储空间称为<code>虚存空间</code>或<code>逻辑地址空间</code>；而计算机物理内存的访问地址则称为<code>实地址</code>或<code>物理地址</code>，其对应的存储空间称为<code>物理存储空间</code>或<code>主存空间</code>。程序进行虚地址到实地址转换的过程称为程序的再定位</p><p>虚存机制也要解决一些关键问题。</p><ol><li class="lvl-3"><p>调度问题 决定哪些程序和数据应被调入主存。</p></li><li class="lvl-3"><p>地址映射问题 在访问主存时把虚地址变为主存物理地址(这一过程称为内地址变 换)；在访问辅存时把虚地址变成辅存的物理地址(这一过程称为外地址变换)，以便换页。 此外还要解决主存分配、存储保护与程序再定位等问题。</p></li><li class="lvl-3"><p>替换问题 决定哪些程序和数据应被调出主存。</p></li><li class="lvl-3"><p>更新问题 确保主存与辅存的一致性。</p></li></ol><h3 id="ye-shi-xu-ni-cun-chu-qi">页式虚拟存储器</h3><p>页式虚拟存储器以<code>页</code>为基本单位。把虚拟空间和主存空间都划分成一个一个大小相等的<code>页</code>,主存的<code>页</code>被称为<code>实页</code>、<code>页框</code>,虚存的页被称为<code>虚页</code>。我们把虚拟地址分为两个字段,<code>虚页号</code>和<code>页内地址</code>。虚拟地址到物理地址的转换是通过<code>页表</code>来实现的。页表是一张存放虚存号和实存号的对照表,它记录程序的虚页调入主存时被安排在主存中的位置。页表一般长久地保存在内存中。</p><h3 id="ye-biao">页表</h3><p>页式虚拟存储器以页为基本单位,虚拟空间与主存空间都被划分为相同的大小</p><p>以下为一个页表式例:</p><ul class="lvl-0"><li class="lvl-2"><p><code>有效位</code>也称<em>装入位</em>,用来表示对应页面是否在主存,若为 1 则表示该虚拟页已从外存调入主存,此时页表项存放该页的物理页号;(内页表)若为 0,则表示没有调用主存,此时页表项可以存放该页的磁盘地址(外页表)</p></li><li class="lvl-2"><p><code>脏位</code>也称<em>修改位</em>,用来表示页面是否被修改过,虚存机制中采用回写策略,利用脏位可判断替换时是否需要写回磁盘</p></li><li class="lvl-2"><p><code>引用位</code>也称<em>使用位</em>,用来配合替换策略进行设置,例如是否实现最先调入(FIFO 位)或最近最少用(LRU 位)策略等</p></li></ul><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E4%B8%BB%E5%AD%98%E4%B8%AD%E7%9A%84%E9%A1%B5.svg" alt="主存中的页"></p><p>CPU 执行指令时将虚拟地址转换为主存物理地址。页表基址寄存器存放进程(每一个进程都有一个页表/段表)的页表首地址,然后根据虚拟地址高位部分的虚拟页号找到对应的页表项,若装入位为 1,则取出物理页号,和虚拟地址低位部分的页内地址拼接,形成实际物理地址;若装入位为 0,则说明缺页,需要操作系统进行缺页处理。</p><p>以下页式虚拟存储器的地址变化过程示意图:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230709104250288.png" alt="image-20230709104250288"></p><p>每个进程所需的页数并不固定，所以页表的长度是可变的，因此通常的实现方法是把 页表的基地址保存在寄存器中，而页表本身则放在主存中。由于虚存地址空间可以很大， 因而每个进程的页表有可能非常长。例如，如果一个进程的虚地址空间为 2GB，每页的大 小为 512B，则总的虚页数为 231/29 =222。 为了节省页表本身占用的主存空间，一些系统把页表安排存储在虚存空间，因而页表本身也要进行分页。当一个进程运行时，其页表中一部分在主存中，另一部分则在辅存中 保存。 另一些系统采用二级页表结构。每个进程有一个页目录表，其中的每个表项指向一个 页表。因此，若页目录表的长度(表项数)是 m，每个页表的最大长度(表项数)为 n，则一个 进程最多可以有 m×n 个页</p><p>优点是,页面的长度固定,页面的长度固定,页表简单,调入方便。缺点是,由于程序不可能正好是页面的整数倍,最后一页的零头将无法利用而造成浪费,并且页不是逻辑上独立的实体,所以处理、保护和共享都不及段式虚拟存储器方便</p><h3 id="kuai-biao-tlb">快表(TLB)</h3><p>地址变换高速缓存(Translation Look-aside Buffer,TLB)</p><p>由于页表通常在主存中，因而即使逻辑页已经在主存中，也至少要访问两次物理存储 器才能实现一次访存，这将使虚拟存储器的存取时间加倍。为了避免对主存访问次数的增 多，可以对页表本身实行二级缓存，把页表中最活跃的部分存放在高速存储器中。这个专用于页表缓存的高速存储部件通常称为转换后援缓冲器(TLB)，又称为快表。而保存在主存中的完整页表则称为慢表。快表的作用是加快地址变换 👇</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230709164335824.png" alt="image-20230709164335824"></p><p><strong>TLB、页表、Cache、主存之间的访问关系</strong></p><p>简而言之，TLB 是地址缓存，那个 cache 是数据缓存。那么其实就分为了三个情况：</p><ol><li class="lvl-3"><p>TLB 缺失，要去页表中找地址</p></li><li class="lvl-3"><p>cache 缺失，要向内存要数据</p></li><li class="lvl-3"><p>缺页，要向磁盘要数据，同时更新 TLB 和 页表</p></li></ol><p>先查找 TLB，如果缺失，那么查找页表，还缺就缺页了。如果查找 TLB 命中，那么根据 TLB 获取物理地址，然后查找数据 cache，就算普通的 cache 查找了。</p><p>以下是 TLB 虚拟存储器的 CPU 访存过程 👇:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/390f3c60-d634-4858-a257-f018e7e2e048.png" alt="390f3c60-d634-4858-a257-f018e7e2e048"></p><h3 id="duan-shi-xu-ni-cun-chu-qi">段式虚拟存储器</h3><p>段式存储器中的<code>段</code>是按照程序的逻辑结构划分的,各个<code>段</code>的长度因程序而异。把虚拟地址分为两个部分:<code>段号</code>和<code>段内地址</code>。虚拟地址到实地址的变换是通过<code>段表</code>来实现的。段表是程序逻辑段和在主存中存放位置的对照表。段表的每行记录与某个段对应的<code>段号</code>、<code>装入位(有效位)</code>、<code>段起点地址</code>和<code>段长</code>。由于段的长度可变,所以段表中要给出各段的起始位置与段的长度</p><p>CPU 根据虚拟地址访存时，首先根据段号与段表基地址拼接成对应的段表行，然后根据该段表行的装入位判断该段是否已调入主存(装入位为“1”，表示该段已调入主存；装入位为“0”，表示该段不在主存中)。已调入主存时，从段表读出该段在主存中的起始地址，与段内地址(偏移量)相加，得到对应的主存实地址。段式虚拟存储器的地址变换如下图所示:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230709205758778.png" alt="image-20230709205758778"></p><p>因为段的长度不固定，段式虚拟存储器也有一些缺点：</p><p>① 主存空间分配比较麻烦。</p><p>② 容易在段间留下许多外碎片，造成存储空间利用率降低。</p><p>③ 由于段长不一定是 2 的整数次幂，因而不能简单地像分页方式那样用虚地址和实地址的最低若干二进制位作为段内偏移量，并与段号进行直接拼接，必须用加法操作通过段起址与段内偏移量的求和运算求得 物理地址。因此，段式存储管理比页式存储管理方式需要更多的硬件支持。</p><p>优点:段的分界与程序的自然分界相对应,因而具有逻辑独立性,使得它易于编译、管理、修改和保护,也便于多道程序的共享</p><h3 id="duan-ye-shi-xu-ni-cun-chu-qi">段页式虚拟存储器</h3><p>把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页程序对主存的调入、调出仍以页为基本传送单位，这样的虚拟存储器称为段页式虚拟存像器。在段页式虚拟存储器中，每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。​ 虚地址分为<code>段号</code>、<code>段内页号</code>、<code>页内地址</code>三部分。CPU 根据虚地址访存时，首先根据段号有到段表地址：然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址；最后从页表中取出实页号，与页内地址拼接形成主存实地址。段页式虚拟存储器的优点是，兼具页式和段式虚拟存储器的优点，可以按段实现共享和像护。缺点是在地址变换过程中需要两次查表，系统开销较大。</p><h3 id="xu-ni-cun-chu-qi-yu-cache-de-bi-jiao">虚拟存储器与 Cache 的比较</h3><p>虚拟存储器与 Cache 既有很多相同之处，又有很多不同之处</p><p><strong>相同之处</strong></p><ol><li class="lvl-3"><p>最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度。</p></li><li class="lvl-3"><p>都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大。</p></li><li class="lvl-3"><p>都有地址的映射、替换算法、更新策略等问题。</p></li><li class="lvl-3"><p>依据程序的局部性原理应用“快速缓存的思想”，将活跃的数据放在相对高速的部件中。</p></li></ol><p><strong>不同之处</strong></p><ol><li class="lvl-3"><p>Cache 主要解决系统速度，而虚拟存储器却是为了解决主存容量。</p></li><li class="lvl-3"><p>Cache 全由硬件实现，是硬件存体器，对所有程序员透明；而虚拟存储器由 OS 和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明。</p></li><li class="lvl-3"><p>对于不命中性能影响，因为 CPU 的速度的为 Cache 的 10 倍，主存的速度为硬盘的 100 倍以上，因此虚拟存储器系统不命中时对系统性能影响更大。</p></li><li class="lvl-3"><p>CPU 与 Cache 和主存都建立了直接访问的通路.而辅存 CPU 没有直接通路。也就是说在 Cache 不命中时主存能和 CPU 直接通信,同时将数据调入 Cache;而虚拟存储器系统不命中时,只能先由硬盘调入主存，而不能直接和 CPU 通信。</p></li></ol><h1 id="zhi-ling-xi-tong">指令系统</h1><p><strong>指令就是计算机执行某种操作的命令。一台计算机所有的指令的集合构成该机的指令系统,也称指令集,指令系统是计算机的主要属性,位于硬件和软件交界面上</strong></p><h2 id="zhi-ling-de-ji-ben-xing-shi">指令的基本形式</h2><p><strong>基本专业词汇</strong>:</p><p>一条指令通常包括<code>操作码</code>和<code>地址码</code>字段两部分</p><table><thead><tr><th style="text-align:center">操作码字段</th><th style="text-align:center">地址码字段</th></tr></thead></table><p><code>操作码</code>指出指令中指令应该执行什么性质的操作以及具有何种功能。操作码是识别指令,了解指令功能及区分操作数地址的组成和使用方法等的关键信息。例如指出的是算数加运算还是算数减运算,是程序转移还是返回操作。</p><p><code>地址码</code>给出被操作的信息(指令或数据)的地址,包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序入口地址等</p><p><strong>指令的长度</strong>是指一条指令中所包含的二进制代码的位数,指令字长取决于<code>操作码长度</code>、<code>操作数地址码的长度</code>和<code>操作数地址的个数</code>。指令长度与机器字长没有固定的关系,它可以等于<a href="#字、字长、机器字长、指令字长、存储字长的区别和联系是什么?">机器字长</a>,也可以大于或小于机器字长。通常,把指令字长等于机器字长的指令称为<code>单字长指令</code>,指令长度等于半个机器字长的指令称为<code>半字长指令</code>,指令长度等与两个机器字长的指令称为<code>双字长指令</code></p><p>在一个指令系统中,若所有指令的长度都是相等的,则称为<code>定长指令字结构</code>。定长指令的执行速度快,控制简单。若各种指令的长度随功能而异,则称为<code>变长指令字结构</code>。然而,因为主存一般都是按<a href="#字、字长、机器字长、指令字长、存储字长的区别和联系是什么?">字节编址</a>的,所以指令字长多为字节的整数倍</p><p>根据指令中操作数地址码的数目不同,可将指令分为以下几种格式:</p><p><strong>零地址指令</strong></p><table><thead><tr><th style="text-align:center">OP</th></tr></thead></table><p>只给出操作码 OP,没有显式地址,这种指令有两种可能</p><ol><li class="lvl-3"><p>不需要操作数的指令,如空操作指令、停机指令、关中断指令等。</p></li><li class="lvl-3"><p>零地址的运算类指令仅用在堆栈计算机中。通常参与运算的两个操作数隐含地从栈顶和次栈顶弹出,再送到运算器进行运算,运算结构再隐含地压入堆栈</p></li></ol><p><strong>一地址指令</strong></p><table><thead><tr><th style="text-align:center">OP</th><th style="text-align:center">A<sub>1</sub></th></tr></thead></table><p>这种指令也有两种常见的形态,要根据操作码的含义确定究竟是哪种。</p><ol><li class="lvl-3"><p>只有目的操作数的单操作指令,按 A<sub>1</sub>的地址读取操作数,进行 OP 操作后,结果存回原地址(A<sub>1</sub>)</p></li></ol><p>指令含义:OP(A<sub>1</sub>) → A<sub>1</sub></p><p>如操作码的含义是加 1、减 1、求反、求补等</p><ol start="2"><li class="lvl-4"><p>隐含约定目的地址的双操作数指令,按指令地址 A<sub>1</sub>可读取源操作数,指令可隐含约定另外一个操作数由 ACC(累加器)提供,运算结果也将存放在 ACC 中</p></li></ol><p>指令含义:(ACC)OP(A<sub>1</sub>) → ACC</p><p><strong>二地址指令</strong></p><table><thead><tr><th style="text-align:center">OP</th><th style="text-align:center">A<sub>1</sub>(目的操作数地址)</th><th style="text-align:center">A<sub>2</sub>(源操作数地址)</th></tr></thead></table><p>指令含义: (A<sub>1</sub>)OP(A<sub>2</sub>) → A<sub>1</sub></p><p>其中目的操作数地址还用来保存此次的运算结果</p><p><strong>三地址指令</strong></p><table><thead><tr><th style="text-align:center">OP</th><th style="text-align:center">A<sub>1</sub></th><th style="text-align:center">A<sub>2</sub></th><th style="text-align:center">A<sub>3</sub>(结果)</th></tr></thead></table><p>指令含义: (A<sub>1</sub>)OP(A<sub>2</sub>) → A<sub>3</sub></p><p>若地址字段均为主存地址,则完成一条三地址需要 4 次访存(取指令 1 次,取两个操作数 2 次,存放结果 1 次)</p><p><strong>四地址指令</strong></p><table><thead><tr><th style="text-align:center">OP</th><th style="text-align:center">A<sub>1</sub></th><th style="text-align:center">A<sub>2</sub></th><th style="text-align:center">A<sub>3</sub>(结果)</th><th style="text-align:center">A<sub>4</sub>(下条需要执行的指令的地址)</th></tr></thead></table><p>设某等长指令字结构机器的指令长度为 16 位包括 4 位基本操作码字段和 三个 4 位地址字段:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230710175330239.png" alt="image-20230710175330239"></p><p>4 位基本操作码若全部用于三地址指令， 则只能安排 16 种三地址指令。通常一个指令系统中指令的地址码个数不一定相同，为了确保指令字长度尽可能统一，可以采用<strong>扩展操作码技术</strong>，向地址码字段扩展操作码的长度。如 表 4.2 所示，三地址指令的操作码占用 4 位基 本操作码编码空间的 0000 ～ 1110 共 24 –1=15 种组合，剩下一个编码 1111 用于把操作码扩 展到 A1 地址域，即从 4 位操作码扩展到 8 位。 二地址指令的操作码占用 8 位操作码编码空间 的 1111, 0000 ～ 1111, 1101 共 24 –2=14 种，剩 下两个编码 1111, 1110 和 1111, 1111 用于把操 作码扩展到 A2 地址域，即从 8 位操作码扩展 到 12 位。一地址指令的操作码占用 12 位操作 码编码空间的 1111, 1110, 0000 ～ 1111, 1111, 1110 共 25 –1=31 种编码，剩下一个编码 1111,1111,1111 用于把操作码扩展到 A3 地址域，即 从 12 位操作码扩展到 16 位。零地址指令的操作码占用 16 位操作码编码空间的 1111,1111,1111,0000 ～ 1111,1111,1111,1111 共 24 =16 种编码</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230710175459752.png" alt="image-20230710175459752"></p><p>设计拓展操作码指令格式时啊,必须注意以下两点:</p><ol><li class="lvl-3"><p>不允许短码是长码的前缀,即短操作码不能与长操作码前面部分的代码相同</p></li><li class="lvl-3"><p>各指令的操作码一定不能重复</p></li></ol><p>通常情况下,对使用频率较高的指令分配较短的操作码,对使用频率较低的指令分配较长的操作码,从而尽可能减少指令译码和分析的时间。</p><blockquote><p>🤔<strong>采用扩展操作码设计方案的目的是</strong>?：</p><p>保持指令字长度不变而增加指令的数量</p></blockquote><h2 id="zhi-ling-de-cao-zuo-lei-xing">指令的操作类型</h2><ol><li class="lvl-3"><p><strong>数据传送</strong></p></li></ol><p>传送指令通常有<code>寄存器之间的传送(MOV)</code>、<code>从内存单元读取数据到CPU寄存器(LOAD)</code>、<code>从CPU寄存器写数据到内存单元中是(STORE)</code>等。</p><ol start="2"><li class="lvl-3"><p><strong>算数和逻辑运算</strong></p></li></ol><p>这类指令主要有加(ADD)、减(SUB)、比较(CMP)、乘(MUL)、除(DIV)、加 1(INC)、减 1(DEC)、与(AND)、或(OR)、取反(NOT)、异或(XOR)等</p><ol start="3"><li class="lvl-3"><p><strong>移位操作</strong></p></li></ol><p>移位指令主要有算法移位、逻辑移位、循环移位</p><ol start="4"><li class="lvl-3"><p><strong>转移操作</strong></p></li></ol><p>转移指令主要有无条件转移(JMP)、条件转移(BRANCH)、调用(CALL)、返回(RET)、陷阱(TRAP)等。</p><p>无条件转移指令在任何情况下都执行转移操作</p><p>条件转移一般是某个标志位的值,或几个标志位的组合。</p><p>调用指令和转移指令的区别:执行调用指令时必须保存下一条指令的地址(返回地址),当程序执行结束时,根据返回地址返回到主程序继续执行;而转移指令则不返回执行。</p><ol start="5"><li class="lvl-3"><p><strong>输入输出操作</strong></p></li></ol><p>用于完成 CPU 与外部设备交换数据或传送控制命令及状态信息</p><h2 id="zhi-ling-de-xun-zhi-fang-shi">指令的寻址方式</h2><p>寻址方式是寻找指令或操作数有效地址的方式,即确定本条指令的数据地址及下一条待执行指令的地址的方法。寻址方式分为<code>指令寻址</code>和<code>数据寻址</code>两大类</p><h3 id="zhi-ling-xun-zhi">指令寻址</h3><p>寻找下一条将要执行的指令地址称为指令寻址</p><p>指令寻址有两种方式:一种是<code>顺序寻址方式</code>,另一种是<code>跳跃寻址方式</code></p><p><strong>顺序寻址</strong></p><p>通过程序计数器 PC 加 1(一个指令字长),自动形成下一条指令地址</p><p><strong>跳跃寻址</strong></p><p>通过转移类指令实现。所谓的跳跃是指下一条指令的地址不由程序计算器 PC 自动给出,而由本条指令给出的下条指令地址的计算方式。而是否跳跃可能受到状态寄存器和操作数的控制,跳跃的地址分为<code>绝对地址(由标记符直接得到)</code>和<code>相对地址(相对于当前指令地址的偏移量)</code>。跳跃的结果是当前指令修改 PC 值,所以下一条指令仍然通过 PC 给出。</p><h3 id="shu-ju-xun-zhi">数据寻址</h3><p>数据寻址是指如何在指令中表示一个操作数的地址,如何用这种表示得到操作数或怎么样计算出操作数的地址</p><p>数据寻址的方式较多,为区分各种方式,通常在指令字中涉案之一个字段,用来表明属于哪一种寻址方式</p><table><thead><tr><th style="text-align:center">操作码</th><th style="text-align:center">寻址地址</th><th style="text-align:center">形式地址 A(偏移量)</th></tr></thead></table><p>以下是一些常见的数据寻址方式:</p><h4 id="yin-han-xun-zhi">隐含寻址</h4><p>这种类型的指令，不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址， 如图所示。例如，单地址的指令格式，就不是明显地在地址字段中指出第二操作数 的地址，而是规定累加寄存器 ACC 作为第二操作数地址。指令格式明显指出的仅是第一操作数的地址 A。因此，累加寄存器 AC 对单地址指令格式来说是隐含地址。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711072851580.png" alt="image-20230711072851580"></p><h4 id="li-ji-shu-xun-zhi">立即数寻址</h4><p>指令的地址字段指出的不是操作数的地址，而是操作数本身，这种寻址方式称为立即 寻址，如图所示。指令中的操作数称为立即数。立即寻址方式的特点是指令中包含 的操作数立即可用，节省了访问内存的时间。</p><table><thead><tr><th style="text-align:center">OP</th><th style="text-align:center">立即寻址特征</th><th style="text-align:center">A</th></tr></thead></table><p>A 部分即位立即数本身,以补码的形式存储</p><h4 id="zhi-jie-xun-zhi">直接寻址</h4><p>直接寻址是一种基本的寻址方法，其特点是：在指令格式的地址字段中直接指出操作 数在内存的地址 A。由于操作数的地址直接给出而不需要经过某种变换，所以称这种寻址 方式为直接寻址方式。采用直接寻址方式时，指令字中的形式地址 A 就是操作数的有效地址 EA。因此通常把 形式地址 A 又称为<code>直接地址</code>。</p><p>下图是直接寻址方式的示意图 👇</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711085829114.png" alt="image-20230711085829114"></p><h4 id="jian-jie-xun-zhi">间接寻址</h4><p>间接寻址是相对于直接寻址而言的，在间接寻址的情况下，指令地址字段中的形式地址 A 不是操作数的真正地址，而是操作数地址有效地址所在的存储单元的地址,也就是<code>操作数地址的地址</code>。间接寻址可以是一次间接寻址,还可以是多次间接寻址</p><p>下面是间接寻址的示意图 👇</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711090943348.png" alt="image-20230711090943348"></p><p>由于访问速度过慢,这种寻址方式并不常见。一般问到扩大寻址范围,通常指的是<code>寄存器间接寻址</code></p><h4 id="ji-cun-qi-xun-zhi">寄存器寻址</h4><p>寄存器寻址是指在指令字种直接给出操作数所在的寄存器编号,即 EA = R,其操作数在由 R<sub>i</sub>所指的寄存器内</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711092026375.png" alt="image-20230711092026375"></p><h5 id="ji-cun-qi-jian-jie-xun-zhi">寄存器间接寻址</h5><p>寄存器 R<sub>i</sub>种给出的不是一个操作数,而是操作数所在的主存单元的地址即 EA = (R<sub>i</sub>)</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711092540650.png" alt="image-20230711092540650"></p><h4 id="pian-yi-xun-zhi">偏移寻址</h4><p>一种强有力的寻址方式是直接寻址和寄存器间接寻址方式的结合，它有几种形式，我 们称它为偏移寻址。有效地址计算公式为 EA=A+®</p><p>常用的三种偏移寻址是<code>相对寻址</code>、<code>基址寻址</code>、<code>变址寻址</code>。</p><h5 id="xiang-dui-xun-zhi">相对寻址</h5><p>相对寻址是把 PC 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址,即 EA = (PC) +A,其中 A 是相对于前指令地址的偏移量,可正可负,补码表示</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711094719377.png" alt="image-20230711094719377"></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711100601565.png" alt="image-20230711100601565"></p><blockquote><p>注意对于转移指令 JMP A,当 CPU 从存储器中取出一字节时,会自动执行(PC) + 1 → PC。若转移指令地址为 X,且占 2B 在取出该指令后 PC 的值会加 2 即(PC) = X+2,这样在执行完该指令后,会自动跳转到 X + 2 + A 的地址继续执行</p></blockquote><blockquote><p>🙋‍♂️ 多道程序设计中，各个程序段可能要在内存中浮动，而相对寻址特别利于程序浮动</p></blockquote><h5 id="ji-zhi-xun-zhi">基址寻址</h5><p>将 CPU 中基址寄存器(BR)的内容加上指令格式中形式地址 A 而形成的操作数的有效地址,即 EA = (BR) + A。其中基址寄存器既可采用专用寄存器,又可采用通用寄存器</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711094605323.png" alt="image-20230711094605323"></p><blockquote><p>注:基址寄存器是<strong>面向操作系统</strong>的，<strong>其内容由操作系统或管理程序确定</strong>。在程序执行过程中，基址寄存器的内容不变(作为基地址)，形式地址可变(作为偏移量)。当采用通用寄存器作为基址寄存器时，可由<strong>用户决定哪个寄存器作为基址寄存器</strong>，但其<strong>内容仍由操作系统确定</strong>。</p></blockquote><p>优点:可扩大寻址范围(基址寄存器的位数大于形式地址 A 的位数) ;用户不必考虑自己的程序存于主存的哪一空间区域，故有利于多道程序设计，以及可用于编制浮动程序。</p><h5 id="bian-zhi-xun-zhi">变址寻址</h5><p>地址域引用一个主存地址，被引用的专用寄存器含有对那个地址的正偏移量。这意味着主存地址位数大于寄存器中的偏移量位数，与基址寻址刚好相反。但是二者 有效地址的计算方法是相同的。变址的用途是为重复操作的完成提供一种高效机制。例如， 主存位置 A 处开始放一个数值列表，打算为表的每个元素加 1。我们需要取每个数位，对 它加 1，然后再存回，故需要的有效地址序列是 A, A+1, A+2, …直到最后一个位置。此时 值 A 存入指令地址字段，再用一个变址寄存器 IX(初始化为 0)。每次操作之后，变址寄存器 内容增 1。此时，EA=A+®，R←(R+1)</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230711104751971.png" alt="image-20230711104751971"></p><p>变址寻址的优点是可扩大寻址范围(变址寄存器的位数大于形式地址 A 的位数);在数组处理过程中，可设定 A 为数组的首地址，不断改变变址寄存器 IX 的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。偏移量(变址寄存器 IX)的位数足以表示整个存储空间。</p><p>显然，变址寻址与基址寻址的有效地址形成过程极为相似。但从本质上讲，两者有较大区别。<strong>基址寻址面向系统，主要用于为多道程序或数据分配存储空间，因此基址寄存器的内容通常由操作系统或管理程序确定，在程序的执行过程中其值不可变，而指令字中的 A 是可变的</strong>:<strong>变址寻址立足于用户，主要用于处理数组问题，在变址寻址中，变址寄存器的内容由用户设定，在程序执行过程中其值可变，而指令字中的 A 是不可变的。</strong></p><h4 id="dui-zhan-xun-zhi">堆栈寻址</h4><p>堆栈有<code>寄存器堆栈(硬堆栈)</code>和<code>存储器堆栈(软堆栈)</code>两种形式，它们都以后进先出(LIFO)的原理存储数据。不论是寄存器堆栈，还是存储器堆栈，数据的存取都与栈顶地址打交通，为此需要一个<code>隐式或显式的堆栈指示器(寄存器)</code>,该寄存器被称为<code>堆栈指针(SP)</code>。数据进栈时使用 PUSH 指令，将数据压入栈顶地址，堆栈指示器减 1；数据退栈时，使用 POP 指令，数据从栈顶地址弹出，堆栈指示器加 1。从而保证了堆栈中数据先进后出的存取顺序。</p><h4 id="ge-ge-xun-zhi-fang-shi-bi-jiao">各个寻址方式比较</h4><table><thead><tr><th style="text-align:center">寻址方式</th><th style="text-align:center">有效地址</th><th style="text-align:center">访存次数(执行阶段)</th></tr></thead><tbody><tr><td style="text-align:center">隐含寻址</td><td style="text-align:center">程序指定</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">立即寻址</td><td style="text-align:center">A 即是操作数</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">直接寻址</td><td style="text-align:center">EA = A</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">一次间接寻址</td><td style="text-align:center">EA = (A)</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">寄存器寻址</td><td style="text-align:center">EA = R<sub>i</sub></td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">寄存器一次寻址</td><td style="text-align:center">EA = (R<sub>i</sub>)</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">相对寻址</td><td style="text-align:center">EA = (PC) + A</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">基址寻址</td><td style="text-align:center">EA = (BR) + A</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">变址寻址</td><td style="text-align:center">EA = (IX) + A</td><td style="text-align:center">1</td></tr></tbody></table><h2 id="cheng-xu-de-ji-qi-ji-dai-ma-biao-shi">程序的机器级代码表示</h2><h3 id="chang-yong-hui-bian-zhi-ling-jie-shao">常用汇编指令介绍</h3><h4 id="xiang-guan-ji-cun-qi">相关寄存器</h4><p>x86 处理器中有 8 个 32 位的通用寄存器,各寄存器及说明如下图所示。为了向后兼容,<code>EAX</code>、<code>EBX</code>、<code>ECX</code>和<code>EDX</code>的高两位字节和低两位字节可以独立使用,<code>E</code>为<code>Extended(拓展)</code>,表示 32 位寄存器;<code>D</code>表示<code>Destination(目标)</code>(Destination Index, DI, 目标索引);<code>S</code>表示<code>Source(源)</code>(Source Index, SI, 源索引)。例如,<code>EAX</code>的低两位称为<code>AX</code>,而<code>AX</code>的高低字节又可以分别作为两个 8 位寄存器,分别称为<code>AH</code>和<code>AL</code>。寄存器的名称与大小写无关,既可以用<code>EAX</code>,又可以用<code>eax</code>。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/%E5%AF%84%E5%AD%98%E5%99%A8.svg" alt="寄存器"></p><p>除了 EBP 和 ESP 外,其他几个寄存器的用途是比较任意的</p><h4 id="hui-bian-zhi-ling-ge-shi">汇编指令格式</h4><p>使用不同编程工具开发程序,用到的汇编程序也不同,一般有两种不同汇编格式:<code>AT&amp;T格式</code>和<code>Intel格式</code>。</p><blockquote><p>AT&amp;T 格式是一种汇编语言的语法格式，主要用于 Unix 和 Linux 等操作系统中。</p></blockquote><p>他们的区别主要体现如下:</p><p>以下简称为<strong>A 格式</strong>和<strong>I 格式</strong></p><p>①A 格式的指令只能用小写字母,而 I 格式的指令对大小写不敏感</p><p>② 在 A 格式中,第一个为<code>源操作数</code>,第二个为<code>目的操作数</code>,方向<strong>从左到右</strong>,合乎日常顺序,I 格式中,第一个为<code>目的操作数</code>,第二个为<code>源操作数</code>,方向<strong>由右向左</strong></p><p>③ 在 A 格式中,寄存器需要加前缀&quot;%“,立即数需要加前缀”$&quot;;在 I 格式中,寄存器和立即数都不需要加</p><p>④ 在内存寻址方面,A 格式使用&quot;()“,而 I 格式使用”[]&quot;</p><p><s>⑤ 在 A 格式中，操作码和源操作数、目标操作数之间用逗号隔开，而在 I 格式中则用空格隔开</s></p><p>⑥ 在处理负责寻址方式时,例如 A 格式的内存操作数&quot;<code>disp(base,index,scale)</code>“分别表示<code>偏移量(disp)</code>、<code>基址寄存器(base)</code>、<code>变址寄存器(index)</code>和<code>比例因子(scale)</code>,如&quot;8(%edx,%eax,2)“表示操作数为 M[R[edx]+R[eax]×2+8],其对应的 I 格式的操作数为”[edx+eax×2+8]”</p><blockquote><p><code>M</code>: 表示内存操作，即对内存进行读取或写入操作。</p><p><code>R[edx]</code>:表示以通用寄存器 edx 的内容作为值参与计算</p><p><code>比例因子</code>:是一个常数，用于与变址寄存器的值相乘。</p><p><code>R[eax]×2</code>:将寄存器 eax 的内容乘以 2 作为变址寄存器的偏移量</p></blockquote><p>⑦ 在指定数据长度方面,A 格式指令操作码的后面紧跟一个字符,表明操作数大小,&quot;b&quot;表示 byte(字节)、&quot;w&quot;表示 word(字)或&quot;l&quot;表示 Long(双字)。I 格式也有类似的语法,他在操作码后面显示地注明 byte ptr、word ptr、dword ptr。</p><p>例子:将一个 16 位的数据保存到内存地址 0x200 处</p><p>AT&amp;T 格式:</p><pre><code class="language-x86asm">movb $0x56, 0x200</code></pre><p>Intel 格式</p><pre><code class="language-x86asm">mov word ptr [0x200], 0x56</code></pre><blockquote><p>由于 32 位和 64 位都是由 16 位拓展而来,因此用 word(字)表示 16 位</p></blockquote><p>以下是两种格式指令格式的对比</p><table><thead><tr><th style="text-align:center">AT&amp;T 格式</th><th style="text-align:center">Intel 格式</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">mov $100, %eax</td><td style="text-align:center">mov eax, 100</td><td style="text-align:center">100 → R[eax]</td></tr><tr><td style="text-align:center">mov %eax, %ebx</td><td style="text-align:center">mov ebx, eax</td><td style="text-align:center">R[eax] → R[ebx]</td></tr><tr><td style="text-align:center">mov %eax, (%ebx)</td><td style="text-align:center">mov [ebx], eax</td><td style="text-align:center">R[eax] → M[R[ebx]]</td></tr><tr><td style="text-align:center">mov %eax, -8(%ebp)</td><td style="text-align:center">mov [ebp-8], eax</td><td style="text-align:center">R[eax] →M[R[ebx]-8]</td></tr><tr><td style="text-align:center">lea 8(%edx, %eax, 2), %eax</td><td style="text-align:center">lea eax, [edx+eax*2+8]</td><td style="text-align:center">R[edx]+R[eax]×2+8 → R[eax](这个 lea 指令（effective address）的意思是计算有效地址,而不是直接从内存中加载数据到寄存器,所以这里不是 M[R[edx]+R[eax]×2+8])</td></tr><tr><td style="text-align:center">movl %eax, %ebx</td><td style="text-align:center">mov dword ptr ebx, eax</td><td style="text-align:center">长度为 4 字节的 R[eax] → R[ebx]</td></tr></tbody></table><blockquote><p>R[r]表示寄存器 r 的内容,M[addr]表示主存单元 addr 的内容,→ 表示信息传送方向</p></blockquote><h4 id="chang-yong-zhi-ling">常用指令</h4><p>汇编指令通常可以分为<code>数据传送指令</code>、<code>逻辑计算指令</code>和<code>控制流指令</code>下面是以 Intel 格式为例的一些重要指令</p><p>以下是一些格式介绍:</p><ul class="lvl-0"><li class="lvl-2"><p><code>&lt;reg&gt;</code>:表示任意寄存器,若其后带有数字,则指定其位数,如&lt;reg32&gt;表示 32 位寄存器(eax、ebx、ecx、edx、esi、edi、ebp、esp);&lt;reg16&gt;代表 16 位寄存器(ax、bx、cx、dx、si、di、bp、sp);&lt;reg8&gt;代表 8 位寄存器(ah、al、bh、bl、ch、cl、dh、dl)</p></li><li class="lvl-2"><p><code>&lt;mem&gt;</code>:表示内存地址(如[eax]、[var+4]或 dword ptr [eax+ebx])</p></li><li class="lvl-2"><p><code>&lt;con&gt;</code>:表示 8 位、16 位或 32 位常数。&lt;con8&gt;表示 8 位常数;&lt;con16&gt;表示 16 位常数;&lt;con32&gt;表示 32 位常数</p></li><li class="lvl-2"><p><code>&lt;cl&gt;</code>:表示要移动的位数，它可以是一个立即数或者是另一个寄存器。</p></li></ul><p>x86 中的指令机器码长度为 1 字节,对同一指令的不同用途有多种编码方式,比如 mov 指令就有 28 种机内编码,用于不同的操作数类型或用于特定的寄存器:</p><pre><code class="language-x86asm">mov &lt;con16&gt;, ax#机器码为B8Hmov &lt;con8&gt;, al#机器码为B0Hmov &lt;reg16&gt;, &lt;reg16&gt;/&lt;mem16&gt;#机器码为89Hmov &lt;reg8&gt;&lt;mem18&gt;, &lt;reg8&gt;#机器码为8AHmov &lt;reg16&gt;/&lt;mem16&gt;, &lt;reg16&gt;#机器码为8BH</code></pre><h5 id="shu-ju-chuan-song-zhi-ling">数据传送指令</h5><h6 id="mov-zhi-ling">mov 指令</h6><p>将第二个操作数(寄存器的内容,内存中的内容或常数值)复制到第一个操作数(寄存器或内存)。但<strong>不能直接用于从内存复制到内存</strong></p><p>其语法如下:</p><pre><code class="language-x86asm">mov &lt;reg&gt;, &lt;reg&gt;mov &lt;reg&gt;, &lt;mem&gt;mov &lt;mem&gt;, &lt;reg&gt;mov &lt;reg&gt;, &lt;con&gt;mov &lt;mem&gt;, &lt;com&gt;#例子:mov eax, ebx #将ebx值复制到eaxmov byte ptr [var], 5#将5保存到var指示的内存地址的一字节中</code></pre><h6 id="push-zhi-ling">push 指令</h6><p>将操作数压入内存的栈,常用于函数调用。ESP 时栈顶,压栈前先将 ESP 值减 4(栈增长方向与内存地址增长方向相反),然后将操作数压入 ESP 指示的地址</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/1251900-20171222111105318-578935555.png" alt="img"></p><p>语法如下:</p><pre><code class="language-x86asm">push &lt;reg32&gt;push &lt;mem&gt;push &lt;con32&gt;#例子:push eax#将eax值压栈push [var]#将var值指示的内存地址的4字节值压栈</code></pre><h6 id="pop-zhi-ling">pop 指令</h6><p>与 push 指令相反,pop 指令执行的是出栈操作,出栈前先将 ESP 指示的地址中的内容出栈,然后将 ESP 的值加 4</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/1251900-20171222111908896-493635123.png" alt="img"></p><p>语法格式如下:</p><pre><code class="language-x86asm">pop edi#弹出栈顶元素送到edipop [ebx] #弹出栈顶元素送到ebx值指示的内存地址的4字节中</code></pre><h5 id="suan-shu-he-luo-ji-yun-suan-zhi-ling">算数和逻辑运算指令</h5><h6 id="add-sub-zhi-ling">add/sub 指令</h6><p><code>add</code>指令将两个操作数相加,相加的结果保存到第一个操作数中。<code>sub</code>指令用于两个操作数相减,相减的结果保存到第一个操作数中</p><pre><code class="language-x86asm">add &lt;reg&gt;,&lt;reg&gt; / sub &lt;reg&gt;,&lt;reg&gt;add &lt;reg&gt;,&lt;mem&gt; / sub &lt;reg&gt;,&lt;mem&gt;add &lt;mem&gt;,&lt;reg&gt; / sub &lt;mem&gt;,&lt;reg&gt;add &lt;reg&gt;,&lt;con&gt; / sub &lt;reg&gt;,&lt;con&gt;add &lt;mem&gt;,&lt;con&gt; / sub &lt;mem&gt;,&lt;con&gt;#例子:sub eax, 10#eax ← eax-10add byte ptr [var], 10 #10与var值指示的内存地址的1字节的值相加,并将结果保存在var值指示的内存地址的字节中</code></pre><h6 id="inc-dec-zhi-ling">inc/dec 指令</h6><p><code>inc</code>指令是表示将操作数自增 1;<code>dec</code>指令是表示将操作数自减 1</p><pre><code class="language-x86asm">inc &lt;reg&gt; / dec &lt;reg&gt;inc &lt;mem&gt; / dec &lt;mem&gt;#例子:dec eax#eax的值自减1inc dword ptr#var所指示的啊内存地址的4字节的值自增1(d double,word 16位)</code></pre><h6 id="imul-zhi-ling">imul 指令</h6><p>带符号整数乘法指令,有两种格式:</p><p>① 两个操作数,将两个操作数相乘,将结果保存在第一个操作数中,<strong>第一个操作数必须为寄存器</strong></p><p>②3 个操作数,将第二个和第三个操作数相乘,将结果保存在第一个操作数中,<strong>第一个操作数必须为寄存器</strong></p><p>其语法格式如下:</p><pre><code class="language-x86asm">imul &lt;reg32&gt;,&lt;reg32&gt;imul &lt;reg32&gt;,&lt;mem&gt;imul &lt;reg32&gt;,&lt;reg32&gt;,&lt;con&gt;imul &lt;reg32&gt;,&lt;mem&gt;,&lt;con&gt;#例子:imul eax, [var]#eax ← eax * [var]imul esi, edi, 25#esi ← edi * 25</code></pre><p>乘法操作结果可能溢出,则编译器设置<code>溢出标志 OF=1</code>,以使 CPU 调出溢出异常处理程序。</p><h6 id="idiv-zhi-ling">idiv 指令</h6><p>带符号整数除法,他只有一个操作数,即除数,而被除数则为 edx:eax 中的内容(64 位整数),操作结果有两部分:商和余数,商送到 eax,余数送到 edx</p><p>其语法如下:</p><pre><code class="language-x86asm">idiv &lt;reg32&gt;idiv &lt;mem&gt;#例子:idiv ebxidiv dword ptr [var]</code></pre><h6 id="and-or-xor-zhi-ling">and/or/xor 指令</h6><p>分别是<code>逻辑与</code>、<code>逻辑或</code>、<code>逻辑异或</code>指令操作,用于操作数的位操作,操作结果放在第一个操作数中</p><pre><code class="language-x86asm">and &lt;reg&gt;,&lt;reg&gt; / or &lt;reg&gt;,&lt;reg&gt; / xor &lt;reg&gt;,&lt;reg&gt;and &lt;reg&gt;,&lt;mem&gt; / or &lt;reg&gt;,&lt;mem&gt; / xor &lt;reg&gt;,&lt;mem&gt;and &lt;mem&gt;,&lt;reg&gt; / or &lt;mem&gt;,&lt;reg&gt; / xor &lt;mem&gt;,&lt;reg&gt;and &lt;reg&gt;,&lt;con&gt; / or &lt;reg&gt;,&lt;con&gt; / xor &lt;reg&gt;,&lt;con&gt;and &lt;mem&gt;,&lt;con&gt; / or &lt;mem&gt;,&lt;con&gt; / xor &lt;mem&gt;,&lt;con&gt;#例子:and eax, 0fH#将eax中的前28位全部置为0,最后4位保持不变,0fH(H表示该数为16进制数)xor edx, edx#置edx中的内容为0</code></pre><h6 id="not-zhi-ling">not 指令</h6><p>位翻转指令,将操作数中的每一位翻转,即 0 → 1、1 → 0</p><p>其语法如下:</p><pre><code class="language-x86asm">not &lt;reg&gt;not &lt;mem&gt;#例子:not byte ptr [var]#将var值指示的内存地址的一字节的所有位翻转</code></pre><h6 id="neg-zhi-ling">neg 指令</h6><p>取负指令</p><pre><code class="language-x86asm">neg &lt;reg&gt;neg &lt;mem&gt;#例子:neg eax#eax ← eax</code></pre><h6 id="shl-shr-zhi-ling">shl/shr 指令</h6><p>逻辑移位指令,shl 为逻辑左移,shr 为逻辑右移,第一个操作数表示被操作数,第二个操作指示移位的位数</p><pre><code class="language-x86asm">shl &lt;reg&gt;,&lt;con8&gt; / shr &lt;reg&gt;,&lt;con8&gt;shl &lt;mem&gt;,&lt;con8&gt; / shr &lt;mem&gt;,&lt;con8&gt;shl &lt;reg&gt;,&lt;cl&gt; / shr &lt;reg&gt;,&lt;cl&gt;shl &lt;mem&gt;,&lt;cl&gt; / shr &lt;mem&gt;,&lt;cl&gt;#例:shl eax, 1#将eax值左移一位,相当于乘2shr ebx, cl #将ebx值右移n位(n为cl中的值),相当于除2</code></pre><h5 id="kong-zhi-liu-zhi-ling">控制流指令</h5><p>x86 处理器维持一个指示当前执行指令的指令指针(IP),当一条指令执行后,此指针自动指向下一条指令。IP 寄存器不能直接操作,但可以用控制流指令更新。通常用标签(label)指示程序中的指令地址,在 x86 的汇编代码中,可在任何指令前加入标签。例如:</p><pre><code class="language-x86asm">mov esi, [ebp+8] begin: xor ecx, ecxmov eax, [esi]</code></pre><p>这样 begin 指示了第二条指令,控制流指令通过标签就可以实现程序指令的跳转</p><h6 id="jmp-zhi-ling">jmp 指令</h6><p>控制 IP 转移到 label 所指示的地址(从 label 中取出指令执行)</p><pre><code class="language-x86asm">jmp &lt;label&gt;#例子:jmp begin#跳转到begin标记的指令执行</code></pre><h6 id="jcondition-zhi-ling">jcondition 指令</h6><p>条件转移指令,依据 CPU 状态字中的一系列条件状态转移。CPU 状态字中包括指示最后一个算数运算结果是否为 0,运算结果是否为负数等</p><pre><code class="language-x86asm">je &lt;label&gt;(jump when equal)jne &lt;label&gt;(jump when not equal)jz &lt;label&gt;(jump when last result was zero)jnz &lt;label&gt;(jump when result was not zero)jg &lt;label&gt;(jump when greather than)jge &lt;label&gt;(jump when greather than or equal to)jl &lt;label&gt;(jump when less than)jle &lt;label&gt;(jump when less than or equal to)#例子:cmp eax, ebxjle done #如果eax的值小于等于ebx的值,跳转到done指示的指令执行,否则执行下一条指令</code></pre><h6 id="cmp-test-zhi-ling">cmp/test 指令</h6><p>cmp 指令用于比较两个操作数的值(compare),test 指令对两个操作数进行逐位与运算,<strong>这两类指令都不保存操作结果,仅根据运算结果设置 CPU 状态字中的条件码</strong></p><pre><code class="language-x86asm">cmp &lt;reg&gt;,&lt;reg&gt; / test &lt;reg&gt;,&lt;reg&gt;cmp &lt;mem&gt;,&lt;reg&gt; / test &lt;mem&gt;,&lt;reg&gt;cmp &lt;reg&gt;,&lt;mem&gt; / test &lt;reg&gt;,&lt;mem&gt;cmp &lt;reg&gt;,&lt;con&gt; / test &lt;reg&gt;,&lt;con&gt;#cmp和test通常和jcondition指令搭配使用,举例:cmp dword ptr [var], 10#将var指示的主存地址为4字节的内容,与10进行比较jne loop#如果相等则顺序执行,如果不相等则跳转到loop处执行test eax, eax#测试eax是否为0jz xxxx#为零则置标志ZF为1,跳转到xxxx处执行</code></pre><h6 id="call-ret-zhi-ling">call/ret 指令</h6><p>分别用于实现子程序(过程、函数等)的调用及返回</p><pre><code class="language-x86asm">call &lt;label&gt;ret</code></pre><p>call 指令首先将当前执行指令地址入栈,然后无条件转移到由标签指示的命令。与其他简单的跳转指令不同,call 指令保存调用前的地址信息(当 call 命令结束后,返回调用之前的地址)。</p><p>ret 指令实现子程序的返回机制,ret 指令弹出栈中保存的指令地址,然后无条件转移到保存的指令地址执行。</p><h3 id="guo-cheng-diao-yong-de-ji-qi-ji-biao-shi">过程调用的机器级表示</h3><p>上面说 call/ret 指令主要用于过程调用,他们都属于一种无条件转移指令。</p><p>假定过程 P(调用者)调用过程 Q(被调用者),过程调用的执行步骤如下:</p><ol><li class="lvl-3"><p>P 将入口参数(实参)放在 Q 能够访问到的地方</p></li><li class="lvl-3"><p>P 将返回地址存到特定的地方,然后控制转移到 Q(call 实现)</p></li><li class="lvl-3"><p>Q 保存 P 的现场(通用寄存器的内容),并为自己的非静态局部变量分配空间</p></li><li class="lvl-3"><p>执行过程 Q</p></li><li class="lvl-3"><p>Q 恢复 P 的现场,将返回结果放到 P 能够访问到的地方,并释放局部变量所占空间</p></li><li class="lvl-3"><p>Q 取出返回地址,将控制转移到 P(ret 实现)</p></li></ol><p>其中寄存器 EAX、ECX 和 EDX 是<code>调用者保存寄存器</code>,其保存和恢复的任务由过程 P 负责,P 调用 Q 时,Q 就可以直接使用这 3 个寄存器</p><p>寄存器 ESI、EDI、EBX 是<code>被调用者保存寄存器</code>,Q 必须先将他们的值保存在栈中才能使用它们,并在返回 P 之前先恢复它们的值</p><p>每个过程都有自己的栈区,称为<code>栈帧</code>,因此,一个栈由若干帧栈帧组成。帧指针寄存器 EBP 指示当前栈帧的起止位置(栈底),栈指针寄存器 ESP 指示栈顶,栈从高地址向低地址增长,因此当前栈帧的范围在帧指针 EBP 和 ESP 指向的区域之间</p><h3 id="xuan-ze-yu-ju-de-ji-qi-ji-biao-shi">选择语句的机器级表示</h3><p>常见的选择结构语句有<code>if-then</code>、<code>if-then-else</code>、<code>case(或switch)</code>等。编译器通过条件码(标志位)设置指令和各类转移指令来实现程序中的选择结构语句。</p><p><strong>条件码(标志位)</strong></p><p>除了整数寄存器,CPU 还维护一组<code>条件码(标志位)寄存器</code>,他们描述了<strong>最近</strong>的算数或逻辑运算操作的属性。可以检测这些寄存器来执行条件分支指令,最常用的条件码如下:</p><ul class="lvl-0"><li class="lvl-2"><p><strong>CF</strong>:进(借)位标志,最近无符号整数加(减)运算后的进(借)位情况。有进(借)位时,CF = 1;否则 CF = 0</p></li><li class="lvl-2"><p><strong>ZF</strong>:零标志。最近的操作的运算结果是否为 0。若结果为 0,ZF = 1;否则 ZF = 0</p></li><li class="lvl-2"><p><strong>SF</strong>:符号标志。最近的带符号数运算结果的符号。若为负,SF = 1;否则 SF = 0</p></li><li class="lvl-2"><p><strong>OF</strong>:溢出标志。最近的带符号数运算结果是否溢出,若溢出,OF =1;否则 OF = 0</p></li></ul><p>可见,OF 和 SF 对无符号数运算来说没有意义,而 CF 对带符号数运算来说没有意义</p><h2 id="cisc-he-risc-de-ji-ben-gai-nian">CISC 和 RISC 的基本概念</h2><p>CISC 复杂指令系统计算机，功能更强大，指令更复杂；RISC 精简指令系统计算机，指令简单，执行速度快。</p><p>RISC 精简指令系统计算机，要求指令系统简化，尽量使用<strong>寄存器-寄存器</strong>操作指令。指令格式一致，指令长度固定、种类少，寻址方式种类少，<strong>指令功能没那么强</strong>。</p><p>RISC 采用指令流水线技术，使大部分指令在一个时钟周期内完成。适合流水线的指令系统的特征有 ∶</p><p>① 指令长度应尽量一致;</p><p>② 指令格式应尽量规整;</p><p>③ 保证除 Load/Store 指令外的其他指令都不访问存储器;</p><p>④<strong>数据和指令在存储器中&quot;对齐&quot;存放</strong>。</p><h1 id="zhong-yang-chu-li-qi">中央处理器</h1><h2 id="cpu-de-gong-neng-he-ji-ben-jie-gou">CPU 的功能和基本结构</h2><h3 id="cpu-de-gong-neng">CPU 的功能</h3><p><strong>指令控制</strong> 程序的顺序控制，称为指令控制。由于程序是一个指令序列，这些指令的 相互顺序不能任意颠倒，必须严格按程序规定的顺序进行，因此，保证机器按顺序执行程 序是 CPU 的首要任务。</p><p><strong>操作控制</strong> 一条指令的功能往往是由若干个操作信号的组合来实现的，因此，CPU 管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制 这些部件按指令的要求进行动作。</p><p><strong>时间控制</strong> 对各种操作实施时间上的定时，称为时间控制。因为在计算机中，各种指令的操作信号均受到时间的严格定时。另外，一条指令的整个执行过程也受到时间的严格 定时。只有这样，计算机才能有条不紊地自动工作。</p><p><strong>数据加工</strong> 所谓数据加工，就是对数据进行算术运算和逻辑运算处理。完成数据的加工处理，是 CPU 的根本任务。因为，原始信息只有经过加工处理后才能对人们有用</p><p><strong>中断处理</strong> 对计算机运行过程中出现的异常情况和特殊请求进行处理</p><h3 id="cpu-de-ji-ben-jie-gou">CPU 的基本结构</h3><p><strong>控制器</strong></p><p>由<code>程序计数器(PC)</code>、<code>指令寄存器(IR)</code>、<code>指令译码器(ID)</code>、<code>时序产生器和操作控制器(OC)</code>组成， 它是发布命令的“决策机构”，即完成协调和指挥整个计算机系统的操作。</p><p>控制器的主要功能有：</p><ol><li class="lvl-3"><p>从指令 cache 中取出一条指令，并指出下一条指令在指令 cache 中的位置。</p></li><li class="lvl-3"><p>对指令进行译码或测试，并产生相应的操作控制信号，以便启动规定的动作。比如， 一次数据 cache 的读/写操作，一个算术逻辑运算操作，或一个输入/输出操作。</p></li><li class="lvl-3"><p>指挥并控制 CPU、数据 cache 和输入/输出设备之间数据流动的方向。</p></li></ol><p>下面详细介绍一下控制器的组成:</p><ol><li class="lvl-3"><p><strong>指令寄存器(IR)</strong> <span style="color:red">指令寄存器用来保存当前正在执行的一条指令。</span>当执行一条指令 时，先把它从指令存储器(简称指存)读出，然后再传送至指令寄存器。指令划分为操作码 和地址码字段，由二进制数字组成。为了执行任何给定的指令，必须对操作码进行测试， 以便识别所要求的操作。一个叫做指令译码器的部件就是做这项工作的。指令寄存器中操 作码字段 OP 的输出就是指令译码器的输入。操作码一经译码后，即可向操作控制器发出具 体操作的特定信号。</p></li><li class="lvl-3"><p><strong>程序计数器(PC)</strong> <span style="color:red">用来指出下一条指令在主存中存放给的地址。</span>在程序开始执行前，必须将它的起始地址，即程序的第一条指令所在的指存单元地址送入 PC，因此 PC 的内容即是从指存提取的第一条指令的地址。当执行指令时，CPU 将自动修改 PC 的内容，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按 顺序来执行的，所以修改的过程通常只是简单的对 PC 加 1。 但是，当遇到转移指令如 JMP 指令时，那么后继指令的地址(即 PC 的内容)必须从指令寄存器中的地址字段取得。在这种情况下，下一条从指存取出的指令将由转移指令来规定，而不是像通常一样按顺序来取得。因此程序计数器的结构应当是具有寄存器和计数两种功能的结构。<code>汇编程序员可见</code></p></li><li class="lvl-3"><p><strong>存储器地址寄存器(MAR)</strong> 用于存放要访问的主存单元的地址</p></li><li class="lvl-3"><p><strong>存储数据寄存器(MDR)</strong> 用于存放向主存写入的信息或从主存读出的信息</p></li><li class="lvl-3"><p><strong>时序系统</strong> 用于产生各种时序信号,他们都由统一时钟(CLOCK)分频得到</p></li><li class="lvl-3"><p><strong>微操作信号信号发生器</strong> 根据 IR 的内容(指令)、PSW 的内容(状态信息)及时序信号,产生控制计算机各个部件所要用到的控制信号</p></li></ol><p><strong>运算器</strong></p><p>由<code>算术逻辑运算单元(ALU)</code>、<a href="####%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8"><code>通用寄存器</code></a>、<code>数据缓冲寄存器(DR)</code>和<code>程序状态字寄存器(状态条件寄存器，PSWR)</code>组成，它是数据加工处理部件。相对控制器而言，运算器接受控制器的命令而进行动作，即运算器所进行的全部操作都是由控制器发出的控制信号来指挥的，所以它是执行部件。</p><p>运算器有两个主要功能：</p><ol><li class="lvl-3"><p>执行所有的算术运算。</p></li><li class="lvl-3"><p>执行所有的逻辑运算，并进行逻辑测试，如零值测试或两个值的比较。 通常，一个算术操作产生一个运算结果，而一个逻辑操作则产生一个判决。</p></li></ol><p>下面详细介绍一下运算器的组成:</p><ol><li class="lvl-3"><p><strong>算数逻辑单元(ALU)</strong>: 进行算数/逻辑运算</p></li><li class="lvl-3"><p><strong>暂存寄存器</strong>: 用于暂存从主存读来的数据,该数据不能存放在通用寄存器中,某则会破坏其原有的内容。<code>暂存寄存器对应用程序员来说是透明的</code></p></li><li class="lvl-3"><p><strong>累加寄存器(ACC)</strong>:一个通用寄存器,用于暂时存放 ALU 的运算结果,可做加法运算的一个输入端</p></li><li class="lvl-3"><p><strong>通用寄存器</strong> 在我们的模型中，通用寄存器有 4 个(R0 ～ R3)，其功能是：当算术逻 辑单元(ALU)执行算术或逻辑运算时，为 ALU 提供一个工作区。例如，在执行一次加法运 算时，选择两个操作数(分别放在两个寄存器)相加，所得的结果送回其中一个寄存器(如 R2)中，而 R2 中原有的内容随即被替换。</p><p>目前 CPU 中的通用寄存器，可多达 64 个，甚至更多。其中任何一个可存放源操作数， 也可存放结果操作数。在这种情况下，需要在指令格式中对寄存器号加以编址。从硬件结 构来讲，需要使用通用寄存器堆结构，以便选择输入信息源。通用寄存器还用作地址指示 器、变址寄存器、堆栈指示器等。</p></li><li class="lvl-3"><p><strong>程序状态字寄存器(PSWR)</strong> 程序状态字寄存器又称为状态条件寄存器，<span style="color:red">保存由算术运算指令和逻辑运算指令运算或测试结果建立的各种条件代码</span>，如运算结果<code>进位标志C)</code>，<code>运算结果溢出标志(V)</code>，<code>运算结果为零标志(Z)</code>，<code>运算结果为负标志(N)</code>，等等。这些 标志位通常分别由 1 位触发器保存。 除此之外，状态条件寄存器还保存中断和系统工作状态等信息，以便使 CPU 和系统能 及时了解机器运行状态和程序运行状态。因此，状态条件寄存器是一个由各种状态条件标 志拼凑而成的寄存器。<code>对所有用户可见</code></p></li><li class="lvl-3"><p><strong>移位器</strong> 对操作数或运算记过进行移位操作</p></li><li class="lvl-3"><p><strong>计数器</strong> 控制乘除运算的操作步骤</p></li></ol><blockquote><p>虚拟存储器对系统程序员可见</p></blockquote><p>以下是哈弗结构的 CPU 模型简略图(数据 cache 和指令 cache 分离)👇:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230712163507973.png" alt="image-20230712163507973"></p><p>`</p><p><strong>寄存器和存储器的可见性总结</strong>:</p><table><thead><tr><th style="text-align:left">寄存器</th><th style="text-align:left">描述</th><th style="text-align:left">汇编程序员可见</th><th style="text-align:left">应用程序员可见</th><th style="text-align:left">系统程序员可见</th><th style="text-align:left">用户是否可见(可编程)</th></tr></thead><tbody><tr><td style="text-align:left">PSW</td><td style="text-align:left">在条件转移指令中使用，以及在程序员使用 CMP 指令时需要用到</td><td style="text-align:left"><strong>是</strong></td><td style="text-align:left">否</td><td style="text-align:left">否</td><td style="text-align:left"><strong>是</strong></td></tr><tr><td style="text-align:left">PC</td><td style="text-align:left">跳转指令需要使用 PC+n 来实现</td><td style="text-align:left"><strong>是</strong></td><td style="text-align:left">否</td><td style="text-align:left">否</td><td style="text-align:left"><strong>是</strong></td></tr><tr><td style="text-align:left">通用寄存器</td><td style="text-align:left">程序员可以使用通用寄存器 R 写指令</td><td style="text-align:left"><strong>是</strong></td><td style="text-align:left"><strong>是</strong></td><td style="text-align:left">否</td><td style="text-align:left"><strong>是</strong></td></tr><tr><td style="text-align:left">MAR</td><td style="text-align:left">内存地址寄存器，用于存储要访问的内存地址</td><td style="text-align:left">否</td><td style="text-align:left">否</td><td style="text-align:left"><strong>是</strong></td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">MDR</td><td style="text-align:left">内存数据寄存器，用于存储从内存读取或将数据写入内存的数据</td><td style="text-align:left">否</td><td style="text-align:left">否</td><td style="text-align:left">是</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">累加器 ACC</td><td style="text-align:left">用于存储运算结果和进行算术逻辑操作</td><td style="text-align:left"><strong>是</strong></td><td style="text-align:left">否</td><td style="text-align:left">否</td><td style="text-align:left"><strong>是</strong></td></tr><tr><td style="text-align:left">IR</td><td style="text-align:left">指令寄存器，用于存储当前正在执行的指令</td><td style="text-align:left">否</td><td style="text-align:left">否</td><td style="text-align:left">否</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">Cache</td><td style="text-align:left">高速缓存，用于临时存储内存中的数据，以提高访问速度</td><td style="text-align:left">否</td><td style="text-align:left">否</td><td style="text-align:left"><strong>是</strong></td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">微程序结构和功能</td><td style="text-align:left">CPU 内部的微指令，用于控制 CPU 的操作流程</td><td style="text-align:left">否</td><td style="text-align:left">否</td><td style="text-align:left"><strong>是</strong></td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">暂存寄存器</td><td style="text-align:left">CPU 内部用于完成某些操作的寄存器</td><td style="text-align:left">否</td><td style="text-align:left">否</td><td style="text-align:left"><strong>是</strong></td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">虚拟寄存器</td><td style="text-align:left">虚拟机中的寄存器</td><td style="text-align:left">否</td><td style="text-align:left"><strong>是</strong></td><td style="text-align:left"><strong>是</strong></td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">虚拟存储器</td><td style="text-align:left">系统程序员通过虚拟存储器来管理内存的使用，以及进行进程之间的隔离和保护。</td><td style="text-align:left">否</td><td style="text-align:left">否</td><td style="text-align:left"><strong>是</strong></td><td style="text-align:left">否</td></tr></tbody></table><h2 id="zhi-ling-de-guo-cheng">指令的过程</h2><h3 id="zhi-ling-zhou-qi">指令周期</h3><p>CPU 从主存中取出并执行一条指令的时间称为指令周期,不同指令的指令周期可能不同。</p><p>指令周期常用若干机器周期来表示,一个机器周期又包含若干个时钟周期(也称节拍或 T 周期,它是 CPU 操作的最基本的单位)。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230712224618774.png" alt="image-20230712224618774"></p><p>完整的指令周期：</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20201019215210426.png" alt="img"></p><p>上述 4 个工作周期都有 CPU 访存操作，只是访存的目的不同。</p><p><strong>取指周期是为了取指令(控制器自动进行，不需要得到相应的指令)</strong></p><p><strong>间址周期是为了取操作数有效地址</strong></p><p><strong>执行周期是为了取操作数并执行运算</strong></p><p><strong>中断周期是为了保存程序断点</strong></p><blockquote><p>为了区分不同的工作周期,在 CPU 内设置了 4 个标志触发器 FE、IND、EX 和 INT,他们分别对应<code>取指</code>、<code>间址</code>、<code>执行</code>和<code>中断</code>周期,并以&quot;1&quot;状态表示有效</p></blockquote><h3 id="zhi-ling-zhou-qi-de-shu-ju-liu">指令周期的数据流</h3><h4 id="qu-zhi-zhou-qi">取指周期</h4><p>根据 PC 中的内容从主存中取出指令代码并存放在 IR 中</p><p>取指周期的数据流向如下图 👇:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230713092234989.png" alt="image-20230713092234989"></p><blockquote><p><strong><em>在取指令开始的时候，PC 存放的是当前指令的地址；取指完成后，PC 中存放的是下一条指令的地址。</em></strong><br>区别在于 是取指令开始的阶段还是取指令结束的阶段。</p></blockquote><h4 id="jian-zhi-zhou-qi">间址周期</h4><p>取操作数的有效地址</p><p>间址周期的数据流向如下图 👇:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230713092728467.png" alt="image-20230713092728467"></p><p>为什么有个或？ 因为在取指周期阶段是先把指令放在 MDR 里面，再传到 IR；进入到间址周期， MDR 中内容是暂时还没有改的，里面存的也还是之前的内容。所以 “有个或” 。</p><blockquote><p>Ad(IR)表示取出 IR 中存放指令字的地址字段</p></blockquote><h4 id="zhi-xing-zhou-qi">执行周期</h4><p>根据 IR 中的指令的操作码和 MDR 中地址对应的主存的操作数，通过 ALU 操作产生执行结果。不同的指令执行周期操作不同，因此数据流无法统一。</p><h4 id="zhong-duan-zhou-qi">中断周期</h4><p>处理中断请求。假设程序断点存入堆栈中,并用 SP 指示栈顶地址,并且进栈操作是先修改栈顶指针,后存入数据</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230713091644918.png" alt="image-20230713091644918"></p><p><span style="color:rgb(246, 132, 43);font-weight:600">只是先暂停任务，去完成其它任务。为了恢复当前任务，需要保存断点。</span><span style="color:rgb( 142, 205, 109);font-weight:600">【断点：本来要执行的下一条指令，即 PC 的内容】</span>一般使用 堆栈结构来保存断点，SP 表示栈顶地址。假设 SP 指向栈顶元素，进栈操作是先修改指针后存入数据。【如果是栈顶元素上一个位置，则是先存入数据，再移动指针】</p><p>调整指针是通过 <span style="color:red;font-weight:600">减 1</span> 实现，和平时的方向是相反的，<span style="color:rgb( 142, 205, 109);font-weight:600">因为在主存中选一片区域做堆栈的时候，是从高地址码向低地址去扩增的。</span>所以进栈用减法，出栈用加法。</p><p><span style="color:rgb(51, 153, 234);font-weight:600">到第 3 步，将 PC 的内容送到 MDR 之后，配合之前写的命令，PC 的内容就会通过数据总线放到存储器中。<br>(MDR)  → M(MAR)</span></p><p>第 3 步完成后，就完成了中断操作的第一个任务：保存断点（即暂停当前任务）；<span style="color:rgb(246, 132, 43);font-weight:600">下一步是要去完成其它任务，怎么开始完成其它任务？</span><br><span style="color:rgb( 142, 205, 109);font-weight:600">把任务要执行的第一条指令地址（即中断服务程序的入口地址）放到 PC 中。</span>这个地址是由向量形成部件产生的（中断章节具体介绍），故该地址又被称为 向量地址。 这样下一步， CPU 还是根据 PC 中的内容去寻找下一条指令，所以就切入到了一个新的程序的运行。</p><h3 id="zhi-ling-zhi-xing-fang-an">指令执行方案</h3><p><strong>单指令周期</strong>：具体来说，就是不分取指阶段、执行阶段等，而是将指令周期作为一个阶段，就相当于每个指令周期都是一个机器周期。这种模式下，指令和指令之间是串行执行的。因为所有的指令需要统一 一个时间，所以指令周期 取决于执行时间最长的指令的执行时间。</p><p><strong>多指令周期</strong>:对不同类型的指令选用不同的执行步骤。指令之间串行执行。</p><p><strong>流水线方案</strong>：间隔一定时间启动就启动一条指令，原理是：在不同的机器周期（不同的小步骤下），一条指令所需要的硬件资源是不同的，所以这样的安排相当于多条指令在并行执行，只不过在不同的阶段在使用不同的硬件。</p><h2 id="shu-ju-tong-lu-de-gong-neng-he-ji-ben-jie-gou">数据通路的功能和基本结构</h2><h3 id="shu-ju-tong-lu-de-gong-neng">数据通路的功能</h3><p>数据通路就是数据在功能部件之间传送的路径；</p><p>数据通路描述了信息从哪里开始、中间经过哪些部件、最终传送到哪个寄存器；</p><p>数据通路由 <mark>控制部件</mark> 控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号；</p><p>数据通路的功能是<mark>实现 CPU 内部的 运算器与寄存器 及 寄存器之间 的数据交换</mark> ；</p><h3 id="shu-ju-tong-lu-de-ji-ben-jie-gou">数据通路的基本结构</h3><p>数据通路的基本结构包括以下三种：</p><p>① <strong>CPU 内部单总线结构</strong></p><p>所有寄存器的输入端和输出端都连接连接到一条公共通路上；</p><p>特点：结构简单、易数据冲突、性能低；</p><p>② <strong>CPU 内部三总线结构</strong></p><p>所有寄存的输入输出端链接到多条公共通路上</p><p>③ <strong>专用数据通路方式</strong></p><p>根据指令执行过程中的数据和地址的流动方向安排连接线路；</p><p>特点：避免使用共享的总线，性能高、硬件量大；</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210715141630.png" alt="找不到图片(Image not found)"></p><blockquote><p>字母加&quot;<code>in</code>&quot;表示该部件允许输入控制信号</p><p>字母加&quot;<code>out</code>&quot;表示该部件允许输出控制信号</p><p>注意: <code>内部总线</code>是指同一部件，如 CPU 内部连接各寄存器及运算部件之间的总线; <code>系统总线</code>是指同一台计算机系统的各部件，如 CPU、内存、通道和各类 IO 接口间互相连接的总线。</p></blockquote><h4 id="ji-cun-qi-zhi-jian-de-shu-chuan-song">寄存器之间的数传送</h4><p>寄存器之间的数据传送可通过 CPU 内部总线完成。在图 5.7 中，某寄存器 AX 的输出和输入分别由 AXout 和 AXin 控制。这里以 PC 寄存器为例，把 PC 内容送至 MAR，实现传送操作的流程及控制信号为</p><pre><code class="language-css">PC→Bus PCout有效，PC内容送总线Bus→MAR MARin有效，总线内容送MAR</code></pre><h4 id="zhu-cun-yu-cpu-zhi-jian-de-shu-ju-chuan-song">主存与 CPU 之间的数据传送</h4><p>主存与 CPU 之间的数据传送也要借助 CPU 内部总线完成。现以 CPU 从主存读取指令为例说明数据在数据通路中的传送过程。实现传送操作的流程及控制信号为</p><pre><code class="language-css">PC→Bus→MAR PCout 和 MARin有效，现行指令地址→MAR1→R CU发读命令MEM(MAR)→MDR MDRin有效MDR→BuS→IR MDRout和 IRin有效，现行指令→IR</code></pre><h5 id="zhi-xing-suan-zhu-huo-luo-ji-yun-suan">执行算术或逻辑运算</h5><p>执行算术或逻辑操作时，由于 ALU 本身是没有内部存储功能的组合电路，因此如要执行加法运算，相加的两个数必须在 ALU 的两个输入端同时有效。图 5.7 中的暂存器 Y 即用于该目的。先将一个操作数经 CPU 内部总线送入暂存器 Y 保存，Y 的内容在 ALU 的左输入端始终有效，再将另一个操作数经总线直接送到 ALU 的右输入端。这样两个操作数都送入了 ALU，运算结果暂存在暂存器 Z 中。</p><pre><code class="language-css">Ad(IR)→Bus→MAR MDRout和 MARin有效1→R CU发读命令MEM→数据线→MDR 操作数从存储器→数据线→MDRMDR→Bus→Y MDRout 和 Yin有效，操作数→Y(ACC)+(Y)→Z ACCout 和 ALUin有效，CU向ALU发加命令，结果→ZZ→ACC Zout和 ACCin有效，结果→ACC</code></pre><h2 id="kong-zhi-qi-de-gong-neng-he-gong-zuo-yuan-li">控制器的功能和工作原理</h2><h3 id="kong-zhi-qi-de-jie-gou-he-gong-neng">控制器的结构和功能</h3><p>从图 5.8 可以看到计算机硬件系统的五大功能部件及其连接关系。它们通过数据总线、地址总线和控制总线连接在一起，其中点画线框内的是控制器部件。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210715150655.png" alt="找不到图片(Image not found)"></p><p>控制器的主要功能有:</p><ol><li class="lvl-3"><p>从主存中取出一条指令，并指出下一条指令在主存中的位置。</p></li><li class="lvl-3"><p>对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。</p></li><li class="lvl-3"><p>指挥并控制 CPU、主存、输入和输出设备之间的数据流动方向。</p></li></ol><p>根据控制器产生微操作控制信号的方式的不同，控制器可分为<code>硬布线控制器</code>和<code>微程序控制器</code>，两类控制器中的 PC 和 IR 是相同的，但确定和表示指令执行步骤的办法以及给出控制各部件运行所需要的控制信号的方案是不同的。</p><h3 id="ying-bu-xian-kong-zhi-qi">硬布线控制器</h3><p>基本原理是根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号。它由复杂的组合逻辑门电路和一些触发器构成，因此又称<code>组合逻辑控制器</code>。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/d9481fa2bf02472bbcfb7d9af2838d29.png" alt="在这里插入图片描述"></p><h4 id="ying-bu-xian-kong-zhi-qi-de-shi-xu-xi-tong-ji-wei-cao-zuo">硬布线控制器的时序系统及微操作</h4><p>1）时钟周期。用时钟信号控制节拍发生器，可以产生节拍，每个节拍的宽度正好对应一个时钟周期。在每个节拍内机器可完成一个或几个需同时执行的操作。</p><p>2）机器周期。机器周期可视为所有指令执行过程中的一个基准时间。不同指令的操作不同，指令周期也不同。访问一次存储器的时间是固定的，因此通常以存取周期作为基准时间，即内存中读取一个指令字的最短时间作为机器周期。在存储字长等于指令字长的前提下，取指周期也可视为机器周期。</p><p>在一个机器周期里可完成若干微操作，每个微操作都需一定的时间，可用时钟信号来控制产生每个微操作命令。</p><p>3）指令周期。</p><p>4）微操作命令分析。控制单元具有发出各种操作命令（控制信号）序列的功能。这些命令与指令有关，而且必须按一定次序发出，才能使机器有序地工作。</p><p>执行程序的过程中，对于不同的指令，控制单元需发出各种不同的微操作命令。一条指令分为 3 个工作周期:取指周期、间址周期和执行周期。下面分析各个子周期的微操作命令。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210930183346.png" alt="找不到图片(Image not found)"></p><h5 id="cpu-de-kong-zhi-fang-shi">CPU 的控制方式</h5><p>控制单元控制一条指令执行的过程，实质上是依次执行一个确定的微操作序列的过程。由于不同指令所对应的微操作数及复杂程度不同，因此每条指令和每个微操作所需的执行时间也不同。主要有以下 3 种控制方式。</p><ol><li class="lvl-3"><p><code>同步控制方式</code> 。所谓同步控制方式，是指系统有一个统一的时钟，所有的控制信号均来自这个统一的时钟信号。通常以最长的微操作序列和最烦琐的微操作作为标准，采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令。同步控制方式的优点是控制电路简单，缺点是运行速度慢。</p></li><li class="lvl-3"><p><code>异步控制方式</code>。异步控制方式不存在基准时标信号，各部件按自身固有的速度工作，通过应答方式进行联络。异步控制方式的优点是运行速度快，缺点是控制电路比较复杂。</p></li><li class="lvl-3"><p><code>联合控制方式</code>。联合控制方式是介于同步、异步之间的一种折中。这种方式对各种不同的指令的微操作实行大部分采用同步控制、小部分采用异步控制的办法。</p></li></ol><h5 id="ying-bu-xian-kong-zhi-dan-yuan-she-ji-bu-zou">硬布线控制单元设计步骤</h5><p>硬布线控制单元设计步骤包括:</p><ol><li class="lvl-3"><p><strong>列出微操作命令的操作时间表</strong>。先根据微操作节拍安排，列出微操作命令的操作时间表。操作时间表中包括各个机器周期、节拍下的每条指令完成的微操作控制信号。表 5.1 列出了 CLA、COM、SHR 等 10 条机器指令微操作命令的操作时间表。表中 FE、IND 和 EX 为 CPU 工作周期标志，T<sub>0</sub>～ T<sub>2</sub>,为节拍，Ⅰ 为间址标志，在取指周期的 T<sub>2</sub>时刻，若测得 I=1，则 IND 触发器置“1”，标志进入间址周期;若 I=0，则 EX 触发器置“1”，标志进入执行周期。同理，在间址周期的 T<sub>2</sub>时刻，若测得 IND=0(表示一次间接寻址)，则 EX 触发器置“1”，进入执行周期;若测得 IND= 1(表示多次间接寻址)，则继续间接寻址。在执行周期的 T<sub>2</sub>时刻，CPU 要向所有中断源发中断查询信号，若检测到有中断请求并满足响应条件，则 INT 触发器置“1”，标志进入中断周期。表中未列出 INT 触发器置“1”的操作和中断周期的微操作。表中第一行对应 10 条指令的操作码，代表不同的指令。若某指令有表中所列出的微操作命令，其对应的单元格内为 1。</p></li><li class="lvl-3"><p><strong>进行微操作信号综合</strong>。在列出微操作时间表后，即可对它们进行综合分析、归类，根据微操作时间表可写出各微操作控制信号的逻辑表达式并进行适当的简化。表达式一般包括下列因素:</p></li></ol><p>微操作控制信号=机器周期 ∧ 节拍 ∧ 脉冲 ∧ 操作码 ∧ 机器状态条件</p><p>根据表 5.1 便可列出每个微操作命令的初始逻辑表达式，经化简、整理可获得能用现有门电路实现的微操作命令逻辑表达式。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716142423.png" alt="找不到图片(Image not found)"></p><p>例如，根据表 5.1 可写出 M(MAR)–MDR 微操作命令的逻辑表达式:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mrow><mi mathvariant="normal">M</mi></mrow><mo>(</mo><mrow><mi mathvariant="normal">M</mi><mi mathvariant="normal">A</mi><mi mathvariant="normal">R</mi></mrow><mo>)</mo><mo>→</mo><mrow><mi mathvariant="normal">M</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">R</mi></mrow></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mspace width="1em"></mspace><mo>=</mo><mrow><mi mathvariant="normal">F</mi><mi mathvariant="normal">E</mi></mrow><mo>⋅</mo><msub><mi>T</mi><mn>1</mn></msub><mo>+</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">N</mi><mi mathvariant="normal">D</mi></mrow><mo>⋅</mo><msub><mrow><mi mathvariant="normal">T</mi></mrow><mn>1</mn></msub><mo>(</mo><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">D</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">T</mi><mi mathvariant="normal">A</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">A</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">J</mi><mi mathvariant="normal">M</mi><mi mathvariant="normal">P</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">B</mi><mi mathvariant="normal">A</mi><mi mathvariant="normal">N</mi></mrow><mo>)</mo><mo>+</mo><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">X</mi></mrow><mo>⋅</mo><msub><mi>T</mi><mn>1</mn></msub><mo>(</mo><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">D</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">A</mi></mrow><mo>)</mo></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mspace width="1em"></mspace><mo>=</mo><msub><mi>T</mi><mn>1</mn></msub><mo>{</mo><mrow><mi mathvariant="normal">F</mi><mi mathvariant="normal">E</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">N</mi><mi mathvariant="normal">D</mi></mrow><mo>(</mo><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">D</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">T</mi><mi mathvariant="normal">A</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">A</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">J</mi><mi mathvariant="normal">M</mi><mi mathvariant="normal">P</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">B</mi><mi mathvariant="normal">A</mi><mi mathvariant="normal">N</mi></mrow><mo>)</mo><mo>+</mo><mrow><mi mathvariant="normal">E</mi><mi mathvariant="normal">X</mi></mrow><mo>(</mo><mrow><mi mathvariant="normal">A</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">D</mi></mrow><mo>+</mo><mrow><mi mathvariant="normal">L</mi><mi mathvariant="normal">D</mi><mi mathvariant="normal">A</mi></mrow><mo>)</mo><mo>}</mo></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned} &amp; \mathrm{M}(\mathrm{MAR}) \rightarrow \mathrm{MDR} \\ &amp; \quad=\mathrm{FE} \cdot T_1+\mathrm{IND} \cdot \mathrm{T}_1(\mathrm{ADD}+\mathrm{STA}+\mathrm{LDA}+\mathrm{JMP}+\mathrm{BAN})+\mathrm{EX} \cdot T_1(\mathrm{ADD}+\mathrm{LDA}) \\ &amp; \quad=T_1\{\mathrm{FE}+\mathrm{IND}(\mathrm{ADD}+\mathrm{STA}+\mathrm{LDA}+\mathrm{JMP}+\mathrm{BAN})+\mathrm{EX}(\mathrm{ADD}+\mathrm{LDA})\}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:2.05em;"></span><span class="strut bottom" style="height:3.6000000000000005em;vertical-align:-1.5500000000000007em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-1.2099999999999997em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span style="top:-0.00999999999999951em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span style="top:1.1900000000000006em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="col-align-l"><span class="vlist"><span style="top:-1.2099999999999997em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mord textstyle uncramped"><span class="mord mathrm">M</span></span><span class="mopen">(</span><span class="mord textstyle uncramped"><span class="mord mathrm">M</span><span class="mord mathrm">A</span><span class="mord mathrm">R</span></span><span class="mclose">)</span><span class="mrel">→</span><span class="mord textstyle uncramped"><span class="mord mathrm">M</span><span class="mord mathrm">D</span><span class="mord mathrm">R</span></span></span></span><span style="top:-0.00999999999999951em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mord mspace quad"></span><span class="mrel">=</span><span class="mord textstyle uncramped"><span class="mord mathrm">F</span><span class="mord mathrm">E</span></span><span class="mbin">⋅</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">I</span><span class="mord mathrm">N</span><span class="mord mathrm">D</span></span><span class="mbin">⋅</span><span class><span class="mord textstyle uncramped"><span class="mord mathrm">T</span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord textstyle uncramped"><span class="mord mathrm">A</span><span class="mord mathrm">D</span><span class="mord mathrm">D</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">S</span><span class="mord mathrm">T</span><span class="mord mathrm">A</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">L</span><span class="mord mathrm">D</span><span class="mord mathrm">A</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">J</span><span class="mord mathrm">M</span><span class="mord mathrm">P</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">B</span><span class="mord mathrm">A</span><span class="mord mathrm">N</span></span><span class="mclose">)</span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">E</span><span class="mord mathrm">X</span></span><span class="mbin">⋅</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord textstyle uncramped"><span class="mord mathrm">A</span><span class="mord mathrm">D</span><span class="mord mathrm">D</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">L</span><span class="mord mathrm">D</span><span class="mord mathrm">A</span></span><span class="mclose">)</span></span></span><span style="top:1.1900000000000006em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mord mspace quad"></span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">{</span><span class="mord textstyle uncramped"><span class="mord mathrm">F</span><span class="mord mathrm">E</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">I</span><span class="mord mathrm">N</span><span class="mord mathrm">D</span></span><span class="mopen">(</span><span class="mord textstyle uncramped"><span class="mord mathrm">A</span><span class="mord mathrm">D</span><span class="mord mathrm">D</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">S</span><span class="mord mathrm">T</span><span class="mord mathrm">A</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">L</span><span class="mord mathrm">D</span><span class="mord mathrm">A</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">J</span><span class="mord mathrm">M</span><span class="mord mathrm">P</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">B</span><span class="mord mathrm">A</span><span class="mord mathrm">N</span></span><span class="mclose">)</span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">E</span><span class="mord mathrm">X</span></span><span class="mopen">(</span><span class="mord textstyle uncramped"><span class="mord mathrm">A</span><span class="mord mathrm">D</span><span class="mord mathrm">D</span></span><span class="mbin">+</span><span class="mord textstyle uncramped"><span class="mord mathrm">L</span><span class="mord mathrm">D</span><span class="mord mathrm">A</span></span><span class="mclose">)</span><span class="mclose">}</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></p><p>式中，ADD、STA、LDA、JMP、BAN 均来自操作码译码器的输出。</p><ol start="3"><li class="lvl-3"><p><strong>画出微操作命令的逻辑图</strong>。根据逻辑表达式可画出对应每个微操作信号的逻辑电路图，并用逻辑门电路实现。</p></li></ol><p>例如，M(MAR)-MDR 的逻辑表达式所对应的逻辑图如图 5.10 所示，图中未考虑门的扇入系数。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716142756.png" alt="找不到图片(Image not found)"></p><blockquote><p>🤔<strong>扇入系数是什么?</strong></p><p>在数字电路设计中，“门的扇入系数”（Fan-in）是指一个逻辑门所能接受的输入数量。每个逻辑门都有一个特定的扇入限制，表示它能够连接的输入信号线的数量。</p><p>逻辑门的扇入系数取决于特定的逻辑门类型。例如，一个 2 输入的 AND 门具有扇入系数 2，意味着它可以连接两个输入信号线。如果连接了超过 2 个输入信号线，可能会导致电路设计上的问题。</p></blockquote><h3 id="wei-cheng-xu-kong-zhi-qi">微程序控制器</h3><p>微程序控制器采用存储逻辑实现，也就是把微操作信号代码化，使每条机器指令转化成为一段微程序并存入一个专门的存储器（控制存储器）中，微操作控制信号由微指令产生。</p><h4 id="wei-cheng-xu-kong-zhi-de-ji-ben-gai-nian">微程序控制的基本概念</h4><p>微程序设计思想就是将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令。这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。目前，大多数计算机都采用微程序设计技术。</p><p>微程序设计技术涉及的基本术语如下:</p><ol><li class="lvl-3"><p><strong>微命令</strong>与<strong>微操作</strong> 。一条机器指令可以分解成一个微操作序列，这些微操作是计算机中最基本的、不可再分解的操作。在微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为 微命令微命令 ，它是构成控制序列的最小单位。例如，打开或关闭某个控制门的电位信号、某个寄存器的打入脉冲等。微命令和微操作是一一对应的。微命令是微操作的控制信号，微操作是微命令的执行过程。微命令有相容性和互斥性之分。相容性微命令是指那些可以同时产生、共同完成某一些微操作的微命令;而互斥性微命令是指在机器中不允许同时出现的微命令。相容和互斥都是相对的，一个微命令可以和一些微命令相容，和另一些微命令互斥。</p></li></ol><blockquote><p>注意:在组合逻辑控制器中也存在微命令与微操作这两个概念，它们并非只是微程序控制器的专有概念。</p></blockquote><ol start="2"><li class="lvl-3"><p><strong>微指令</strong>与<strong>微周期</strong>。微指令是若干微命令的集合。存放微指令的控制存储器的单元地址称为微地址。一条微指令通常至少包含两大部分信息:</p></li></ol><p>① 操作控制字段操作控制字段 ，又称微操作码字段，用于产生某一步操作所需的各种操作控制信号。</p><p>② 顺序控制字段顺序控制字段 ，又称微地址码字段，用于控制产生下一条要执行的微指令地址。微周期通常指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。</p><ol start="3"><li class="lvl-3"><p><strong>主存储器</strong>与<strong>控制存储器</strong>。主存储器用于存放程序和数据，在 CPU 外部，用 RAM 实现;<code>控制存储器（CM）</code>用于存放微程序，在 CPU 内部，用 ROM 实现。</p></li><li class="lvl-3"><p><strong>程序</strong>与<strong>微程序</strong>。 <code>程序是指令的有序集合指令的有序集合</code> ，用于完成特定的功能; <code>微程序微程序是微指令的有序集合微指令的有序集合 </code>，<strong>一条指令的功能由一段微程序来实现</strong>。</p></li></ol><p>微程序和程序是两个不同的概念。微程序是由微指令组成的，用于描述机器指令。微程序实际上是机器指令的实时解释器，是由计算机设计者事先编制好并存放在控制存储器中的，一般不提供给用户。对于程序员来说，计算机系统中微程序的结构和功能是透明的，无须知道。而程序最终由机器指令组成，是由软件设计人员事先编制好并存放在主存或辅存中的。</p><p>读者应注意区分以下寄存器:</p><p>①<code>地址寄存器(MAR)</code>。用于存放主存的读/写地址。</p><p>②<code>微地址寄存器(CMAR或μPC)</code>。用于存放控制存储器的读/写微指令的地址。</p><p>③<code>指令寄存器（IR)</code>。用于存放从主存中读出的指令。</p><p>④<code>微指令寄存器（CMDR或μIR)</code>。用于存放从控制存储器中读出的微指令。</p><h4 id="wei-cheng-xu-kong-zhi-qi-zu-cheng-he-gong-zuo-guo-cheng">微程序控制器组成和工作过程</h4><h5 id="wei-cheng-xu-kong-zhi-qi-de-ji-ben-zu-cheng">微程序控制器的基本组成</h5><p>图 5.11 所示为一个微程序控制器的基本结构，主要画出了微程序控制器比组合逻辑控制器多出的部件，包括:</p><p>①<strong>控制存储器</strong>。它是微程序控制器的核心部件，用于存放各指令对应的微程序，控制存储器可用只读存储器 ROM 构成。</p><p>②<strong>微指令寄存器</strong>。用于存放从 CM 中取出的微指令，它的位数同微指令字长相等。</p><p>③<strong>微地址形成部件</strong>。用于产生初始微地址和后继微地址,以保证微指令的连续执行。</p><p>④<strong>微地址寄存器</strong>。接收微地址形成部件送来的微地址，为在 CM 中读取微指令作准备。</p><p><strong>微程序控制器</strong>在结构上通常位于<code>指令译码器</code>和<code>操作控制器</code>之间</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210930184630.png" alt="找不到图片(Image not found)"></p><blockquote><p>图中的控制存储器就是 CM</p></blockquote><h5 id="wei-cheng-xu-kong-zhi-qi-de-gong-zuo-guo-cheng">微程序控制器的工作过程</h5><p>微程序控制器的工作过程实际上就是在微程序控制器的控制下计算机执行机器指令的过程，这个过程可以描述如下:</p><p>① 执行取微指令公共操作。具体的执行是:在机器开始运行时，自动将取指微程序的入口地址送入 CMAR，并从 CM 中读出相应的微指令送入 CMDR。取指微程序的入口地址一般为 CM 的 0 号单元，当取指微程序执行完后，从主存中取出的机器指令就已存入指令寄存器中。</p><p>② 由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入 CMAR。</p><p>③ 从 CM 中逐条取出对应的微指令并执行。</p><p>④ 执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第 ①<br>步，以完成取下一条机器指令的公共操作。</p><p>以上是一条机器指令的执行过程，如此周而复始，直到整个程序执行完毕。</p><h4 id="wei-cheng-xu-he-ji-qi-zhi-ling">微程序和机器指令</h4><p>通常，一条机器指令对应一个微程序。由于任何一条机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编成一个微程序，这个微程序只负责将指令从主存单元中取出并送至指令寄存器。</p><p>此外，也可编出对应间址周期的微程序和中断周期的微程序。这样，控制存储器中的微程序个数应为机器指令数再加上对应取指、间址和中断周期等共用的微程序数。</p><blockquote><p>注意:若指令系统中具有 n 种机器指令，则控制存储器中的微程序数至少是 n+1(1 为公共的取指微程序)。</p></blockquote><h5 id="wei-zhi-ling-de-bian-ma-fang-shi">微指令的编码方式</h5><p>微指令的编码方式又称微指令的控制方式，是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。</p><h6 id="zhi-jie-bian-ma-zhi-jie-kong-zhi-fang-shi">直接编码（直接控制）方式</h6><p>微指令的直接编码方式如图 5.12 所示。直接编码法无须进行译码，微指令的微命令字段中每位都代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置成 1 或 0 即可。每个微命令对应并控制数据通路中的一个微操作。</p><p>这种编码的优点是简单、直观，执行速度快，操作并行性好;缺点是微指令字长过长，n 个微命令就要求微指令的操作字段有 n 位，造成控制存储器容量极大。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716143824.png" alt="找不到图片(Image not found)"></p><p>以下是一个具体的直接编码样例 👇：</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230713200142941.png" alt="image-20230713200142941"></p><blockquote><p>遵循<code>互斥性微命令</code>分在同一段内，<code>相容性微命令</code>分在不同段内。</p></blockquote><h6 id="zi-duan-zhi-jie-bian-ma-fang-shi">字段直接编码方式</h6><p>将微指令的微命令字段分成若干小字段，把互斥性微命令组合在同一字段中，把相容性微命令组合在不同字段中，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关，这就是字段直接编码方式，如图 5.13 所示。</p><p>这种方式可以缩短微指令字长，但因为要通过译码电路后再发出微命令，因此比直接编码方式慢。</p><p>微命令字段分段的原则:</p><p>① 互斥性微命令分在同一段内，相容性微命令分在不同段内。</p><blockquote><p>所谓<code>相容性</code>的微操作，是指在同时或同一个 CPU 周期内可以并行执行的 微操作。</p><p>所谓<code>相斥性</code>的微操作，是指不能在同时或不能在同一个 CPU 周期内并行执行的微操作。</p></blockquote><p>② 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。</p><p>③ 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为 3 位时，最多只能表示 7 个互斥的微命令，通常用 000 表示不操作。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210930185025.png" alt="找不到图片(Image not found)"></p><p>图 5.21 示出了一个简单运算器模型，其中 ALU 为算术逻辑单元，R1、R2、R3 为三个寄存器。三个寄存器的内容都可以通过多路开关从 ALU 的 X 输入端或 Y 输入端送至 ALU，而 ALU 的输出可以送往任何一个寄存器 或同时送往 R1，R2，R3 三个寄存器。在 我们给定的数据通路中，多路开关的每 个控制门仅是一个常闭的开关，它的一个输入端代表来自寄存器的信息，而另一个输入端则作为操作控制端。一旦两 个输入端都有输入信号时，它才产生一个输出信号，从而在控制线能起作用的 一个时间宽度中来控制信息在部件中流 动。图中每个开关门由控制器中相应的 微命令来控制，例如，开关门 4 由控制 器中编号为 4 的微命令控制，开关门 6 由编号为 6 的微命令控制，如此等等。 三个寄存器 R1、R2、R3 的时钟输入端 1、 2、3 也需要加以控制，以便在 ALU 运算 完毕而输出公共总线上电平稳定时，将结果打入到某一寄存器。另外，我们假定 ALU 只有 +，–，M(传送)三种操作。Cy 为最高进位触发器，有进位时该触发器状态为“1”。</p><p>ALU 的操作(加、减、传送)在同一个 CPU 周期中只能选择一种，不能并行，所以+，–， M(传送)三个微操作是相斥性的微操作。类似地，4、6、8 三个微操作是相斥性的，5、7、 9 三个微操作也是相斥性的。ALU 的 X 输入微操作 4、6、8 与 Y 输入的 5、7、9 这两组信号中，任意两个微操作也都是相容性的。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230713195734514.png" alt="image-20230713195734514"></p><blockquote><p>其直接编码格式如上上上图 5.22</p></blockquote><h6 id="zi-duan-jian-jie-bian-ma-fang-shi">字段间接编码方式</h6><p>一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，因此称为字段间接编码，又称隐式编码。这种方式可进一步缩短微指令字长，但因削弱了微指令的并行控制能力，因此通常作为字段直接编码方式的一种辅助手段。</p><h5 id="wei-zhi-ling-de-di-zhi-xing-cheng-fang-shi">微指令的地址形成方式</h5><p>后继微地址的形成主要有以下两大基本类型:</p><ol><li class="lvl-3"><p><strong>直接由微指令的下地址字段指出</strong>。微指令格式中设置一个下地址字段，<strong>由微指令的下地址字段直接指出后继微指令的地址，这种方式又称</strong><mark>断定方式</mark>。</p></li><li class="lvl-3"><p><strong>根据机器指令的操作码形成</strong>。机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。</p></li></ol><p>实际上，微指令序列地址的形成方式还有以下几种:</p><p>① 增量计数器法，即(CMAR)+1→CMAR，适用于后继微指令的地址连续的情况。</p><p>② 根据各种标志决定微指令分支转移的地址。</p><p>③ 通过网络测试形成。</p><p>④ 由硬件直接产生微程序入口地址。</p><p>电源加电后，第一条微指令的地址可由专门的硬件电路产生，也可由外部直接向 CMAR 输入微指令的地址，这个地址即为取指周期微程序的入口地址。</p><h5 id="wei-zhi-ling-de-ge-shi">微指令的格式</h5><p>微指令格式与微指令的编码方式有关，通常分水平型微指令和垂直型微指令两种。</p><p><strong>水平型微指令</strong></p><p>从编码方式看，<code>直接编码</code>、<code>字段直接编码</code>、<code>字段间接编码</code>和<code>混合编码</code>都属于水平型微指令。水平型微指令的基本指令格式如图 5.14 所示，指令字中的一位对应一个控制信号，有输出时为 1，否则为 0。一条水平型微指令定义并执行几种并行的基本操作。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716144416.png" alt="找不到图片(Image not found)"></p><p>水平型微指令的优点是微程序短，执行速度快;缺点是微指令长，编写微程序较麻烦。</p><p><strong>垂直型微指令</strong></p><p>垂直型微指令的特点是采用类似机器指令操作码的方式，在微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能，其基本的指令格式如图 5.15 所示。一条垂直型微指令只能定义并执行一种基本操作。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716144502.png" alt="找不到图片(Image not found)"></p><p>垂直型微指令格式的优点是微指令短、简单、规整，便于编写微程序;缺点是微程序长，执行速度慢，工作效率低。</p><p><strong>混合型微指令</strong></p><p>在垂直型的基础上增加一些不太复杂的并行操作。微指令较短，仍便于编写;微程序也不长，执行速度加快。</p><p><strong>水平型微指令和垂直型微指令的对比</strong>👇：</p><table><thead><tr><th style="text-align:left">特点</th><th style="text-align:left">水平型微指令</th><th style="text-align:left">垂直型微指令</th></tr></thead><tbody><tr><td style="text-align:left">并行操作能力</td><td style="text-align:left">强</td><td style="text-align:left">较差</td></tr><tr><td style="text-align:left">效率</td><td style="text-align:left">高</td><td style="text-align:left">低</td></tr><tr><td style="text-align:left">灵活性</td><td style="text-align:left">强</td><td style="text-align:left">较差</td></tr><tr><td style="text-align:left">执行时间</td><td style="text-align:left">短</td><td style="text-align:left">长</td></tr><tr><td style="text-align:left">微指令字长度</td><td style="text-align:left">较长</td><td style="text-align:left">较短</td></tr><tr><td style="text-align:left">微程序长度</td><td style="text-align:left">短</td><td style="text-align:left">长</td></tr><tr><td style="text-align:left">用户掌握难度</td><td style="text-align:left">高</td><td style="text-align:left">相对容易</td></tr></tbody></table><h5 id="wei-cheng-xu-kong-zhi-dan-yuan-de-she-ji-bu-zou">微程序控制单元的设计步骤</h5><p>微程序控制单元设计的主要任务是编写各条机器指令所对应的微程序。具体的设计步骤如下:</p><ol><li class="lvl-3"><p>写出对应机器指令的微操作命令及节拍安排。无论是组合逻辑设计还是微程序设计，对应相同的 CPU 结构，两种控制单元的微操作命令和节拍安排都是极相似的。如微程序控制单元在取指阶段发出的微操作命令及节拍安排如下:</p></li></ol>\begin{aligned}T_{0}&:\quad \text{PC}\to\text{MAR},\ 1\to\text{R}\\T_{1}&:\quad \text{M(MAR)}\to\text{MDR},\ (\text{PC})+1\to\text{PC}\\T_{2}&:\quad \text{MDR}\to\text{IR},\ \text{OP(IR)}\to\text{微地址形成部件}\end{aligned}<p>与硬布线控制单元相比，只在 T<sub>2</sub>节拍内的微操作命令不同。微程序控制单元在 T<sub>2</sub>节拍内要将指令的操作码送至微地址形成部件，即 OP(IR)→ 微地址形成部件，以形成该条机器指令的微程序首地址。而硬布线控制单元在 T<sub>2</sub>,节拍内要将指令的操作码送至指令译码器，以控制 CU 发出相应的微命令，即 OP(IR)→ID。</p><p>若把一个节拍 T 内的微操作安排在一条微指令中完成，上述微操作对应 3 条微指令。但由于微程序控制的所有控制信号都来自微指令，而微指令又存在控制存储器中，因此欲完成上述这些微操作，必须先将微指令从控制存储器中读出，即必须先给出这些微指令的地址。在取指微程序中，除第一条微指令外，其余微指令的地址均由上一条微指令的下地址字段直接给出，因此上述每条微指令都需增加一个将微指令下地址字段送至 CMAR 的微操作，记为 Ad(CMDR)→CMAR。取指微程序的最后一条微指令，其后继微指令的地址是由微地址形成部件形成的，即微地址形成部件 →CMAR。为了反映该地址与操作码有关，因此记为 OP(IR)→ 微地址形成部件 →CMAR。</p><p>综上所述，考虑到需要形成后继微指令地址，上述分析的取指操作共需 6 条微指令完成:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/80450e5a13714efc8bf44aaac9496007.png" alt="在这里插入图片描述"></p><p>执行阶段的微操作命令及节拍安排，分配原则类似。与硬布线控制 单元微操作命令的节拍安排相比，多了将下一条微指令地址送至 CMAR 的微操作命令，即 Ad(CMDR)→CMAR。其余的微操作命令与硬布线控制单元相同。</p><blockquote><p>注意:这里为了理解，应将微指令和机器指令相联系，因为每执行完一条微指令后要得到下一条微指令的地址。</p></blockquote><ol start="2"><li class="lvl-3"><p>确定微指令格式。微指令格式包括微指令的编码方式、后继微指令地址的形成方式和微指令字长等。</p></li></ol><p>根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数。由微指令数确定微指令的顺序控制字段的位数。最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长。</p><ol start="3"><li class="lvl-3"><p>编写微指令码点。根据操作控制字段每位代表的微操作命令，编写每条微指令的码点。</p></li></ol><h5 id="dong-tai-wei-cheng-xu-she-ji-he-hao-wei-cheng-xu-she-ji">动态微程序设计和毫微程序设计</h5><ol><li class="lvl-3"><p><strong>动态微程序设计</strong>。在一台微程序控制的计算机中，假如能根据用户的要求改变微程序，则这台机器就具有动态微程序设计功能。</p></li></ol><p>动态微程序的设计需要可写控制寄存器的支持，否则难以改变微程序的内容。实现动态微程序设计可采用可擦除可编程只读存储器（EPROM)。</p><ol start="2"><li class="lvl-3"><p><strong>毫微程序设计</strong>。在普通的微程序计算机中，从主存取出的每条指令是由放在控制存储器中的微程序来解释执行的，通过控制线对硬件进行直接控制。</p></li></ol><p>若硬件不由微程序直接控制，而是通过存放在第二级控制存储器中的毫微程序来解释的，这个第二级控制存储器就称为毫微存储器，直接控制硬件的是毫微微 指令。</p><h3 id="ying-bu-xian-kong-zhi-qi-he-wei-cheng-xu-kong-zhi-qi-de-bi-jiao">硬布线控制器和微程序控制器的比较</h3><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716150404.png" alt="找不到图片(Image not found)"></p><h2 id="zhi-ling-liu-shui-xian">指令流水线</h2><p>一条指令的执行过程可分解为若干阶段，每个阶段由相应的功能部件完成。如果将各阶段视为相应的流水段，则指令的执行过程就构成了一条指令流水线。采用流水线技术只需增加少量硬件就能把计算机的运算速度提高几倍，因此成为计算机中普遍使用的一种并行处理技术。</p><h3 id="zhi-ling-liu-shui-de-ding-yi">指令流水的定义</h3><p>根据计算机的不同，具体的分法也不同。例如，图 5.16 把一条指令的执行过程分为如下 <code>三个</code>阶段（或过程)。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716181707.png" alt="找不到图片(Image not found)"></p><p><code>取指</code> :根据 PC 内容访问主存储器，取出一条指令送到 IR 中。</p><p><code>分析</code> :对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址 EA，并从有效地址 EA 中取出操作数。</p><p><code>执行</code> :根据操作码字段，完成指令规定的功能，即把运算结果写到通用寄存器或主存中。</p><p>当多条指令在处理器中执行时,可以采用以下两种方式。</p><ol><li class="lvl-3"><p>顺序执行方式。前一条指令执行完后，才启动下一条指令，如图 5.17(a)所示。假设取指、分析、执行三个阶段的时间都相等，用 t 表示，顺序执行 n 条指令所用时间 T 为</p></li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mn>3</mn><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">T = 3nt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mrel">=</span><span class="mord mathrm">3</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span></span></p><p>传统冯·诺依曼机采用顺序执行方式，又称串行执行方式。其优点是控制简单，硬件代价小;缺点是执行指令的速度较慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低。例如取指时内存是忙碌的，而指令执行部件是空闲的。</p><ol start="2"><li class="lvl-3"><p>流水线执行方式。为了提高指令的执行速度，可以把取 k ＋ 1 条指令提前到分析第 k 条指令的期间完成，而将分析第 k ＋ 1 条指令与执行第 k 条指令同时进行，如图 5.17(b)所示。采用此种方式时，执行 n 条指令所用的时间为</p></li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mo>(</mo><mn>2</mn><mo>+</mo><mi>n</mi><mo>)</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">T = (2+n)t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mord mathit">t</span></span></span></span></span></p><p>与顺序执行方式相比，采用流水线执行方式能使指令的执行时间缩短近 2/3，各功能部件的利用率明显提高。但为此需要付出硬件上较大开销的代价，控制过程也更复杂。在理想情况下，每个时钟周期都有一条指令进入流水线，处理机中同时有 3 条指令在执行，每个时钟周期都有一条指令完成，每条指令的时钟周期数（即 CPI）都为 1。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716182135.png" alt="找不到图片(Image not found)"></p><p>为了进一步获得更高的执行速度，还可以将流水段进一步细分。如将一条指令的执行过程分为 <code>取指令</code> 、 <code>指令译码</code> 、 <code>执行</code> 和 <code>写回</code> 四个阶段，就形成了 <code>四级流水</code> ;还可进一步分为 <code>取指令(IF)</code> 、 <code>指令译码(ID)</code> 、 <code>执行(EX)</code> 、<code>访存(M)</code> 和 <code>写回(WB)</code> ，就形成了 <code>五级流水 </code>。</p><ul class="lvl-0"><li class="lvl-2"><p>各缩写的全称</p></li><li class="lvl-2"><p>IF：instruction fetch</p></li><li class="lvl-2"><p>ID：instruction decode</p></li><li class="lvl-2"><p>EX：execute</p></li><li class="lvl-2"><p>M：memory</p></li><li class="lvl-2"><p>WB：write back</p></li></ul><p>流水线设计的原则是如下:指令流水段个数以最复杂指令所用的功能段个数为准;流水段的长度以最复杂的操作所花的时间为准。假设某条指令的 5 个阶段所花的时间分别如下。① 取指:200ps;译码:100ps;③ 执行: 150ps;④ 访存 200ps;⑤ 写回 100ps。不考虑数据通路中的各种延迟，该指令的总执行时间为 750ps。按照流水线设计原则，每个流水段的长度为 200ps，所以每条指令的执行时间为 1ns，反正比串行执行时增加了 250ps。假设某程序中有 N 条指令，单周期处理机所用时间为 N×750ns。而流水处理机所用时间为 750ps + (N-1)×200。因此，<code>流水线方式并不能缩短一条指令的执行时间</code>，但是，对于整个程序来说，可以大大增加指令执行的吞吐率。</p><p>为了利于实现指令流水线，指令集应具有如下特征:</p><ol><li class="lvl-3"><p>指令长度应尽量一致，有利于简化取指令和指令译码操作。否则，取指令所花时间长短不易，使取指部件极其复杂，且也不利于指令译码。</p></li><li class="lvl-3"><p>指令格式应尽量规整，尽量保证源寄存器的位置相同，有利于在指令未知时就可取寄存器操作数，否则须译码后才能确定指令中各寄存器编号的位置。</p></li><li class="lvl-3"><p>采用 Load/Store 指令，其他指令（如运算指令）都不能访问存储器，这样可把 Load/Store 指令的地址计算和运算指令的执行步骤规整在同一个周期中，有利于减少操作步骤。</p></li><li class="lvl-3"><p>数据和指令在存储器中“<code>对齐</code>”存放。这样，有利于减少访存次数，使所需数据在一个流水段内就能从存储器中得到。</p></li></ol><h3 id="liu-shui-xian-de-biao-shi-fang-fa">流水线的表示方法</h3><p>通常用时空图来直观地描述流水线的工作过程，如图 5.18 所示。</p><p>在时空图中，横坐标表示时间，即输入流水线中的各个任务在流水线中所经过的时间。流水线中各个流水段的执行时间都相等时，横坐标就被分割成相等长度的时间段。纵坐标表示空间，即流水线的每个流水段（对应各执行部件)。</p><p>在图 5.18 中，第一条指令 I1 在时刻 T<sub>0</sub>进入流水线，在时刻 T<sub>4</sub>流出流水线。第二条指令 I——2 在时刻 T<sub>1</sub>进入流水线，在时刻 T<sub>5</sub>流出流水线。以此类推，每经过一个 Δt 时间，便有一条指令进入流水线，从时刻 t4 开始有一条指令流出流水线。</p><p>从图 5.18 中可以看出，当 t<sub>8</sub> =8Δt 时，流水线上便有 5 条指令流出。若采用串行方式执行指令，当 t8 =8Δt 时，只能执行 2 条指令，可见使用流水线方式成倍地提高了计算机的速度。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716182718.png" alt="找不到图片(Image not found)"></p><h3 id="liu-shui-xian-fang-shi-de-te-dian">流水线方式的特点</h3><p>与传统的串行执行方式相比，采用流水线方式具有如下特点:</p><ol><li class="lvl-3"><p>把一个任务（一条指令或一个操作）分解为几个有联系的子任务，每个子任务由一个专门的功能部件来执行，并依靠多个功能部件并行工作来缩短程序的执行时间。</p></li><li class="lvl-3"><p>流水线每个功能段部件后面都要有一个缓冲寄存器，或称锁存器，其作用是保存本流水段的执行结果，供给下一流水段使用。</p></li><li class="lvl-3"><p>流水线中各功能段的时间应尽量相等，否则将引起堵塞、断流。</p></li><li class="lvl-3"><p>只有连续不断地提供同一种任务时才能发挥流水线的效率，所以在流水线中处理的必须是连续任务。在采用流水线方式工作的处理机中，要在软件和硬件设计等多方面尽量为流水线提供连续的任务。</p></li><li class="lvl-3"><p>流水线需要有<code>装入时间</code>和<code>排空时间</code>。装入时间是指第一个任务进入流水线到输出流水线的时间。排空时间是指最后一个任务进入流水线到输出流水线的时间。</p></li></ol><h3 id="liu-shui-xian-de-fen-lei">流水线的分类</h3><p>按照不同的分类标准，可以把流水线分成多种不同的种类。下面从几个不同的角度介绍流水线的基本分类方法。</p><h5 id="bu-jian-gong-neng-ji-chu-li-ji-ji-he-chu-li-ji-jian-ji-liu-shui-xian">部件功能级、处理机级和处理机间级流水线</h5><p>根据流水线使用级别的不同，流水线可分为部件功能级流水线、处理机级流水线和处理机间流水线。</p><p><code>部件功能级流水</code> 将复杂的算术逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差、对阶、尾数相加及结果规格化等 4 个子过程。</p><p><code>处理机级流水</code> 把一条指令解释过程分成多个子过程，如前面提到的取指、译码、执行、访存和写回 5 个子过程。</p><p>处理机间流水是一种宏流水，其中每个处理机完成某一专门任务，各个处理机得到的结果需存放在与下一个处理机共享的存储器中。</p><h5 id="dan-gong-neng-liu-shui-xian-he-duo-gong-neng-liu-shui-xian">单功能流水线和多功能流水线</h5><p>按可以完成的功能，流水线可分为单功能流水线和多功能流水线。</p><p><code>单功能流水线</code>是指只能实现一种固定的专门功能的流水线; <code>多功能流水线</code> 是指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线。</p><h5 id="dong-tai-liu-shui-xian-he-jing-tai-liu-shui-xian">动态流水线和静态流水线</h5><p>按同一时间内各段之间的连接方式，流水线可分为静态流水线和动态流水线。</p><p><code>静态流水线</code> 指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。</p><p><code>动态流水线</code> 指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。</p><h5 id="xian-xing-liu-shui-xian-he-fei-xian-xing-liu-shui-xian">线性流水线和非线性流水线</h5><p>按流水线的各个功能段之间是否有反馈信号，流水线可分为线性流水线与非线性流水线。</p><p><code>线性流水线</code> 中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。 <code>非线性流水线</code> 存在反馈回路，从输入到输出的过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。</p><p>流水线的每个子过程由专用的功能段实现，各功能段所需的时间应尽量相等。否则，时间长的功能段将成为流水线的瓶颈。</p><h4 id="mark-ying-xiang-liu-shui-xian-de-yin-su-mark"><mark>影响流水线的因素</mark></h4><p>在指令流水线中，可能会遇到一些情况使得流水线无法正确执行后续指令而引起流水线阻塞或停顿，这种现象称为流水线冲突（冒险)。导致流水线冲突的原因主要有 3 种: <code>结构冒险(资源冲突)</code>、 <code>数据冒险(数据冲突)</code>和 <code>控制冒险(控制冲突)</code>。</p><blockquote><p>以下还是使用<code>冒险</code>,因为描述的是两个指令之间的关系和隐藏风险，而不是事实上的发生了冲突</p></blockquote><h5 id="zi-yuan-mou-xian">资源冒险</h5><p>由于多条指令在同一时刻争用同一资源而形成的冲突称为资源冲突，即由硬件资源竞争造成的冲突，有以下两种解决办法:</p><p>1）前一指令访存时，使后一条相关指令（以及其后续指令）暂停一个时钟周期。</p><p>2）单独设置数据存储器和指令存储器，使取数和取指令操作各自在不同的存储器中进行。</p><p>事实上，现代计算机都引入了 Cache 机制，而 L1 Cache 通常采用数据 Cache 和指令 Cache 分离的方式，因而也就避免了资源冲突的发生。</p><h5 id="shu-ju-mou-xian">数据冒险</h5><p>在一个程序中，下一条指令会用到当前指令计算出的结果，此时这两条指令即为数据冲突。当多条指令重叠处理时就会发生冲突，数据冲突可分为三类（结合综合题 3 理解):</p><ol><li class="lvl-3"><p><strong>写后读(Read After Write，RAW)相关</strong>:表示当前指令将数据写入寄存器后，下一条指令才能从该寄存器读取数据。否则，先读后写，读到的就是错误（旧）数据。</p></li><li class="lvl-3"><p><strong>读后写(Write After Read，WAR）相关</strong>:表示当前指令读出数据后，下一条指令才能写该寄存器。否则，先写后读，读到的就是错误（新）数据。</p></li><li class="lvl-3"><p><strong>写后写(Write After Write，WAW)相关</strong>:表示当前指令写入寄存器后，下一条指令才能写该寄存器。否则，下一条指令在当前指令之前写，将使寄存器的值不是最新值。</p></li></ol><p><em>解决的办法有以下几种</em>:</p><ol><li class="lvl-3"><p>把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行(流水线气泡)，可分为硬件阻塞(stall)和软件插入“NOP”指令(空指令,即不执行任何有用的操作，只是占据了一个时钟周期，以使后续指令延迟进入流水线)两种方法。</p></li><li class="lvl-3"><p>设置相关专用通路，即不等前一条指令把计算结果写回寄存器组，下一条指令也不再读寄存器组，而直接把前一条指令的 ALU 的计算结果作为自己的输入数据开始计算过程，使本来需要暂停的操作变得可以继续执行，这称为<code>数据旁路技术</code>(流水线定向)。</p></li><li class="lvl-3"><p>通过编译器对数据相关的指令编译优化的方法，调整指令顺序来解决数据相关。</p></li></ol><h5 id="kong-zhi-chong-tu">控制冲突</h5><p>一条指令要确定下一条指令的位置，例如在执行转移、调用或返回等指令时会改变 PC 值，而造成断流,会引起控制冒险。解决的办法有以下几种:</p><ol><li class="lvl-3"><p><strong>对转移指令进行分支预测</strong>，尽早生成转移目标地址。分支预测分为简单（静态）预测和动态预测。静态预测总是预测条件不满足，即继续执行分支指令的后续指令。动态预测根据程序执行的历史情况，进行动态预测调整，有较高的预测准确率。</p></li><li class="lvl-3"><p><strong>预取转移成功和不成功两个控制流方向上的目标指令</strong>。</p></li><li class="lvl-3"><p>加快和提前形成条件码。</p></li><li class="lvl-3"><p>提高转移方向的猜准率。</p></li></ol><blockquote><p>注意:Cache 缺失的处理过程也会引起流水线阻塞。在不过多增加硬件成本的情况下，如何尽可能地提高指令流水线的运行效率是选用指令流水线技术必须解决的关键问题。</p></blockquote><h3 id="mark-liu-shui-xian-de-xing-neng-zhi-biao-mark"><mark>流水线的性能指标</mark></h3><p>衡量流水线性能的主要指标有<code>吞吐率</code>、<code>加速比</code>和<code>效率</code>。下面以<a href="#####%E7%BA%BF%E6%80%A7%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%B5%81%E6%B0%B4%E7%BA%BF">线性流水线</a>为例分析流水线的主要性能指标，其分析方法和有关公式也适用于非线性流水线。</p><h4 id="tun-tu-lu">吞吐率</h4><p>流水线的吞吐率 TP(Through Put)是指<strong>单位时间内流水线所完成的任务数量或输出结果的数量</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>P</mi><mo>=</mo><mfrac><mi>n</mi><mrow><msub><mi>T</mi><mi>k</mi></msub></mrow></mfrac><mspace width="2em"></mspace><mspace width="2em"></mspace><mtext><mi mathvariant="normal">(</mi><mn>3</mn><mi mathvariant="normal">.</mi><mn>1</mn><mi mathvariant="normal">)</mi></mtext></mrow><annotation encoding="application/x-tex">TP=\frac n{T_k}\qquad\qquad\text{(3.1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.10756em;"></span><span class="strut bottom" style="height:1.9435600000000002em;vertical-align:-0.8360000000000001em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mord mspace qquad"></span><span class="mord mspace qquad"></span><span class="text mord displaystyle textstyle uncramped"><span class="mord mathrm">(</span><span class="mord mathrm">3</span><span class="mord mathrm">.</span><span class="mord mathrm">1</span><span class="mord mathrm">)</span></span></span></span></span></span></p><p>其中,n 为任务数,T<sub>k</sub>是处理完 n 个任务所用的时间,这是计算流水线吞吐率的最基本的公式</p><p><strong>各段时间均相等的流水线</strong></p><p>以下为个段时间均相等(都是 Δt)的线性流水的时空图。这里假设段数为 k,连续输入 n 个任务第一个任务输入后,经过 kΔt 的时间从输出端流出(完成)。此后的 n-1 个 Δt 中,每个 Δt 时间完成一个任务。在这种情况下,流水线完成 n 个连续任务所需要的总时间为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>k</mi></msub><mo>=</mo><mi>k</mi><mi mathvariant="normal">Δ</mi><mi>t</mi><mo>+</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi><mo>=</mo><mo>(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi><mspace width="2em"></mspace><mspace width="2em"></mspace><mtext><mi mathvariant="normal">(</mi><mn>3</mn><mi mathvariant="normal">.</mi><mn>2</mn><mi mathvariant="normal">)</mi></mtext></mrow><annotation encoding="application/x-tex">T_k = k\Delta t + (n-1)\Delta t = (k+n-1)\Delta t \qquad\qquad \text{(3.2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span><span class="mord mspace qquad"></span><span class="mord mspace qquad"></span><span class="text mord displaystyle textstyle uncramped"><span class="mord mathrm">(</span><span class="mord mathrm">3</span><span class="mord mathrm">.</span><span class="mord mathrm">2</span><span class="mord mathrm">)</span></span></span></span></span></span></p><p>将式 3.2 带入式 3.1 中得<strong>流水线实际吞吐率</strong>为:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>P</mi><mo>=</mo><mfrac><mi>n</mi><mrow><mo>(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">TP = \frac n{(k+n-1)\Delta t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.10756em;"></span><span class="strut bottom" style="height:2.0435600000000003em;vertical-align:-0.936em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span><span style="top:-0.2300000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><p>这种情况下的<strong>最大吞吐率</strong>为:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><msub><mi>P</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><msub><mi>lim</mi><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mfrac><mi>n</mi><mrow><mo>(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">TP_{max}=\lim\limits_{x \to \infty} \frac n{(k+n-1)\Delta t} = \frac 1{\Delta t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.32144em;"></span><span class="strut bottom" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mop op-limits"><span class="vlist"><span style="top:0.6em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">x</span><span class="mrel">→</span><span class="mord mathrm">∞</span></span></span></span><span style="top:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span><span class="mop">lim</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span><span style="top:-0.2300000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716183823.png" alt="找不到图片(Image not found)"></p><p>由以上式子可知流水线的实际吞吐率总是小于最大吞吐率</p><p><strong>各段不完全相等的流水线</strong></p><p>在下图(a)所示的流水线中，各段时间不完全相等。其中 S<sub>1</sub>S<sub>2</sub>S<sub>3</sub>,S<sub>5</sub>各段的时间都是 Δt,S<sub>4</sub>的时间是 3Δt ,是其他各段时间的 3 倍。S<sub>4</sub>是该<strong>流水线的瓶颈段</strong>。除了第一个任务外,其余(n-1)个任务必须按瓶颈段的时间间隔 max(Δt<sub>1</sub> ,Δt<sub>2</sub>,…,Δt<sub>k</sub>)连续流入流水线。图(b)是该流水线的时空图，图中的灰色方格表示相应流水段在这一段时间内是空闲的。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230714171756533.png" alt="image-20230714171756533"></p><p><em>实际吞吐率为</em>:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">P</mi></mrow><mo>=</mo><mfrac><mrow><mi>n</mi></mrow><mrow><msup><mo>∑</mo><mi>k</mi></msup><mi mathvariant="normal">Δ</mi><msub><mi>t</mi><mi>i</mi></msub><mo>+</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi>max</mi><mo>(</mo><mi mathvariant="normal">Δ</mi><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋅</mo><mo>⋅</mo><mo>⋅</mo><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><msub><mi>t</mi><mi>k</mi></msub><mo>)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\mathrm{TP}=\frac{n}{\sum\limits^k\Delta t_i+(n-1)\max(\Delta t_1,\Delta t_2,\cdot\cdot\cdot,\Delta t_k)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.10756em;"></span><span class="strut bottom" style="height:2.783678em;vertical-align:-1.676118em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord displaystyle textstyle uncramped"><span class="mord mathrm">T</span><span class="mord mathrm">P</span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:1.426113em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mop op-limits"><span class="vlist"><span style="top:-0.000004999999999977245em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span><span class="op-symbol small-op mop">∑</span></span></span><span style="top:-0.950005em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathrm">Δ</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathrm">Δ</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">Δ</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord">⋅</span><span class="mbin">⋅</span><span class="mord">⋅</span><span class="mpunct">,</span><span class="mord mathrm">Δ</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><blockquote><p>max(Δt<sub>1</sub> ,Δt<sub>2</sub>,…,Δt<sub>k</sub>)为得出 Δt<sub>1</sub> ,Δt<sub>2</sub>,…,Δt<sub>k</sub>之间的最大值带入计算</p></blockquote><p>其中 Δt<sub>i</sub>为第 i 段的时间，共有 k 个段。分母中的第一部分是流水线完成第一个任务所用的时间;第二部分是完成其余 n-1 个任务所用的时间。</p><p><em>流水线最大吞吐率为</em>:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><msub><mi>P</mi><mrow><mi>max</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>max</mi><mo>(</mo><mi mathvariant="normal">Δ</mi><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mi mathvariant="normal">Δ</mi><msub><mi>t</mi><mi>k</mi></msub><mo>)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">TP_{\max}=\frac1{\max(\Delta t_1,\Delta t_2,\cdotp\cdotp\cdotp\Delta t_k)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.32144em;"></span><span class="strut bottom" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mop">max</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mop">max</span><span class="mopen">(</span><span class="mord mathrm">Δ</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord mathrm">Δ</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mpunct">⋅</span><span class="mpunct">⋅</span><span class="mpunct">⋅</span><span class="mord mathrm">Δ</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span><span style="top:-0.2300000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><p>对于上图的例子.最大吞吐率为:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><msub><mi>P</mi><mrow><mi>max</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>3</mn><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">TP_{\max}=\frac1{3\Delta t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.32144em;"></span><span class="strut bottom" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mop">max</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">3</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><p>从上式可以看出，当流水线各段的时间不完全相等时，流水线的最大吞吐率和实际吞吐率由时间最长的那个段决定,这个段就成了整条流水线的瓶颈。这时，瓶颈段一直处于忙碌状态，而其余各段则在许多时间内都是空闲的，硬件使用效率低。</p><p>可以用下面两种方法来消除瓶颈段(将其转换为各段时间相等的流水线)。</p><p><strong>细分瓶颈法</strong></p><p>把流水线中的瓶颈段切分为几个独立的功能段,从而使流水线各段的处理时间都相等。把瓶颈段 S<sub>4</sub>细分为 3 个子流水线段：S<sub>4-1</sub>，S<sub>4-2</sub>，S<sub>4-3</sub>。这样所产生的流水线各段时间均为 Δt,即每隔 Δt 流出一个结果</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230714175113790.png" alt="image-20230714175113790"></p><p><strong>重复设置瓶颈段</strong></p><p>如果无法把瓶颈段再细分，就可以采用重复设置瓶颈段的方法来解决问题。重复设置的段并行工作，在时间上依次错开处理任务。这种方法的缺点是控制逻辑比较复杂，所需要的硬件也增加了。​ 下图给出了把 S<sub>4</sub>,重复设置后的流水线及时空图。这里，从 S<sub>3</sub>到并列的 S<sub>4a</sub>,S<sub>4b</sub>,S<sub>4c</sub>之间需要设置一个数据分配器，它把从 S<sub>3</sub>输出的第一个任务分配给 S<sub>4a</sub>,第二个任务分配给 S<sub>4b</sub>,第三个任务分配给 S<sub>4c</sub>之后按此重复。而在 S<sub>4a</sub>,S<sub>4b</sub>,S<sub>4c</sub>到 S<sub>5</sub>之间需要设置一个数据收集器、依次分时将数据收集到 S<sub>5</sub>中。改进后的流水线能做到每隔 Δt 流出一个结果。</p><p>重复设置瓶颈段示意图 👇：</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230714180014032.png" alt="image-20230714180014032"></p><p>对应的流水时空图 👇：</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/image-20230714180056753.png" alt="image-20230714180056753"></p><p>上述两种方法都能使改进后的流水线最大吞吐率达到</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><msub><mi>P</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">TP_{max} = \frac 1{\Delta t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.32144em;"></span><span class="strut bottom" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">m</span><span class="mord mathit">a</span><span class="mord mathit">x</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><h4 id="jia-su-bi">加速比</h4><p>完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比，称为流水线的<code>加速比 </code>。</p><p>不使用流水线（即顺序执行）所用的时间为 T<sub>s</sub>，使用流水线后所用的时间为 T<sub>k</sub>，则该流水线的加速比为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mfrac><mrow><msub><mi>T</mi><mi>s</mi></msub></mrow><mrow><msub><mi>T</mi><mi>k</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">S=\frac{T_s}{T_k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.36033em;"></span><span class="strut bottom" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><p>若流水线各段执行的时间都相等，则一条 k 段流水线完成 n 个任务所需的时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>k</mi></msub><mo>=</mo><mo>(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">T_k=(k+n-1)\Delta t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span>。而不使用流水线，即顺序执行 n 个任务时，所需的时间为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mi>k</mi></msub><mo>=</mo><mi>k</mi><mi>n</mi><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">T_k=kn\Delta t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit">n</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span>。将和值代入上式，得实际加速比为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mfrac><mrow><mi>k</mi><mi>n</mi><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow><mrow><mo>(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>k</mi><mi>n</mi></mrow><mrow><mo>(</mo><mi>k</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">S=\frac{kn\Delta t}{(k+n-1)\Delta t}=\frac{kn}{(k+n-1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.37144em;"></span><span class="strut bottom" style="height:2.30744em;vertical-align:-0.936em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span><span style="top:-0.2300000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit">n</span><span class="mord mathrm">Δ</span><span class="mord mathit">t</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span></span></span></span><span style="top:-0.2300000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">n\to \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mrel">→</span><span class="mord mathrm">∞</span></span></span></span>时，最大加速比为 S<sub>max</sub> = k</p><h4 id="xiao-lu">效率</h4><p>流水线的设备利用率称为流水线的<code>效率</code>。在时空图上，流水线的效率定义为完成 n 个任务占用的时空区有效面积，与 n 个任务所用的时间及 k 个流水段所围成的时空区总面积之比。因此，流水线的效率包含了时间和空间两个因素。</p><p>n 个任务占用的时空区有效面积就是顺序执行 n 个任务所使用的总时间 T<sub>0</sub>，而 n 个任务所用的时间与 k 个流水段所围成的时空区总面积为 kT<sub>k</sub>，其中 T<sub>k</sub>是流水线完成 n 个任务所使用的总时间，因此计算流水线效率（E)的一般公式为</p>E=\frac {n个任务占用的时空区有效面积}{n个任务所用时间与k个流水段所围成的时空区总面积} = \frac {T_0}{kT_k}<p>若流水线的各段执行时间相等，上式中的分子部分是 n 个任务实际占用的有效面积，分母部分是完成 n 个任务所用的时间与 k 个流水段所围成的总面积。因此，通过时空图来计算流水线的效率非常方便。</p><p>流水线的各段执行时间均相等，当连续输入的任务数 n→∞ 时，最高效率为 E=1。</p><h3 id="mark-wu-duan-shi-zhi-ling-liu-shui-xian-mark"><mark>五段式指令流水线</mark></h3><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/e344585772fa4a45a228018db89afbfc.png" alt="在这里插入图片描述"></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/be46112aa19441c693c6055ca302d0b0.png" alt="在这里插入图片描述"></p><h4 id="yun-suan-lei-zhi-ling">运算类指令</h4><p>重点关注 运算类指令 各阶段的操作；</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/fb1878e37d2743b49542cee416a6beca.png" alt="在这里插入图片描述"></p><h4 id="load-zhi-ling">LOAD 指令</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/1e9acc5bcacd44a2adfe4c37240198c2.png" alt="在这里插入图片描述"></p><h4 id="store-zhi-ling">STORE 指令</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/47b21adcbcbb40b2b6753e95de074209.png" alt="在这里插入图片描述"></p><h4 id="tiao-jian-zhuan-yi-zhi-ling">条件转移指令</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/2c2025c254754b94bf97e88d45f388de.png" alt="在这里插入图片描述"></p><h4 id="wu-tiao-jian-zhuan-yi-zhi-ling">无条件转移指令</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/d416f4cd1a914a61b3f62ee2675cdf5a.png" alt="在这里插入图片描述"></p><h3 id="gao-ji-liu-shui-ji-zhu">高级流水技术</h3><p>有两种增加指令级并行的策略：</p><p>一种是多发射技术，它通过采用多个内部功能部件，使流水线功能段能同时处理多条指令，处理及一次可以发射多条指令进入流水线执行</p><p>另一种是超流水线技术，它通过增加流水线级数来使更多的指令同时在流水线中重叠执行</p><h4 id="chao-biao-liang-liu-shui-xian-ji-zhu">超标量流水线技术</h4><p>每个时钟周期内可并发多条独立指令，即以并行操作方式将两条或多条指令编译并执行，为此需配置多个功能部件。</p><p>超标量计算机不能调整指令的执行顺序，因此通过编译优化技术，把可并行执行的指令搭配起来，挖掘更多的指令并行性，如图 5.20 所示。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716184812.png" alt="找不到图片(Image not found)"></p><h4 id="chao-chang-zhi-ling-zi">超长指令字</h4><p>又称<code>静态发射技术</code>，由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字（可达几百位)，为此需要采用多个处理部件。</p><h4 id="chao-liu-shui-xian-ji-zhu">超流水线技术</h4><p>流水线功能划分得越多,时钟周期就越短，指令吞吐率也就越高,因此<strong>超流水线技术是通过提高流水线主频得方式来提升流水线的性能</strong>。但是流水线级数越多，用于流水线寄存器的开销也就越大，因而流水线级数是有限制的，并不是越多越好</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716184857.png" alt="找不到图片(Image not found)"></p><p>超流水线 CPU 在流水线充满后，每个时钟周期还是执行一条指令，CPI=1，但其主频更高</p><p>多发射流水线 CPU 每个时钟周期可以处理多条指令，CPI&lt;1，相对而言，多发射里露水线成本更高，控制更复杂</p><pre><code class="language-css">下列给出的处理器类型中理想情况下 CPI 为 1 的是:()I、单周期 CPU；II、多周期 CPU ；III、基本流水线 CPU； IV 超标量流水线 CPUA、I，II； B、I,III; C、II,IV; D、III,IV；解析：理想情况下 CPI（Cycle Per Instruction）为 1 表示每个指令在理想情况下只需要一个时钟周期来执行。根据给出的处理器类型，我们来分析每种类型的 CPU 是否满足 CPI 为 1。I. 单周期 CPU：在单周期 CPU 中，每条指令都需要相同数量的时钟周期来执行，因此 CPI 可能为 1。因此，I 是一个可能满足 CPI 为 1 的选项。II. 多周期 CPU：在多周期 CPU 中，不同类型的指令可能需要不同数量的时钟周期来执行，因此 CPI 不一定为 1。因此，II 不满足 CPI 为 1。III. 基本流水线 CPU：在基本流水线 CPU 中，指令被划分为多个阶段，并且多个指令可以同时执行。在理想情况下，每个阶段只需要一个时钟周期，因此 CPI 可能为 1。因此，III 是一个可能满足 CPI 为 1 的选项。IV. 超标量流水线 CPU：在超标量流水线 CPU 中，多个指令可以同时执行，但每个指令可能需要多个时钟周期来执行完整的流水线流程。因此，CPI 不一定为 1。因此，IV 不满足 CPI 为 1。综上所述，满足 CPI 为 1 的选项是 B、I,III。因此，答案是 B。其中，单周期 CPU (I) 和基本流水线 CPU (III) 是理想情况下 CPI 为 1 的处理器类型。</code></pre><h2 id="duo-chu-li-qi-de-ji-ben-gai-nian">多处理器的基本概念</h2><h3 id="sisd-simd-mimd">SISD、SIMD、MIMD</h3><p>基于指令流的数量和数据流的数量，计算机体系结构的分类。</p><h4 id="dan-zhi-ling-liu-dan-shu-ju-liu-jie-gou-sisd">单指令流单数据流结构(SISD)</h4><p><code>(Single Instruction Single Data,SISD)</code></p><p>传统的串行计算机结构，通常只包含一个处理器和一个存储器。有些使用流水线的方式，所以有时会设置多个功能部件，并采用多模块交叉方式组织存储器。（之前介绍的大多都是 SISD 结构）</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/aae30ec640a345f6b2ed7d39bacd049b.png" alt="在这里插入图片描述"></p><h4 id="dan-zhi-ling-liu-duo-shu-ju-liu-jie-gou-simd">单指令流多数据流结构（SIMD）</h4><p><code>(Single Instruction Multiple Data,SIMD)</code></p><p>一个指令流同时对多个数据流进行处理，一般称为数据级并行技术。通常是由一个指令控制部件、多个处理单元组成。每个处理单元虽然执行的都是同一条指令，但每个单元都有自己的地址寄存器，就有了不同的数据地址。一个顺序应用程序被编译之后，可能按照 SISD 组织并运行与串行硬件上，也可能按 SIMD 组织并运行于并行硬件上。</p><p>for 循环效率高，但 switch 或 case 时效率低。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/a698d9454c6748fd955f7cde99d7b28f.png" alt="在这里插入图片描述"></p><p>向量处理器也是 SIMD 的变体，是一种实现了直接操作一维数组（向量）指令集的 CPU。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/80bf2635f10b443996352f52aa008128.png" alt="在这里插入图片描述"></p><h4 id="duo-zhi-ling-liu-dan-shu-ju-liu-jie-gou-misd">多指令流单数据流结构（MISD）</h4><p>同时执行多条指令，处理同一个数据，实际上不存在这样的计算机。</p><h4 id="duo-zhi-ling-liu-duo-shu-ju-liu-jie-gou-mimd">多指令流多数据流结构（MIMD）</h4><p><code>(Multiple Instruction Multiple Data,MIMD)</code></p><p>同时执行多条指令，处理多个不同的数据。分为多计算机系统和多处理器系统。<code>多计算机系统</code>：每个计算机节点都具有各自的私有存储器，并且具有独立的主存地址空间，不能通过存取指令来访问不同节点的私有存储器，而要通过消息传递进行数据传送，也称为消息传递 MIMD。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/3b2815de8c7b45fd92480579ae993519.png" alt="在这里插入图片描述"></p><p><code>多处理器系统</code>：共享存储多处理器（SMP）系统的简称，它具有共享的单一地址空间，通过访存指令来访问系统中的所有存储器，也称共享存储 MIMD</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/1c0220e29fdd4af883fbd1823642bdd5.png" alt="在这里插入图片描述"></p><p>SIMD 和 MIMD 是两种并行计算模式，其中<strong>SIMD 是一种数据级并行模式</strong>，而<strong>MIMD 是一种并行程度更高的线程级并行或线程级以上并行计算模式</strong>。</p><h3 id="ying-jian-duo-xian-cheng-de-ji-ben-gai-nian">硬件多线程的基本概念</h3><p>在传统的 CPU 中，线程的切换包含了一系列开销，频繁切换回极大影响系统性能，为了减少这些开销，便诞生了硬件多线程。</p><p>硬件多线程中必须为每个线程提供单独的通用寄存器组、单独的程序计数器等，线程的激活只需要激活选中的寄存器，从而省略了与存储器数据交换的环节，节省了开销。</p><p>三种实现方式：</p><ol><li class="lvl-3"><p><strong>细粒度多线程</strong></p></li></ol><p>多个线程之间轮流交叉执行指令，多个线程之间的指令是互不相关的，可以乱序并行执行。该方式下，处理器能在每个时钟周期切换线程。</p><ol start="2"><li class="lvl-3"><p><strong>粗粒度多线程</strong></p></li></ol><p>仅在一个线程出现较大开销的阻塞时，才切换线程，如 Cache 缺失。当发生流水线阻塞的时候，必须清除被阻塞的流水线，新线程的指令开始执行前需要重载流水线，开销较上一种较大。</p><ol start="3"><li class="lvl-3"><p><strong>同时多线程（SMT）</strong></p></li></ol><p>SMT 是上述两种多线程技术的变体。它是实现指令级并行的同时，实现线程级的并行，即在同一时钟周期内，发射不同线程中的多条指令执行。</p><p>Intel 处理器中的超线程即使 SMT，在一个单处理器或的那个核中设置了两套线程状态部件，共享高速缓存和功能部件。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/1f193862d63442a9a475cf98a07586fa.png" alt="在这里插入图片描述"></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/f45ea43a584f4654aa368ce0be701017.png" alt="在这里插入图片描述"></p><h3 id="duo-he-chu-li-qi-de-ji-ben-gai-nian">多核处理器的基本概念</h3><p>**将多个处理单元集成到单个 CPU 中，每个处理单元称为一个核（core）。**每个核可以有自己的 Cache，也可以共享一个 Cache。所有核一般都是对称的，并且共享主存，因此<code>多核属于共享存储的对称多处理器</code>。</p><p>在多核计算机系统中，若要充分发挥硬件的性能，必须采用多线程执行，使每个核在同一时刻都有线程在执行，这是真正的并行执行。</p><h3 id="gong-xiang-nei-cun-duo-chu-li-qi-de-ji-ben-gai-nian">共享内存多处理器的基本概念</h3><p><strong>具有共享的单一物理地址空间的多处理器被称为共享内存多处理器（SMP）</strong>。处理器通过存储器中的共享变量相互通信，所有处理器都能通过存取指令访存任何存储器的位置。（即使这些系统共享同一个物理地址空间，它们仍然可以在自己的虚拟地址空间中单独地运行程序）</p><p>单一地址空间的多处理器分类：</p><ol><li class="lvl-3"><p><code>统一存储访问（UMA）多处理器</code>：根据处理器与共享存储器之间的连接方式，分为基于总线、基于交叉开关网络和基于多级交换网络连接等几种处理器。（每个处理器对所有存储单元的访问时间都是大致相同的）</p></li><li class="lvl-3"><p><code>非统一存储访问（NUMA）多处理器</code>：处理器中不带高速缓存时，被称为 NC-NUMA；处理器中带有一致性高速缓存时，被称为 CC-NUMA，（某些访问请求要比其他的快）</p></li></ol><h1 id="zong-xian">总线</h1><h2 id="zong-xian-gai-shu">总线概述</h2><p>随着计算机的发展和应用领域的不断扩大，IO 设备的种类和数量也越来越多。为了更好地解决 IO 设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为总线连接。为了进一步简化设计，又提出了各类总线标准。</p><h3 id="zong-xian-ji-ben-gai-nian">总线基本概念</h3><h4 id="zong-xian-de-ding-yi">总线的定义</h4><p>总线是一组能为多个部件分时共享的公共信息传送线路。<code>分时</code>和<code>共享</code>是总线的两个特点。</p><p><code>分时 </code>是指同一时刻只允许有一个部件向总线发送信息，若系统中有多个部件，则它们只能分时地向总线发送信息。</p><p><code>共享 </code>是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可通过这组线路分时共享。在某一时刻只允许有一个部件向总线发送信息，但多个部件可同时从总线上接收相同的信息。</p><h4 id="zong-xian-she-bei">总线设备</h4><p>总线上所连接的设备，按其对总线有无控制功能可分为<code>主设备</code>和<code>从设备</code>两种。</p><p><code>主设备</code> ：总线的主设备是指获得总线控制权的设备。</p><p><code>从设备</code> ：总线的从设备是指被主设备访问的设备，它只能响应从主设备发来的各种总线命令。</p><h4 id="zong-xian-te-xing">总线特性</h4><p>总线特性是指<code>机械特性</code>（尺寸、形状)、 <code>电气特性</code>（传输方向和有效的电平范围)、 <code>功能特性</code>（每根传输线的功能）和 <code>时间特性</code> （信号和时序的关系)。</p><h4 id="mark-zong-xian-de-cu-fa-chuan-shu-fang-shi-mark"><mark>总线的猝发传输方式</mark></h4><p>在一个总线周期内传输存储地址连续的多个数据字的总线传输方式，称为<code>猝发传送</code> 。</p><ul class="lvl-0"><li class="lvl-2"><p>又称<code>突发传输</code></p></li><li class="lvl-2"><p>传送一个起始地址之后，可以连续读取连续的地址的内容</p></li><li class="lvl-2"><p>没有突发传输的话，后面的内容每一次都要传送地址</p></li></ul><pre><code class="language-css">【2012统考真题】某同步总线的时钟频率为100MHz，宽度为32位，地址/数据线复用，每传输一个地址或数据占用一个时钟周期。若该总线支持突发（猝发）传输方式，则一次“主存写”总线事务传输128位数据所需要的时间至少是（）.A. 20nsB.40nsC.50nsD. 80ns解析3.C由于总线频率为100MHz，因此时钟周期为 10ns。总线位宽与存储字长都是32位，因此每个时钟周期可传送一个32位存储字。猝发式发送可以连续传送地址连续的数据，因此总传送时间为:传送地址10ns，传送128位数据40ns，共需50ns。</code></pre><h3 id="zong-xian-de-fen-lei">总线的分类</h3><p>计算机系统中的总线，按功能划分为以下 3 类。</p><h4 id="pian-nei-zong-xian">片内总线</h4><p>片内总线是芯片内部的总线，它是 CPU 芯片内部寄存器与寄存器之间、寄存器与 ALU 之间的公共连接线。</p><h4 id="xi-tong-zong-xian">系统总线</h4><p>系统总线是计算机系统内各功能部件(CPU、主存、I/O 接口)之间相互连接的总线。按系统总线传输信息内容的不同，又可分为 3 类：<code>数据总线</code>、<code>地址总线</code>和<code>控制总线</code>。</p><ol><li class="lvl-3"><p><code>数据总线</code> 用来传输各功能部件之间的数据信息，它是<code>双向传输总线</code>，其位数与<code>机器字长 </code>、<code> 存储字长</code>有关。</p></li><li class="lvl-3"><p><code>地址总线</code> 用来指出数据总线上的源数据或目的数据所在的 <code>主存单元</code> 或 <code>I/O端口的地址</code> ，它是<code>单向传输总线</code>，地址总线的位数与主存地址空间的大小有关。</p></li><li class="lvl-3"><p><code>控制总线</code> 传输的是控制信息，包括 CPU 送出的控制命令和主存（或外设）返回 CPU 的反馈信号。</p></li></ol><blockquote><p>注意区分数据通路和数据总线:各个功能部件通过数据总线连接形成的数据传输路径称为数据通路。数据通路表示的是数据流经的路径，而 <code>数据总线</code>是承载的媒介。</p></blockquote><h4 id="tong-xin-zong-xian">通信总线</h4><p>通信总线是在计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间传送信息的总线，通信总线也称外部总线。</p><p>此外，按时序控制方式可将总线划分为 <code>同步总线</code> 和 <code>异步总线</code> ，还可按数据传输格式将总线划分为 <code>并行总线</code> 和 <code>串行总线</code> 。</p><h3 id="xi-tong-zong-xian-de-jie-gou">系统总线的结构</h3><p>总线结构通常分为<code>单总线结构</code>、<code>双总线结构</code>和<code>三总线结构</code>等。</p><h4 id="dan-zong-xian-jie-gou">单总线结构</h4><p>单总线结构将 CPU、主存、IO 设备（通过 IO 接口）都挂在<code>一组</code>总线上，允许 IO 设备之间、IO 设备与主存之间直接交换信息，如图 6.1 所示。CPU 与主存、CPU 与外设之间可直接进行信息交换，而无须经过中间设备的干预。</p><blockquote><p>注意，单总线并不是指只有一根信号线，系统总线按传送信息的不同可细分为地址总线、数据总线和控制总线。</p></blockquote><p>优点:结构简单，成本低，易于接入新的设备;缺点:带宽低、负载重，多个部件只能争用唯一的总线，且不支持并发传送操作。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20211002141738.png" alt="找不到图片(Image not found)"></p><h4 id="shuang-zong-xian-jie-gou">双总线结构</h4><p>双总线结构有两条总线:一条是 <code>主存总线 </code>，用于在 CPU、主存和通道之间传送数据;另一条是<code>IO总线</code> ，用于在多个外部设备与通道之间传送数据，如图 6.2 所示。</p><p>优点:将低速 IO 设备从单总线上分离出来，实现了存储器总线和 IO 总线分离。缺点:需要增加通道等硬件设备。</p><h4 id="san-zong-xian-jie-gou">三总线结构</h4><p>三总线结构是在计算机系统各部件之间采用 3 条各自独立的总线来构成信息通路，这 3 条总线分别为<code>主存总线 </code>、 <code>IO总线</code> 和 <code>直接内存访问(Direct Memory Access,DMA)总线 </code>，如图 6.3 所示。</p><p>主存总线用于在 CPU 和内存之间传送地址、数据和控制信息。IO 总线用于在 CPU 和各类外设之间通信。DMA 总线用于在内存和高速外设之间直接传送数据。</p><p>优点:提高了 IO 设备的性能，使其更快地响应命令，提高系统吞吐量。缺点:系统工作效率较低。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716190047.png" alt="找不到图片(Image not found)"></p><h3 id="mark-zong-xian-de-xing-neng-zhi-biao-mark"><mark>总线的性能指标</mark></h3><ol><li class="lvl-3"><p>总线的<strong>传输周期</strong> 。指一次总线操作所需的时间（包括申请阶段、寻址阶段、传输阶段和结束阶段)，简称<code>总线周期</code>。总线传输周期通常由若干总线时钟周期构成。</p></li><li class="lvl-3"><p>总线<strong>时钟周期</strong> 。即机器的时钟周期。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。</p></li><li class="lvl-3"><p>总线的<strong>工作频率</strong> 。总线上各种操作的频率，为<code>总线周期的倒数</code>。实际上指<strong>1 秒内传送几次数据</strong>。若总线周期=N 个时钟周期，则总线的工作频率=时钟频率/N。</p></li><li class="lvl-3"><p>总线的<strong>时钟频率</strong> 。即机器的时钟频率，它为时钟周期的倒数。</p></li><li class="lvl-3"><p>总线<strong>宽度</strong> 。又称总线位宽，它是总线上同时能够传输的数据位数，通常指<code> 数据总线的根数</code>，如 32 根称为 32 位总线。</p></li><li class="lvl-3"><p>总线<strong>带宽</strong> 。可理解为总线的 数据传输率数据传输率 ，即单位时间内总线上可传输数据的位数，通常用每秒传送信息的字节数来衡量，单位可用字节/秒（B/s）表示。总线带宽=总线工作频率 ×(总线宽度/8)。</p></li></ol><blockquote><p>注意:总线带宽和总线宽度应加以区别。</p></blockquote><ol start="7"><li class="lvl-3"><p>总线<strong>复用</strong> 。总线复用是指一种信号线在不同的时间传输不同的信息，因此可以使用较少的线传输更多的信息，从而节省空间和成本。</p></li><li class="lvl-3"><p>信号<strong>线数</strong> 。 <code>地址总线</code> 、 <code>数据总线</code> 和 <code>控制总线</code> 3 种总线数的总和称为信号线数。其中，总线的最主要性能指标为总线宽度、总线（工作）频率、总线带宽，总线带宽是指总线本身所能达到的最高传输速率，它是衡量总线性能的重要指标。</p></li></ol><p>三者关系:总线带宽=总线宽度 × 总线频率。</p><p>例如，总线工作频率为 22MHz，总线宽度为 16 位，则总线带宽=22×(16/8)=44MB/s。</p><h3 id="zong-xian-zhong-cai">*总线仲裁</h3><p>为解决多个主设备同时竞争总线控制权的问题，应当采用总线仲裁部件，以某种方式选择一个主设备优先获得总线控制权。只有获得了总线控制权的设备，才能开始传送数据。</p><p>总线仲裁方式按其仲裁控制机构的设置可分为<code>集中仲裁方式</code>和<code>分布仲裁方式</code>两种。</p><h4 id="ji-zhong-zhong-cai-fang-shi">集中仲裁方式</h4><p>总线控制逻辑基本上集中于一个设备（如 CPU)中。将所有的总线请求集中起来，利用一个特定的裁决算法进行裁决，称为集中仲裁方式。集中仲裁方式有链式查询方式、计数器定时查询方式和独立请求方式三种。</p><h5 id="lian-shi-cha-xun-fang-shi">链式查询方式</h5><p>链式查询方式如图 6.4 所示。总线上所有的部件共用一根总线请求线，当有部件请求使用总线时，需经此线发总线请求信号到总线控制器。由总线控制器检查总线是否忙，若总线不忙，则立即发总线响应信号，经总线响应线 BG 串行地从一个部件传送到下一个部件，依次查询。若响应信号到达的部件无总线请求，则该信号立即传送到下一个部件;若响应信号到达的部件有总线请求，则信号被截住，不再传下去。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716190533.png" alt="找不到图片(Image not found)"></p><p>在链式查询中，部件离总线控制器越近，其优先级越高;部件离总线控制器越远，其优先级越低。</p><p>优点:链式查询方式优先级固定。此外，只需很少几根控制线就能按一定优先次序实现总线控制，结构简单，扩充容易。</p><p>缺点:对硬件电路的故障敏感，且优先级不能改变。当优先级高的部件频繁请求使用总线时，会使优先级较低的部件长期不能使用总线。</p><h5 id="ji-shu-qi-ding-shi-cha-xun-fang-shi">计数器定时查询方式</h5><p>计数器定时查询方式如图 6.5 所示。它采用一个计数器控制总线使用权，相对链式查询方式多了一组设备地址线，少了一根总线响应线 BG。它仍共用一根总线请求线，当总线控制器收到总线请求信号并判断总线空闲时，计数器开始计数，计数值通过设备地址线发向各个部件。当地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线控制权，同时中止计数器的计数及查询。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716190741.png" alt="找不到图片(Image not found)"></p><p>优点:计数可从“0”开始，此时一旦设备的优先次序被固定，设备的优先级就按 0,1,⋯,n 的顺序降序排列，而且固定不变;计数也可从上一次的终点开始，即采用一种循环方法，此时设备使用总线的优先级相等;计数器的初值还可由程序设置，因此优先次序可以改变，且这种方式对电路的故障没有链式查询方式敏感。</p><p>缺点:增加了控制线数（若设备有 n 个，则大致需要 ⌈log<sub>2</sub>n⌉+2 条控制线)，控制也比相对链式查询要复杂。</p><h5 id="du-li-qing-qiu-fang-shi">独立请求方式</h5><p>独立请求方式如图 6.6 所示。每个设备均有一对总线请求线 BR,和总线允许线 BG;。当总线上的部件需要使用总线时，经各自的总线请求线发送总线请求信号，在总线控制器中排队，当总线控制器按一定的优先次序决定批准某个部件的请求时，给该部件发送总线响应信号，该部件接到此信号后就获得了总线使用权，开始传送数据。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716191554.png" alt="找不到图片(Image not found)"></p><p>优点:响应速度快，总线允许信号 BG 直接从控制器发送到有关设备，而不必在设备间传递或查询,而且对优先次序的控制相当灵活。</p><p>缺点:控制线数量多（设备有 n 个，需要 2n+1 条控制线，其中加的那条控制线为 BS 线，基作用是让设备向总线控制部件反馈已使用完总线)，总线控制逻辑更复杂。为方便记忆，下面归纳了 3 种集中仲裁方式的区别与联系（假设设备有 n 个)，如表 6.1 所示。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716191643.png" alt="找不到图片(Image not found)"></p><h4 id="fen-bu-zhong-cai-fang-shi">分布仲裁方式</h4><p>分布仲裁方式不需要中央仲裁器，每个潜在的主模块都有自己的仲裁号和仲裁器。当它们有总线请求时，就会把它们各自唯一的仲裁号发送到共享的仲裁总线上，每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较。若仲裁总线上的仲裁号优先级高，则它的总线请求不予响应，并撤销它的仲裁号。最后，获胜者的仲裁号保留在仲裁总线上。</p><h3 id="chang-jian-de-zong-xian-biao-zhun">常见的总线标准</h3><p>目前，典型的总线标准有<code>ISA</code>、<code>EISA</code>、<code>VESA</code>、<code>PCI</code>、<code>PCI-Express</code>、<code>AGP</code>、<code>RS-232C</code>、<code>USB</code>等。它们的主要区别是总线宽度、带宽、时钟频率、寻址能力、是否支持突发传送等。</p><ol><li class="lvl-3"><p><code>ISA</code>。ISA (Industry Standard Architecture，工业标准体系结构）总线是最早出现的微型计算机的系统总线，应用在 IBM 的 AT 机上。</p></li><li class="lvl-3"><p><code>EISA</code>。EISA (Extended Industry Standard Architecture，扩展的 ISA）总线是为配合 32 位 CPU 而设计的扩展总线，EISA 对 ISA 完全兼容。</p></li><li class="lvl-3"><p><code>VESA</code>。VESA (Video Electronics Standards Association，视频电子标准协会）总线是一个 32 位标准的计算机局部总线，是针对多媒体 PC 要求高速传送活动图像的大量数据应运而生的。</p></li><li class="lvl-3"><p><code>PCI</code>。PCI (Peripheral Component Interconnect，外部设备互连）总线是高性能的 32 位或 64 位总线，是专为高度集成的外围部件、扩充插板和处理器/存储器系统设计的互连机制。目前常用的 PCI 适配器有显卡、声卡、网卡等。PCI 总线支持即插即用。PCI 总线是一个与处理器时钟频率无关的高速外围总线，属于局部总线。PCI 总线可通过桥连接实现多层 PCI 总线。</p></li><li class="lvl-3"><p><code>PCI-Express (PCI-E)</code>。PCI-Express 是最新的总线和接口标准，它将全面取代现行的 PCI 和 AGP，最终统一总线标准。</p></li><li class="lvl-3"><p><code>AGP</code>。AGP (Accelerated Graphics Port，加速图形接口）是一种视频接口标准，专用于连接主存和图形存储器，属于局部总线。AGP 技术为传输视频和三维图形数据提供了切实可行的解决方案。</p></li><li class="lvl-3"><p><code>RS-232C</code>。RS-232C (Recommended Standard，RS）是由美国电子工业协会（EIA）推荐的一种串行通信总线，是应用于串行二进制交换的数据终端设备（DTE）和数据通信设备(DCE）之间的标准接口。</p></li><li class="lvl-3"><p><code>USB</code>。USB (Universal Serial Bus，通用串行总线）是一种连接外部设备的 IO 总线，属于<code>设备总线</code>。具有即插即用、热插拔等优点，有很强的连接能力。</p></li><li class="lvl-3"><p><code>PCMCIA</code>。PCMCIA (Personal Computer Memory Card International Association）是广泛应用于笔记本电脑的一种接口标准，是一个用于扩展功能的小型插槽。PCMCIA 具有即插即用功能。</p></li><li class="lvl-4"><p><code>IDE</code>。IDE (Integrated Drive Electronics，集成设备电路)，更准确地称为 ATA，是一种 IDE 接口磁盘驱动器接口类型，硬盘和光驱通过 IDE 接口与主板连接。</p></li><li class="lvl-4"><p><code>SCSI</code>。SCSI (Small Computer System Interface，小型计算机系统接口）是一种用于计算机和智能设备之间（硬盘、软驱、光驱、打印机等）系统级接口的独立处理器标准。SCSI 是一种智能的通用接口标准。</p></li><li class="lvl-4"><p><code>SATA</code>。SATA (Serial Advanced Technology Attachment，串行高级技术附件）是一种基于行业标准的串行硬件驱动器接口，是由 Intel、IBM、Dell、APT、Maxtor 和 Seagate 公司共同提出的硬盘接口规范。</p></li></ol><h2 id="zong-xian-shi-wu-he-ding-shi">总线事务和定时</h2><h3 id="zong-xian-shi-wu">总线事务</h3><p>从请求总线到完成总线使用的操作序列称为总线事务,它是在一个总线周期中发生的一系列活动。典型的总线事务包括<code>请求操作</code>、<code>仲裁操作</code>、<code>地址传输</code>、<code>数据传输</code>和<code>总线释放</code></p><ol><li class="lvl-3"><p><code>请求阶段</code>。 主设备(CPU 或 DMA)发出总线传输请求,并且获得总线控制权</p></li><li class="lvl-3"><p><code>仲裁阶段</code>。 总线冲裁机构决定将下一个传输周期的总线使用权授予某个申请者</p></li><li class="lvl-3"><p><code>寻址阶段</code> 。取得使用权的主模块通过总线发出本次要访问的从模块（或从设备）的地址及有关命令，启动参与本次传输的从模块。</p></li><li class="lvl-3"><p><code>传输阶段</code> 。主模块和从模块进行数据交换，可单向或双向进行数据传送。</p></li><li class="lvl-3"><p><code>结束阶段 </code>。主模块的有关信息均从系统总线上撤除，让出总线使用权。</p></li></ol><blockquote><p><strong>突发(猝发)传送方式</strong>能够进行连续成组数据的传送,其寻址阶段发送的是连续数据单元的首地址,在传输阶段传送多个连续单元的数据,每个时钟周期可以传送一个字长的信息,但是不释放总线,直到一组数据全部传送完毕后,再释放总线</p></blockquote><h3 id="tong-bu-ding-shi-fang-shi">同步定时方式</h3><p>所谓同步定时方式，是指系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。时钟产生相等的时间间隔，每个间隔构成一个总线周期。在一个总线周期中，发送方和接收方可以进行一次数据传送。因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线的传送周期开始。</p><p>优点:传送速度快，具有较高的传输速率;总线控制逻辑简单。</p><p>缺点:主从设备属于强制性同步;不能及时进行数据通信的有效性检验，可靠性较差。</p><p>同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统。</p><h3 id="yi-bu-ding-shi-fang-shi">异步定时方式</h3><p>在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。通常，把交换信息的两个部件或设备分为主设备和从设备，主设备提出交换信息的“请求”信号，经接口传送到从设备;从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。</p><p>优点:总线周期长度可变，能保证<strong>两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合</strong>。</p><p>缺点:比同步控制方式稍复杂一些，速度比同步定时方式慢。</p><p>根据“请求”和“回答”信号的撤销是否互锁，异步定时方式又分为以下 3 种类型。</p><ol><li class="lvl-3"><p><code>不互锁方式</code> 。主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间便撤销“请求”信号。而从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间后自动撤销“回答”信号。双方不存在互锁关系，如图 6.7(a)所示。</p></li></ol><ol start="2"><li class="lvl-3"><p><code>半互锁方式 </code>。主设备发出“请求”信号后，必须在接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动撤销“回答”信号，不存在互锁关系。半互锁方式如图 6.7(b)所示。</p></li><li class="lvl-3"><p><code>全互锁方式</code> 。主设备发出“请求”信号后，必须在从设备“回答”后才撤销“请求”信号;从设备发出“回答”信号后，必须在获知主设备“请求”信号已撤销后，再撤销其“回答”信号。双方存在互锁关系，如图 6.7©所示。</p></li></ol><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716191950.png" alt="找不到图片(Image not found)"></p><p><strong>思考</strong></p><blockquote><p>🤔<strong>引入总线结构有什么好处?</strong></p><p>① 简化了系统结构，便于系统设计制造。</p><p>② 大大减少了连线数目，便于布线，减小体积，提高系统的可靠性。</p><p>③ 便于接口设计，所有与总线连接的设备均采用类似的接口。</p><p>④ 便于系统的扩充、更新与灵活配置，易于实现系统的模块化。</p><p>⑤ 便于设备的软件设计，所有接口的软件对不同的接口地址进行操作。</p><p>⑥ 便于故障诊断和维修，同时也能降低成本。</p></blockquote><h1 id="shu-ru-shu-chu-xi-tong">输入输出系统</h1><h2 id="i-o-xi-tong-ji-ben-gai-nian">*I/O 系统基本概念</h2><h3 id="shu-ru-shu-chu-xi-tong-1">输入/输出系统</h3><p>输入/输出是以主机为中心而言的，将信息从外部设备传送到主机称为输入，反之称为输出。输入/输出系统解决的主要问题是对各种形式的信息进行输入和输出的控制。</p><p>I/O 系统中的几个基本概念如下:</p><ol><li class="lvl-3"><p><code>外部设备</code> 。包括输入/输出设备及通过输入/输出接口才能访问的外存储设备。</p></li><li class="lvl-3"><p><code>接口接口 </code>。在各个外设与主机之间传输数据时进行各种协调工作的逻辑部件。协调包括传输过程中速度的匹配、电平和格式转换等。</p></li><li class="lvl-3"><p><code>输入设备</code> 。用于向计算机系统输入命令和文本、数据等信息的部件。键盘和鼠标是最基本的输入设备。</p></li><li class="lvl-3"><p><code>输出设备</code> 。用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。显示器和打印机是最基本的输出设备。</p></li><li class="lvl-3"><p><code>外存设备 </code>。指除计算机内存及 CPU 缓存等外的存储器。硬磁盘、光盘等是最基本的外存设备。</p></li></ol><p>一般来说，I/O 系统由 I/O 软件和 I/O 硬件两部分构成:</p><ol><li class="lvl-3"><p><code>I/O 软件</code> 。包括驱动程序、用户程序、管理程序、升级补丁等。通常采用 I/O 指令和通道指令实现 CPU 与 I/O 设备的信息交换。</p></li><li class="lvl-3"><p><code>I/O 硬件 </code>。包括外部设备、设备控制器和接口、I/O 总线等。通过设备控制器来控制 I/O 设备的具体动作;通过 I/O 接口与主机（总线）相连。</p></li></ol><h3 id="i-o-kong-zhi-fang-shi">I/O 控制方式</h3><p>在输入/输出系统中，经常需要进行大量的数据传输，而传输过程中有各种不同的 I/O 控制方式，基本的控制方式主要有以下 4 种:</p><ol><li class="lvl-3"><p><code>程序查询方式 </code>。由 CPU 通过程序不断查询 I/O 设备是否已做好准备，从而控制 I/O 设备与主机交换信息。</p></li><li class="lvl-3"><p><code>程序中断方式</code> 。只在 I/O 设备准备就绪并向 CPU 发出中断请求时才予以响应。</p></li><li class="lvl-3"><p><code>DMA方式</code> 。主存和 I/O 设备之间有一条直接数据通路，当主存和 I/O 设备交换信息时，无须调用中断服务程序。</p></li><li class="lvl-3"><p><code> 通道方式</code> 。在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行 I/O 命令时，只需启动有关通道，通道将执行通道程序，从而完成 I/O 操作。</p></li></ol><p>其中，方式 1 和方式 2 主要用于数据传输率较低的外部设备，方式 3 和方式 4 主要用于数据传输率较高的设备。</p><h3 id="wai-bu-she-bei">外部设备</h3><p>外部设备也称外围设备，是除主机外的能直接或间接与计算机交换信息的装置。最基本的外部设备主要有键盘、鼠标、显示器、打印机、磁盘存储器和光盘存储器等。</p><h4 id="shu-ru-she-bei">输入设备</h4><h5 id="jian-pan">键盘</h5><p>键盘是最常用的输入设备，通过它可发出命令或输入数据。</p><p>键盘通常以矩阵的形式排列按键，每个键用符号标明其含义和作用。每个键相当于一个开关，按下键时，电信号连通;松开键时，弹簧弹起键，电信号断开。</p><p>键盘输入信息可分为 3 个步骤:① 查出按下的是哪个键;② 将该键翻译成能被主机接收的编码，如 ASCII 码;③ 将编码传送给主机。</p><h5 id="shu-biao">鼠标</h5><p>鼠标是常用的定位输入设备，它把用户的操作与计算机屏幕上的位置信息相联系。常用的鼠标有 机械式机械式 和 光电式光电式 两种。</p><p>工作原理:鼠标在平面上移动时，其底部传感器把运动的方向和距离检测出来，从而控制光标做相应的运动。</p><h4 id="shu-chu-she-bei">输出设备</h4><h5 id="xian-shi-qi">显示器</h5><p>显示设备种类繁多，按显示设备所用的显示器件分类，有阴极射线管（CRT）显示器、液晶显示器（LCD）、发光二极管（LED）显示器等。按所显示的信息内容分类，有字符显示器、图形显示器和图像显示器 3 大类。显示器属于用点阵方式运行的设备，有以下主要参数。</p><ol><li class="lvl-3"><p><code>屏幕大小</code> :以对角线长度表示，常用的有 12 ～ 29 英寸等。</p></li><li class="lvl-3"><p><code>分辨率</code> :所能表示的像素个数，屏幕上的每个光点就是一个像素，以宽和高的像素数的乘积表示，如 800×600、1024×768 和 1280×1024 等。</p></li><li class="lvl-3"><p><code>灰度级</code> :灰度级是指黑白显示器中所显示的像素点的亮暗差别，在彩色显示器中则表现为颜色的不同，灰度级越多，图像层次越清楚、逼真，典型的有 8 位（256 级）、16 位等。</p></li><li class="lvl-3"><p><code>刷新</code> :光点只能保持极短的时间便会消失，为此必须在光点消失之前再重新扫描显示一遍，这个过程称为刷新。</p></li><li class="lvl-3"><p><code>刷新频率</code> :指单位时间内扫描整个屏幕内容的次数。按照人的视觉生理，刷新频率大于 30Hz 时才不会感到闪烁，通常显示器的刷新频率为 60 ～ 120Hz。</p></li><li class="lvl-3"><p><code>显示存储器(VRAM)</code>:也称刷新存储器，为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中。其存储容量由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大。</p></li></ol>VRAM容量=分辨率×灰度级位数<p>(1) <strong>阴极射线管（CRT）显示器</strong></p><p>CRT 显示器主要由电子枪、偏转线圈、荫罩、高压石墨电极、荧光粉涂层和玻璃外壳 5 部分组成，具有可视角度大、无坏点、色彩还原度高、色度均匀、可调节的多分辨率模式、响应时间极短等目前 LCD 难以超过的优点。</p><p><strong>按显示信息内容不同</strong>，可分为<code>字符显示器</code>、<code>图形显示器</code>和<code>图像显示器</code>;<strong>按扫描方式不同</strong>，可分为<code>光栅扫描</code>和<code>随机扫描</code>两种显示器。下面简要介绍字符显示器和图形显示器。</p><p>①<code>字符显示器</code>。显示字符的方法以点阵为基础。点阵是指由 m×n 个点组成的阵列。点阵的多少取决于显示字符的质量和字符窗口的大小。字符窗口是指每个字符在屏幕上所占的点数，它包括字符显示点阵和字符间隔。</p><p>将点阵存入由 ROM 构成的字符发生器中，在 CRT 进行光栅扫描的过程中，从字符发生器中依次读出某个字符的点阵，按照点阵中 О 和 1 代码的不同控制扫描电子束的开或关，从而在屏幕上显示字符。对应于每个字符窗口，所需显示字符的 ASCII 代码被存放在视频存储器 VRAM 中，以备刷新。</p><p>②<code>图形显示器</code>。将所显示图形的一组坐标点和绘图命令组成显示文件存放在缓冲存储器中，缓存中的显示文件传送给矢量（线段）产生器，产生相应的模拟电压，直接控制电子束在屏幕上的移动。为在屏幕上保留持久稳定的图像，需按一定的频率对屏幕反复刷新。这种显示器的优点是分辨率高且显示的曲线平滑。目前高质量的图形显示器采用这种随机扫描方式。缺点是当显示复杂图形时，会有闪烁感。</p><p>(2)<strong>液晶显示器（LCD）</strong></p><p>原理:利用液晶的电光效应，由图像信号电压直接控制薄膜晶体管，再间接控制液晶分子的光学特性来实现图像的显示。</p><p>特点:体积小、重量轻、省电、无辐射、绿色环保、画面柔和、不伤眼等。</p><p>(3)<strong>LED（发光二极管）显示器</strong></p><p>原理:通过控制半导体发光二极管来显示文字、图形、图像等各种信息。</p><p>LCD 与 LED 是两种不同的显示技术。LCD 是由液态晶体组成的显示屏，而 LED 则是由发光二极管组成的显示屏。与 LCD 相比，LED 显示器在亮度、功耗、可视角度和刷新速率等方面都更具优势。</p><h5 id="da-yin-ji">打印机</h5><p>打印机是计算机的输出设备之一，用于将计算机的处理结果打印在相关介质上。</p><p>按工作原理，打印机分为击打式和非击打式两大类;按工作方式，打印机分为点阵打印机、针式打印机、喷墨式打印机、激光打印机等。</p><p>（1）针式打印机</p><p>原理:在联机状态下，主机发出打印命令，经接口、检测和控制电路，间歇驱动纵向送纸和打印头横向移动，同时驱动打印机间歇冲击色带，在纸上打印出所需的内容。</p><p>特点:针式打印机擅长“多层复写打印”，实现各种票据或蜡纸等的打印。其工作原理简单，造价低廉，耗材（色带）便宜，但打印分辨率和打印速度不够高。</p><p>（2）喷墨式打印机</p><p>原理:带电的喷墨雾点经过电极偏转后，直接在纸上形成所需字形。彩色喷墨打印机基于三基色原理，即分别喷射 3 种颜色的墨滴，按一定的比例混合出所要求的颜色。</p><p>特点:打印噪声小，可实现高质量彩色打印，通常打印速度比针式打印机快;但防水性差，高质量打印需要专用打印纸。</p><p>（3）激光打印机</p><p>原理:计算机输出的二进制信息，经过调制后的激光束扫描，在感光鼓上形成潜像，再经过显影、转印和定影，在纸上得到所需的字符或图像。</p><p>特点:打印质量高、速度快、噪声小、处理能力强;但耗材多、价格较贵、不能复写打印多份，且对纸张的要求高。</p><p>激光打印机是将激光技术和电子显像技术相结合的产物。感光鼓（也称硒鼓）是激光打印机的核心部件。</p><h2 id="i-o-jie-kou">I/O 接口</h2><p>I/O 接口（I/O 控制器）是主机和外设之间的交接界面，通过接口可以实现主机和外设之间的信息交换。主机和外设具有各自的工作特点，它们在信息形式和工作速度上具有很大的差异，接口正是为了解决这些差异而设置的。</p><h3 id="i-o-jie-kou-de-gong-neng">I/O 接口的功能</h3><p>I/O 接口的主要功能如下:</p><ol><li class="lvl-3"><p><code>实现主机和外设的通信联络控制</code>。解决主机与外设时序配合问题，协调不同工作速度的外设和主机之间交换信息，以保证整个计算机系统能统一、协调地工作。</p></li><li class="lvl-3"><p>进行 <code>地址译码</code>和<code>设备选择</code> 。CPU 送来选择外设的地址码后，接口必须对地址进行译码以产生设备选择信息，使主机能和指定外设交换信息。</p></li><li class="lvl-3"><p>实现<code>数据缓冲</code> 。<strong>CPU 与外设之间的速度往往不匹配，为消除速度差异，接口必须设置数据缓冲寄存器，用于数据的暂存，以避免因速度不一致而丢失数据。</strong></p></li><li class="lvl-3"><p><code>信号格式的转换</code> 。外设与主机两者的电平、数据格式都可能存在差异，接口应提供计算机与外设的信号格式的转换功能，如电平转换、并/串或串/并转换、模/数或数/模转换等。</p></li><li class="lvl-3"><p>传送<code>控制命令</code>和<code>状态信息</code> 。CPU 要启动某一外设时，通过接口中的命令寄存器向外设发出启动命令;外设准备就绪时，则将“准备好”状态信息送回接口中的状态寄存器，并反馈给 CPU。外设向 CPU 提出中断请求时，CPU 也应有相应的响应信号反馈给外设。</p></li></ol><h3 id="i-o-jie-kou-de-ji-ben-jie-gou">I/O 接口的基本结构</h3><p>如图 7.3 所示，I/O 接口在主机侧通过 I/O 总线与内存、CPU 相连。通过<code>数据总线 </code>，在 <code>数据缓冲寄存器</code>与内存或 CPU 的寄存器之间进行数据传送。同时接口和设备的状态信息被记录在<code>状态寄存器</code>中，通过数据线将状态信息送到 CPU。CPU 对外设的控制命令也通过数据线传送，一般将其送到 I/O 接口的控制寄存器。状态寄存器和控制寄存器在传送方向上是相反的。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716195002.png" alt="找不到图片（Image not found）"></p><p>接口中的地址线用于给出要访问的 I/O 接口中的寄存器的地址，它和读/写控制信号一起被送到 I/O 接口的控制逻辑部件，其中地址信息用以选择和主机交换信息的寄存器，通过控制线传送来的读/写信号确认是读寄存器还是写寄存器，此外控制线还会传送一些仲裁信号和握手信号。</p><p>接口中的 I/O 控制逻辑还要能对控制寄存器中的命令字进行译码，并将译码得到的控制信号通过外设界面控制逻辑送到外设，同时将数据缓冲寄存器的数据发送到外设或从外设接收数据到数据缓冲寄存器。另外，它还要具有收集外设状态到状态寄存器的功能。</p><p>对数据缓冲寄存器、状态/控制寄存器的访问操作是通过相应的指令来完成的，通常称这类指令为 I/O 指令，I/O 指令只能在操作系统内核的底层 I/O 软件中使用，它们是一种<code>特权指令 </code>。</p><blockquote><p>注意:接口和端口是两个不同的概念。端口是指接口电路中可以进行读/写的寄存器，若干端口加上相应的控制逻辑才可以组成接口。</p></blockquote><h3 id="i-o-jie-kou-de-lei-xing">I/O 接口的类型</h3><p>从不同的角度看，I/O 接口可以分为不同的类型。</p><p>1）按数据传送方式可分为 <code>并行接口 </code>（一字节或一个字的所有位同时传送）和<code>串行接口 </code>（一位一位地传送），接口要完成数据格式的转换。</p><blockquote><p>注意:这里所说的数据传送方式指的是外设和接口一侧的传送方式，而在主机和接口一侧，数据总是并行传送的。</p></blockquote><p>2）按主机访问 I/O 设备的控制方式可分为 <code>程序查询接口 </code>、 <code>中断接口</code> 和 <code>DMA接口</code> 等。</p><p>3）按功能选择的灵活性可分为<code>可编程接口</code> 和 <code>不可编程接口</code> 。</p><h3 id="i-o-duan-kou-ji-qi-bian-zhi">I/O 端口及其编址</h3><p>I/O 端口是指接口电路中可被 CPU 直接访问的寄存器，主要有<code>数据端口 </code>、 <code>状态端口</code> 和 <code>控制端口</code> ，若干端口加上相应的控制逻辑电路组成接口。通常，CPU 能对数据端口执行读写操作，但对状态端口只能执行读操作，对控制端口只能执行写操作。</p><p>I/O 端口要想能够被 CPU 访问，就必须要对各个端口进行编号，每个端口对应一个端口地址。而对 I/O 端口的编址方式有与存储器统一编址和独立编址两种。</p><ol><li class="lvl-3"><p><code>统一编址</code> ，又称存储器映射方式，是指把 I/O 端口当作存储器的单元进行地址分配，这种方式 CPU 不需要设置专门的 I/O 指令，用统一的 访存指令访存指令 就可以访问 I/O 端口。</p><p>优点:不需要专门的输入/输出指令，可使 CPU 访问 I/O 的操作更灵活、更方便，还可使端口有较大的编址空间。</p><p>缺点:端口占用存储器地址，使内存容量变小，而且利用存储器编址的 I/O 设备进行数据输入/输出操作，执行速度较慢。</p></li><li class="lvl-3"><p><code>独立编址</code> ，又称 I/O 映射方式，I/O 端口的地址空间与主存地址空间是两个独立的地址空间，因而无法从地址码的形式上区分，需要设置专门的/O 指令来访问 I/O 端口。</p><p>优点:输入/输出指令与存储器指令有明显区别，程序编制清晰，便于理解。</p><p>缺点:输入/输出指令少，一般只能对端口进行传送操作，尤其需要 CPU 提供存储器读/写、I/O 设备读/写两组控制信号，增加了控制的复杂性。</p></li></ol><h2 id="i-o-fang-shi">I/O 方式</h2><p>输入/输出系统实现主机与 I/O 设备之间的数据传送，可以采用不同的控制方式，各种方式在代价、性能、解决问题的着重点等方面各不相同，常用的 I/O 方式有<code>程序查询</code> 、 <code>程序中断</code>、 <code>DMA</code> 和<code>通道 </code>等，其中前两种方式更依赖于 CPU 中程序指令的执行。</p><h3 id="cheng-xu-cha-xun-fang-shi">程序查询方式</h3><p>信息交换的控制完全由主机执行程序实现，程序查询方式接口中设置一个数据缓冲寄存器（数据端口）和一个设备状态寄存器（状态端口）。主机进行 I/O 操作时，先发出询问信号，读取设备的状态并根据设备状态决定下一步操作究竟是进行数据传送还是等待。</p><p>程序查询方式的工作流程如下（见图 7.4）</p><p>① CPU 执行初始化程序，并预置传送参数。</p><p>② 向 I/O 接口发出命令字，启动 I/O 设备。</p><p>③ 从外设接口读取其状态信息。</p><p>④ CPU 不断查询 I/O 设备状态，直到外设准备就绪。</p><p>⑤ 传送一次数据。</p><p>⑥ 修改地址和计数器参数。</p><p>⑦ 判断传送是否结束，若未结束转第 ③ 步，直到计数器为 0。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716195423.png" alt="找不到图片（Image not found）"></p><p>在这种控制方式下，CPU 一旦启动 I/O，就必须停止现行程序的运行，并在现行程序中插入一段程序。程序查询方式的主要特点是 CPU 有<code>“踏步”等待现象</code>，CPU 与 I/O 串行工作。这种方式的接口设计简单、设备量少，但 CPU 在信息传送过程中要花费很多时间来查询和等待，而且在<code> 一段时间</code>内只能和<code>一台</code>外设交换信息，效率大大降低。</p><h3 id="mark-cheng-xu-zhong-duan-fang-shi-mark"><mark>程序中断方式</mark></h3><p>现代计算机系统中都配有完善的异常和中断处理系统，CPU 的数据通路中有相应的异常和中断的检测和响应逻辑，在外设接口中有相应的中断请求和控制逻辑，操作系统中有相应的中断服务程序。这些中断硬件线路和中断服务程序有机结合，共同完成异常和中断的处理过程。</p><h4 id="yi-chang-he-zhong-duan">异常和中断</h4><h5 id="yi-chang">异常</h5><p><strong>异常</strong>是指由<code>CPU内部异常</code>引起的意外事件，分为<code>硬故障中断</code> 和<code>程序性异常</code>。<code>硬故障中断 </code>是由硬连线出现异常引起的，如<code>电源掉电</code> 、<code> 存储器线路错</code>等。 <code>程序性异常</code>也称 <code>软中断</code> ，是指在 CPU 内部因执行指令而引起的异常事件。如<code>整除0 </code>、<code>溢出 </code>、<code>断点</code> 、<code>单步跟踪 </code>、<code>非法指令</code> 、 <code>栈溢出</code> 、 <code>地址越界</code> 、<code>缺页</code> 、分时系统中的 <code>时间片中断</code> 及用户态到核心态的<code>切换 </code>等。按发生异常的报告方式和返回方式不同， <code>内部异常</code> 可分为<code>故障 </code>（Fault）、 <code>自陷 </code>（Trap）和 <code>终止</code> （Abort）三类。</p><p>① <strong>故障</strong>（Fault）</p><p>指在引起故障等指令启动后、执行结束前被检测到的异常事件。例如，指令译码时，出现“非法操作码”;取数据时，发生“缺段”或“缺页”;执行整数除法指令时，发现“除数为 0”等。对于“缺段”“缺页”等异常处理后，已将所需的段或页面从磁盘调入主存，可回到发生故障的指令继续执行，断点为当前发生故障的指令;对于“非法操作码”“除数为 0”等， 因为无法通过异常处理程序恢复故障 ，因此不能回到原断点执行，必须终止进程的执行。</p><p>② <strong>自陷</strong>（Trap）</p><p>自陷也称陷阱或陷入，它是预先安排的一种“异常”事件，就像预先设定的“陷阱”一样。通常的做法是:事先在程序中用一条特殊指令或通过某种方式设定特殊控制标志来人为设置一个“陷阱”，当执行到被设置了“陷阱”的指令时，CPU 在执行完自陷指令后，自动根据不同“陷阱”类型进行相应的处理，然后返回到自陷指令的下一条指令执行。注意，当自陷指令是转移指令时，并不是返回到下一条指令执行，而是返回到转移目标指令执行。</p><p>在 80x86 中，用于程序调试的<code>“ 断点设置 ”</code>功能就是通过<code>自陷</code>方式实现的。此外，系统调用指令、条件自陷指令（如 MIPS 中 teq、teqi、tne、tnei 等一组按条件进入陷阱的指令）等都属于陷阱指令，执行到这些指令时，无条件或有条件地自动调出操作系统内核程序进行执行。</p><p>③ <strong>终止</strong>（Abort）</p><p>如果在执行指令的过程中发生了使计算机无法继续执行的硬件故障，如电源掉电、线路故障等，那么程序将无法继续执行，只能终止，此时，调出中断服务程序来重启系统。这种异常与故障和自陷不同，不是由特定指令产生的，而是<code>随机</code>发生的。</p><h5 id="wai-bu-zhong-duan">外部中断</h5><p><code>外中断</code>是指来自 CPU 外部、与 CPU 执行指令无关的事件引起的中断，包括<code>I/O设备</code>发出的 I/O 中断（如键盘输入、打印机缺纸等）、<code>外部信号中断</code>（如用户按 Esc 键），以及各种定时器引起的时钟中断等。<strong>外中断在狭义上一般称为中断（书中若未说明，一般是指外中断）</strong>。</p><p>外中断和内部异常在本质上是一样的，但它们之间有以下两个重要的不同点:</p><ol><li class="lvl-3"><p>“缺页”或“溢出”等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不阻止任何指令的完成。</p></li><li class="lvl-3"><p>异常的检测是由 CPU 自身完成的，不必通过外部的某个信号通知 CPU。对于中断，CPU 必须通过总线获取中断源的标识信息，才能获知哪个设备发生了何种中断。</p></li></ol><blockquote><p>有些教材也将异常和中断统称为中断，将由 CPU 内部产生的异常称为内中断，将通过中断请求线 INTR 和 NMI 从 CPU 外部发出的中断请求称为外中断。</p></blockquote><h4 id="zhong-duan-de-ji-ben-gai-nian">中断的基本概念</h4><p>程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU 暂时中止现行程序，而转去对这些异常情况或特殊请求进行处理，在处理完毕后 CPU 又自动返回到现行程序的断点处，继续执行原程序。</p><p>程序中断的作用如下:</p><p>① 实现 CPU 与 I/O 设备的并行工作。</p><p>② <code>处理</code>硬件故障和软件错误。</p><p>③ 实现人机交互，用户<code>干预</code>机器需要用到中断系统。</p><p>④ 实现<code>多道程序</code>、<code>分时操作</code>，多道程序的切换需借助于中断系统。</p><p>⑤ 实时处理需要借助中断系统来实现<code>快速响应</code>。</p><p>⑥ 实现应用程序和操作系统（管态程序）的切换，称为<code>“软中断”</code>。</p><p>⑦ 多处理器系统中各处理器之间的 信息交流信息交流 和 任务切换任务切换 。</p><p>程序中断方式的思想:CPU 在程序中安排好于某个时刻启动某台外设，然后 CPU 继续执行原来的程序，不需要像查询方式那样一直等待外设准备就绪。一旦外设完成数据传送的准备工作，就主动向 CPU 发出中断请求，请求 CPU 为自己服务。在可以响应中断的条件下，CPU 暂时中止正在执行的程序，转去执行中断服务程序为外设服务，在中断服务程序中完成一次主机与外设之间的数据传送，传送完成后，CPU 返回原来的程序，如图 7.5 所示。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716210133.png" alt="找不到图片（Image not found）"></p><h4 id="cheng-xu-zhong-duan-fang-shi-gong-zuo-liu-cheng">程序中断方式工作流程</h4><h6 id="zhong-duan-qing-qiu">中断请求</h6><p>中断源是请求 CPU 中断的设备或事件，一台计算机允许有多个中断源。每个中断源向 CPU 发出中断请求的时间是随机的。为记录中断事件并区分不同的中断源，中断系统需对每个中断源设置中断请求标记触发器 INTR，当其状态为“1”时，表示中断源有请求。这些触发器可组成中断请求标记寄存器，该寄存器可集中在 CPU 中，也可分散在各个中断源中。</p><p><code>内中断</code>皆为<code>不可屏蔽中断</code> 。通过 INTR 信号线发出的<code>外中断</code>是<code>可屏蔽中断</code> ，在关中断（IF =1）的情况下不会被响应;而通过 NMI 信号发出的是不可屏蔽中断，即使在关中断（IF=0）的情况下也会被响应。不可屏蔽中断的处理优先级最高，任何时候只要发生不可屏蔽中断，都要中止现行程序的执行，转到不可屏蔽中断处理程序执行。</p><h6 id="zhong-duan-pan-you">中断判优</h6><p>中断系统在任一瞬间只能响应一个中断源的请求。由于许多中断源提出中断请求的时间都是随机的，因此当多个中断源同时提出请求时，需通过中断判优逻辑确定响应哪个中断源的请求，例如故障中断的优先级别较高，然后是 I/O 中断。</p><p>中断判优既可以用硬件实现，又可用软件实现。硬件实现是通过<code>硬件排队器</code>实现的，它既可以设置在 CPU 中，又可以分散在各个中断源中，软件实现是通过<code>查询程序</code>实现的。</p><p><strong>一般来说，硬件故障中断属于最高级，其次是软件中断，不可屏蔽中断优于可屏蔽中断，DMA 请求优于 I/O 设备传送的中断请求，高速设备优于低速设备，输入设备优于输出设备，实时设备优于普通设备等。</strong></p><h6 id="cpu-xiang-ying-zhong-duan-de-tiao-jian">CPU 响应中断的条件</h6><p>CPU 在满足一定的条件下响应中断源发出的中断请求，并经过一些特定的操作，转去执行中断服务程序。CPU 响应中断必须满足以下 3 个条件:</p><p>① 中断源有中断请求。</p><p>② CPU 允许中断及开中断。</p><p>③ 一条指令执行完毕，且没有更紧迫的任务。</p><blockquote><p>注意:I/O 设备的就绪时间是随机的，而 CPU 在统一的时刻即每条指令执行阶段结束前向接口发出中断查询信号，以获取 I/O 的中断请求，也就是说，<strong>CPU 响应中断的时间是在每条指令执行阶段的结束时刻。这里说的中断仅指外中断，内中断不属于此类情况。</strong></p></blockquote><h6 id="zhong-duan-xiang-ying">中断响应</h6><p>CPU 响应中断后，经过某些操作，转去执行中断服务程序。这些操作是由硬件直接实现的，我们将它称为<code>中断隐指令</code> 。中断隐指令并不是指令系统中的一条真正的指令，它没有操作码，所以中断隐指令是一种不允许也不可能为用户使用的特殊指令。它所完成的操作如下:</p><p>① <code>关中断</code> 。CPU 响应中断后，首先要保护程序的断点和现场信息，在保护断点和现场的过程中，CPU 不能响应更高级中断源的中断请求。</p><p>② <code>保存断点</code> 。为保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断点（指令无法直接读取的 PC 和 PSWR 等的内容）保存起来。</p><p>③ <code>引出中断服务程序</code> 。实质是取出中断服务程序的入口地址并传送给程序计数器（PC）。</p><h6 id="zhong-duan-xiang-liang">中断向量</h6><p>每个中断都有一个类型号，每个中断类型号都对应一个中断服务程序，每个中断服务程序都有一个入口地址，CPU 必须找到入口地址，即中断向量，把系统中的全部中断向量集中存放到存储器的某个区域内，这个存放中断向量的存储区就称为<code>中断向量表</code>。</p><p><strong>CPU 响应中断后，中断硬件会自动将中断向量地址传送到 CPU，由 CPU 实现程序的切换，这种方法称为中断向量法，采用中断向量法的中断称为向量中断</strong>。</p><blockquote><p>注意: <code>中断向量</code>是<code>中断服务程序的入口地址 </code>，<code>中断向量地址</code>是指 <code>中断服务程序的入口地址的地址</code> 。</p></blockquote><h6 id="zhong-duan-chu-li-guo-cheng">中断处理过程</h6><p>不同计算机的中断处理过程各具特色，就其多数而论，中断处理流程如图 7.6 所示。</p><p>中断处理流程如下:</p><p>① <code>关中断</code> 。在保护断点和现场期间不能被新的中断所打断，必须关中断。否则，若断点或现场保存不完整，在中断服务程序结束后，就不能正确地恢复并继续执行现行程序。</p><p>② <code>保存断点</code> 。断点可以压入堆栈，也可以存入主存的特定单元中。</p><p>③ <code>引出中断服务程序</code> 。通常有两种方法寻址中断服务程序的入口地址: <code>硬件向量法</code> 和 <code>软件查询法</code> 。硬件向量法通过硬件产生中断向量地址，再由中断向量地址找到中断服务程序的入口地址。软件查询法用软件编程的办法寻找入口地址。</p><blockquote><p>注意:硬件产生的实际上是中断类型号，而中断类型号指出了中断向量存放的地址，因此能产生中断向量地址。</p></blockquote><p>④<code> 保存现场和屏蔽字</code> 。进入中断服务程序后首先要保存现场和中断屏蔽字，现场信息是指用户可见的工作寄存器的内容，它存放着程序执行到断点处的现行值。</p><blockquote><p>注意:现场和断点，这两类信息都不能被中断服务程序破坏。现场信息因为用指令可直接访问，所以通常在中断服务程序中通过指令把它们保存到栈中，即由软件实现;而断点信息由 CPU 在中断响应开始时自动保存到栈或专门的寄存器中，即由硬件实现。</p></blockquote><p>⑤ <code>开中断</code> 。允许更高级中断请求得到响应，实现中断嵌套。</p><p>⑥ <code>执行中断服务程序</code> 。这是中断请求的目的。</p><p>⑦ <code>关中断</code> 。保证在恢复现场和屏蔽字时不被中断。</p><p>⑧ <code>恢复现场和屏蔽字</code> 。将现场和屏蔽字恢复到原来的状态。</p><p>⑨ <code>开中断、中断返回</code> 。中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序。</p><p>其中，①③ 在 CPU 进入中断周期后，由中断隐指令（硬件自动）完成;④⑨ 由中断服务程序完成。</p><blockquote><p>注意: 恢复现场是指在中断返回之前，中断服务程序必须将寄存器的内容恢复到中断处理之前的状态。这一步骤由中断服务程序完成。而中断返回则由中断服务程序的最后一条中断返回指令来完成。</p></blockquote><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716210821.png" alt="找不到图片（Image not found）"></p><h4 id="duo-zhong-zhong-duan-he-zhong-duan-ping-bi-ji-zhu">多重中断和中断屏蔽技术</h4><p>若 CPU 在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求，而 CPU 对新的中断请求不予响应，则这种中断称为<code>单重中断 </code>，如图 7.7（a）所示。若 CPU 暂停现行的中断服务程序，转去处理新的中断请求，则这种中断称为<code>多重中断</code>，又称<code>中断嵌套 </code>，如图 7.7（b）所示。</p><p>中断屏蔽技术主要用于多重中断。CPU 要具备多重中断的功能，必须满足下列条件:</p><p>① 在中断服务程序中提前设置开中断指令。</p><p>② 优先级别高的中断源有权中断优先级别低的中断源。</p><p>每个中断源都有一个 <code>屏蔽触发器 </code>， 1 表示<code>屏蔽该中断源</code>的请求， 0 表示可以<code>正常申请</code>，所有屏蔽触发器组合在一起便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。</p><p>关于中断屏蔽字的设置及多重中断程序执行的轨迹，下面通过实例说明。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716211109.png" alt="找不到图片（Image not found）"></p><p>例题:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716211251.png" alt="找不到图片（Image not found）"></p><h3 id="dma-fang-shi">DMA 方式</h3><p><strong>DMA(Direct Memory Access)方式</strong>是一种<code>完全由硬件</code>进行成组信息传送的控制方式，它具有程序中断方式的优点，即在数据准备阶段，CPU 与外设并行工作。DMA 方式在外设与内存之间开辟一条“直接数据通道”，信息传送不再经过 CPU，降低了 CPU 在传送数据时的开销，因此称为<code>直接存储器存取</code>方式。由于数据传送不经过 CPU，也就不需要保护、恢复 CPU 现场等烦琐操作。</p><p>这种方式适用于磁盘机、磁带机等高速设备大批量数据的传送，它的硬件开销比较大。在 DMA 方式中，中断的作用仅限于<code>故障</code>和<code>正常传送结束时的处理</code> 。</p><h4 id="dma-fang-shi-de-te-dian">DMA 方式的特点</h4><p>主存和 DMA 接口之间有一条直接数据通路。由于 DMA 方式传送数据不需要经过 CPU,因此不必中断现行程序，I/O 与主机并行工作，程序和传送并行工作。</p><p>DMA 方式具有下列特点:</p><p>① 它使主存与 CPU 的固定联系脱钩，主存既可被 CPU 访问，又可被外设访问。</p><p>② 在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。</p><p>③ 主存中要开辟专用缓冲区，及时供给和接收外设的数据。</p><p>④ DMA 传送速度快，CPU 和外设并行工作，提高了系统效率。</p><p>⑤ DMA 在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。</p><h4 id="dma-kong-zhi-qi-de-zu-cheng">DMA 控制器的组成</h4><p>在 DMA 方式中，对数据传送过程进行控制的硬件称为 DMA 控制器（DMA 接口）。当 I/O 设备需要进行数据传送时，通过 DMA 控制器向 CPU 提出 DMA 传送请求，CPU 响应之后将让出系统总线，由 DMA 控制器接管总线进行数据传送。其主要功能如下:</p><ol><li class="lvl-3"><p>接受外设发出的 DMA 请求，并向 CPU 发出总线请求。</p></li><li class="lvl-3"><p>CPU 响应此总线请求，发出总线响应信号，接管总线控制权，进入 DMA 操作周期。</p></li><li class="lvl-3"><p>确定传送数据的主存单元地址及长度，并自动修改主存地址计数和传送长度计数。</p></li><li class="lvl-3"><p>规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作。</p></li><li class="lvl-3"><p>向 CPU 报告 DMA 操作的结束。</p></li></ol><p>图 7.10 给出了一个简单的 DMA 控制器。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716211543.png" alt="找不到图片（Image not found）"></p><ul class="lvl-0"><li class="lvl-2"><p><code>主存地址计数器</code>:存放要交换数据的主存地址。</p></li><li class="lvl-2"><p><code>传送长度计数器</code>:记录传送数据的长度，计数溢出时，数据即传送完毕，自动发中断请求信号。</p></li><li class="lvl-2"><p><code>数据缓冲寄存器</code>:暂存每次传送的数据。</p></li><li class="lvl-2"><p><code>DMA请求触发器</code>:每当 I/O 设备准备好数据后，给出一个控制信号，使 DMA 请求触发器置位。</p></li><li class="lvl-2"><p><code>“控制/状态”逻辑</code>:由控制和时序电路及状态标志组成，用于指定传送方向，修改传送参数，并对 DMA 请求信号和 CPU 响应信号进行协调和同步。</p></li><li class="lvl-2"><p><code>中断机构</code>:当一个数据块传送完毕后触发中断机构，向 CPU 提出中断请求。</p></li></ul><p>在 DMA 传送过程中，DMA 控制器将接管 CPU 的地址总线、数据总线和控制总线，CPU 的主存控制信号被禁止使用。而当 DMA 传送结束后，将恢复 CPU 的一切权利并开始执行其操作。由此可见，DMA 控制器必须具有控制系统总线的能力。</p><h4 id="dma-de-chuan-song-fang-shi">DMA 的传送方式</h4><p>主存和 I/O 设备之间交换信息时，不通过 CPU。但当 I/O 设备和 CPU 同时访问主存时，可能发生冲突，为了有效地使用主存，DMA 控制器与 CPU 通常采用以下 3 种方式使用主存:</p><ol><li class="lvl-3"><p>停止 CPU 访存。当 I/O 设备有 DMA 请求时，由 DMA 控制器向 CPU 发送一个停止信号，使 CPU 脱离总线，停止访问主存，直到 DMA 传送一块数据结束。数据传送结束后，DMA 控制器通知 CPU 可以使用主存，并把总线控制权交还给 CPU。</p></li><li class="lvl-3"><p>周期挪用（或周期窃取）。当 I/O 设备有 DMA 请求时，会遇到 3 种情况:</p><ol><li class="lvl-6">此时 CPU 不在访存（如 CPU 正在执行乘法指令），因此 I/O 的访存请求与 CPU 未发生冲突;</li><li class="lvl-6">CPU 正在访存，此时必须待存取周期结束后，CPU 再将总线占有权让出;</li><li class="lvl-6">I/O 和 CPU 同时请求访存，出现访存冲突，此时 CPU 要暂时放弃总线占有权。I/O 访存优先级高于 CPU 访存，因为 I/O 不立即访存就可能丢失数据，此时由 I/O 设备挪用一个或几个存取周期，传送完一个数据后立即释放总线，是一种单字传送方式。</li></ol></li><li class="lvl-3"><p>DMA 与 CPU 交替访存。这种方式适用于 CPU 的工作周期比主存存取周期长的情况。例如，若 CPU 的工作周期是 1.2μs，主存的存取周期小于 0.6μs，则可将一个 CPU 周期分为 C<sub>1</sub>和 C<sub>2</sub>,两个周期，其中 C<sub>1</sub>专供 DMA 访存，C<sub>2</sub>专供 CPU 访存。这种方式不需要总线使用权的申请、建立和归还过程，总线使用权是通过 C<sub>1</sub>和 C<sub>2</sub>分时控制的。</p></li></ol><h5 id="dma-de-chuan-song-guo-cheng">DMA 的传送过程</h5><p>DMA 的数据传送过程分为预处理、数据传送和后处理 3 个阶段:</p><ol><li class="lvl-3"><p><code>预处理 </code>。由 CPU 完成一些必要的准备工作。首先，CPU 执行几条 I/O 指令，用以测试 I/O 设备状态，向 DMA 控制器的有关寄存器置初值、设置传送方向、启动该设备等。然后，CPU 继续执行原来的程序，直到 I/O 设备准备好发送的数据（输入情况）或接收的数据（输出情况）时，I/O 设备向 DMA 控制器发送 DMA 请求，再由 DMA 控制器向 CPU 发送总线请求（有时将这两个过程统称为 DMA 请求），用以传输数据。</p></li><li class="lvl-3"><p><code>数据传送</code> 。DMA 的数据传输可以以单字节（或字）为基本单位，也可以以数据块为基本单位。对于以数据块为单位的传送（如硬盘），DMA 占用总线后的数据输入和输出操作都是通过循环来实现的。需要指出的是，这一循环也是由 DMA 控制器（而非通过 CPU 执行程序）实现的，即数据传送阶段完全由 DMA（硬件）控制。</p></li><li class="lvl-3"><p><code>后处理 </code>。DMA 控制器向 CPU 发送中断请求，CPU 执行中断服务程序做 DMA 结束处理，包括校验送入主存的数据是否正确、测试传送过程中是否出错（错误则转入诊断程序）及决定是否继续使用 DMA 传送其他数据块等。DMA 的传送流程如图 7.11 所示。</p></li></ol><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80/20210716211945.png" alt="找不到图片（Image not found）"></p><h4 id="dma-fang-shi-he-zhong-duan-fang-shi-de-qu-bie">DMA 方式和中断方式的区别</h4><p>DMA 方式和中断方式的重要区别如下:</p><p>① 中断方式是程序的切换，需要保护和恢复现场;而 DMA 方式除了预处理和后处理，其他时候不占用 CPU 的任何资源。</p><p>② 对中断请求的响应只能发生在每条指令执行完毕时（即指令的执行周期后）;而对 DMA 请求的响应可以发生在每个机器周期结束时（在取指周期、间址周期、执行周期后均可），只要 CPU 不占用总线就可被响应。</p><p>③ 中断传送过程需要 CPU 的干预;而 DMA 传送过程不需要 CPU 的干预，因此数据传输率非常高，适合于高速外设的成组数据传送。</p><p>④ DMA 请求的优先级高于中断请求。</p><p>⑤ 中断方式具有对异常事件的处理能力，而 DMA 方式仅局限于传送数据块的 I/O 操作。</p><p>⑥ 从数据传送来看，中断方式靠程序传送，DMA 方式靠硬件传送。</p><h2 id="zong-jie">总结</h2><h3 id="cpu-xiang-ying-zhong-duan-ying-ju-bei-na-xie-tiao-jian">CPU 响应中断应具备哪些条件?</h3><p>在 CPU 内部设置的中断屏蔽触发器必须是开放的。</p><p>① 外设有中断请求时，中断请求触发器必须处于“1”状态，保持中断请求信号。</p><p>② 外设（接口）中断允许触发器必须为“1”，这样才能把外设中断请求送至 CPU.</p><p>③ 具备上述三个条件时，CPU 在现行指令结束的最后一个状态周期响应中断。</p><h3 id="zhong-duan-xiang-ying-you-xian-ji-he-zhong-duan-chu-li-you-xian-ji-fen-bie-zhi-shi-yao">中断响应优先级和中断处理优先级分别指什么?</h3><p>中断响应优先级是由硬件排队线路或中断查询程序的查询顺序决定的，不可动态改变;而中断处理优先级可以由中断屏蔽字来改变，反映的是正在处理的中断是否比新发生的中断的处理优先级低（屏蔽位为“0”，对新中断开放），若是，则中止正在处理的中断，转到新中断去处理，处理完后再回到刚才被中止的中断继续处理。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础</title>
      <link href="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络体系概述"><a href="#计算机网络体系概述" class="headerlink" title="计算机网络体系概述"></a>计算机网络体系概述</h1><p><strong>计算机网络是”以能够相互共享资源的方式互联起来的自治计算机系统的集合体”</strong></p><h2 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h2><ul><li>组成成分: 硬件、软件、协议</li><li>工作方式: 边缘部分和核心部分</li><li>功能组成:通信子网和资源子网</li></ul><h2 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h2><p>数据通信(最基本最重要的功能)</p><p>资源共享,分布式处理,提高可靠性,负载均衡</p><h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><h3 id="按分布范围分类"><a href="#按分布范围分类" class="headerlink" title="按分布范围分类"></a>按分布范围分类</h3><p> 广域网(WAN)、城域网(MAN) 5-50km</p><p> 局域网(LAN)、个人区域网(PAN) 10m</p><h3 id="按传输技术分类"><a href="#按传输技术分类" class="headerlink" title="按传输技术分类"></a>按传输技术分类</h3><p> 广播式网络(局域网、广域网中的无线,卫星通信)</p><p> 点对点网络:采用<code>存储转发</code>和<code>路由选择</code>机制(广域网基本属于点对点网络)</p><h3 id="按拓扑结构分类"><a href="#按拓扑结构分类" class="headerlink" title="按拓扑结构分类"></a>按拓扑结构分类</h3><h4 id="总线型"><a href="#总线型" class="headerlink" title="总线型"></a>总线型</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230608163723803.png" alt="image-20230608163723803"></p><h4 id="星型"><a href="#星型" class="headerlink" title="星型"></a>星型</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230608163750535.png" alt="image-20230608163750535"></p><h4 id="环形"><a href="#环形" class="headerlink" title="环形"></a>环形</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230608163909998.png" alt="image-20230608163909998"></p><h4 id="树型"><a href="#树型" class="headerlink" title="树型"></a>树型</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230608164005762.png" alt="image-20230608164005762"></p><h4 id="网状"><a href="#网状" class="headerlink" title="网状"></a>网状</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230608164038289.png" alt="image-20230608164038289"></p><h3 id="按使用者分类"><a href="#按使用者分类" class="headerlink" title="按使用者分类"></a>按使用者分类</h3><p> 电路交换网络</p><p> 报文交换网络</p><p> 分组交换网络</p><h3 id="按传输介质分类"><a href="#按传输介质分类" class="headerlink" title="按传输介质分类"></a>按传输介质分类</h3><p><strong>有线网络</strong></p><ul><li>双绞线网络</li><li>同轴电缆网络</li></ul><p><strong>无线网络</strong></p><ul><li>蓝牙</li><li>微波</li><li>无线电</li></ul><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="==计算机网络的性能指标=="></a>==计算机网络的性能指标==</h2><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>(即数字信道所能传送的”最高数据率”的同义词)</p><p> 单位: 在通信领域为赫兹(Hz)</p><p> 在计算机网络中是(b/s)</p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p> 发送时延:分组长度/信道宽度</p><p> 传播时延:信道长度/电磁波在信道上的传播速率</p><p> 处理时延:提取数据报首数据部分,解析首部,查找合适路由所需时间</p><p> 排队时延:分组进入路由器输入队列等待处理,然后在路由器的输入队列中等待处理</p><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p> 表示当第一个发送的比特到达终点后信道的比特量</p><p> 带宽 × 传输时延</p><h3 id="往返时延-RRT-Round-Trip-Time"><a href="#往返时延-RRT-Round-Trip-Time" class="headerlink" title="往返时延(RRT Round Trip Time)"></a>往返时延(RRT Round Trip Time)</h3><p> 发送端收到接受端的确认报文所需的时间</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p> 单位时间内通过某个网络所需的时间</p><h3 id="速率-传输速率、数据率、比特率"><a href="#速率-传输速率、数据率、比特率" class="headerlink" title="速率(传输速率、数据率、比特率)"></a>速率(传输速率、数据率、比特率)</h3><p> 单位为 b/s 或 bit/s(bps bit per second)</p><p> k=10^3^ M=10^6^ G=10^9^ T=10^12^ P=10^15^ Z=10^18^ E=10^21^</p><p> 需要注意的是在计算机存储中 k=2^10^ M=2^20^ G=2^30^……</p><h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p> 某一时间段内有数据通过的时间占这一段时间的百分比</p><h2 id="协议、服务、接口"><a href="#协议、服务、接口" class="headerlink" title="协议、服务、接口"></a>协议、服务、接口</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul><li>语法:传输数据的格式</li><li>语义:所需要完成的功能(发出何种控制信息,完成何种动作,已经做出何种相应)</li><li>同步:事件实现顺序的说明</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p> 上层通过接口来访问下层提供的服务</p><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p> 下层为上层提供功能的调用,它是垂直的</p><p> 服务原语:</p><ul><li>请求(request):服务用户发往服务提供者,请求完成某项工作</li><li>指示(indication):服务提供者发往服务用户,指示服务用户做某件事</li><li>响应(response):服务用户发往服务提供者,作为对指示的响应</li><li>证实(confirmation):由服务提供者发往服务用户作为对请求的证实</li></ul><h4 id="服务的种类"><a href="#服务的种类" class="headerlink" title="服务的种类"></a>服务的种类</h4><ul><li><ul><li>面向连接的服务:通信前双方必须先建立连接,分配相应的资源(如缓冲区),以确保通信的正常进行</li><li>无连接的服务(尽最大努力交付):不需要建立连接,直接发送数据</li></ul></li><li><ul><li>可靠服务:网络具有纠错、检错、应答机制,能保证数据正确可靠的到达目的地</li><li>不可靠服务:尽量可靠、正确的传输,是一种尽力而为的服务</li></ul></li><li><ul><li>有应答服务:接受方收到数据后向发送方给出相应的应答(文件传输服务)</li><li>无应答服务:接受方收到数据后不给出相应应答,若需要应答也是由高层来实现(www 服务)</li></ul></li></ul><h2 id="OSI-与-TCP-IP-模型"><a href="#OSI-与-TCP-IP-模型" class="headerlink" title="==OSI 与 TCP/IP 模型=="></a>==OSI 与 TCP/IP 模型==</h2><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230606121610515.png" alt="image-20230606121610515"></p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p><strong>传输单位</strong>:==比特==</p><p><strong>任务</strong>:==透明传输比特流==</p><p><strong>功能</strong>:在物理媒体上为数据端设备透明传输比特流</p><p><strong>物理层协议(物理层接口标准,物理层规程):</strong><code>EIA-232C</code>、<code>EIA/TIA RS-449</code>、<code>CCITT的X.21</code></p><p>注意 传输信息所用的物理媒介(双绞线,光纤,无线信道)并不处于物理层协议之内而处于物理层协议之下</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p><strong>传输单位:</strong>==帧==</p><p><strong>任务</strong>: 将网络层传来的数据报封装成帧</p><p><strong>功能</strong>:封装成帧,差错控制,流量控制,传输管理</p><p><strong>典型协议:</strong><code>SDLC</code>、<code>HDLC</code>、<code>SLIP</code>→<code>PPP</code>、<code>STP</code></p><p>注意实际上数据链路层分为两个子层:MAC 子层和高级数据链路控制子层</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a><strong>网络层</strong></h3><p><strong>传输单位</strong>:==数据包==</p><p><strong>任务</strong>:把网络层的<code>协议数据单元(分组)</code>从源端到目的端,为分组交换网络上的==不同主机==提供通信服务</p><p><strong>功能</strong>:实现路由选择、流量控制、拥塞控制、差错控制、网际互连等功能</p><p><strong>典型协议:</strong><code>IP</code>、<code>ICMP</code>、<code>IPX</code>、<code>IGMP</code>、<code>ARP(Address Resolution Protocol)</code>、<code>RARP</code>、<code>OSPF</code></p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p><strong>传输单位:</strong>==报文段==或者==用户数据报==</p><p> TCP UDP</p><p><strong>任务</strong>:负责不同主机中的两个==进程==之间的通信,提供端到端的可靠的传输服务</p><p><strong>功能</strong>:为端到端的服务提供流量控制、差错控制、服务质量、数据传输管理</p><p><strong>典型协议:</strong><code>TCP</code>、<code>UDP</code></p><h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>允许不同主机上的各个进程进行会话,建立、管理以及终止进程间的会话</p><p>校验点技术使通信会话在通信失效时从校验点继续恢复通信,实现数据同步</p><h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>不同机器采用的编码和表示方法不同,表示层采用标准编码形式,功能为数据压缩,加密和解密</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>用户与网络的接口,最复杂的一层</p><p><strong>典型协议:</strong><code>FTP</code>、<code>SMTP</code>、<code>HTTP</code>、<code>DNS</code>、<code>RTP</code></p><p><strong><em>OSI 模型与 TCP/IP 模型的区别</em></strong></p><ul><li>OSI 模型网络层支持无连接和面向连接的服务,传输层只支持面向连接的服务(TCP,SPX)</li><li>TCP/IP 模型网络层仅支持无连接的服务(IP),传输层提供面向连接(TCP)和无连接的服务(UDP)</li></ul><h1 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h1><p><strong>模拟信号(数据):</strong>连续变换的数据</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/resize,m_lfit,w_536,limit_1.jpeg" alt="波形图"></p><p><strong>数字信号(数据)</strong>:取值仅有有限的几个离散数据: 01001101001</p><h2 id="信源、信宿、信道"><a href="#信源、信宿、信道" class="headerlink" title="信源、信宿、信道"></a>信源、信宿、信道</h2><p><strong>信源</strong>:产生和发送数据的源头</p><p><strong>信宿</strong>:接受数据的终点</p><p><strong>信道</strong>:数据的传输媒介</p><p>数字信号传输(基带传输)</p><p>模拟信号在模拟信道中传输(宽带传输)</p><h2 id="通信双方的交互方式"><a href="#通信双方的交互方式" class="headerlink" title="通信双方的交互方式"></a>通信双方的交互方式</h2><ul><li>单向通信</li><li>半双工通信(通信双方在同一时间)</li><li>全双工通信</li></ul><h2 id="速率、波特与带宽"><a href="#速率、波特与带宽" class="headerlink" title="==速率、波特与带宽=="></a>==速率、波特与带宽==</h2><p><strong>速率</strong>:数据传输速率</p><pre><code class="lang-css">    - 码元传输速率(波特率) Baud →代表每秒发生的信号变化次数    - 信息传输速率 b/s</code></pre><p><strong>带宽:</strong> 指信号所具有频带的宽 HZ 同时表示单位时间内的最高数据率</p><p>所以三者可以互相转换</p><h2 id="奈氏准则和香农定律"><a href="#奈氏准则和香农定律" class="headerlink" title="==奈氏准则和香农定律=="></a>==奈氏准则和香农定律==</h2><h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><p>在理想低通的信道(没有噪声,带宽有限)</p><p>理想低通信道下的极限数据传输速率:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/奈氏准则.svg" alt="奈氏准则"></p><p>极限码元速率:2W Baud</p><h3 id="香农定律"><a href="#香农定律" class="headerlink" title="香农定律"></a>香农定律</h3><p>在带宽受限且有高斯白噪音干扰的信道的极限传输速率,当用此速率进行传输时,可以做到不产生误差</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/香农定理.svg" alt="香农定理"></p><p>信噪比: S/N,10log~10~(S/N) (dB)</p><blockquote><p>🤔<strong>信噪比为 S/N,为什么还要取对数 10log~10~(S/N)</strong>❓</p><ul><li>以数字信号表示,即一般数值.如噪声功率为 1,信号功率为 100,信噪比为 100/1=100.</li><li><p>以分贝形式表示,同样还是上述数字,分贝形式表示的信噪比为 10log~10~(100/1) = 20dB</p><p>两者的区别在于,前者(数值)是没有单位的,后者必须加 dB,代表分贝.两者数值上等价</p><p>采用分贝表示的原因是,很多时候信号要比噪声强得多,比如信号比噪声强 10 亿倍,使</p><p>用分贝表示则不容易丢失 0</p></li></ul></blockquote><h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p><strong>编码</strong>:将数字数据编码为数字信号</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/编码.svg" alt="编码"></p><p><strong>调制</strong>:数字信号调制为模拟信号</p><p>正交振幅调制(QAM)</p><ul><li>调频:幅移键控(FSK)</li><li>调幅:频移键控(ASK)</li><li>调相:相移键控(PSK)</li></ul><p>采用 m 个相位,每个相位 n 种振幅</p><p>即 log~2~(mn)为每一波特(Baud)所携带的比特数</p><p><strong>模拟信号编码为数字信号</strong></p><p>采样、量化和编码</p><p><strong>采样定理</strong>:==奈奎斯特定理==</p><p>模拟信号转换为数字信号时**原始信号中的最大频率为 f,那么采样频率 f~采样~必须大于等于最大频率的两倍,才能保证采样后的数字信号完整保留原始模拟信号的信息</p><h2 id="电路交换-报文交换与分组交换"><a href="#电路交换-报文交换与分组交换" class="headerlink" title="电路交换,报文交换与分组交换"></a>电路交换,报文交换与分组交换</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p> 进行数据传输前,两结点之间必须建立一条专用的物理通信路径</p><p> 连接建立 → 数据传输 → 连接释放</p><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p> 数据交换的单位是报文,报文携带有<code>目标地址</code>,<code>源地址</code></p><p> 报文交换节点采用的是存储转发的传输方式</p><p> (主要使用在早期的电报通信网中)</p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>同样采用存储转发方式,但限制了每一次传输数据块大小,把大的数据块划分成合理的小数据块,然后添加一些必要的控制信息(源地址、目的地址、编号信息),构成一个个分组(Packet)</p><ul><li>数据报<ul><li>发送分组前不需要建立连接</li><li>最大努力交付</li></ul></li><li>虚电路<ul><li>虚电路的建立:建立一条逻辑通路</li><li>数据传输,进行双向的数据传输</li><li>虚电路的释放:发送释放请求,逐段断开整个连接</li></ul></li></ul><h4 id="分组交换和报文交付时间比较"><a href="#分组交换和报文交付时间比较" class="headerlink" title="==分组交换和报文交付时间比较=="></a>==分组交换和报文交付时间比较==</h4><p>所有链路的数据传输速率为 100Mbps,分组大小为 1000B,其中分组头大小为 20B,若主机 H1 向主机 H2 发送一个大小为 980000B 的文件,在不考虑分组拆装时间和传播时延的情况下,H1 发送开始到 H2 接受为止,需要的时间是多少?</p><p>网络拓扑图如下 👇</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/拓扑.svg" alt="未命名绘图-第 12 页.drawio"></p><p><strong>报文交换时间</strong></p><p>文件从 H1 发送到 R1 所用的时间为:</p><p>t~1~ = (980000×8)/(100×10^6^)</p><p>所以 H1 到 H2 中要经过 3 段路程</p><p>t~总~ = t~1~ × 3</p><p><strong>分组交换时间</strong></p><p>分析:</p><p>一个分组 1000B,分组头 20B =&gt; 一个分组中数据部分为 980B</p><p>分组数 =&gt; 980000B / 980B = 1000 组</p><p>分析前三个分组的传送时间</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/分组交换.svg" alt="分组交换"></p><p>可得时间示意图</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/时间图.svg" alt="时间图"></p><blockquote><p>可类比计算机组成原理中的流水线</p></blockquote><p>当分组 1 到 R1 时</p><p>t = (1000 × 8)/(100×10^6^)</p><p>则分组 1 到 H2 的时间为</p><p>t~1 总~ = t × 3</p><p>所以可得 T~总~为</p><p>T~总~ = 分组 1 到达时间 + (1000 - 1)×t =&gt; T~总~ = t~1 总~ + (1000 - 1)×t</p><h2 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h2><p><code>双绞线</code>、<code>同轴电缆</code>、<code>光纤</code>与<code>无线传输介质</code></p><h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3><h4 id="屏蔽双绞线-STP"><a href="#屏蔽双绞线-STP" class="headerlink" title="屏蔽双绞线(STP)"></a>屏蔽双绞线(STP)</h4><p>shielded twisted pair</p><p><code>F/UTP</code>(FTP,U/FTP) U 代表整条电缆不再加另外的屏蔽层</p><p> 铝箔屏蔽</p><h4 id="无屏蔽双绞线-UTP"><a href="#无屏蔽双绞线-UTP" class="headerlink" title="无屏蔽双绞线(UTP)"></a>无屏蔽双绞线(UTP)</h4><p>unshielded twisted pair</p><h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p> 50Ω 同轴电缆(基带同轴电缆):基带数字信号传送(局域网应用广泛)</p><p> 75Ω 同轴电缆(宽带同轴电缆):宽带信号(有线电视系统)</p><h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p>可见光的频率约为 10^8^MHZ 因此光纤通信带宽范围极大</p><p><strong>多模光纤</strong>:利用光的全反射,只适合近距离传输</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/多模光纤.svg" alt="多模光纤"></p><p><strong>单模光纤</strong>:适合远距离传输</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/单模光纤.svg" alt="单模光纤"></p><h3 id="无线传输介质"><a href="#无线传输介质" class="headerlink" title="无线传输介质"></a>无线传输介质</h3><h4 id="无线电波"><a href="#无线电波" class="headerlink" title="无线电波"></a>无线电波</h4><p>有较强的穿透能力可以传输很长的距离</p><p>应用场景:</p><p> 无线手机通信</p><p> 无线局域网(WLAN)</p><h4 id="微波、红外线和激光"><a href="#微波、红外线和激光" class="headerlink" title="微波、红外线和激光"></a>微波、红外线和激光</h4><p>高带宽,地面传输距离有限</p><p>卫星通信利用地球同步卫星作为中继器转发</p><p>三颗同步卫星(120^°^)能基本实现全球通信</p><p>(传播时延长、保密性差)</p><h2 id="物理接口层的特性"><a href="#物理接口层的特性" class="headerlink" title="物理接口层的特性"></a>物理接口层的特性</h2><ul><li><strong>机械特性</strong>:指明接口所用接线器形状、尺寸、引脚数目、排列、固定和锁定装置</li><li><strong>电气特性</strong>:接口电缆中各条线上的电压范围</li><li><strong>功能特性</strong>:某条件上出现的某一电平和电压的意义</li><li><strong>过程特性(规程特性)</strong>:对不同功能的各种可能事件的出现顺序</li></ul><p><a href="###物理层">接口标准</a></p><h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p>将信号整形后放大再转发出去</p><p>中继器两端都是网段而不是子网</p><p>中继器不能连接两个不同速率的局域网,且需要为同一协议</p><blockquote><p>如果某个网络设备具有”<code>存储转发</code>“的功能</p><p>那么可以认为它能连接两个不同的协议</p></blockquote><p>在采用粗同轴电缆的 10BASE5 的以太网规范中</p><p>规定:==5-4-3 规则==</p><p>互相串联的中继器个数不能超过<code>4个</code>,而且用<code>4个</code>中继器串联的<code>5段</code>通信介质中,只有<code>3段</code>可以挂接计算机</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/543.svg" alt="543"></p><blockquote><p><code>放大器</code>与<code>中继器</code>功能类似</p><p>但是放大器是放大的<code>模拟信号</code>,原理是将衰减的信号<code>放大</code></p><p> 中继器是放大的<code>数据信号</code>,原理是将衰减的信号<code>整形再生</code></p></blockquote><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>实质是一个多端口的中继器</p><p>如果两个或以上的端口同时发送数据那么其所有数据都无效</p><p>即<strong>所有集线器的端口都属于一个冲突域</strong></p><p>即 1 个 10M 带宽的集线器连接 8 台计算机时每台计算机工作时的真正带宽为 10/8 = 1.25Mb/s</p><h3 id="Q-A"><a href="#Q-A" class="headerlink" title="Q.A"></a>Q.A</h3><blockquote><p>==传输媒介并不是物理层==</p><p>其在物理层下面</p><p>传输媒体传输的是信号,即传输不知道所传输的信号代表什么</p><p>但物理层规定了功能特性,所以能识别信号的意义</p></blockquote><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/传输媒介.svg" alt="传输媒介"></p><blockquote><p><strong>什么是基带传输,频带传输和宽带传输?三者的区别是什么?</strong></p><p> <strong>基带传输</strong>→ 在计算机内部或在相邻设备近距离传输时可以不经过调制直接传输数字信号</p><p> <strong>频带传输</strong>→ 用数字信号对特定频率的载波进行调制,将其变为适合传送的信号后再进行传输(远距离/无线传输)</p><p> <strong>宽带传输</strong>→ 借助频带传输,可将链路容量分解为多个信道,每个信道可以携带不同的信号(频分复用)</p></blockquote><h1 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="==数据链路层=="></a>==数据链路层==</h1><h2 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h2><p>将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路</p><p>使其对网络层表现为一条无差错的链路</p><h2 id="为网络层提供的服务"><a href="#为网络层提供的服务" class="headerlink" title="为网络层提供的服务"></a>为网络层提供的服务</h2><p>1)无确认的无连接的服务</p><p> 适用于实时通信,误码率较低的网络(以太网)</p><p>2)有确认无连接的服务</p><p> 适用于误码率较高的通信(无线通信)</p><p>3)有确认的面向连接的服务</p><p> 适用于通信要求较高的场合(可靠性,实时性)</p><blockquote><p><code>有连接就一定有确认</code></p></blockquote><h2 id="链路的管理"><a href="#链路的管理" class="headerlink" title="链路的管理"></a>链路的管理</h2><p> 数据链路层连接的建立、维持和释放的过程称为链路管理</p><p><code>帧定界</code>、<code>帧同步</code>、<code>透明传输</code></p><p>在 HDLC 协议中(高级数据链路控制协议)</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/HDLC.svg" alt="HDLC"></p><h2 id="流量控制-OSI-体系结构"><a href="#流量控制-OSI-体系结构" class="headerlink" title="流量控制(OSI 体系结构)"></a>流量控制(OSI 体系结构)</h2><p>限制发送方的数据流量,使其发送速率不超过接收方的接受能力</p><p>对数据链路层来说,控制的是<code>相邻两节点之间的数据链接的流量</code></p><h2 id="差错控制"><a href="#差错控制" class="headerlink" title="==差错控制=="></a>==差错控制==</h2><p>通过 CRC(循环冗余校验)方式发现位错,通过自动重传请求(Automatic Repeat Request,aARQ)</p><h3 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h3><h4 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a><strong>奇偶校验码</strong></h4><p>n-1 位的信息元后+1 位的校验元</p><p>如果是奇校验码,则代表码长为 n 种有”1”的个数为奇数</p><p> 偶 偶</p><p>不足:只能校验奇/偶位数的错误</p><h4 id="循环冗余码-CRC"><a href="#循环冗余码-CRC" class="headerlink" title="循环冗余码(CRC)"></a><strong>循环冗余码(CRC)</strong></h4><p>发送方和接受方事先商定一个多项式(多项式的最高位和最低位必须为 1)</p><p><code>除数</code>由多项式可得:例如 CRC = X^3^ + X^2^ + 1</p><p>则除数为 1101</p><p><code>被除数</code>为待校验数后加上述多项式最大阶个 0</p><p><code>余数</code>长度为多项式最大阶的位数(X^n^+……+1 即 n 位)</p><p>除法中相减为<code>模2运算</code>(异或运算 → 同 0 异 1)</p><p>最后的发送的帧或报文结构为待校验数+余数(FCS)</p><p>接受方用收到的帧除以商定的多项式 G(x),若能整除,那么认为无差错</p><blockquote><p>循环冗余码(CRC)是具有纠错功能的,只是数据链路层只使用了它的检错功能</p><p>检测到错误的帧直接丢弃,是为了方便协议的实现</p></blockquote><h3 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h3><h4 id="海明码"><a href="#海明码" class="headerlink" title="==海明码=="></a>==海明码==</h4><ol><li><p><strong>确定海明码位数</strong></p><p>设 n 为有效信息位数,k 为校验位的位数</p><p>则信息位 n 和校验位 k 应满足</p><p>n+k ≤ 2^k^-1</p></li></ol><blockquote><p>因为他只能校验一位错误</p><p>即为编码后错误的情况的个数</p><p>为 n+k 位 每 1 个单独的位出错情况,还有一种情况为每一位均无错的情况</p><p>所以总的出错的情况有 n+k+1 种</p><p>校验位 k 位能表示的错误情况为 2^k^个</p><p>k 位校验码表示的错误数应大于 n+k+1 的情况</p></blockquote><ol><li><p><strong>确定校验码在原码的位置</strong></p><p>==设原信息码为 1010==</p><p>校验位在海明码的 2^i-1^(海明码位数为信息位数+校验位数)</p><p>则有 4 位信息位,3 位校验位</p><p>海明码为 H~7~H~6~H~5~H~4~H~3~H~2~H~1~</p><p>校验码位置:P~1~ = 2 ^1-1^→ 第 1 位 P~2~ = 2^2-1^ → 第 2 位 P~3~^3-1^ = 4 → 第 4 位</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/haiming1.svg" alt="haiming1"></p><p>D 为信息位</p><p>P 为校验码所处的位置</p></li></ol><ol><li><p><strong>分组以形成校验关系</strong></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/haiming.svg" alt="haiming"></p><p>按照 P~i~的 i 位上的数去找信息位上相同位来进行分组,若 P~i~的 i 位上的数与信息位 i 位上的数相同,则为一组</p><p>即 G~P1~ = D~1~D~2~D~4~ G~P2~ = D~1~D~3~D~4~ G~P3~ = D~2~D~3~D~4~</p></li></ol><ol><li><p><strong>检验位取值</strong></p><p>P~i~的值为其组的信息位去异或(同 0 异 1)所得</p><p>即:</p><p>P~1~ = D~1~ ⊕ D~2~ ⊕ D~4~ = 0 ⊕ 1 ⊕ 1 = 0</p><p>P~2~ = D~1~ ⊕ D~3~ ⊕ D~4~ = 0 ⊕ 0 ⊕ 1 = 1</p><p>P~1~ = D~2~ ⊕ D~3~ ⊕ D~4~ = 1 ⊕ 0 ⊕ 1 = 1</p><p>则最后所得的海明码为:1010010</p></li></ol><blockquote><p>校验原理:每个校验组与该校验位进行异或操作后结果为 0,则该校验组正确</p><p>海明码纠错 d 位需要码距 2d+1</p><p> 检错 d+1</p></blockquote><h2 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h2><p>把比特组合成以帧为单位进行传输,为了在出错时只重发出错的帧而不用重发全部数据,从而提高效率</p><p>组帧主要解决三个问题</p><p><code>帧定界</code>、<code>帧同步</code>、<code>透明传输</code></p><h3 id="帧定界"><a href="#帧定界" class="headerlink" title="帧定界"></a>帧定界</h3><h4 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h4><p>在帧的头部使用一个计数字段来表明帧内字符数</p><h4 id="字符填充法"><a href="#字符填充法" class="headerlink" title="字符填充法"></a>字符填充法</h4><p><code>SOH</code>代表一帧的开始</p><p><code>EOT</code>代表一帧的结束</p><blockquote><p>若帧的数据字段中包含有<code>SOH</code>和<code>EOT</code>则在其前插入<code>ESC</code>(转义字符),若有<code>ESC</code>则在<code>ESC</code>前插入<code>ESC</code></p></blockquote><h4 id="零比特填充法"><a href="#零比特填充法" class="headerlink" title="零比特填充法"></a>零比特填充法</h4><p>以<code>01111110</code>来标志一帧的开始或结束</p><blockquote><p>在信息位中 5 个连续的 1 后加一个 0 以此区分<code>01111110</code></p></blockquote><h2 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h2><h3 id="停止等待流量控制"><a href="#停止等待流量控制" class="headerlink" title="停止等待流量控制"></a>停止等待流量控制</h3><p>发送方每发送一帧都要等待对方的应答信号才能发送下一帧</p><p>接收方每接受一帧都要反馈一个应答信号接收下一帧</p><h3 id="滑动窗口流量控制"><a href="#滑动窗口流量控制" class="headerlink" title="滑动窗口流量控制"></a>滑动窗口流量控制</h3><p>发送方每收到一个确认帧,发送窗口就往后滑动一帧位置</p><p>接受方每发送一个确认帧,接受窗口就往后滑动一帧位置</p><p><strong>==多帧滑动窗口与后退 N 帧协议(GBN→Go-Back-N)==</strong></p><p>当发送方发送了 N 个帧后,该 N 帧的前一个帧在计时器超时后仍未被确认</p><p>则发送方重传该出错帧以及发送的 N 帧</p><p>为了减少开销,GBN 规定可以在连续收到几个正确的帧后,才对最后一个数据帧发送确认信息(累积确认)</p><p>(即表明该数据帧和此前收到的帧已均被正确无误的收到)</p><blockquote><p>==序号==：因为可靠数据传输的重传机制，所以必不可免的会产生重复帧问题，这时就需要对发送方的数据帧和接收方的确认帧标明序号。一般序号采用 n 位二进制的形式，比如 3 位二进制(000-111)可以表示序号 0-7，所以可以使用的序号空间大小为 8。如果 n 位二进制，则序号空间大小为 2^n^，序号最大值 MAX_SEQ 为 2^n^-1。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/序号空间.svg" alt="序号空间"></p><p>🤔<strong>为什么发送窗口~max~ ≤ 序号空间大小-1</strong>❓</p><p>假设一种实际情况，发送方发送了 0-7 号数据帧，过了不久收到了来自接收方的 7 号确认帧，然后发送方又连续发了新的 0-7 号数据帧，然后过不久又收到了来自接收方对 7 号的确认帧,此时便出现了问题，发送方无法分辨：</p><ul><li>7 号确认帧是对之前的一组 0-7 号数据帧的确认，而新发送的数据全部丢失了</li><li>7 号帧是对新发送的一组数据进行确认</li></ul></blockquote><p><strong>==多帧滑动窗口与选择重传协议(SR→Selective Repeat)==</strong></p><p>选择重传中，接收窗口是大于 1 的，接收方设有缓存，这也就意味着接收方可以不再是按序接收，只要接收到的数据帧在接收窗口的范围内，即可被接收，即使是乱序到达的，仍然放入缓存，等都按序到达一起提交。为了实现只重传某些数据帧，<strong>所以与回退 N 不同，选择重传的接收方对接收到的每个数据帧单独确认（收到谁确认谁），发送方只重传没有收到 ACK 的帧，并为每个帧设定一个定时器。</strong></p><blockquote><p><strong>发送窗口 + 接收窗口 &lt;= 序号空间</strong></p><p><strong>发送窗口与接收窗口大小相同时，发送窗口~MAX~ &lt;= （序号空间 / 2）</strong></p><p>🤔<strong>为什么</strong>❓</p><p>假设序列号空间仍为 8(0-7)，发送窗口大小为 7，避免了回退 N 帧中的问题。接收窗口与发送窗口大小相同。假设发送方连续发送 0-6 号帧后，等待确认帧。接收方成功接收到 0-6 号帧，向前移动窗口如图，回复对接收数据的确认帧。现在假设一种极端情况 0-6 号确认帧全部丢失，发送方直到 0 号数据帧定时器超时未收到确认，重发 0 号数据帧，接收方收到 0 号数据帧恰好落在自己的接收窗口，当做新帧放入缓存，接收方此时希望接收到的最小数据帧为 7 号帧，直到接收方收到一个 7 号帧后，一起交付给网络层，但是这一批并不是正确的帧，而是包含与之前已提交的 0-6 号重复的数据，故产生了错误。在这种情况下，接收方无法分辨到来的 0 号帧是对之前帧的重传还是新帧的到来，因为接收方的新老窗口序号发生了重叠</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/滑动窗口.png" alt="在这里插入图片描述"></p></blockquote><h2 id="信道利用率-1"><a href="#信道利用率-1" class="headerlink" title="信道利用率"></a>信道利用率</h2><p>有效地发送数据的时间占整个发送周期的比率</p><blockquote><p>发送周期:发送方从开始发送数据到收到第一个确认帧的周期</p></blockquote><h2 id="信道吞吐率"><a href="#信道吞吐率" class="headerlink" title="信道吞吐率"></a>信道吞吐率</h2><p>信道利用率 × 发送方的发送速率</p><h2 id="介质访问控制-MAC-子层"><a href="#介质访问控制-MAC-子层" class="headerlink" title="介质访问控制(MAC 子层)"></a>介质访问控制(MAC 子层)</h2><h3 id="信道划介质访问控制"><a href="#信道划介质访问控制" class="headerlink" title="信道划介质访问控制"></a>信道划介质访问控制</h3><h4 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h4><h5 id="频分复用-FDM"><a href="#频分复用-FDM" class="headerlink" title="频分复用(FDM)"></a>频分复用(FDM)</h5><p>Frequency-division multiplexing</p><p>系统传输效率高,由于技术较为成熟,实现也较为容易</p><h5 id="时分复用-TDM"><a href="#时分复用-TDM" class="headerlink" title="时分复用(TDM)"></a>时分复用(TDM)</h5><p>Time-division multiplexing</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/TDM.svg" alt="TDM"></p><p>所以可知若线路传输速率为 800Mb/s</p><p>则 A、B、C、D 每个用户的最高速率为 200Mb/s</p><p><strong>统计时分复用(STDM)</strong></p><p>动态分配每个用户的时间片</p><p>则上述每个用户的最高速率为 800Mb/s</p><h5 id="波分多路复用-WDM"><a href="#波分多路复用-WDM" class="headerlink" title="波分多路复用(WDM)"></a>波分多路复用(WDM)</h5><p>光的频分多路复用</p><h5 id="码分复用-CDM"><a href="#码分复用-CDM" class="headerlink" title="==码分复用(CDM)=="></a>==码分复用(CDM)==</h5><pre><code class="lang-css">例题:共有四个站点进行码分多址通信,四个站的码片分别为:A(-1,-1,-1,+1,+1,-1,+1,+1)B(-1,-1,+1,-1,+1,+1,+1,-1)C(-1,+1,-1,+1,+1,+1,-1,-1)D(-1,+1,-1,-1,-1,-1,+1,-1)现收到这样的码片序列(-1,+1,-3,+1,-1,+3,+1,+1)请问哪个站发送了数据,发送的是0还是1?解:设: K1为A站发送的数据    K2为B站发送的数据    K3为C站发送的数据    K4为D站发送的数据即可得四元一次方程组:    K1×(-1)+K2×(-1)+K3×(-1)+K4×(-1) = -1    K1×(-1)+K2×(-1)+K3×1+K4×1 = 1    K1×(-1)+K2×1+K3×(-1)+K4×(-1) = -3    K1×1+K2×1+K3×1+K4×(-1) = 1    可解得:K1 = 1;K2 = -1;K3 = 0;K4 = 1    即AD发送原码,B发送反码,C没有发送</code></pre><blockquote><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/CDM-1686210653669-8.svg" alt="CDM"></p></blockquote><h3 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h3><p>为了解决随机接入发生的碰撞,每个用户需要按照一定的规则反复重传他的帧,直到该帧无碰撞地通过</p><p><strong>常用的协议</strong></p><h4 id="ALOHA-协议"><a href="#ALOHA-协议" class="headerlink" title="ALOHA 协议"></a>ALOHA 协议</h4><p>全称:Additive Link One-Line Hawaii System</p><ol><li><p><strong>纯 ALOHA 协议</strong></p><p>思想:想发就发,不监听信道,不按时间槽发送,超时/收到 NAK 否认帧后随机重发</p></li><li><p><strong>时隙 ALOHA 协议</strong></p><p>思想:把各个站点的时间同步,再划分时间片,所有用户只能在时间片的开始发送数据</p><p>遇到冲突的情况也只能在时间片的开始发</p></li></ol><h4 id="CSMA-协议"><a href="#CSMA-协议" class="headerlink" title="==CSMA 协议=="></a>==CSMA 协议==</h4><p>载波监听多路访问协议</p><ol><li><p><strong>1-坚持 CSMA</strong></p><p>侦听到信道忙,继续侦听信道,侦听到信道空闲立刻发送数据,若冲突,随机等待,再重新监听</p></li><li><p><strong>非坚持 CSMA(0-坚持 CSMA)</strong></p><p>发送数据时,首先侦听信道,如果信道空闲,立即发送,如果信道繁忙,放弃侦听,等待一个随机时间后重复</p></li><li><p><strong>P-坚持 CSMA</strong></p><p>(用于时分信道)</p><p>持续监听信道,若信道空闲则有 P 概率发送数据,1-P 的概率推迟到下一个时隙</p></li></ol><h4 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="==CSMA/CD 协议=="></a>==CSMA/CD 协议==</h4><p>基于冲突检测的载波监听多路访问技术</p><p>802.3 中的核心，应用在 10M/100M 的半双工有线网络中(总线型局域网(以太网))</p><p><strong>主要思想:</strong></p><p> ==先听后发==,==边听边发==,==冲突停发==,==随机重发==</p><p>在冲突发生时，为了使两个站点都能及时正确接受到冲突发生的信号，要满足传输一帧的时间大于 2 倍的信道传输时延</p><p>CSMA/CD 协议下最小帧长的计算:</p><p> 最小帧长 = <a href="###往返时延(RRT Round Trip Time">RRT</a>) × 数据发送速率</p><p>争用期为 RRT</p><blockquote><p><strong>随机重发:</strong></p><p>==二进制指数退避算法==</p><p>思想:</p><p> 1.定义参数 K(K 为重传次数) K 的取值为[重传次数,10]</p><p> 当重传次数超过 10 后,K 就一直取 10</p><p> 2.从整数集合[0,1,……,2^k^-1]中随机取一个数 r</p><p> 重传所退避的时间为 rRRT</p><p> 重传 16 次说明此时网络太拥挤,认为此帧无法发送,抛弃此帧</p></blockquote><h4 id="CSMA-CA-协议"><a href="#CSMA-CA-协议" class="headerlink" title="CSMA/CA 协议"></a>CSMA/CA 协议</h4><p>载波监听多点接入 / 碰撞避免 协议</p><p>应用于 802.11 无线局域网</p><h4 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h4><p>用于令牌环网</p><p>一个站点只有取得令牌(token)后才能发送数据,因此不会产生冲突</p><p>令牌和数据传输的过程为</p><ol><li>网络空闲,令牌循环传递</li><li>令牌到有数据要发送的站点,该站点修改令牌的一个标志位并在令牌中附加自己需要传输的数据帧,将令牌变为一个数据帧发送出去</li><li>源站通过返回的帧来检验是否要重传</li><li>无错后源站重新产生一个令牌,交出信道控制权</li></ol><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h3 id="局域网的基本概念和体系结构"><a href="#局域网的基本概念和体系结构" class="headerlink" title="局域网的基本概念和体系结构"></a><strong>局域网的基本概念和体系结构</strong></h3><p>局域网（Local Area Network）：简称 LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道。</p><p>特点 1：覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内。</p><p>特点 2：使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb/s~10Gb/s）。</p><p>特点 3：通信延迟时间端，误码率低，可靠性较高。</p><p>特定 4：各站为平等关系，共享传输信道。</p><p>特点 5：多采用分布式控制和广播式通信，能进行广播和组播。</p><p>决定局域网的主要要素为：网络拓扑，传输介质与介质访问控制方法。</p><p><strong>三种特殊局域网拓扑:</strong></p><p><strong>==以太网==</strong></p><p>使用范围最广</p><p>逻辑拓扑为<a href="####总线型">总线型结构</a></p><p>物理拓扑为<a href="####星型">星型或者拓展星型</a></p><p>以太网采用两项措施以简化通信</p><ol><li>采用无连接的工作方式,不对发送的数据帧编号,也不要求接受方发送确认,即以太网尽最大努力交付数据,提供的是不可靠服务,对于差错的纠正则由高层完成</li></ol><blockquote><p>🙋‍♂️ 严格来说以太网是指符合 DIX Ethernet V2 标准的以太网,但 DIX Ethernet V2 与 802.3 标准只有很小的差距</p><p>所以将 802.3 局域网简称为以太网</p></blockquote><p><strong>令牌环</strong></p><p>IEEE 802.5</p><p>逻辑拓扑为<a href="####环形">环形结构</a></p><p>物理拓扑是<a href="####星型">星型结构</a></p><p><strong>FDDI</strong></p><p>光纤分布数字接口</p><p>IEEE802.8</p><p>逻辑拓扑为<a href="####环形">环形结构</a></p><p>物理拓扑为双环结构</p><blockquote><p>🙋‍♂️IEEE802 标准定义的局域网参考模型只对应 OSI 模型中的数据链路层和物理层</p><p>并将数据链路层拆分为两个子层:逻辑链路控制(LLC)子层和媒体接入控制(MAC)子层</p><p>与接入媒体有关的内容都放在 MAC 子层,它向上屏蔽对物理层访问的各种差异,提供对物理层的统一访问</p><p>由于以太网在局域网市场取得垄断地位,几乎称为局域网代名词</p><p>而 802 协会制定的 LLC 子层的作用已经不大,因此现在许多网卡仅装有 MAC 协议而没有 LLC 协议</p></blockquote><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><h3 id="以太网传输介质与-网卡"><a href="#以太网传输介质与-网卡" class="headerlink" title="以太网传输介质与==网卡=="></a>以太网传输介质与==网卡==</h3><h4 id="传输介质-1"><a href="#传输介质-1" class="headerlink" title="传输介质"></a>传输介质</h4><p>各种传输介质以及其情况:</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">10BASE5</th><th style="text-align:center">10BASE2</th><th style="text-align:center">10BASE-T</th><th style="text-align:center">10BASE-FL</th></tr></thead><tbody><tr><td style="text-align:center">传输媒体</td><td style="text-align:center">基带同轴电缆(粗缆)</td><td style="text-align:center">基带同轴电缆(细缆)</td><td style="text-align:center">非屏蔽双绞线</td><td style="text-align:center">光纤对(850nm)</td></tr><tr><td style="text-align:center">编码</td><td style="text-align:center"><a href="###编码与调制">曼彻斯特编码</a></td><td style="text-align:center"><a href="###编码与调制">曼彻斯特编码</a></td><td style="text-align:center"><a href="###编码与调制">曼彻斯特编码</a></td><td style="text-align:center"><a href="###编码与调制">曼彻斯特编码</a></td></tr><tr><td style="text-align:center">拓扑结构</td><td style="text-align:center">总线型</td><td style="text-align:center">总线型</td><td style="text-align:center">星型</td><td style="text-align:center">点对点</td></tr><tr><td style="text-align:center">最大段长</td><td style="text-align:center">500m</td><td style="text-align:center">185m</td><td style="text-align:center">100m</td><td style="text-align:center">2000m</td></tr><tr><td style="text-align:center">最多节点数</td><td style="text-align:center">100</td><td style="text-align:center">30</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr></tbody></table></div><p><code>10</code>是 10Mbit/s 的传输速率 <code>BASE</code>表示使用基带传输 <code>T</code>代表双绞线 <code>FL</code>代表光纤</p><blockquote><p>🙋‍♂️10BASE-T 非屏蔽双绞线以太网拓扑结构为星型,星型网中心为<code>集线器</code>,但使用集线器的以太网在逻辑上仍然是一个总线型网,属于一个冲突域</p><p>上表的内容是常识,题目中不会显示告诉你上述信息</p></blockquote><h4 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h4><p>计算机与外部局域网的连接是通过主板上的网络接口板[又称网络适配器(Adapter)或者网络接口卡(Network Interface Card,NIC)]来实现的</p><p>网卡与局域网之间的通信是通过电缆或双绞线以<code>串行</code>的方式进行的,而网卡和计算机的通信是通过计算机主板上的 I/O 总线以<code>并行</code>的方式进行的,</p><p>所以网卡的重要功能就是:<strong>进行数据的串并转换</strong></p><p>网卡不仅能实现与局域网传输媒介之间的物理连接和电信号匹配,还涉及到帧的发送与接收,帧的封装与拆封,介质访问控制,数据的编码与解码,及数据缓冲功能</p><p>全世界的每块网卡出厂时都有一块唯一的代码,称为<code>介质访问控制(MAC)地址</code>,这个地址控制主机在网络中的数据通信</p><p>数据链路层设备(网桥,交换机等)都使用各个网卡的 MAC 地址</p><p>所以<strong>网卡工作在数据链路层和物理层</strong></p><h3 id="以太网的-MAC-帧"><a href="#以太网的-MAC-帧" class="headerlink" title="以太网的 MAC 帧"></a>以太网的 MAC 帧</h3><p>MAC 地址(物理地址)</p><p>MAC 地址长 6 字节,一般为连字符或冒号分隔</p><p>12 个十六进制数表示如:</p><pre><code class="lang-css">02-60-8c-e4-b1-21</code></pre><p>高 24 位为厂商代码</p><p>低 24 位为厂商自行分配的网卡序列号</p><h4 id="DIX-Ethernet-V2-MAC-帧"><a href="#DIX-Ethernet-V2-MAC-帧" class="headerlink" title="DIX Ethernet V2 MAC 帧"></a>DIX Ethernet V2 MAC 帧</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/v2MAC-1686307099365-2.svg" alt="v2MAC"></p><p>==地址==:通常使用 6 字节(48bit)的数据(MAC 地址)</p><p>==类型==:2 字节指出出数据域中携带的数据应交给哪个协议实体处理</p><p>==数据==:包含高层的协议消息,数据较小的时候进行填充</p><blockquote><p>由以上图可知以太网的最小帧长为 64 字节</p><p>🤔<strong>这个数据位为什么最小为 64 字节</strong>❓</p><p>规定 10Mbit/s 的以太网争用期为 51.2μs,然后考虑到传输过程中的干扰最小帧长为 64B,MAC 头部和尾部占用 18 字节,所以数据位最小长度为 46B,而 1500 是规定的,没有为什么</p><p>循环冗余校验码需要校验包括数据部分(最后加上)</p></blockquote><h4 id="802-3-MAC-帧"><a href="#802-3-MAC-帧" class="headerlink" title="802.3 MAC 帧"></a>802.3 MAC 帧</h4><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/802.svg" alt="802"></p><p>802.3 帧格式与 DIX 以太帧的格式不同之处在于,使用了长度域替代了 DIX 中的类型域,指出数据域的长度</p><blockquote><p>但是在实践中,上述长度/类型两种机制可以并存,由于 IEEE802.3 数据段的最大字节数为 1500</p><p>所以长度段的最大值是 1500,因此从 1501→65535 的值可用于类型段标识符</p></blockquote><h4 id="IEEE802-11-无线局域网-wifi"><a href="#IEEE802-11-无线局域网-wifi" class="headerlink" title="IEEE802.11 无线局域网(wifi)"></a>IEEE802.11 无线局域网(wifi)</h4><p>无线局域网课分为两大类:</p><p><code>有固定基础设施的无线局域网</code>和<code>无固定基础设施的移动自组织网络</code></p><p><strong>有固定基础设施的无线局域网</strong></p><p> 对于固定基础设施的无线局域网,IEEE 指定了无线局域网的 802.11 系列协议标准</p><p>包括 802.11a/b/g/n 等.使用 XIN 星型拓扑,其中心称为<code>接入点(Access Point, AP)</code>,在 MAC 层使用 CSMA/CA 协议.使用 802.11 系列协议的局域网又称 Wi-Fi</p><p> 802.11 标准规定无线局域网最小构件是<code>基本服务集BSS(Basic Service Set)</code>.一个基本服务集包括一个接入点和若干个移动站.各站在本 BSS 内之间通信,或与本 BSS 外部站的通信,都必须通过本 BSS 的 AP,安装 AP 时没必须为该 AP 分配一个不超过 32 字节的<code>服务集标识符(Service Set IDentifier, SSID)</code>和一个信道.SSID 是指使用该 AP 的无线局域网的名字,一个基本服务集覆盖的地理范围称为一个<code>基本服务区(Basic Service Area,BSA)</code>,无线局域网的基本服务区范围直径一般不超过 100m</p><p> 一个基本服务集可以是孤立的,也可以通过 AP 连接到一个<code>分配系统(Distribution System,DS)</code>,然后再连接到另一个基本服务集,就构成了一个<code>拓展服务集(Extended Service Set, ESS)</code>.分配系统的作用就是使拓展服务集对上层表现的就像一个基本服务集一样,ESS 还可以通过一种称为 Portal(门户)的设备为无线用户提供到有线连接的以太网的接入,门户的作用相当于一个网桥</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/ESS-1686449906009-2.svg" alt="ESS"></p><p>上图中 AP1 中的移动站如需要跟 AP2 中的移动站进行通信,就必须经过 AP1 和 AP2,即 A→AP~1~→AP~2~→B.</p><p>若移动站 A 从某个基本服务集<code>漫游</code>到另一个基本服务集时,仍可以和 B 进行通信,但 A 在不同服务集中使用的 AP 改变了</p><p><strong>无固定基础设施移动自组织网络</strong></p><p>又称自组网络(ad hoc network).自组网络没有上述基本服务集中的 AP,而是由一些平等状态的移动站相互通信组成的临时网络,各节点直接地位平等,中间节点都为转发节点,因此都具有路由器的功能</p><p><strong>802.11 MAC 帧</strong></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/802.11.svg" alt="802.11"></p><p>802.11 帧最重要的是 4 个地址字段,上述地址都是 MAC 硬件地址,这里仅讨论前三个地址字段(第四个地址字段用于自组网络).这三个地址字段的内容取决于帧控制字段中的<code>去往AP</code>和<code>来自AP</code>这两个字段的数值</p><p>地址 1 是接收地址,地址 2 是发送地址,下表给出了 802.11 帧地址字段的最常用的两种情况</p><div class="table-container"><table><thead><tr><th>去往 AP</th><th>来自 AP</th><th>地址 1</th><th>地址 2</th><th>地址 3</th><th>地址 4</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>接收地址=目的地址</td><td>发送地址=AP 地址</td><td>源地址</td><td>——</td></tr><tr><td>1</td><td>0</td><td>接收地址=AP 地址</td><td>发送地址=源地址</td><td>目的地址</td><td>——</td></tr></tbody></table></div><blockquote><p>🙋‍♂️ 接收地址和目的地址并不等同</p><p>发送地址和源地址并不等同</p></blockquote><h4 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h4><p>通过虚拟局域网(Virtual LAN),可以把一些较大的局域网分割成一些较小的与地理位置无关的的逻辑上的 VLAN,而每个 VLAN 是一个较小的广播域</p><p>802.ac 标准定义支持 VLAN 的以太网帧格式的拓展.它在以太网帧中插入了一个 4 字节的标识符,称为 VLAN 标签,用来指明发送该帧的计算机属于哪个虚拟局域网.</p><p>插入 VLAN 标签的帧被称为<code>802.1Q帧</code></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/802.1Q.svg" alt="802.1Q"></p><p>VLAN 标签的前两个字节置为 0x8100,表示这是一个 802.1Q 帧,在后两个字节中前 4 位无用,后 12 位标识了这个帧属于哪个 VLAN</p><h3 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h3><p>速率达到或者超过 100Mb/s 的以太网被称为高速以太网</p><p><strong>100BASE-T 以太网</strong></p><p> <em>100BASE-T</em>以太网是在双绞线上传输 100Mb/s 基带信号的星型拓扑结构以太网,它使用<a href="#####==CSMA/CD协议==">CSMA/CD</a>协议.</p><p>这种以太网既支持全双工,又支持半双工方式,可在全双工方式下工作无冲突发生.因此,在全双工方式下不使用<a href="#####==CSMA/CD协议==">CSMA/CD</a>协议</p><p> MAC 帧格式仍然是 802.3 标准规定的.保持最短帧长不变,但将一个网段的最大线缆长度减小到 100m.</p><p>帧的时间间隔从原来的 9.6μs 改为现在的 0.96μs.</p><p><strong>吉比特以太网</strong></p><p> 又称千兆以太网,允许在 1Gb/s 的速率下使用全双工和半双工两种方式工作.使用 802.3 协议规定的帧格式</p><p><strong>10 吉比特以太网</strong></p><p> 不再使用铜线而只使用光纤作为传输媒体,,10 吉比特以太网只工作在全双工方式,因此没有争用问题,不适用<a href="#####==CSMA/CD协议==">CSMA/CD</a>协议</p><h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p>WAN,又称外网/公网</p><p>广域网和局域网的区别和联系如下表所示</p><div class="table-container"><table><thead><tr><th></th><th>广域网</th><th>局域网</th></tr></thead><tbody><tr><td>范围</td><td>广、跨区域</td><td>较小,在一个区域内</td></tr><tr><td>连接方式</td><td>结点之间点到点连接,一个结点与多个结点交换机相连</td><td>多点接入</td></tr><tr><td>OSI 参考模型层</td><td>网络层,数据链路层,物理层</td><td>数据链路层,物理层</td></tr><tr><td>联系与相似点</td><td>1.广域网和局域网都是互联网的重要构成,从互联网的角度上来看,二者平等<br>2.连接到一个局域网或一个广域网上的主机在该网内进行通时,只需要使用其网络的物理地址</td><td></td></tr><tr><td>着重点</td><td>强调资源共享</td><td>强调数据传输</td></tr></tbody></table></div><h3 id="广域网数据链路层协议"><a href="#广域网数据链路层协议" class="headerlink" title="广域网数据链路层协议"></a>广域网数据链路层协议</h3><h4 id="PPP-协议"><a href="#PPP-协议" class="headerlink" title="PPP 协议"></a>PPP 协议</h4><p>PPP(Point-To-Point Protocol)是使用串行线路通信的面向字节的协议,该协议应用在直接连接两个结点的链路上.设计的目的主要是用来通过拨号或者专线方式建立点对点连接发送数据</p><p>PPP 协议有三个组成部分:</p><ol><li>链路控制协议(LCP)。一种拓展链路控制协议,用于建立、测试和管理数据链路</li><li>网络控制协议(NCP)。PPP 协议允许同时采用多种网络层协议,每个不同的网络层协议要用一个相应的 NCP 来配置,为网络层协议建立和配置逻辑连接</li><li><p>一个将 IP 数据报封装到串行链路的方法,IP 数据报在 PPP 帧中就是其信息部分,这个信息部分的长度受最大传送单元(MTU)的限制</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/ppp.svg" alt="ppp"></p></li></ol><blockquote><ol><li><p>PPP 提供差错检测但不提供纠错功能,只保证无差错接收(通过硬件进行 CRC 校验)</p></li><li><p>它仅支持点对点的链路通信,不支持多点线路</p></li><li><p>PPP 只支持全双工链路</p></li><li><p>PPP 的两端可以运行不用的网络层协议,但仍然可以使用同一个 PPP 进行通信</p></li><li><p>PPP 是面向字节的,当信息字段出现和标志字段一致的比特组合时,PPP 有两种处理方法:若 PPP 用在异步线路(默认),采用<a href="#####字符填充法">字符填充法</a></p><p>若 PPP 用在 SONET/SDH 等同步线路,则协议规定采用硬件来完成比特填充</p></li></ol><p>==TCP/IP 协议族==</p><p>SLIP PPP IP ICMP ARP TCP UDP FTP DNS SMTP</p></blockquote><h2 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h2><h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p>工作在链路层的 MAC 子层</p><p>可以使以太网各个网段成为隔离的碰撞域(一个广播域)</p><p>一个网段的故障不会影响另一网段的运行</p><h3 id="局域网交换机"><a href="#局域网交换机" class="headerlink" title="局域网交换机"></a>局域网交换机</h3><p>又称以太网交换机,其实质是一个多端口的网桥</p><p>交换机的每个端口结点所占用的带宽并不会因为端口结点数目的增加而减少</p><p>整个交换机的总带宽会随着端口结点的增加而增加</p><p>利用交换机可以实现虚拟局域网(VLAN)</p><p>不仅可以隔离冲突域也可以隔离广播域</p><p><strong>以太网交换机的特点</strong></p><p>✅ 以太网交换机的每个端口,都直接与单台主机相连,并且一般都工作在全双工方式</p><p>✅ 以太网交换机能同时连接多对端口,使每对相互通信的主机都能像独占通信媒体那样无碰撞地传输数据</p><p>✅ 以太网交换机是一种即插即用设备,其内部的帧的转发表是通过自学习算法自动建立起来的</p><p>✅ 以太网交换机由于使用专用的交换结构芯片,交换效率较高</p><p>✅ 以太网交换机独占传输媒体带宽</p><p><strong>以太网交换机的交换模式</strong></p><ul><li>直通式交换机,只检查帧的目的地址,这使帧在接收后几乎能被马上转发出去.这种方式速度快,但缺乏智能性和安全性,也不支持具有不同速率的端口的交换</li><li>存储转发式交换机,先将收到的帧缓存到高速缓冲器中,并检查数据是否正确,确认无误后通过查找转发表转换为成输出端口将该帧转发.如果帧有错,那么将其丢弃.优点是可靠性高,能支持不同速率端口间的转换,缺点是延迟较大</li></ul><p><strong>交换机的自学习功能</strong></p><p>交换表一开始是空的</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/自学.svg" alt="自学"></p><p>具体的流程如下</p><pre><code class="lang-mermaid">sequenceDiagram    participant 交换机    participant A    participant B    Note over 交换机: 初始状态：交换表为空    A-&gt;&gt;交换机: 发送帧（源MAC地址：A，目标MAC地址：B）    Note over 交换机: 接收到帧    交换机-&gt;&gt;交换机: 学习源MAC地址（MAC地址：A，接收端口：端口1）    交换机--&gt;&gt;A: 发送帧（源MAC地址：A，目标MAC地址：B）    Note over 交换机: 广播，因为未知目标    B-&gt;&gt;交换机: 发送帧（源MAC地址：B，目标MAC地址：A）    Note over 交换机: 接收到帧    交换机-&gt;&gt;交换机: 学习源MAC地址（MAC地址：B，接收端口：端口2）    交换机--&gt;&gt;A: 发送帧（源MAC地址：B，目标MAC地址：A）    Note over 交换机: 知道目标在端口1，转发到端口1</code></pre><p>交换两帧后的交换表:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/自学2.svg" alt="自学2"></p><p>过滤指决定一个帧应该转发到某个接口还是应当丢弃。<br>转发是决定一个帧应该被导向哪个接口。<br>交换机的转发和过滤功能是借助交换机表实现的。交换机表的表项包括：一个 MAC 地址，通向该 MAC 地址的交换机接口以及表项放置在表中的时间。<br>假设一个目的地址为 DD-DD-DD-DD-DD-DD 的帧从交换机接口 x 到达，交换机用 MAC 地址 DD-DD-DD-DD-DD-DD 索引它的表，有三种可能情况 1.表中没有 DD-DD-DD-DD-DD-DD，此时，交换机向除 x 外的所有接口广播该帧 2.表中有 DD-DD-DD-DD-DD-DD，但该表项对应的接口为 x。此时，交换机丢弃该帧 3.表中有 DD-DD-DD-DD-DD-DD，且该表项对应的接口为 y！=x。此时，交换机向接口 y 转发该帧。<br>交换机的自学习</p><p>交换机表初始为空。对于每个接口接收到的每个入帧，该交换机在其表中存储。如果一段时间后没有接收到以该地址为源地址的帧，则会删除该地址。</p><p><strong>交换机和路由器的比较</strong></p><p>1.交换机使用 MAC 地址转发分组，而路由器使用 IP 地址。 2.交换机即插即用，而路由器需要配置 3.交换机对于分组的转发和过滤效率更高。因为交换机只处理至协议栈的第二层，而路由器处理至第三层。 4.为了防止广播帧的循环，交换机的拓扑结构被限制为一颗生成树，而网络寻址是分层次的，且 IP 有特殊字段来限制寿命，因此路由器的拓扑结构没有限制。</p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p><strong>关于物理层、数据链路层、网络层设备对于隔离冲突域和广播域的总结</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">设备名称</th><th style="text-align:center">能否隔离冲突域</th><th style="text-align:center">能否隔离广播域</th></tr></thead><tbody><tr><td style="text-align:center">集线器</td><td style="text-align:center">不能</td><td style="text-align:center">不能</td></tr><tr><td style="text-align:center">中继器</td><td style="text-align:center">不能</td><td style="text-align:center">不能</td></tr><tr><td style="text-align:center">交换机</td><td style="text-align:center">能</td><td style="text-align:center">不能</td></tr><tr><td style="text-align:center">网桥</td><td style="text-align:center">能</td><td style="text-align:center">不能</td></tr><tr><td style="text-align:center">路由器</td><td style="text-align:center">能</td><td style="text-align:center">能</td></tr></tbody></table></div><h1 id="网络层-1"><a href="#网络层-1" class="headerlink" title="==网络层=="></a>==网络层==</h1><h2 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a>网络层的功能</h2><p> 向上只提供简单灵活,无连接的,尽最大努力交付的数据报服务(还提供可靠的面向连接的虚电路服务)</p><h2 id="异构网络互联"><a href="#异构网络互联" class="headerlink" title="异构网络互联"></a>异构网络互联</h2><p>将两个以上的计算机网络通过一定的方法,用一些中间设备(又称中继系统)相互连接起来</p><p>根据所在的层次,中继系统分为以下 4 种</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/中继系统.svg" alt="中继系统"></p><blockquote><p>🙋‍♂️ 网络的异构性是指传输介质、数据编码、链路控制协议及不同的数据单元格式和转发机制</p></blockquote><h2 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h2><p>路由器主要完成两个功能:一个是路由选择(确定哪一条路径),二是分组转发(当一个分组到达时所采取的动作)</p><p><strong>路由选择</strong></p><p>按照复杂的分布式算法,根据从各组相邻路由器所得到的关于整个网络拓扑的变化情况,动态地改变所选择的路由</p><p><strong>分组转发</strong></p><p>指路由器根据转发表将用户的 IP 数据报从合适的端口转发出去</p><p>路由表是根据路由选择算法得出的,而转发表是从路由表得出的.转发表结构应当使查找过程最优化,路由表则需要对网络拓扑变化的计算最优化</p><p>讨论路由选择原理时往往不去区分转发表和路由表,而是笼统的使用路由表一词</p><h2 id="SDN-软件定义网络"><a href="#SDN-软件定义网络" class="headerlink" title="SDN(软件定义网络)"></a>SDN(软件定义网络)</h2><p>在传统的互联网中,每个路由器既有转发表,又有数据选择软件</p><p>即一个路由器又有数据层面,又有控制层面</p><p>在 SDN 网络中</p><p>路由器之间不再交换信息,网络层面有一个逻辑上的远程控制器</p><p>优点:</p><ol><li>控制与转发功能分离</li><li>控制层面集中化</li><li>接口开放可编程</li></ol><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>判断网络是否进入拥塞控制的方法是:<code>观察网络的吞吐量与网络负载关系</code></p><p>若随着网络负载的 ↑ 吞吐量明显小于正常吞吐量</p><p>那么可以判断网络出现了轻度拥塞</p><p>若随着网络负载 ↑ 吞吐量 ↓ 则网络出现拥塞</p><p>若随着网络负载 ↑ 吞吐量=0 则网络出现死锁</p><h2 id="路由算法"><a href="#路由算法" class="headerlink" title="==路由算法=="></a>==路由算法==</h2><blockquote><p>路由是指分组从源到目的地时,决定端到端路径的网络范围的进程</p></blockquote><p><strong>名词介绍:<code>自治系统</code></strong></p><p>自治系统 <code>AS</code> (Autonomous System) ：</p><p>自治系统就是几个路由器组成了一个小团体 👨‍👩‍👧‍👧，小团体内部使用专用的协议进行通信，而小团体和小团体之间也使用专用的协议进行通信。</p><p>就像这个一样 👇</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70.png" alt="img"></p><blockquote><p>🙋‍♂️ 值得一提的是，尽管一个 AS 内部使用了路由选择协议，但是一个 AS 对其他 AS 还是相当于两个普通的路由器在通信。</p></blockquote><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>非适应性路由算法</p><p>由管理员手动配置路由信息</p><p>适用于拓扑变化不大的小网络</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>自适应路由算法</p><h4 id="距离-向量路由协议"><a href="#距离-向量路由协议" class="headerlink" title="距离-向量路由协议"></a>距离-向量路由协议</h4><p>每个结点定期将整个路由选择表传送给与之相应的结点</p><p>每个路由选择表包含</p><ol><li>每条路径的目的地(另一个结点)</li><li>路径的代价(距离)</li></ol><blockquote><p>🙋‍♂️ 这里的距离是一个抽象的概念,如<code>路由信息协议(Routing Information Protocol, RIP)</code>就将距离定义为”跳数”,跳数是指从源端口到达目的端口所经过的路由器的个数,每经过一个路由器,跳数+1</p></blockquote><h5 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h5><p>路由信息协议(Routing Information Protocol, RIP)是<code>应用层协议</code>,它使用==UDP==传输数据(端口 520)</p><p>关于距离的定义：</p><ul><li><p>从一个路由器到直接连接的网络的距离定义为 1。</p></li><li><p>从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。</p></li><li><p>“距离” 也称为 “跳数”(hop count)，因为每经过一个路由器，跳数就加 1。</p></li><li><p>这里的“距离”实际上指的是“最短距离”。</p></li></ul><p><strong>RIP 规定</strong>:</p><p>🔢 一条路径最多只能包含 <code>15</code>个路由器。</p><p>⏲ 默认为任意两个使用 RIP 的路由器每<code>30s</code>广播一次 RIP 路由更新信息,如果<code>180s</code>没有收到相邻路由器的更新那么将其距离设置为 16(不可达)</p><p>⭐RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”。但这这意味着 RIP 只会选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。</p><p>📢 在 RIP 中不支持子网掩码的 RIP 广播,所以 RIP 中每个网络的子网掩码必须相同,但在新的 RIP2 中,支持变长子网掩码和 CIDR</p><p><strong>RIP 协议的三个特点</strong></p><p>1️⃣ 仅和相邻路由器交换信息。<br>2️⃣ 交换的信息是当前本路由器所知道的全部信息，即自己的路由表。<br>3️⃣ 按固定的时间间隔交换路由信息，例如，每隔 30 秒。</p><p><strong>RIP 路由表更新</strong></p><p>假定网络中的路由器 B 的路由表有如下的项目（这三列分别表示“目的网络”、“距离”和“下一跳路由器”）：</p><p><strong>B 的路由表</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">目的网络</th><th style="text-align:center">距离</th><th style="text-align:center">下一跳路由器</th></tr></thead><tbody><tr><td style="text-align:center">N1</td><td style="text-align:center">7</td><td style="text-align:center">A</td></tr><tr><td style="text-align:center">N2</td><td style="text-align:center">2</td><td style="text-align:center">C</td></tr><tr><td style="text-align:center">N6</td><td style="text-align:center">8</td><td style="text-align:center">F</td></tr><tr><td style="text-align:center">N8</td><td style="text-align:center">4</td><td style="text-align:center">E</td></tr><tr><td style="text-align:center">N9</td><td style="text-align:center">4</td><td style="text-align:center">F</td></tr></tbody></table></div><p>现在 B 收到从 C 发来的路由信息（这两列分别表示“目的网络”“距离”）：</p><p><strong>B 收到 C 发来的路由信息</strong></p><div class="table-container"><table><thead><tr><th>目的网络</th><th>距离</th></tr></thead><tbody><tr><td>N2</td><td>4</td></tr><tr><td>N3</td><td>8</td></tr><tr><td>N6</td><td>4</td></tr><tr><td>N8</td><td>3</td></tr><tr><td>N9</td><td>5</td></tr></tbody></table></div><p><strong>B 将收到的信息进行整理可得</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">目的网络</th><th style="text-align:center">距离</th><th style="text-align:center">下一跳路由器</th></tr></thead><tbody><tr><td style="text-align:center">N2</td><td style="text-align:center">4+1 = 5</td><td style="text-align:center">C</td></tr><tr><td style="text-align:center">N3</td><td style="text-align:center">8+1 =9</td><td style="text-align:center">C</td></tr><tr><td style="text-align:center">N6</td><td style="text-align:center">4+1 = 5</td><td style="text-align:center">C</td></tr><tr><td style="text-align:center">N8</td><td style="text-align:center">3+1 =4</td><td style="text-align:center">C</td></tr><tr><td style="text-align:center">N9</td><td style="text-align:center">5+1 =6</td><td style="text-align:center">C</td></tr></tbody></table></div><p>因为 B 距离 C 有一跳所以在 C 发来的路由信息中需要加一跳</p><p><strong>B 将整理后的路由表与原表进行对比,选出到目的网络最短的距离后,得出最终表</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">目的网络</th><th style="text-align:center">距离</th><th style="text-align:center">下一跳路由器</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">N1</td><td style="text-align:center">7</td><td style="text-align:center">A</td><td style="text-align:center">无新信息，不改变</td></tr><tr><td style="text-align:center">N2</td><td style="text-align:center">5</td><td style="text-align:center">C</td><td style="text-align:center">相同的下一跳，更新</td></tr><tr><td style="text-align:center">N3</td><td style="text-align:center">9</td><td style="text-align:center">C</td><td style="text-align:center">新的项目，添加进来</td></tr><tr><td style="text-align:center">N6</td><td style="text-align:center">5</td><td style="text-align:center">C</td><td style="text-align:center">不同的下一跳，距离更短，更新</td></tr><tr><td style="text-align:center">N8</td><td style="text-align:center">4</td><td style="text-align:center">E</td><td style="text-align:center">不同的下一跳，距离一样，不改变</td></tr><tr><td style="text-align:center">N9</td><td style="text-align:center">4</td><td style="text-align:center">F</td><td style="text-align:center">不同的下一跳，距离更大，不改变</td></tr></tbody></table></div><blockquote><p>相同的下一跳，且更新后的距离不变,不更新</p></blockquote><p><strong>RIP 缺点</strong></p><p>1️⃣ RIP 限制了网络的规模,他能使用的最大距离为 15(16 表示不可达)</p><p>2️⃣ 路由器之间交换的是路由器中的完整路由表,因此网络规模越大,开销越大</p><p>3️⃣ 网络出现故障时,会出现”慢收敛”现象</p><blockquote><p>🤔<strong>为什么 RIP 会出现好消息传送得快,坏消息传的慢这种现象</strong>❓</p><p>即网络出故障的传播时间往往需要较长的时间(例如数分钟)</p><p>当网络出现故障时，要经过较长的时间才能将此信息传送到所有的路由器，即<code>“慢收敛”</code>。</p><p><em>“收敛”就是在自治系统中所有的结点都得到正确的路由选择信息的过程。</em></p><p><em>“慢收敛”又被称为<code>路由回路</code></em></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/router.png" alt="在这里插入图片描述"></p><p>当出现坏消息时，比如网 1 出现了故障：</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/20200512234553365.png" alt="在这里插入图片描述"></p><p>这个时候 R1 是知道是无法到达的，则其到网 1 的距离为 16，并且为直接交付。<br>但是 R2 在收到 R1 报文之前，即在 R2 并不知道 R1 出故障时，发送了原来的报文，1 2 R1。<br>于是，R1 收到 R2 更新报文后，误以为可以经过 R2 到网 1，于是更新自己的路由表，1 3 R2，并且将次更新信息发送给 R2.<br>然后 R2 以后又跟新自己的路由表为 1 4 R1, 30s 后，又把这个信息发送给 R1.<br>……………………<br>然后就这样一直循环</p><p>一直到知道了距离等于 16 为止，R2 将网 1 标记为不可到达(即距离为 16)。</p></blockquote><h4 id="链路状态路由协议"><a href="#链路状态路由协议" class="headerlink" title="链路状态路由协议"></a>链路状态路由协议</h4><p>一个结点检查自身所有直通链路状态,并将所得的状态信息发送给网络上所有的结点</p><p>每当结点收到链路状态报文,结点就利用状态去更新字节的网络拓扑和状态,一但链路状态发生改变就对网络图利用<code>Dijkstra算法</code>重新计算</p><p>特点:</p><p>1️⃣ 向自治系统的所有路由器发送信息。使用的是<code>洪泛法</code>即路由器通过所有端口向所有相邻路由器发送信息,每个相邻路由器又将消息发送给其相邻的路由器(不包括刚发送信息的路由器)。</p><p>2️⃣ 发送的信息是与路由器相邻的所有路由器的链路状态,但这只是路由器所知道的部分信息。所谓的”链路状态”,是指说明本路由与哪些路由器相邻及该链路的”度量”。对于<code>OSPF算法</code>,链路状态的”度量”主要用来表示费用、距离、时延、带宽</p><p>3️⃣ 只有链路状态改变才会向所有路由器发送信息。</p><p><strong>典型协议:</strong><code>OSPF</code></p><h5 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h5><p>开放最短;路径优先协议(Open Shortest Path First)</p><p><strong>OSPF 除了具有链路状态路由算法的特点,还有以下特点</strong>:</p><p>4️⃣OSPF 是网络层协议,他不使用 UDP 或者 TCP 而直接用 IP 数据报传送(IP 数据报首部的协议字段为 89)</p><p>5️⃣OSPF 对不同的链路可根据 IP 分组的不同服务类型(TOS)而设置成不同的代价。因此,OSPF 对不同类型的业务可计算不同的路由,十分灵活</p><p>6️⃣ 如果在同一个目的网络有多条代价相同的路径,那么可以将通信量分配给这几条路径。这称为<code>多路径间的负载均衡</code></p><p>7️⃣ 所有在 OSPF 路由器之间交换的分组都有鉴别功能,因而保证了仅在可信赖的路由之间交换链路状态信息</p><p>8️⃣ 支持可变长度的子网划分和无分类编制 CIDR</p><p>9️⃣ 每个链路状态都带上一个 32 位的序号,序号越大,状态越新</p><h4 id="路径向量路由协议"><a href="#路径向量路由协议" class="headerlink" title="路径向量路由协议"></a>路径向量路由协议</h4><h5 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h5><p><strong>边界网关协议(Border Gateway Protocol, BGP) 是不同自治系统的路由器之间交换路由信息的协议。</strong>==BGP 是应用层协议,它是基于 TCP 的==。 默认为当前较新的版本 BGP-4。</p><p><strong>BGP 发言人</strong> :</p><p>每个 自治系统 ( Autonomous System ) 都要 选择一个路由器 , 当做本 自治系统 的发言人 , 该路由器 称为 “BGP 发言人” ; 该 BGP 发言人 路由器大多数情况 是之前说的 OSPF 协议 主干区域的自治系统边界路由器 ; ( 也有例外 )</p><p>BGP 协议 简介 :</p><p>① 交换对象 : 与 其它 自治系统 的 BGP 发言人 交换信息 ;</p><p>② 交换信息 : 交换 网络可达性 信息 , 到达某个网络 , 所要经过的 自治系统 ;</p><p>③ 交换周期 : 发生变化时 才更新 , 并且只 更新有变化的部分 ;</p><p><strong>BGP 协议信息交换过程</strong></p><p>BGP 交换的 网络可达性信息 , 就是到达某个网络 , 所要经过的 一系列的自治系统 ( Autonomous System ) ;</p><p>当 BGP 发言人交换了网络可达性信息后 , 各个 BGP 发言人就可以根据采用的策略 , 从收到的路由信息中 , 找到到达指定 自治系统 ( Autonomous System ) 的 较好的路由 ; ( 注意不是最佳路由 )</p><p>交换的信息 本质是一组完整的路径 ;</p><p><strong>BGP 协议的特点 :</strong></p><p>① 路由表内容 : BGP 协议支持 CIDR 无分类编址 , BGP 路由表项目内容是 : 网络前缀 , 下一跳路由 , 到达目的网络所要经过的自治系统序列 ;</p><p>② 更新数据时机 : 在 BGP 刚启动时 , BGP 与 相邻 BGP 发言人 交换<code>整个 BGP 路由表</code> , 之后只需要在发生变化时, <code>更新有变化的部分</code> ; 这样能节省资源开销 ;</p><h3 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h3><p> 当网络规模扩大时,路由器的路由表成比例的增大,这不仅会消耗越来越多的路由器缓冲区空间,而且需要用更多的 CPU 时间来扫描路由表,用更多的带宽来交换路由状态信息.因此路由选择必须按照层次的方式进行</p><p> 因特网将整个互联网划分为许多较小的自治系统(注意一个自治系统包含很多个局域网),每个自治系统有权自主的决定本系统内应采用何种路由选择协议,如果两个自治系统之间需要通信,那么就需要一种在两个自治系统之间的协议来屏蔽这些差异,因此因特网把路由选择协议分为两大类:<code>内部网关协议</code>和<code>外部网关协议</code></p><p>具体示意图如下 👇</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70-1686545505778-11.png" alt="img"></p><p>✅<strong>内部网关协议(Interior Gateway Protocol, IGP)</strong></p><p>自治系统内部使用的路由选择协议(域内路由选择)</p><p>典型协议:<code>RIP</code>、<code>OSPF</code></p><p><code>OSPF</code>将一个<code>自治系统(AS)</code>再划分为若干区域(Area),每个路由器只知道如何将分组路由到自己所在区域的目标地址,对其他区域内的结构毫不知情</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70-1686545751064-17.png" alt="img"></p><p>✅<strong>外部网关协议(Exterior Gateway Protocol, EGP)</strong></p><p>自治系统间使用的路由选择协议(域间路由选择)</p><p>典型协议:<code>BGP</code></p><p>具体示意图如下 👇</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70-1686545582072-14.png" alt="img"></p><blockquote><p><strong>分组的直接交付和间接交付</strong></p><p>✅<code>直接交付</code>:接收端的 IP 地址与发送方的 IP 地址同属一个子网</p><p>✅<code>间接交付</code>:接收端的 IP 地址与发送方的 IP 地址不同属一个子网</p></blockquote><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="==IPv4=="></a>==IPv4==</h2><p>IPv4 即现在普遍使用的 IP 协议(版本 4).IP 协议定义数据传送的基本单元——IP 分组及其确切的数据结构</p><h3 id="IPv4-分组"><a href="#IPv4-分组" class="headerlink" title="IPv4 分组"></a>IPv4 分组</h3><p>一个 IP 分组由首部和数据部分组成,首部前一部分的长度固定,共 20B,是所有 IP 分组所必有的,在首部固定部分的后面是一些可选字段,其长度可变</p><p>IP 分组格式如下 👇</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/IP分组.svg" alt="未命名绘图-第 9 页.drawio"></p><blockquote><p>🤔<strong>报文，数据报，分片，分组，帧的区别</strong>❓</p><p><strong>报文（message）</strong>：传输协议交给 ip 的数据称为报文；典型的报文包含一个传输层首部和应用程序数据；</p><p><strong>数据报（datagram）</strong>：在报文首部加上 ip 首部形成一个数据报；</p><p><strong>分片（fragment）</strong>：如果在选定网络中，数据报的长度太大，ip 就会把数据报分裂成几个分片，每个分片含有它自己的 ip 首部和一段原来数据报的数据；</p><p><strong>分组（packet）</strong>:提交给数据链路层进行传送时，一个 ip 分片或者一个很小的无需分片的 ip 数据报成为分组；</p><p><strong>帧（frame）</strong>:数据链路层在分组前面加上它自己的首部形成帧，并发送该帧；</p></blockquote><p>IP 首部的重要字段含义如下:</p><ol><li>✅ 版本。指 IP 协议的版本,目前广泛使用的版本为 4</li><li>✅<strong>首部长度</strong>。占 4 位,可以表示的最大十进制数 15。==以 32 位(4B)为单位==,最大值为 60B(15×4B)</li><li>✅<strong>总长度</strong>。占 16 位。指首部和数据之和的长度,==单位为字节==,因此数据报的最大长度为 2^16^-1 = 65535B。以太网帧的最大传送单元(MTU)为 1500B,因此当一个 IP 数据报封装成帧时,数据报总长度(首部＋数据)一定不能超过下层数据链路层的 MTU</li><li>✅ 标识。占 16 位。它是一个计数器,每产生一个数据报就+1,并赋值给标识字段。但他不是”序号”(因为 IP 是无连接的服务)。当一个数据报的长度超过网络的 MTU 时,必须分片,此时每个数据报片都复制一次标识号,以便能重装成原来的数据报</li><li>标志。占 3 位,但只有低两位有效。标志字段的最低位为 MF,MF=1 表示后面还有分片,MF=0 表示最后一个分片。标志字段中间一位是 DF,只有当 DF=0 时才允许分片</li><li>✅<strong>片偏移</strong>。占 13 位。它指出较长的分组在分片后,某片在原分组中的相对位置。片偏移==以 8 个字节为偏移单位==。除最后一个分片外,每个分片长度一定是 8B 的整数倍</li><li>✅ 生存时间(TTL)。占 8 位。数据报在网络中可以通过的路由器数的最大值,标识分组在网络中的寿命,以确保分组不会永远在网络中循环。路由器在转发分组前,先把 TTL 减 1。若 TTL 被减为 0,则该分组必须被丢弃</li><li>✅ 协议。占 8 位。指出此分组携带的数据使用的何种协议,即分组的数据部分应该上交给哪个协议进行处理,如 TCP、UDP 等。其中值 6 表示 TCP,值 17 表示 UDP</li><li>✅ 首部校验和。占 16 位。首部校验和只校验分组的首部,而不校验数据部分。</li><li>✅ 源地址字段。占 4B,标识发送方的 IP 地址</li><li>✅ 目的地址字段。占 4B,标识接收方的 IP 地址</li></ol><blockquote><p>关于长度的标记需要记住,需要熟悉 IP 数据报首部的各个字段的意义与功能,但不需要记忆 IP 数据报首部,正常情况下如果需要参考首部,题目都会直接给出</p></blockquote><h3 id="IP-数据报分片"><a href="#IP-数据报分片" class="headerlink" title="IP 数据报分片"></a>IP 数据报分片</h3><pre><code class="lang-css">一个数据报长度为4000B(固定首部长度)。现经过一个网络传送,但这此网络能够传送的数据最大长度为1500B。试问应当划分为几个短一点的数据报片?每个数据片段的数据字段长度、片偏移字段和MF标志应为何值?分析:1️⃣使用固定首部:IP数据报首部字节固定部分为20字节2️⃣源数据报中数据部分占4000-20 = 3980B3️⃣ 网络能传送的最大有效载荷为(即MTU的数据部分)1500 - 20 = 1480B4️⃣片偏移字段的长度单位为8B#应当划分为几个短一点的数据报片?3980/1480 = 2 余 1020B所以应该分为3个短一些的片#每个数据片段的数据字段长度?1480B 1480B 1020B#每个数据片段的片偏移字段的值?第一个 0第二个 1480/8 = 185第三个 (1480×2)/8 = 370#每个数据片段的MF标志的值?1 1 0</code></pre><p><strong>修改 MTU 的数值后需要注意!!</strong></p><pre><code class="lang-css">一个长4000B的IP数据报(固定首部长度)现经过一个网络传送,但这此网络能够传送的数据最大长度为800B。试问应当划分为几个短一点的数据报片?每个数据片段的数据字段长度、片偏移字段和MF标志应为何值分析:1️⃣使用固定首部:IP数据报首部字节固定部分为20字节2️⃣源数据报中数据部分占4000-20 = 3980B3️⃣ 网络能传送的最大有效载荷为(即MTU的数据部分)800 - 20 = 780B4️⃣片偏移字段的长度单位为8B,那么其数据部分必须为8的整数倍,由分析3所得的780B则无法满足,应修改为776B(8的整数倍中最接近780B的数)</code></pre><blockquote><p>注意:MF=0 并不能确定是独立数据报还是分片得来的,只有当 MF=0 且偏移字段&gt;0 时,才能确定是分片的最后一个分片</p></blockquote><h3 id="IPv4-与-NAT"><a href="#IPv4-与-NAT" class="headerlink" title="IPv4 与 NAT"></a>IPv4 与 NAT</h3><h4 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h4><p>每台主机所拥有的 32 位比特的全球标识</p><p>格式为: 网络号+主机号</p><p>IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/IP的分类.svg" alt="IP的分类"></p><p><strong>IP 地址中有特殊用途,不用于主机的 IP 地址</strong></p><p>✅ 主机号全为 0 表示网络本身</p><p>✅ 主机号全为 1 表示本网络的广播地址</p><p>✅127.x.x.x 保留为回环自检地址,表示任意主机本身,目的地址为回环自检地址的 IP 报永远不会出现在任何网络上</p><p>✅32 位全为 0 表示本网络的本主机(在 IPV4 中表示的是无效的目标地址，但是在服务器端它表示本机上的所有 IPV4 地址)</p><p>✅ 全为 1 表示整个 TCP/IP 网络的广播地址,但由于路由器对广播域的隔离 255.255.255 等效于本网络中的广播地址</p><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>网络地址转换(Network Adress Translation)</p><p>网络地址转换是指用通过将专用网络转换为公用网络从而隐藏内部管理的 IP 地址。它使整个专用网只需要一个全球 IP 地址就可与因特网连通,由于专用网本地 IP 是可重用的,所以 NAT 大大节省了 IP 地址的消耗,同时,它隐藏了内部网络结构,从而降低了内部网络受到攻击的风险</p><p>以下是一些私有 IP 地址网段</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">网段数</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">A 类</td><td style="text-align:center">1</td><td style="text-align:center">10.x.x.x</td></tr><tr><td style="text-align:center">B 类</td><td style="text-align:center">16</td><td style="text-align:center">172.16.x.x~172.31.x.x</td></tr><tr><td style="text-align:center">C 类</td><td style="text-align:center">256</td><td style="text-align:center">192.168.x.x~192.255.x.x</td></tr></tbody></table></div><p><strong>NAT 路由器</strong></p><p>使用 NAT 转换表</p><p>NAT 转换表中存放着{全球 IP 地址:端口号}到{私有 IP 地址:端口号}的映射</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/NAT.svg" alt="NAT"></p><p>通过这种映射可以使多个私有 IP 映射到一个全球 IP</p><blockquote><p>🙋‍♂️ 普通路由器在转发 IP 数据报时,不改变其源 IP 地址和目的 IP 地址。而 NAT 路由器在转发 IP 数据报时,一定要更换其 IP 地址(转换源 IP 地址或目的 IP 地址)。普通路由器仅工作在网络层,而 NAT 路由器转发数据报时需要查看和转换传输层的端口号</p></blockquote><h3 id="子网划分与子网掩码、CIDR"><a href="#子网划分与子网掩码、CIDR" class="headerlink" title="子网划分与子网掩码、CIDR"></a>子网划分与子网掩码、CIDR</h3><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>将一个大的网络划分成几个较小的网络，而每一个网络都有其自己的子网地址</p><p><strong>划分子网的意义</strong><br>在了解子网划分这个问题，首先要明白划分子网到底有什么意义。大家都知道所谓广播传输，就是向本网段的所有节点都发送同样的数据包，这就势必要占用相当多的网络资源（因为每个广播数据包硬件设备都要对它进行分析），特别是带宽资源。然而最令人讨厌的就是在这些广播传输中对终端真正有用的只是所有广播接收用户中的一个。而且网络规模越大，广播数据包发送所占用的资源越多。<br>明白以上这样一个事实后我们就知道划分子网的一下几方面意义：<br>✅ 减少广播：因为广播数据包只能在同一网段中传输，网络规模小了，网络中用户少了，当然占用的资源也就少了。<br>✅ 节省 IP 地址资源：对本身规模较大（200 个用户以上）的网络，划分子网 后，可用的 IP 地址是减少了，但是如果对于那些很小的企业网络来说，划分子网后，又可节省大量的 IP 地址资源。因为几个小网络可以共用一个大的网络地址范围，而且同样可以取到隔离的作用。有四个机房，每个机房 25 台机器，需要给这些机器配置 IP 地址和子网掩码。如果采用 4 个 C 类地址段，每个机房一个，然后在一一配置，一共浪费了（254-25）*4=916 个 IP 地址。<br>✅ 安全性高：由于不同子网之间是不能直接通信的（但可通过路由器或网关进行），在网络形式不容乐观的今天，网络越小，安全性就相对越高。</p><p>✅ 便于维护：一个大的网络要查找故障点是相当困难的，如果把网络规模缩小了，查找的范围也就小了，维护起来也更方便了。</p><p><strong>子网划分的基本思路</strong></p><p>✅ 子网划分纯属单位内部的事,单位对外仍表现为一个没有划分子网的网络</p><p>✅ 从主机号借用若干比特位,作为子网号,当然主机号就减少了相应的比特位。三级 IP 地址的结构如下: IP 地址 = {&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</p><p>✅ 凡是从其他网络发送给本单位网络,</p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p> 为了告诉主机或路由器对 A、B、C 类网络进行了划分,使用子网掩码来表示源网络中子网号对主机号的借位</p><p> 子网掩码是一个与 IP 地址相对应的、长 32bit 的二进制串,1 对应 IP 地址及子网号,0 对应于主机号计算机只需要将 IP 地址和其对应的子网掩码逐位相<code>与(逻辑AND运算)</code>,就可以得出对应子网的网络地址</p><blockquote><p>现在的因特网标准规定:所有的网络都必须使用子网掩码。如果一个网络未发生子网,就采用默认子网掩码。</p><p>A、B、C 类地址的默认子网掩码为 255.0.0.0、255.255.0.0、255.255.255.0</p></blockquote><h4 id="无分类编址-CIDR"><a href="#无分类编址-CIDR" class="headerlink" title="无分类编址 CIDR"></a>无分类编址 CIDR</h4><p><strong>无分类域间路由选择 CIDR</strong>是在变长子网掩码的基础上提出的一种消除传统的 A、B、C 类网络划分,并且可以在软件的支持下实现<code>超网</code>构造的一种 IP 地址的划分方法</p><p><strong>CIDR 最主要的特点</strong>:<br>✅CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。<br>✅CIDR 使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。<br>✅IP 地址从三层编址（使用子网掩码）又回到了两层编址。<br>✅CIDR 使用“斜线记法” ，它又称为 CIDR 记法，即在 IP 地址后面加上一个斜线“/”，然后写上网络前缀所占的位数（这个数值对应于三层编址中子网掩码中 1 的个数）。<br>✅CIDR 把网络前缀都相同的连续的 IP 地址组成“CIDR 地址块”。</p><p><strong>CIDR 结构记法</strong></p><pre><code class="lang-css">IP::=&#123;&lt;网络前缀&gt;,&lt;主机号&gt;&#125;</code></pre><p><strong>CIDR 地址块</strong>:</p><p>128.14.32.0/20 表示的地址块共有 212 个地址（因为斜线后面的 20 是网络前缀的位数，所以这个地址的主机号是 12 位）。<br>这个地址块的起始地址是 128.14.32.0。<br>在不需要指出地址块的起始地址时，也可将这样的地址块简称为“/20 地址块”。<br>128.14.32.0/20 地址块的最小地址：128.14.32.0<br>128.14.32.0/20 地址块的最大地址：128.14.47.255<br>全 0 和全 1 的主机号地址一般不使用。<br>举个栗子<br>128.14.32.0/20 表示的地址（2^12^ 个地址）</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/1868057-20200116113955907-746362849.png" alt="img"></p><p><strong>路由聚合(route aggregation)</strong><br>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。<br><code>路由聚合也称为构成超网(supernetting)</code>。<br>CIDR 地址块划分举例<br>一个大学把 c 类地址分配给各个系</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/1868057-20200116113934556-1532572828.png" alt="img"></p><p>这个 ISP （互联网服务提供商）共有 64 个 C 类网络。如果不采用 CIDR 技术，则在与该 ISP 的路由器交换路由信息的每一个路由器的路由表中，就需要有 64 个项目。但采用地址聚合后，只需用路由聚合后的 1 个项目 206.0.64.0/18 就能找到该 ISP。</p><p>构成超网<br>前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C 类地址。<br>这些 C 类地址合起来就构成了超网。<br>网络前缀越短，其地址块所包含的地址数就越多。而在三层结构的 IP 地址中，划分子网是使网络前缀变长。</p><p><strong>最长前缀匹配(最佳匹配)</strong>:</p><p>使用 CIDR 时,查找路由表时应当匹配结果中选择最长网络前缀的路由</p><p>原因：网络前缀越长，其地址块就越小，因而路由就越具体(more specific)越准确 。</p><blockquote><p>得到下一跳路由器的 IP 地址后,并不是直接将该地址填入待发送的数据报,而是将该 IP 地址转换为 MAC 地址(通过 ARP),将此 MAC 地址放到 MAC 帧的首部,,然后根据这个 MAC 地址找到下一条路由器.在不同网络中传送时,MAC 帧的源地址和目的地址要发生变化,但是在网桥转发帧时,不改变帧的源地址,请注意区分</p></blockquote><h2 id="ARP、DHCP-与-ICMP"><a href="#ARP、DHCP-与-ICMP" class="headerlink" title="ARP、DHCP 与 ICMP"></a>ARP、DHCP 与 ICMP</h2><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>地址解析协议 Address Rsolution Protocol</p><p>无论网络层使用何种协议,在链路层传送数据帧时都必须使用 MAC 地址</p><p>所以使用 ARP 来完成 IP → MAC 地址的映射</p><p>每台主机都有一个 ARP 高速缓存</p><p>主机 A 欲向某台主机 B 发送 IP 数据报,先在 ARP 高速缓存中查看有无主机 B 的 IP 地址,如果有,查出其 MAC 地址,将其 MAC 地址写入 MAC 帧的目标地址,如果没有则通过使用目的地址为: FF:FF:FF:FF:FF:FF 的帧来封装并广播 ARP 请求分组,使同一局域网的所有主机都收到此 ARP 请求,主机 B 收到 ARP 请求后向主机 A 发送 ARP 相应分组,分组中包含主机 B 的 IP 和 MAC 地址的映射,主机 A 收到 ARP 响应分组后,将其映射写入 ARP 缓存</p><blockquote><p>🙋‍♂️ARP 在 TCP/IP 中是网络层协议,在 OS 模型中是链路层协议,但是我的理解是其更应该是属于链路层和网络层协议中间的协议,因为其能看到 IP 地址,又能对 MAC 帧进行操作(修改其目的 MAC 地址)</p></blockquote><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>动态主机配置协议(Dynamic Host Conficuration Protocol),常用于给主机动态分配 IP 地址,它提供了即插即用的联网机制,该机制允许以太计算机加入新的网络和获取 IP 地址而不用手工参与.DHCP 是<code>应用层协议</code>,它是基于<code>UDP</code>的</p><p>DHCP 工作原理如下:</p><p> 使用客户端/服务器模式</p><p> 需要 IP 的主机在启动时就向 DHCP 服务器广播发送报文,此时主机成为<code>DHCP客户</code>.本地网络上所有的主机都能接收到该<code>发现报文</code>,但只有<code>DHCP服务器</code>才能回应此报文,DHCP 服务器先在其数据库上查找该计算机的配置,若找到则返回找到的信息,若未找到,则从服务器的<code>IP池</code>中取一个地址分配给该计算机,DHCP 的回答报文称为<code>提供报文</code></p><blockquote><p>DHCP 允许网络上配置多台 DHCP 服务器,当客户端发出”DHCP 发现”消息时可能会收到多个应答报文,客户端只会挑选其中一个,通常是最先到达的</p></blockquote><h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>网际控制信息协议(Internet Control Message Protocol)</p><p>使用 ICMP 让主机或路由器报告差错和异常情况。ICMP 报文作为 IP 层数据报的数据,加上数据报的首部,组成 IP 数据报发送出去。<code>ICMP是IP层协议</code>。</p><p>ICMP 报文的种类有两种,即<code>ICMP差错报文</code>和<code>ICMP询问报文</code></p><p><strong>ICMP 差错报告报文</strong>分为 5 种类型</p><ol><li><strong>终点不可达</strong>:当主机或路由器不能交付数据报时,向源终点发终点不可达</li><li><strong>源点抑制</strong>:当路由器或者主机拥塞而丢弃数据报时,就向源点发送源点抑制报文,使源点知道应当把数据报的发送速率放慢</li><li><strong>时间超过</strong>:当路由器收到生存时间为(TTL)为零的数据报时,除丢弃该数据报外,还要向源点发送时间超过报文。当终点在预先规定时间内不能收到一个数据报的全部数据报片时,就把已收到的数据报片全丢弃,并向源点发送时间超过报文</li><li><strong>参数问题</strong>:当路由或目的主机收到数据报首部中有的字段值不正确时,就丢弃该数据报,并向源点发送参数问题报文</li><li><strong>改变路由(重定向)</strong>:路由器把改变路由报文发送给主机,让主机知道下次应将数据报发送给另外的路由器(可通过更好的路径)</li></ol><p>🚨 不应发送 ICMP 差错报告报文的有以下几种:</p><ol><li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文</li><li>对第一个分片的数据报片的所有后续数据报片不再发送 ICMP 差错报告报文</li><li>对有组播地址的数据报都不发送 ICMP 报告报文</li><li>对具特殊地址(如 127.0.0.0 或 0.0.0.0)的数据报发送 ICMP 差错报告报文</li></ol><p><strong>ICMP 询问报文</strong>分 4 种类型:<code>回送请求和回答报文</code>、<code>时间戳请求和回答报文</code>、<code>地址掩码请求和回答报文</code>、<code>路由器询问和通告报文</code> 。最常用的是前两种</p><p>ICMP 最常见的应用是<code>分组网间探测PING</code>(用来测试两台主机之间的连通性,使用 ICMP 回送和请求报文)和<code>Traceroute(路由追踪)</code>(这是 UNIX 的命令,Windows 中是 Tracert,可以用来跟踪分组经过的路由,使用了 ICMP 时间时间超过报文)</p><blockquote><p>🙋‍♂️PING 工作在应用层,它直接使用网络层的 ICMP,而未使用传输层测 TCP 或 UDP。Traceroute 工作在网络层</p></blockquote><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p><strong>为了解决 IP 地址耗尽的措施有 3 种</strong>:</p><ol><li>采用 DIDR</li><li>采用 NAT 以节省全球 IP 地址</li><li>采用更大空间地址空间的新版本的 IPv6</li></ol><p>IPv6 地址的主要特点如下:</p><ul><li>从 32 位增大到 128 位</li><li>拓展的地址层次结构</li><li>灵活的首部格式</li><li>改进的选项</li><li>允许协议继续扩充</li><li>支持即插即用(即自动配置)</li><li>支持资源的预分配</li><li>IPv6 只有在包的源节点才能分片,是端到端的,传输路径中的路由器不能分片,所以从一般意义上说,IPv6 不允许分片(不允许类似 IPv4 的路由分片)</li><li>IPv4 首部长度必须是 8B 的整数倍,IPv4 是 4B 的整数倍</li><li>增大了安全性。身份验证和保密功能是 IPv6 的关键特征</li></ul><h3 id="IPv6-地址"><a href="#IPv6-地址" class="headerlink" title="IPv6 地址"></a>IPv6 地址</h3><p>IPv6 数据报的目的地址可以是以下三种部分:</p><ol><li>单播。单播就是传统的点对点通信</li><li>多播。多播是一点对多点的通信,分组被交付到一组计算机的每台计算机</li><li>任播。这使 IPv6 增加的一种类型。任播的目的站是一组计算机,但数据报在交付时只交付其中一台计算机,通常是距离最近的一台计算机</li></ol><p><strong>IPv6 地址的缩写</strong></p><p>IPv4 地址通常使用点分十进制表示法。如果 IPv6 也用这种表示法,那么地址书写起来将相当长,所以 IPv6 采用了冒号 16 进制表示法,即用每 4 位二进制数用一个 16 进制数表示,并用冒号将每 4 位 16 进制数用冒号分隔</p><p>例:point_down:</p><pre><code class="lang-css">4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170</code></pre><p>每 16 位二进制我们将其称之为域</p><p><strong>当 16 位域的开头有一些 0,可以直接省略,但必须保留 1 个字符</strong></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/ipv6缩写.svg" alt="ipv6缩写"></p><p><strong>当有相连的 0 值域时,还可以进一步缩写,这些域可以用双冒号缩写</strong></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/缩写.svg" alt="缩写"></p><blockquote><p>🚨 双冒号表示法在一个地址中仅能出现一次,选择相邻数最多的 0 值域进行使用</p></blockquote><p><strong>IPv4 向 IPv6 过渡可以采用的两种方法</strong></p><p>1️⃣<em>双协议栈</em></p><p>即一台设备上同时装有 IPv4 和 IPv6 的协议栈</p><p>如果是路由器不同接口,可能分别配置了 IPv4 和 IPv6 地址,如果是计算机,则同时具有 IPv4 和 IPv6 地址</p><p>2️⃣<em>隧道技术</em></p><p>将 IPv6 数据报封装到 IPv4 数据报的数据部分,使 IPv6 能在 IPv4 网络中传输</p><h2 id="IP-组播"><a href="#IP-组播" class="headerlink" title="IP 组播"></a>IP 组播</h2><h3 id="IP-数据报的三种传输方式"><a href="#IP-数据报的三种传输方式" class="headerlink" title="IP 数据报的三种传输方式"></a>IP 数据报的三种传输方式</h3><p><strong>单播</strong>：单播用于发送数据包到单个目的地，且每 发送一份单播报文都使用一个单播 IP 地址作为目的地址。是一种点对点传输方式。</p><p><strong>广播</strong>：广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种点对多点传输方式。</p><p><strong>组播（多播）</strong>：当网络中的某些用户需要特定数据时，组播数据发送者仅发送一次数据，借助组播路由协议为组播数据包建立组播分 发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点传输方式。</p><h4 id="单播和组播的比较"><a href="#单播和组播的比较" class="headerlink" title="单播和组播的比较"></a>单播和组播的比较</h4><p>单播在发送者和每一接收者之间需要单独的数据信道。<br>组播提高了数据传送效率。减少了主干网出现拥塞的可能性。组播组中的主机可以是在同一个物理网络，也可以来自不同的物理网络（如果有组播路由器的支持=&gt;组播路由器：运行组播协议的路由器）。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/af6f6abead684157a3871ca83a5c8b7a_无水印 (2" alt="af6f6abead684157a3871ca83a5c8b7a_无水印">.png)</p><h3 id="IP-组播地址"><a href="#IP-组播地址" class="headerlink" title="IP 组播地址"></a>IP 组播地址</h3><p>IP 组播地址让源设备能够将分组发送给一组设备。属于多播组的设备将被分配一个组播组 IP 地址（一群共同需求主机的相同标识）。</p><p>组播地址范围为 224.0.0.0 ～ 239.255.255.255（D 类地址），一个 D 类地址表示一个组播组。只能用作分组的目标地址。源地址总是为单播地址。</p><p><strong>IP 组播地址的特点</strong>： 1.组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于 UDP。 2.对组播数据报不产生<code>ICMP差错报文</code>。 3.并非所有 D 类地址都可以作为组播地址</p><h3 id="IP-组播的分类"><a href="#IP-组播的分类" class="headerlink" title="IP 组播的分类"></a>IP 组播的分类</h3><p>组播可以分为两种:一种只在本局域网上进行<strong>硬件组播</strong>;另一种则在<strong>因特网的范围内进行组播</strong>。在因特网上进行组播的最后阶段，还是要把组播数据报在局域网上用硬件组播交付给组播组的所有成员。</p><p>IANA(互联网地址指派机构)拥有的以太网组播地址范围是从 01-00-5E-00-00-00 到 01-00-5E-7F-FF-FF。不难看出,每个 MAC 地址种只有 23 位可以用作组做。这只能和 D 类 IP 地址中的 23 位有一一对应的关系</p><p>下面是硬件组播映射关系:point_down:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/组播.svg" alt="组播"></p><blockquote><p>🤔<strong>以太网组播 IP 地址 224.215.145.230 应该映射到的组播 MAC 地址是</strong>❓</p><p>以太网组播地址块的范围是 01-00-5E-00-00-00~01-00-5E-7F-FF-FF，而且在每个地址中，只有后 23 位可用组播。这样，只能和 D 类 P 地址中的后 23 位有–一对应关系。D 类 P 地址可供分配的有 28 位,可见这 28 位中的前 5 位不能用来构成以太网硬件地址。215 的二进制为 11010111,其中，在映射过程中最高位为 0，因此 215.145.230 的二进制为 01010111.10010001.11100110，对应的十六进制数是 57-91-E6。</p><p>所以是 01-00-5E-57-91-E6</p></blockquote><h3 id="IGMP-协议与组播路由选择协议"><a href="#IGMP-协议与组播路由选择协议" class="headerlink" title="IGMP 协议与组播路由选择协议"></a>IGMP 协议与组播路由选择协议</h3><p>ROUND 1：</p><p>某主机要加入组播组时，该主机向组播组的组播地址发送一个 IGMP 报文，声明自己要称为该组的成员。<br>本地组播路由器收到 IGMP 报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器。</p><p>ROUND 2：<br>本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。<br>只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的；如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</p><p>组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/8e7826dcd85e4dd6a52abfdff4642fb8_无水印.png" alt="8e7826dcd85e4dd6a52abfdff4642fb8_无水印"></p><h2 id="移动-IP"><a href="#移动-IP" class="headerlink" title="移动 IP"></a>移动 IP</h2><h3 id="移动-IP-的概念"><a href="#移动-IP-的概念" class="headerlink" title="移动 IP 的概念"></a>移动 IP 的概念</h3><p>移动 IP 技术是移动结点(计算机/服务器等)以<strong>固定的网络 IP 地址</strong>，实现<strong>跨越不同网段的漫游</strong>功能，并保证了基于网络 IP 的网络权限在漫游过程中不发生任何改变。</p><p>基于 IPv4 的移动 IP 定义三种功能实体:移动结点、归属代理（也称本地代理）和外埠代理(也称外部代理)。归属代理和外埠代理又统称为移动代理。</p><p><strong>移动结点</strong>：具有永久 IP 地址的移动设备。<br><strong>归属代理（本地代理）</strong>：一个移动结点的永久“居所”称为归属网络，在归属网络中代表移动节点执行移动管理功能的实体叫做归属代理。<br><strong>永久地址（归属地址/主地址）</strong>：移动站点在归属网络中的原始地址。<br><strong>外部代理（外地代理）</strong>：在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理。<br><strong>转交地址（辅地址）</strong>：可以是外部代理的地址或动态配置的一个地址。</p><p>移动 P 技术的基本通信流程如下:</p><ol><li>移动结点在本地网时，按传统的 TCP/IP 方式进行通信（在本地网中有固有的地址)。</li><li>移动结点漫游到一个外地网络时，仍然使用固定的 P 地址进行通信。为了能够收到通信对端发给它的 IP 分组，移动结点需要向本地代理注册当前的位置地址，这个位置地址就是转交地址（它可以是外部代理的地址或动态配置的一个地址)。</li><li>本地代理接收来自转交地址的注册后，会构建一条通向转交地址的隧道，将截获的发给移动结点的 P 分组通过隧道送到转交地址处。</li><li>在转交地址处解除隧道封装，恢复原始的 IP 分组，最后送到移动结点，这样移动结点在外网就能够收到这些发送给它的 IP 分组。</li><li>移动结点在外网通过外网的路由器或外部代理向通信对端发送 IP 数据包。</li><li>移动结点来到另一个外网时，只需向本地代理更新注册的转交地址，就可继续通信。</li><li>移动结点回到本地网时，移动结点向本地代理注销转交地址，这时移动结点又将使用传统的 TCP/IP 方式进行通信。</li></ol><blockquote><p>🙋‍♂️ 移动 P 为移动主机设置了两个 P 地址，即主地址和辅地址（转交地址)。移动主机在本地网时，使用的是主地址。当移动到另一个网络时，需要获得一个临时的辅地址，但此时主地址仍然不变。从外网移回本地网时，辅地址改变或撤销，而主地址仍然保持不变。</p></blockquote><h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h2><h3 id="冲突域和广播域"><a href="#冲突域和广播域" class="headerlink" title="冲突域和广播域"></a>冲突域和广播域</h3><h4 id="冲突域"><a href="#冲突域" class="headerlink" title="冲突域"></a>冲突域</h4><p> 冲突域是指连接到同一物理介质上的所有结点的集合,这些结点之间存在介质争用现象,在 OSI 模型中,冲突域被视为第一层的概念,像中继器、集线器等简单无脑复制转发信号的第一层设备所链接的结点都属于一个冲突域,也就是说他们不能划分冲突域</p><h4 id="广播域"><a href="#广播域" class="headerlink" title="广播域"></a>广播域</h4><p> 广播域是指接收相同广播消息的结点集合。也就是说在该集合中任何一个节点发送一个广播帧,其他能收到这个帧的结点都被认为是该广播域的一部分。在 OSI 模型中,广播域被视为第二层概念,像第一层(集线器等)、第二层(交换机等)设备所连接的结点都属于同一个广播域</p><p> 通常所说的局域网(LAN)特指使用路由器分割的网络,也就是广播域</p><h1 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h1><p>传输层对收到的报文进行差错检测(首部数据部分)网络层只检查 IP 数据报的首部,不检验数据部分</p><h2 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h2><h3 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h3><p> 端口能让应用层的各种进程将其数据通过通过端口向下交付给传输层,以及让传输层应当将其报文段的数据通过端口交付给应用层相应进程</p><p>端口是传输层的服务访问端口(Transport Service Access Point,TSAP)</p><p>数据链路层的 SAP 是 MAC 地址</p><p>网络层的 SAP 是 IP 地址</p><p>传输层的 SAP 是端口</p><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>应用进程用过端口号进行标识,端口长度为==16bit==,能够表示 65536(2^16^)个不同的端口号。端口号具有本地意义,即端口号只标识本计算机应用层各个进程,在因特网中不同计算机相同端口号是没有联系的。根据端口号范围,可将端口分为两类:</p><p>🖥︎ 服务端使用的端口号</p><ol><li><p>熟知端口号:0~1023(IANA 将其指派给了 TCP/IP 最重要的一些应用程序)</p><p>常用的熟知端口号</p><p>| 应用程序 | 熟知端口号 |<br>| :———: | :————: |<br>|   FTP    |     21     |<br>|  TELNET  |     23     |<br>|   SMTP   |     25     |<br>|   DNS    |     53     |<br>|   TFTP   |     69     |<br>|   HTTP   |     80     |<br>|   SNMP   |    161     |<br>|  HTTPS   |    443     |</p></li><li><p>登记端口号:1024~49151(供没有使用熟知端口号的应用使用,必须在 IANA 登记,以防止重复)</p></li></ol><p>💻︎ 客户端使用的端口号</p><p>49152~65535</p><p>仅在客户进程运行时才动态选择,又称临时端口(短暂端口)</p><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>在网络中通过 IP 地址来标识区别不同的主机。通过端口号来标识和区分一台主机中不同的应用进程。端口号拼接到 IP 地址即构成<code>套接字Socket</code>。在网络中采用发送方和接受方的套接字来识别端点。套接字,实际上是一个通信端点,即:</p><pre><code class="lang-css">套接字Socket = (IP地址:端口号)</code></pre><p>它唯一地标识网络中一台主机和其上的一个应用(进程)</p><h2 id="无连接服务和面向连接服务"><a href="#无连接服务和面向连接服务" class="headerlink" title="无连接服务和面向连接服务"></a>无连接服务和面向连接服务</h2><p><a href="####服务的种类">无连接服务和面向连接服务</a></p><p>TCP/IP 协议族在 IP 层之上使用了两个传输协议:<code>TCP</code>与<code>UDP</code></p><p>TCP 提供面向连接的服务,使用 TCP 的应用有:<code>FTP(文件传输协议)</code>、<code>HTTP(超文本传输协议)</code>、<code>TELNET(远程登录)</code></p><p>UDP 提供无连接的服务,使用 UDP 的应用有:<code>TFTP(小文件传输协议)</code>、<code>DNS</code>、<code>SNMP</code>和<code>RTP(实时传输协议)</code></p><blockquote><p>🤔<strong>IP 数据报与 UDP 数据报的区别</strong>❓</p><p>UDP 数据报是封装在 IP 数据报的数据部分进行传输的</p><p>🤔<strong>TCP 和网络层虚电路的区别</strong>❓</p><p>TCP 报文在传输层抽象的逻辑信道中传输,对路由器不可见;虚电路所经过的交换结点,都必须保存虚电路的状态信息,而网络层采用的虚电路方式则无法提供无连接的服务而传输层采用 TCP 不影响网络层提供无连接的服务</p></blockquote><h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><p> UDP 仅在 IP 数据报服务之上增加了两个最基本的服务:复用/分用以及差错检测</p><p> UDP 常用于传输较少数据的网络应用,如 DNS,SNMP。UDP 也常用于多媒体应用(如 IP 电话、实时视频会议、流媒体等),可靠数据可靠数据传输对其并不重要,但较大的延迟无法容忍</p><p>UDP 的优点有以下 5 点:</p><ol><li><p>UDP 无须建立连接,因此 UDP 不会引入建立连接的时延</p></li><li><p>无连接状态</p></li><li><p>分组开销少,为 8B</p></li><li><p>UDP 没有拥塞控制,因此网络中的拥塞不会影响主机的发送效率</p></li><li><p>UDP 支持一对一、一对多、多对一的交互通信</p></li></ol><h3 id="UDP-数据报"><a href="#UDP-数据报" class="headerlink" title="UDP 数据报"></a>UDP 数据报</h3><p> UDP 是面向报文的,UDP 对应用层交下的报文添加首部后就交付给网络层,既不合并,也不拆分,接收方 UDP 对网络层上交的 UDP 数据报,去除首部,原封不动交付上层应用进程,”报文”是 UDP 数据报处理的最小单位,<code>UDP的报文长度发送应用进程决定</code>。</p><p><strong>以下为 UDP 首部格式</strong>👇</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/UDP首部.svg" alt="UDP首部"></p><p>各字段意义如下 👇</p><ol><li><em>源端口</em>:需要对方回信时使用,不使用就全为 0</li><li><em>目的端口</em>:目的端口号。这在终点交付报文中必须使用到</li><li><em>长度</em>:UDP 数据报长度(首部+数据),其最小值为 8(仅有首部)</li><li><em>校验和</em>:检测 UDP 在传输中是否有错,有错就丢弃。该字段是可选的,当源主机不想计算校验和时,则直接令该字段全为 0</li></ol><h4 id="UDP-校验"><a href="#UDP-校验" class="headerlink" title="UDP 校验"></a>UDP 校验</h4><p> 在计算校验和时要在 UDP 首部临时添加一个 12B 的”伪首部”,计算完后移除,如果数据部分长度不是偶数位,则需要在数据部分尾部填入一个全零字节(计算后移除,不发送)</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/udp校验.svg" alt="udp校验"></p><p>检验和主要是基于反码求和运算:</p><blockquote><p>反码算数运算：两个数进行二进制反码求和的运算很简单。它的规则是从低位到高位逐列进行计算。0 和 0 相加是 0，0 和 1 相加是 1，1 和 1 相加是 0，但要产生一个进位 1，加到下一列。如果最高位相加后产生进位，则最后得到的结果要加 1。</p></blockquote><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/2053630-20200602184154246-457729371.jpg" alt="img"></p><p>UDP 校验和的计算方法:</p><p>发送方:</p><p>1.将校验和字段置零。</p><p>2.把所有比特位按 16-bit（2 字节）一组进行划分。</p><p>3.把 2 中划分好的组进行向加，如果遇到进位，将进位值加到值的最低位上。举例：（用 16 进制表示）</p><p>0xBB5E+0xFCED = 0x1 B84B, 可以看出在这个例子中结果有进位，所以将进位值 1 加到值的最低位上，得到结果是 0xB84C</p><p>4.把所有的组相加到一起后，得到的结果是一个 16 位的数，<code>将这个结果取反后则得到了校验码</code>。</p><p>接收方:</p><ol><li>将 4 个 16 比特的数（包含校验和）加起来，一定等于 1111 1111 1111 1111（相当于两个反码相加），<strong>这也是取反码做校验和的原因</strong></li><li>如果不等，校验和错误，传输出现问题</li></ol><h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="==TCP 协议=="></a>==TCP 协议==</h2><p>TCP 是在不可靠的 IP 层之上实现的可靠的数据传输协议,它主要解决传输可靠、有序、无丢失和不重复的问题。</p><p><strong>TCP 的主要特点如下</strong>:</p><ol><li>TCP 是面向连接的传输层协议,TCP 连接时一条逻辑链路</li><li>每条 TCP 连接只能有两个端点,每条 TCP 的连接只能是端到端的(进程对进程)</li><li><p>TCP 提供全双工通信,允许通信双方的应用程序在任何时候都能发送数据。为此 TCP 连接的两端都设有发送缓存和接受缓存,用来临时存放双方通信的数据</p><p>发送缓存用来存放以下数据:</p><p>① 发送应用程序出纳送给发送方 TCP 准备发送的数据;</p><p>② 发送方已发送但尚未收到确认的数据</p><p>接收缓存用来存放以下数据:</p><p>① 按序到达但尚未被接受应用程序读取的数据</p><p>② 不按序到达的数据</p></li></ol><pre><code class="lang-css">4) TCP是面向字节流的,虽然应用程序和TCP的交互是一次一个数据块(大小不等),但TCP把应用程序交下来的数据仅视为一连串的无结构的字节流4) TCP提供可靠交付的服务,保证传送的数据无差错,不丢失,不重复且有序</code></pre><h3 id="TCP-报文段"><a href="#TCP-报文段" class="headerlink" title="TCP 报文段"></a>TCP 报文段</h3><p><strong>以下为 TCP 首部格式</strong>👇</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/TCP报文-1686806714799-4.svg" alt="TCP报文"></p><p><strong>TCP 首部各字段意义如下</strong>:</p><ol><li><em>源端口和目的端口</em>:各占 2B。端口是运输层与应用层的服务接口,==运输层的复用和分用的功能都要靠端口实现==</li><li><em>序号</em>:占 4B,范围是 0~2^23^-1。因为 TCP 是面向字节流的(即 TCP 的传输时是逐个字节传送的),所以 TCP 连接传送的字节流中的每个字节都按顺序编号。序号字段的值指的是本报文段所发送的数据的第一个字节的序号</li><li><em>确认号</em>:占 4B,是期望收到对方下一个报文段的第一个数据字节的序号,若确认号为 N 则表明到序号 N-1 为止的所有数据都已正确收到</li><li><em>数据偏移(首部长度)</em>:占 4 位。注意与<a href="####IPv4分组">IP 数据报分片的数据偏移</a>进行区分,这里表示的是首部长度,即 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。数据偏移以==4B 为单位==,而 4 位二进制最多能表示 15,所以 TCP 首部最大长度为 60B</li><li><em>保留</em>:占 6 位,保留为今后使用,但目前应置为 0</li><li><em>紧急位 URG</em>:当 URG = 1 时表明紧急指针字段有效。他告诉系统此报文中有紧急数据,应当尽快传送</li><li><strong><em>确认位 ACK</em></strong>:仅当 ACK = 1 时确认字段有效,ACK = 0 时确认号无效</li><li><em>推送位 PUSH</em>:接收方收到 PUSH = 1 的报文时应尽快交付给应用程序,而不用等到整个缓存满了再向上交付</li><li><em>复位位 RST</em>:RST = 1 时表明连接出现严重差错(如主机崩溃或其他原因)必须释放连接再重新建立连接</li><li><strong><em>同步位 SYN</em></strong>:SYN = 1 时表明这是一个请求连接或者连接接受报文当 SYN = 1 ACK =0 时表明是连接请求;SYN = 1 ACK = 1 表明同意建立连接</li><li><em>终止位 FIN</em>:用来释放一个连接,当 FIN = 1 时表示此报文的发送方数据已经发送完毕,并要求释放运输连接</li><li><em>窗口</em>:允许对方发送给的数据量</li><li><em>校验和</em>:要求将 TCP 报文首部加上一个 12B 的”伪首部”后再进行计算(只需要将 UDP 伪首部中的协议字段从<code>17</code>改为<code>6</code>,其他部分与 UDP 一样)</li><li><em>紧急指针</em>:占 2B。紧急指针在 URG = 1 时才有效,它指出在本报文段中紧急数据共有多少字节(紧急指针在报文段数据的最前面)</li><li><em>选项</em>:长度可变。TCP 最初之规定了一种选项,即最大报文长度(Maximum Segment Size, MSS)。MSS 是 TCP 报文段中的数据字段的最大长度(仅仅是数据字段)</li><li>填充。这是为了使整个首部长度是 4B 的整数倍</li></ol><h3 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h3><p> TCP 是面向连接的服务,因此每个 TCP 连接都有三个阶段:<code>连接建立</code>、<code>数据传输</code>、<code>连接释放</code></p><p> TCP 把连接作为最基本的抽象,每条 TCP 连接有两个端点,TCP 连接的端点不是主机,不是主机的 IP 地址,不是应用进程,也不是传输层的协议端口。TCP 连接的端口即为<a href="####套接字">套接字(Socket)</a>或插口。,每条 TCP 连接唯一地被通信的两个端点(即两个套接字)确定。</p><p> TCP 连接的建立采用客户端/服务器模式(C/S 模式)。主动发起连接的应用进程称为客户(Client),而被动等待连接建立的应用进程称为服务器(Server)</p><h4 id="TCP-连接的建立"><a href="#TCP-连接的建立" class="headerlink" title="TCP 连接的建立"></a>TCP 连接的建立</h4><p>连接的建立经历以下 3 个步骤,通常称为<code>&quot;三次握手&quot;</code>👇</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/2019110521581684_无水印.jpg" alt="2019110521581684_无水印"></p><ol><li><p>服务器进程准备好接受外来的连接，这通常是通过调用 socket，bind，listen 这三个函数来完成，我们称之为被动打开（passive open）。然后服务器进程就处于<code>LISTEN</code>状态，等待客户的连接请求，如有，则作出响应。</p></li><li><p>客户通过调用 connect 发起主动打开（active open），向服务器发出连接请求报文段，请求中的首部的同步位 SYN = 1，同时选择一个初始序号 seq = x。TCP 规定，<code>SYN报文段不能携带数据，但要消耗一个序号</code>。<br>这时，TCP 客户进入<code>SYN-SEND（同步已发送）</code>状态。</p></li><li><p>服务器收到客户端连接请求后，必须确认（ACK）客户的 SYN 报文段。在确认报文段中，把 SYN 和 ACK 位都置为 1，确认号为<code>ack = x + 1</code>，同时也为自己选择一个初始序号<code>seq = y</code>。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。<br>这时，TCP 服务器进入<code>SYN-RCVD（同步收到）</code>状态。</p></li><li><p>客户在收到服务器的确认后，还要向服务器进程给出确认。确认报文段的 ACK 置 1，确认号<code>ack = y + 1</code>，而自己的序号<code>seq = x + 1</code>。TCP 规定，这个报文段可以携带数据，也可以不携带数据，如果不携带数据，下一个数据报文段的序号仍是<code>seq = x + 1</code>。<br>这时，TCP 连接已经建立，客户进入<code>ESTABLISHED（已建立连接）</code>状态。</p></li><li><p>服务器收到客户的确认后，也进入<code>ESTABLISHED</code>状态。</p><p>在上述的建立连接的过程中，前后发送了三个报文段，因此 TCP 建立连接<br>的过程也称之为三次握手（three-way handshake）。</p></li></ol><blockquote><p>🤔<strong>为什么需要三次握手?而不是 2 次</strong>❓</p><p>为什么客户在收到服务器的确认后，还要向服务器发送一次确认呢？这主要是为了防止已失效的连接请求报文段突然又传送到了服务器，因而发生错误。<br>考虑一种情况，客户发出连接请求后，但因连接请求报文丢失而未收到确认。于是客户再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。客户共发送了两个连接请求报文段，其中第一个丢失，第二个到达了服务器。没有“已失效的连接请求报文段”。<br>现假定一种异常情况。即客户发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达服务器。本来这是一个早已失效的报文段，但服务器收到此失效的连接请求后，就误认为是客户又一次发出一次新的连接请求。于是就向客户发出确认报文段，同意建立连接。假定不采用三次握手，那么只要服务器发出确认，新的连接就建立了。<br>由于现在客户端并没有发出建立连接的请求，因此不会理睬服务器的确认，也不会向服务器发送数据。但服务器却以为新的连接已经建立了，并一直等待客户发送数据。服务器的许多资源就这样白浪费了。<br>采用三次握手的办法可以防止上述现象的发生。例如刚才的情况下，客户不会向服务器的确认发出确认，由于服务器收不到确认，就知道客户并没有要求建立连接。</p><p>🚨 值得注意的是,服务器在第二次握手的时候就已经预先分配了资源,而客户端分配缓存资源的时间在第三次握手,这就使得服务器易受到<code>SYN洪泛攻击</code></p></blockquote><h4 id="TCP-连接的释放"><a href="#TCP-连接的释放" class="headerlink" title="TCP 连接的释放"></a>TCP 连接的释放</h4><p>天下没有不散的筵席,TCP 也同样如此。参与 TCP 连接的两个进程中的任意一个都能终止该连接。TCP 连接释放的过程被称为<code>&quot;四次挥手&quot;</code>👇</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/20191105215832763_无水印_无水印.jpg" alt="20191105215832763_无水印_无水印"></p><ol><li>A 的应用进程先发出释放连接报文段，并停止发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部 FIN 置 1，其序号为 seq = u。这时 A 进入<code>FIN-WAIT-1（终止等待1）</code>状态。</li><li>B 收到连接释放报文段后即发出确认确认号为 ack = u + 1，而自己的序号为 seq = v。然后 B 就进入<code>CLOSE-WAIT（关闭等待）</code>状态。TCP 服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍接收。</li><li>A 收到来自 B 的确认后，就进入<code>FIN-WAIT-2（终止等待2）</code>状态，等待 B 发出的连接释放报文段。</li><li>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放 连接。这时 B 发出的连接释放报文段 FIN = 1，还必须重复上次已发送过的确认号 ack = u + 1。假定 B 的序号为 w（在半关闭期间 B 可能又发送了一些数据）。这时 B 就进入了<code>LAST-ACK（最后确认）</code>状态，等待 A 的确认。</li><li>A 收到了的连接释放报文段后，必须对此发出确认。其确认号为 ack = w + 1，而自己的序号为 seq = u + 1。然后进入到<code>TIME-WAIT（时间等待）</code>状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器（TIME-WAIT timer）设置的时间 2MSL 后，A 才进入到 CLOSED 状态。时间 MSL 叫做最长报文段寿命（Maximum Segment Lifetime）。</li><li>B 只要收到 A 发出的确认，就进入 CLOSED 状态。我们注意到，B 结束 TCP 连接的时间要比 A 早一些。<br>由于释放 TCP 连接的过程需要发送四个报文段，因此释放连接的过程也称之为<code>四次挥手</code>。</li></ol><blockquote><p>🙋‍♂️<strong>TIME_WAIT 状态</strong><br>上述释放连接的过程中，A 在 TIME-WAIT 状态必须等待 2MSL，才进入 CLOSED 状态，上面也提到，这个 MSL 是报文段的最长寿命。那么 MSL 的真实含义是什么呢？<br>MSL 是任何 IP 数据报能够在网络中存活的最长时间。我们知道这个时间是有限的，因为每个数据报含有一个称为跳限（hop limit）的 8 位字段，它的最大值是 255，即最大为 255 跳。尽管这是一个跳数限制而不是真正的时间限制，我们仍然假设：具有最大跳限的数据报在网络中存在的时间不可能超过 MSL 秒。<br>任何 TCP 实现都必须为 MSL 选择一个值。RFC 1122 的建议值为 2 分钟，对于现在的网络，MSL = 2 分钟可能太长了，故一些实现采用 30 秒的值，这意味着，TIME-WAIT 状态的持续时间在 1 分钟到 4 分钟之间。<br><strong>为什么客户在 TIME-WAIT 状态必须 2MSL 的时间呢？这有两个理由</strong>：</p><p>1）<strong>可靠地实现 TCP 全双工连接的终止</strong><br>客户 A 最后一个 ACK 报文段可能丢失，这样服务器 B 处于 LAST-ACK 状态而收不到确认。接下来 B 会超时重传 FIN + ACK 报文段，而 A 就能在 2MSL 时间内收到这个重传的 FIN + ACK 报文段，并再重传一次确认，并重新启动 2MSL 计时器。最后，A 和 B 都正常进入 CLOSED 状态。<br>如果 A 在发送完最后一个 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样 B 就无法按照正常步骤进入 CLOSED 状态。</p><p>2）<strong>防止“已失效的连接请求报文段”出现在本连接中</strong><br>客户 A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都会网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p><p><strong>对于应用程序来说，什么情况下会出现大量 TIME_WAIT 的状态</strong>？</p><p>TIME_WAIT 的出现是一般是客户主动关闭 TCP 连接而出现的，即出现在客户端机器，服务端机器一般不会出现 TIME_WAIT 状态。</p></blockquote><h3 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h3><p> TCP 的任务是在 IP 层的不可靠、尽力而为服务的基础上建立一种可靠数据传输服务。TCP 提供的可靠数据传输服务就是要保证接收方进程从缓冲区读出的字节流与发送方发出的字节流是完全一样的。TCP 使用了校验、序号、确认和重传机制来达到这个目的。</p><p>其中校验机制与<a href="#####UDP校验">UDP 校验机制</a>一致,只不过将其协议段从 17 改为 6</p><p><strong>序号</strong></p><p> TCP 首部的序号字段用来保证数据能有序提交给应用层，TCP 把数据看成一个无结构但是有序的字节流，而序号是建立在传送的字节流之上，而不是建立在报文段之上。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</p><p><strong>确认</strong></p><p> TCP 首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。TCP 默认使用累计确认，即 TCP 只确认数据流中至第一个丢失字节为止的字节。例如，接收方 B 收到了发送方 A 发送的包含字节 0~2 和 6 ~7 的报文段。由于某些原因，B 还没有收到字节 3~5 的报文段，此时 B 仍在等待字节 3(和其后面的字节)，因此，B 到 A 的下一个报文段将确认号字段设置为 3。</p><p><strong>重传</strong></p><p> 有两种事件会导致 TCP 对报文段进行重传：</p><ol><li><p><em>超时</em></p><p>TCP 每发送一个报文设置一个计时器</p><p>当计时器的时间高于加权平均往返时间 RTT~s~(随着 RRT 样本值的变化而变化)还未收到确认,就重传该报文</p></li><li><p><em>冗余 ACK(冗余确认)</em></p><p>TCP 规定当发送方收到对同一个报文段的 3 个冗余 ACK 时,就可以认为跟在这个确认报文段之后的报文段已经丢失</p><p>每当比期望序号大的失序报文段到达时，发送一个冗余 ACK，指明下一个期待字节的序号。</p><p>发送方已发送 1，2，3，4，5 报文段<br>​ 接收方收到 1，返回给 1 的确认(确认号为 2 的第一个字节)<br>​ 接收方收到 3，仍返回给 1 的确认(确认号为 2 的第一个字节)<br>​ 接收方收到 4，仍返回给 1 的确认(确认号为 2 的第一个字节)<br>​ 接收方收到 5，仍返回给 1 的确认(确认号为 2 的第一个字节)</p><p>发送方收到 3 个对于报文段 1 的冗余 ACK——认为 2 报 文段丢失，重传 2 号报文段</p></li></ol><h3 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h3><p>基于数据链路层所介绍的<a href="####滑动窗口流量控制">滑动窗口</a></p><p><code>传输层</code>和<code>数据链路层</code>的流量控制的区别是:</p><pre><code class="lang-css">1) 传输层是定义`端到端之间的流量控制`,数据链路层定义中间`两个相邻结点的流量控制`1) 传输层的窗口可以动态变化,数据链路层的滑动窗口协议的窗口大小不能动态变化</code></pre><h3 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h3><p><strong>拥塞控制和流量控制的区别</strong></p><p>拥塞控制是让网络能够承受现有的网络负荷,是一个全局性的过程,涉及所有主机、路由器</p><p>流量控制往往是点到点的通信量的控制,是一个端到端的访问</p><h4 id="TCP-的拥塞控制算法"><a href="#TCP-的拥塞控制算法" class="headerlink" title="TCP 的拥塞控制算法"></a>TCP 的拥塞控制算法</h4><p>慢开始、拥塞避免、快重传、快恢复</p><p><strong>TCP 协议要求发送方维护两个窗口</strong>:</p><ol><li><p>接收窗口<code>rwnd</code></p><p>接收方根据目前接收缓存大小所许诺的的最新窗口值</p></li><li><p>拥塞窗口<code>cwnd</code></p><p>发送方根据字节估算的网络拥塞程度而设置的窗口值</p></li></ol><p>发送窗口的上限值应取接收窗口 rwnd 和拥塞窗口 cwnd 中较小的一个即:</p><pre><code class="lang-css">发送MAX = min[rwnd,cwnd]</code></pre><h5 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h5><p>思想:</p><ol><li><p>先令 cwnd = 1 (此处这里的 1 代表 1 个 MSS 的长度(最大报文段长度),<code>窗口是以字节为单位的</code>)</p></li><li><p>每当过一个<a href="###往返时延(RRT Round Trip Time">RRT(往返时延)</a>)cwnd 的值翻倍</p><p>一直到一个阈值 → 慢开始门限(ssthresh)</p></li><li><p>然后进行拥塞避免算法</p></li></ol><h5 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h5><p>思想:</p><ol><li>每过一个 RRT 就把 cwnd+1</li><li>若网络出现拥塞(即未按时收到确认),就把慢开始门限(ssthresh)设置为出现拥塞时的 cwnd 的一半,然后将 cwnd 重新设置为 1,重新执行慢开始算法</li></ol><p><strong>以下是拥塞避免和慢开始的流程图</strong>👇</p><pre><code class="lang-mermaid">graph TDA(开始) --&gt; B[cwnd = 1]B --&gt; C&#123;cwnd &lt; ssthresh&#125;C -- 是 --&gt; D[慢开始: cwnd翻倍]D --&gt; CC -- 否 --&gt; E[拥塞避免: cwnd + 1]E --&gt; F&#123;出现拥塞?&#125;F -- 是 --&gt; G[ssthresh = cwnd / 2, cwnd = 1]G --&gt; CF -- 否 --&gt; E</code></pre><blockquote><p>当 cwnd = ssthresh 既可以使用慢开始算法,又可以使用拥塞避免算法(通常使用)</p></blockquote><h5 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h5><p><strong>快重传(利用了冗余 ACK)</strong></p><p> 当收到 3 个对同一个报文段的 ACK 确认,立即重传对方尚未收到的报文段,而不必等待那个报文段设置的重传计时器超时。快重传并非取消重传计时器,而是在某些情况下可更早地重传丢失的报文段</p><blockquote><p>🤔<strong>TCP 是使用的 GBN 还是 SR 选择重传</strong>❓</p><p>TCP 使用累计确认,值看起来像是 GBN 的风格,但是正确收到但失序的报文并不会丢弃,而是缓存起来,TCP 至多一次重传一个报文段(即冗余 ACK 之后的报文段),而 GBN 需要重传错误报文段后的所有报文段,,另外 TCP 提供一个 SACK 选项,即选择确认选项,而使用选择确认选项时,TCP 看起来就和 SR 非常相似。因此,TCP 的差错恢复机制可视为 GBN 和 SR 协议的混合体</p></blockquote><p><strong>快恢复</strong></p><p>当网络拥塞发生时(发送方连续收到三个冗余 ACK 时),进行网络拥塞的处理后(将慢开始门限设置为此时发送方 cwnd 的一半),将 cwnd 设置为慢开始 sstresh 的值,然后执行拥塞避免算法,由于跳过了拥塞窗口 cwnd 从 1 起始的慢开始过程,所以被称为快恢复</p><h1 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h1><h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><h3 id="客户-服务器模型"><a href="#客户-服务器模型" class="headerlink" title="客户/服务器模型"></a>客户/服务器模型</h3><p>Client/Server 模型(C/S 模型)中有一个总是打开的主机称为<code>服务器</code>,它服务于许多来自其他称为<code>客户机</code>的主机请求。</p><p><strong>最主要的特征</strong>:<em>客户是服务请求方.服务器是服务提供方</em></p><p>主要特点还有:</p><ol><li>网络各计算机地位不平等</li><li>客户机之间不直接通信</li><li>可拓展性不佳</li></ol><p><strong>常见应用</strong>:<code>web</code>、<code>文件传输协议(FTP)</code>、<code>远程登录</code>和<code>电子邮件</code></p><h3 id="P2P-模型"><a href="#P2P-模型" class="headerlink" title="P2P 模型"></a>P2P 模型</h3><p>P2P 网络是指在互联网中由对等结点组成的覆盖网络(Overlay Network),是一种动态的逻辑网络,它没有固定的客户和服务器划分,<em>任意一对计算机(对等方)直接通信</em>(显著特点)</p><p>P2P 缺点:占用较多内存影响整机速度,经常进行 P2P 下载会对硬盘造成较大的损伤</p><h2 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统(DNS)"></a>域名系统(DNS)</h2><p>域名系统(Domain Name System, DNS)用来把便于人们记忆具有特定含义的主机名转换为便于机器处理的 IP 地址。</p><p>DNS 使用 C/S 模型,其协议运行在<a href="###UDP协议">UDP</a>之上,使用<code>53</code>号端口</p><p>概念上可将 DNS 分为三个部分:<code>层次域名空间</code>、<code>域名服务器</code>和<code>解析器</code></p><h3 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h3><p>层次域名空间结构如下 👇</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/域名.svg" alt="域名"></p><ol><li>标号中的英文不区分大小写</li><li>标号中除连字符(-)外不能使用其他标点符号</li><li>每个标号不能超过 63 个字符,多标号组成的完整域名不超过 255 个字符</li><li>级别最低的域名写最左边,级别最高的顶级域名写最右边</li></ol><p><strong>顶级域名</strong>分为三类<br>(Top Level Domain, TLD)</p><ol><li><p><em>国家(地名)顶级域名(nTLD)</em>:”.cn”表示中国;”.us”代表美国;”.uk”表示英国</p></li><li><p><em>通用顶级域名(gTLD)</em>:常见的有”.com”→ 公司;”.net”→ 网络服务机构;”.org”→ 非盈利组织和”.gov”→ 国家或政府部门</p></li><li><p><em>基础结构域名</em>:这种顶级域名只有一个,即 arpa 用于反向域名解析(又称反向域名)</p></li></ol><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/域名树状.svg" alt="域名树状"></p><h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><p> DNS 将域名地址解析成 IP 地址,其使用了大量的域名服务器并将它们以层次的方式组织,没有一台域名服务器有因特网上所有主机的映射,相反映射分布在所有 DNS 上,采用”分布式”设计的 DNS,是一个在因特网上实现分布式数据库的精彩范例</p><p>总共四种类型的域名服务器:</p><h4 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a>根域名服务器</h4><p> 所有根域名服务器都知道所有的顶级域名服务器的 IP 地址</p><p> 本地域名服务器只要字节无法解析们都要首先求助于根域名服务器,通常它不直接把待查询的域名直接转换为 IP 地址,而是告诉本地域名服务器下一步应当找哪个顶级域名服务器进行查询</p><blockquote><p>🙋‍♂️ 因特网上有<code>13</code>个域名服务器(其实为 13 个 IP 地址,每个 IP 地址后都是一个冗余服务器的集群),中国没有根域名服务器(IPv4),只有根镜像域名服务器</p><p>(我国已有 IPv6 根域名服务器)</p></blockquote><h4 id="顶级域名服务器"><a href="#顶级域名服务器" class="headerlink" title="顶级域名服务器"></a>顶级域名服务器</h4><p> 这些域名服务器管理在该顶级域名服务器注册的所有二级域名,收到 DNS 请求时,就给出相应的回答(可能是最后的结果,也可能是下一步应当查找的域名服务器的 IP)</p><h4 id="授权域名服务器"><a href="#授权域名服务器" class="headerlink" title="授权域名服务器"></a>授权域名服务器</h4><p> 每台主机都必须在授权域名服务器处登记。为了更可靠地工作,一台主机最好至少有两个授权域名服务器。实际上许多域名服务器同时充当本地域名服务器和授权域名服务器</p><p> 授权域名服务器总能将其管辖的主机名转换为该主机的 IP 地址</p><blockquote><p>🤔<strong>到底什么是授权域名服务器</strong>❓</p><p>假设你有一家网上商店，网址是www.example.com。为了让人们能够访问你的网站，你需要注册一个域名，并将其映射到你的网站服务器的IP地址上。你选择了一个域名注册公司来注册你的域名，比如GoDaddy。注册完成后，你需要将域名服务器配置为GoDaddy的域名服务器。</p><p>此时，GoDaddy 就是你的授权域名服务器。当有人在浏览器中输入www.example.com时，浏览器会向本地域名服务器发送一个查询请求，询问该网址对应的IP地址是什么。本地域名服务器可能不知道答案，因此会向更高级别的域名服务器发送查询请求，该请求最终会到达GoDaddy的域名服务器。</p><p>GoDaddy 的域名服务器保存了你的域名信息，包括将www.example.com映射到哪个IP地址上。它会将这个信息返回给本地域名服务器，本地域名服务器再将其返回给浏览器，浏览器就可以通过该IP地址连接到你的网站了。</p><p>因此，授权域名服务器的作用是确保每个域名的真实信息只能由授权的机构进行管理和修改，从而防止了恶意攻击和网络欺诈。</p></blockquote><h4 id="本地域名服务器"><a href="#本地域名服务器" class="headerlink" title="本地域名服务器"></a>本地域名服务器</h4><p> 每个因特网服务提供者(ISP) 或一所大学甚至一所大学中的各个系,都可以拥有一个本地域名服务器,每当一台主机发出 DNS 请求时,这个报文就发送给该主机的本地域名服务器</p><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p><em>正向解析</em>:把域名映射成 IP 地址</p><p><em>反向解析</em>:把 IP 地址映射成域名</p><p> 客户端要域名解析时,通过本机的 DNS 客户端构造一个 DNS 请求报文,以 UDP 数据报的方式发往本地域名服务器</p><p>域名解析由两种方式:<code>递归查询</code>和<code>递归与迭代相结合的查询</code>:</p><p><strong>递归查询</strong></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/递归查询.svg" alt="递归查询"></p><p>上图中 1-8 表示顺序</p><p>(对根域名服务器造成的负载过大,实际中不使用)</p><p><strong>递归与迭代相结合的查询(实际使用)</strong></p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/迭代查询.svg" alt="迭代查询"></p><p>假定某客户机想获知域名为 y.abc.com 主机的 IP 地址，域名解析的过程（共使用 8 个 UDP 报文）如下：<br>① 客户机向其本地域名服务器发出 DNS 请求报文<br>② 本地域名服务器收到请求后，查询本地缓存，若没有该记录，则以 DNS 客户的身份向根域名服务器发出解析请求<br>③ 根域名服务器收到请求后，判断该域名属于.com 域，将对应的顶级域名服务器 dns.com 的 IP 地址返回给本地域名服务器<br>④ 本地域名服务器向顶级域名服务器 dns.com 发出解析请求报文<br>⑤ 顶级域名服务器 dns.com 收到请求后，判断该域名属于 abc.com 域，因此将对应的授权域名服务器 dns.abc.com 的 IP 地址返回给本地域名服务器<br>⑥ 本地域名服务器向授权域名服务器 dns.abc.com 发起解析请求报文<br>⑦ 授权域名服务器 dns.abc.com 收到请求后，将查询结果返回给本地域名服务器<br>⑧ 本地域名服务器将查询结果保存到本地缓存，同时返回给客户机</p><p>为了提高 DNS 的查询效率，并减少因特网上的 DNS 查询报文数量，在域名服务器中广泛地使用了高速缓存。当一个 DNS 服务器接收到 DNS 查询结果时，它能将该 DNS 信息缓存在<code>高速缓存</code>中。 这样，当另一个相同的域名查询到达该 DNS 服务器时，该服务器就能够直接提供所要求的 IP 地址，而不需要再去向其他 DNS 服务器询问。 因为主机名和 IP 地址之间的映射不是永久的，所以 DNS 服务器将在一段时间后丢弃高速缓存中的信息。</p><blockquote><p>🙋‍♂️ 为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器，并处理超过合理时间的项（如每个项目只存放两天）。当权限域名服务器回答一个查询请求时，在响应中指明绑定有效存在的时间值。增加此时间值可减少网络开销，减少此时间值可以提高域名转换的准确性。</p></blockquote><h2 id="文件传输协议-FTP"><a href="#文件传输协议-FTP" class="headerlink" title="文件传输协议(FTP)"></a>文件传输协议(FTP)</h2><p>FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。它屏蔽了各计算机系统的细节，因而适合于在异构网络中的任意计算机之间传送文件。<br>  FTP 提供以下功能：<br>  ① 提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力<br>  ② 以用户权限管理的方式提供用户对远程 FTP 服务器上的文件管理能力<br>  ③ 以匿名 FTP 的方式提供公用文件共享的能力</p><p>FTP 采用==客户/服务器的工作方式，它使用 TCP 可靠的传输服务==。 一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接收新的请求；另外有若干从属进程，负责处理单个请求。其工作步骤如下：<br>  ① 打开熟知==端口 21（控制端口）==，使客户进程能够连接上<br>  ② 等待客户进程发连接请求<br>  ③ 启动从属进程来处理客户进程发来的请求。主进程与从属进程并发执行，从属进程对客户进程的请求处理完毕后即终止<br>  ④ 回到等待状态，继续接收其他客户进程的请求</p><p>FTP 服务器必须在整个会话期间保留用户的状态信息。特别是服务器必须把指定的用户账户与控制连接联系起来，服务器必须追踪用户在远程目录树上的当前位置。</p><h3 id="控制连接与数据连接"><a href="#控制连接与数据连接" class="headerlink" title="控制连接与数据连接"></a>控制连接与数据连接</h3><h4 id="控制连接"><a href="#控制连接" class="headerlink" title="控制连接"></a>控制连接</h4><p>服务器监听==21 号端口==，等待客户连接，建立在这个端口上的连接称为控制连接，控制连接用来传输控制信息（如连接请求、传送请求等），并且控制信息都以 7 位 ASCII 格式传送。FTP 客户发出的传送请求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。在传输文件时还可以使用控制连接（如客户在传输中途发一个中止传输的命令），==因此控制连接在整个会话期间一直保持打开状态==。</p><h4 id="数据连接"><a href="#数据连接" class="headerlink" title="数据连接"></a>数据连接</h4><p>服务器端的控制进程在接收到 FTP 客户发来的文件传输请求后，就创建“数据传送进程”和“数据连接”。数据连接用来连接客户端和服务器端的数据传送进程，数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。<br>   因为 FTP 使用了一个分离的控制连接，所以也称 FTP 的控制信息是带外（Out-of-band）传送的。==使用 FTP 时，若要修改服务器上的文件，则需要先将此文件传送到本地主机，然后再将修改后的文件副本传送到原服务器==。 网络文件系统（NFS）允许进程打开一个远程文件，并在该文件的某个特定位置开始读写数据。这样，NFS 可使用户复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</p><p><code>数据连接在每次数据传输完毕后就关闭</code></p><p>数据连接有两种传输模式:</p><p><strong>主动模式 PORT</strong></p><p>登录成功后要读取数据时,客户端随机开放一个端口,并发送命令给服务器,服务器收到 PORT 命令和端口号后,通过 20 号端口和客户端提供的端口连接</p><p>即==”服务器固定端口 20 连接到客户端端口”==</p><blockquote><p>🙋‍♂️ 匿名用户使用<code>anonymous</code>作为用户名</p></blockquote><p><strong>被动模式 PASV</strong></p><p>客户端要读取数据时,发送 PASV 到服务器,服务器随机开放一个端口,并告知客户端,客户端再连接到服务器开放的端口进行数据传输</p><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="电子邮件系统的组成结构"><a href="#电子邮件系统的组成结构" class="headerlink" title="电子邮件系统的组成结构"></a>电子邮件系统的组成结构</h3><p>电子邮件是一种异步通信方式，通信时不需要双方同时在场。电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可以随时上网到自己使用的邮件服务器进行读取。<br>   一个电子邮件系统应具有下图所示的三个最主要的组成构件，即<code>用户代理（User Agent）</code>、<code>邮件服务器</code>和<code>电子邮件使用的协议</code>，如<code>SMTP</code>、<code>POP3（或IMAP）</code>等。</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/电子邮件系统.svg" alt="电子邮件系统"></p><p><strong>用户代理（UA）</strong>：<code>用户与电子邮件系统的接口</code>。用户代理使用户能够通过一个很友好的接口发送和接收邮件，用户代理至少应当具有撰写、显示和邮件处理的能力。通常情况下，用户代理就是一个运行在 PC 上的程序，常见的有 Outlook、Foxmail 等</p><p><strong>邮件服务器</strong>：组成电子邮件系统的核心。邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况（已交付、被拒绝、丢失等）。邮件服务器采用客户/服务器方式工作，但它能够同时充当客户和服务器。例如，当邮件服务器 A 向邮件服务器 B 发送邮件时，A 就作为 SMTP 客户，而 B 是 SMTP 服务器；反之，当 B 向 A 发送邮件时，B 就是 SMTP 客户，而 A 就是 SMTP 服务器。</p><p><strong>邮件发送协议和读取协议</strong>：==邮件发送协议用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，通常使用的是 SMTP；邮件读取协议用于用户代理从邮件服务器读取邮件，如 POP3==。 <code>SMTP采用的是“推”（Push）的通信方式</code>，即在用户代理向邮件服务器发送邮件及在邮件服务器之间发送邮件时，SMTP 客户端主动将邮件“推”送到 SMTP 服务器端。而<code>POP3采用的是“拉”（Pull）的通信方式</code>，即用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件。</p><h3 id="电子邮件格式与-MIME"><a href="#电子邮件格式与-MIME" class="headerlink" title="电子邮件格式与 MIME"></a>电子邮件格式与 MIME</h3><h4 id="电子邮件格式"><a href="#电子邮件格式" class="headerlink" title="电子邮件格式"></a>电子邮件格式</h4><p>一个电子邮件分为信封和内容两大部分，邮件内容又分为首部和主体两部分。RFC 822 规定了邮件的首部格式，而邮件的主体部分则让用户自由撰写。用户写好首部后，邮件系统自动地将信封所需的信息提取出来并写在信封上，用户不需要亲自填写信封上的信息。<br>   邮件内容的首部包含一些首部行，每个首部行由一个关键字后跟冒号再后跟值组成。有些关键字是必需的，有些则是可选的。最重要的关键字是<code>To:</code>和<code>Subject：</code>。<br>  ==To 是必需的关键字==，后面填入<code>一个</code>或<code>多个</code>收件人的电子邮件地址。电子邮件地址的规定格式为：收件人邮箱名@邮箱所在主机的域名，如abc@test.com，其中收信人邮箱名即用户名，abc 在 test.com 这个邮件服务器上必须是唯一的。这也就保证了abc@test.com这个邮件地址在整个因特网上是唯一的。<br>  Subject 是可选关键字，是邮件的主题，反映了邮件的主要内容<br>   当然，还有一个必填的关键字是 From，但它通常由邮件系统自动填入。首部和主体之间用一个空行进行分割。典型的邮件内容如下：</p><pre><code class="lang-css">From:hoopdog@hust.edu.comTo:abc@test.comSubject:Say hello to Internetbalabalabala......</code></pre><h4 id="多用途网际邮件扩充（MIME）"><a href="#多用途网际邮件扩充（MIME）" class="headerlink" title="多用途网际邮件扩充（MIME）"></a>多用途网际邮件扩充（MIME）</h4><p>由于 SMTP 只能传送一定长度的 ASCII 码，许多其他非英语国家的文字就无法传送，且无法传送可执行文件及其他二进制对象，因此提出了多用途网络邮件扩充（Multipurpose Internet Mail Extensions,MIME）<br>  <code>MIME并未改动SMTP或取代它</code>。MIME 的意图是继续使用目前的格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则。也就是说，MIME 邮件可在现有的电子邮件程序和协议下传送。MIME 与 SMTP 的关系如图：</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/mime.svg" alt="mime"></p><p>MIME 主要包括以下三部分内容：<br> ①5 个新的邮件首部字段，包括 MIME 版本、内容描述、内容标识、内容传送编码和内容类型<br> ② 定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化<br> ③ 定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变</p><h3 id="SMTP-和-POP3"><a href="#SMTP-和-POP3" class="headerlink" title="SMTP 和 POP3"></a>SMTP 和 POP3</h3><h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><p>简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）是一种提供可靠且有效的电子邮件传输的协议，它控制两个相互通信的 SMTP 进程交换信息。由于 SMTP 使用客户/服务器方式，因此负责发送邮件的 SMTP 进程就是 SMTP 客户，而负责接收邮件的 SMTP 进程就是 SMTP 服务器。==SMTP 使用的是 TCP 连接，端口号为 25==。 SMTP 通信有以下三个阶段：<br>  （1）连接建立<br>   发件人的邮件发送到发送方邮件服务器的邮件缓存中后，==SMTP 客户就每隔一定时间对邮件缓存扫描一次==。如发现有邮件，就使用 SMTP 的熟知端口号（25）与接收方邮件服务器的 SMTP 服务器建立 TCP 连接。连接建立后，接收方 SMTP 服务器发出 220 Service ready（服务就绪）。然后 SMTP 客户向 SMTP 服务器发送 HELO 命令，附上发送方的主机名。<br>  ==SMTP 不使用中间邮件服务器。TCP 连接总是在发送方和接收方这两个邮件服务器之间直接建立，而不管它们相隔多远==。接收方的邮件服务器因故障暂时不能建立连接时，发送方的邮件服务器只能等待一段时间后再次尝试连接。<br>  （2）邮件传送<br>   连接建立后，就可开始传送邮件。邮件的传送从 MAIL 命令开始，MAIL 命令后面有发件人的地址。如 MAIL FROM：hoopdog@hust.edu.cn。若 SMTP 服务器已准备好接收邮件，则回答 250 OK。接着 SMTP 客户端发送一个或多个 RCPT（收件人 recipient 的缩写）命令，格式为 RCPT TO：&lt;收件人地址&gt;。每发送一个 RCPT 命令，都应有相应的信息从 SMTP 服务器返回，如 250OK 或 550 No such user here（无此用户）<br>  RCPT 命令的作用是，先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮件，以便不至于发送了很长的邮件后才知道地址错误，进而避免浪费通信资源。<br>   获得 OK 的回答后，客户端就使用 DATA 命令，表示要开始传输邮件的内容。正常情况下，SMTP 服务器回复信息是 354 Start mail input;end with &lt; CRIF &gt;.&lt; CRIF &gt;。&lt; CRIF &gt;表示回车换行。此时 SMTP 客户端就可开始传送邮件内容，并用&lt; CRIF &gt;.&lt; CRIF &gt;（两个回车，中间一个点）表示邮件内容的结束。<br>  （3）连接释放<br>   邮件发送完毕后，SMTP 客户应发送 QUIT 命令。SMTP 服务器返回的信息是 221（服务关闭），表示 SMTP 同意释放 TCP 连接。邮件传送的全部过程就此结束。</p><h4 id="POP3-和-IMAP"><a href="#POP3-和-IMAP" class="headerlink" title="POP3 和 IMAP"></a>POP3 和 IMAP</h4><p><code>邮局协议（Post Office Protocol,POP）</code>是一个非常简单但功能有限的邮件读取协议，现在使用的是它的第三个版本 POP3。POP3 采用的是“拉”（Pull）的通信方式，当用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件。<br>  POP 也使用客户/服务器的工作方式，==在传输层使用 TCP，端口号为 110==。接收方的用户代理上必须运行 POP 客户程序，而接收方的邮件服务器上则运行 POP 服务器程序。POP 有两种工作方式：<code>“下载并保留”</code>和<code>“下载并删除”</code>。 在“下载并保留”方式下，用户从邮件服务器上读取邮件后，邮件依然会保存在邮件服务器上，用户可再次从服务器上读取该邮件；而使用“下载并删除”方式时，邮件一旦被读取，就在邮件服务器上被删除，用户不能再次从服务器上读取。<br>   另一个邮件接收协议是<code>因特网报文存取协议（IMAP）</code>，它比 POP 复杂得多，IMAP 为用户提供了创建文件夹、在不同文件夹之间移动邮件及在远程文件夹中查询邮件的命令，为此 IMAP 服务器维护了会话用户的状态信息。IMAP 的另一特性是允许用户代理只获取报文的某些部分，例如可以只读取一个报文的首部，或一个多部分 MIME 报文的一部分。这非常适用于低带宽的情况，用户可能并不想取回邮箱中的所有邮件，尤其是包含很多音频或视频的大邮件。</p><p>目前有很多<code>基于万维网的电子邮件</code>，如 Hotmail、Gmail 等。这种电子邮件的特点是，==用户浏览器与 Hotmail 或 Gmail 的邮件服务器之间的邮件发送或接收使用的是 HTTP，而仅在不同邮件服务器之间传送邮件时才使用 SMTP==。</p><h2 id="万维网-www"><a href="#万维网-www" class="headerlink" title="万维网(www)"></a>万维网(www)</h2><p>==万维网（World Wide Web，WWW）是一个资料空间,在这个空间中：一样有用的事物称为一种“资源”，并由一个全域“统一资源定位符”（URL）标识。这些资源通过超文本传输协议（HTTP）传送给使用者，而后者通过单击链接来获取资源。==</p><p>万维网的内核部分是由三个标准构成的：</p><p>（1）<em>统一资源定位符（URL）</em><br>   负责标识万维网上的各种文档，并使每个文档在整个万维网的范围内具有唯一的标识符 URL。<br>（2）<em>超文本传输协议（HTTP）</em><br>   一个应用层协议，它使用 TCP 连接进行可靠的传输， HTTP 是万维网客户程序和服务器程序之间交互所必须严格遵守的协议<br>（3）<em>超文本标记语言（HTML）</em><br>   一种文档结构的标记语言，它使用一些约定的标记对页面上的各种信息（包括文字、声音、图像、视频等）、格式进行描述</p><p>URL 是对可以从因特网上得到的资源的位置和访问方法的一种简洁表示。URL 相当于一个文件名在网络范围的扩展。<br>  URL 的一般形式是：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;<br>  &lt;协议&gt;是指用什么协议来获取万维网文档,常见的协议有 http、ftp 等；&lt;主机&gt;是存放资源的主机在因特网中的域名，也可以是 IP 地址；&lt;端口&gt;和&lt;路径&gt;有时可以省略。</p><h3 id="超文本传输协议（HTTP）"><a href="#超文本传输协议（HTTP）" class="headerlink" title="超文本传输协议（HTTP）"></a>超文本传输协议（HTTP）</h3><p> <code>HTTP定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器</code>。 从层次的角度看，HTTP 是面向事务的（Transaction-oriented）应用层协议，<code>它规定了在浏览器和服务器之间的请求和响应的格式与规则</code>，是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础</p><p>每个万维网站点都有一个服务器进程,他不断监听 TCP 的端口 80(HTTP 端口<code>80</code>,HTTPS 端口<code>443</code>)</p><p> HTTP 采用 TCP 作为传输层协议，保证了数据的可靠传输。 HTTP 不必考虑数据在传输过程中被丢弃后又怎样被重传。但是，HTTP 本身是无连接的。 也就是说，虽然 HTTP 使用了 TCP 连接，但通信的双方在交换 HTTP 报文之前不需要先建立 HTTP 连接。</p><p>HTTP 既可以使用<code>非持久连接</code>，也可以使用<code>持久连接（HTTP/1.1支持）</code><br>   对于非持久连接，每个网页元素对象（如 JPEG 图形、Flash 等）的传输都需要单独建立一个 TCP 连接。也就是说，请求一个万维网文档所需的时间是该文档的传输时间（与文档大小成正比）加上两倍往返时间 RTT（一个 RTT 用于 TCP 连接，另一个 RTT 用于请求和接收文档）</p><blockquote><p>🙋‍♂️ 所谓持久连接，是指万维网服务器在发送响应后仍然保持这条连接，使同一个客户和服务器可以继续在这条连接上传送后续的 HTTP 请求与响应报文。</p></blockquote><p> 持久连接又分为非流水线和流水线两种方式。对于非流水线方式，客户在收到前一个响应后才能发出下一个请求。HTTP/1.1 的默认方式是使用流水线的持久连接。这种情况下，客户每遇到一个对象引用就立即发出一个请求，因而客户可以逐个地连续发出对各个引用对象的请求。如果所有的请求和响应都是连续发送的，那么所有引用的对象共计经历 1 个 RTT 延迟，而不是像非流水线方式那样，每个引用都必须有 1 个 RTT 延迟。</p><h4 id="HTTP-的报文结构"><a href="#HTTP-的报文结构" class="headerlink" title="HTTP 的报文结构"></a>HTTP 的报文结构</h4><p>HTTP 是面向文本的（Text-Oriented），因此报文中的每个字段都是一些 ASCII 码串，并且每个字段的长度都是不确定的。有两类 HTTP 报文：</p><p> 请求报文(resquest)：从客户向服务器发送的请求报文<br>  响应报文(response)：从服务器到客户的回答</p><p>请求和响应报文格式如下 👇</p><p><img src="计算机网络基础/http报文.svg" alt="http报文"></p><p>总结:</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/12.jpg" alt="img"></p><p>以下一图总结并回顾<a href="####TCP报文段">报文段</a>、<a href="####IPv4分组">IP 数据报</a>、<a href="#####以太网的MAC帧">MAC 帧</a>的相关知识 👇</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/总结.svg" alt="总结"></p><h4 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h4><h5 id="请求报文中几个常用方法"><a href="#请求报文中几个常用方法" class="headerlink" title="请求报文中几个常用方法"></a>请求报文中几个常用方法</h5><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">GET</td><td style="text-align:center">请求读取由 URL 标识的信息</td></tr><tr><td style="text-align:center">HEAD</td><td style="text-align:center">请求读取由 URL 标识的信息的首部</td></tr><tr><td style="text-align:center">POST</td><td style="text-align:center">给服务器添加信息(如注释)</td></tr><tr><td style="text-align:center">CONNECT</td><td style="text-align:center">用于代理服务器</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">请求服务器删除指定数据</td></tr></tbody></table></div><h5 id="响应报文中的状态码"><a href="#响应报文中的状态码" class="headerlink" title="响应报文中的状态码"></a>响应报文中的状态码</h5><div class="table-container"><table><thead><tr><th>状态码</th><th>名字</th><th>意义</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续</td></tr><tr><td>101</td><td>Switching Protocols</td><td>切换协议</td></tr><tr><td>102</td><td>Processing</td><td>处理中</td></tr><tr><td>103</td><td>Early Hints</td><td>早期提示</td></tr><tr><td>200</td><td>OK</td><td>请求成功</td></tr><tr><td>201</td><td>Created</td><td>已创建</td></tr><tr><td>202</td><td>Accepted</td><td>已接受</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非官方信息</td></tr><tr><td>204</td><td>No Content</td><td>无内容</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容</td></tr><tr><td>207</td><td>Multi-Status</td><td>多状态</td></tr><tr><td>208</td><td>Already Reported</td><td>已报告</td></tr><tr><td>226</td><td>IM Used</td><td>IM 已使用</td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久重定向</td></tr><tr><td>302</td><td>Found</td><td>找到</td></tr><tr><td>303</td><td>See Other</td><td>参见其他</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向</td></tr><tr><td>308</td><td>Permanent Redirect</td><td>永久重定向</td></tr><tr><td>400</td><td>Bad Request</td><td>错误的请求</td></tr><tr><td>401</td><td>Unauthorized</td><td>未经授权</td></tr><tr><td>402</td><td>Payment Required</td><td>需要付款</td></tr><tr><td>403</td><td>Forbidden</td><td>禁止访问</td></tr><tr><td>404</td><td>Not Found</td><td>未找到</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>方法不允许</td></tr><tr><td>406</td><td>Not Acceptable</td><td>不可接受</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>需要代理身份验证</td></tr><tr><td>408</td><td>Request Timeout</td><td>请求超时</td></tr><tr><td>409</td><td>Conflict</td><td>冲突</td></tr><tr><td>410</td><td>Gone</td><td>已删除</td></tr><tr><td>411</td><td>Length Required</td><td>需要 Content-Length 头部</td></tr><tr><td>412</td><td>Precondition Failed</td><td>前提条件失败</td></tr><tr><td>413</td><td>Payload Too Large</td><td>请求有效载荷过大</td></tr><tr><td>414</td><td>URI Too Long</td><td>请求的 URI 过长</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>不支持的媒体类型</td></tr><tr><td>416</td><td>Range Not Satisfiable</td><td>范围不可满足</td></tr><tr><td>417</td><td>Expectation Failed</td><td>预期失败</td></tr><tr><td>418</td><td>I’m a teapot</td><td>我是一个茶壶</td></tr><tr><td>421</td><td>Misdirected Request</td><td>被错导的请求</td></tr><tr><td>422</td><td>Unprocessable Entity</td><td>无法处理的实体</td></tr><tr><td>423</td><td>Locked</td><td>已锁定</td></tr><tr><td>424</td><td>Failed Dependency</td><td>依赖关系失败</td></tr><tr><td>425</td><td>Too Early</td><td>过早</td></tr><tr><td>426</td><td>Upgrade Required</td><td>需要升级</td></tr><tr><td>428</td><td>Precondition Required</td><td>需要前提条件</td></tr><tr><td>429</td><td>Too Many Requests</td><td>请求过多</td></tr><tr><td>431</td><td>Request Header Fields Too Large</td><td>请求头字段过大</td></tr><tr><td>451</td><td>Unavailable For Legal Reasons</td><td>由于法律原因不可用</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误</td></tr><tr><td>501</td><td>Not Implemented</td><td>未实现</td></tr><tr><td>502</td><td>Bad Gateway</td><td>错误的网关</td></tr><tr><td>503</td><td>Service Unavailable</td><td>服务不可用</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>网关超时</td></tr><tr><td>505</td><td>HTTP Version Not Supported</td><td>不支持的 HTTP 版本</td></tr><tr><td>506</td><td>Variant Also Negotiates</td><td>变体协商也有问题</td></tr><tr><td>507</td><td>Insufficient Storage</td><td>存储空间不足</td></tr><tr><td>508</td><td>Loop Detected</td><td>检测到循环</td></tr><tr><td>510</td><td>Not Extended</td><td>未扩展</td></tr><tr><td>511</td><td>Network Authentication Required</td><td>需要网络认证</td></tr></tbody></table></div><p>HTTP 是无状态的协议,也就是说同一个客户端第二次访问同一个服务器上的页面,服务器的相应与第一次访问相同,因为服务器不记得曾经访问过这个客户,也不记得客户端的访问次数</p><p>在实际应用中常使用 🍪<code>cookie/token + 数据库</code>的方式来跟踪用户活动</p><p>客户端发送 http 请求,服务器接受 client 请求后建立一个<code>session</code>,并 sent 一个 http respone 到 client,这个 response head 中包含了一个<code>set-cookie头部</code>该头部包含<code>sessionid</code></p><p><code>set-cookie</code>格式如下:</p><pre><code class="lang-css">set-cookie : value[; Expries : date][;Domain = domain][;Path = path][;Max-Age : value][;Secure ...]</code></pre><p><em>Expries</em>:cookie 最长有效时间(时间戳),没有设置则表示这是一个会话期 cookie,当会话被关闭此时会话期 cookie 在彼时被移除</p><blockquote><p>🙋‍♂️ 在服务端渲染的页面,其 Expries 的时间戳是服务器时间</p><p>而在客户端渲染的页面,其 Expries 的时间戳是客户端时间</p></blockquote><p><em>Max-Age</em>:cookie 失效前需要经过的秒数,秒数为 0 或-1 会将 cookie 直接过期。Max-Age 的优先级比 Expries 更高</p><p><em>Domain</em>:指定 cookie 可以送达的主机名,没指定的话默认值为当前文档访问地址中的主机部分</p><p><em>Secure</em>:一个带有安全属性的 cookie(只有在请求使用 https 的时候才会被发送到服务端,以阻止中间人攻击)</p><p><em>HttpOnly</em>:用于阻止 JS 通过 Document.cookie 属性访问 cookie,其用来防范跨站攻击脚本 xss</p><p><em>samesite</em>:<samesite-value>:允许一则 cookie 不随跨站请求一起被发送,这可以一定程度上防范跨站请求伪造攻击(CSRF)</samesite-value></p><p> samesite-value:</p><pre><code class="lang-css">    1) strict:意味着浏览器只对同一站点发送请求,即请求来自设置cookie的站点(同域,同协议)    1) Lax:cookie不会在跨站请求中被发送。如加载图像或frame的请求,但cookie在用户从外站导航到源站时cookie也将被发送,这是samesite未被设置时的默认行为    1) None:浏览器在跨站和同站均会发送cookie,设置这一值的同时必须同时设置secure属性</code></pre><h5 id="什么是跨站-什么是跨域-二者有何区别"><a href="#什么是跨站-什么是跨域-二者有何区别" class="headerlink" title="什么是跨站?什么是跨域?二者有何区别?"></a>什么是跨站?什么是跨域?二者有何区别?</h5><p>跨域的定义并不是域名不同或者域不同,而是”不同源”</p><p>同源的定义是协议、域名、端口号三者都相同的 URL</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/源.svg" alt="源"></p><p>具有相同协议、主机名、端口号的组合的网站被视为”相同来源”(same-origin)其他所有内容均视为”跨域”(cross-origin)</p><p>站(site)</p><p>站是指有效顶级域名(effective Top-LeveL Domain, eTLD)和其前面的二级域名的一个整体,即(eTLD+1)</p><p><img src="/2023/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/站.svg" alt="站"></p><blockquote><p>eTLD 列表在 publicsuffix.org/list 上进行维护</p></blockquote><p><strong>同站和跨站</strong></p><p>具有相同的 eTLD+1 的网端被视为同站(same-site)</p><p>具有不同的 eTLD+1 的网端被视为跨站(cross-site)</p><blockquote><p>尽管同站忽略了协议(无协议的同站)在某些情况下必须严格区分协议,以防 HTTP 被用作弱通道,一些文档将同站更明确的定义为 schemeful same site(协议与 eTLD+1 都相同)</p><p>即<a href="https://www.example与http://www.example.com视为跨站">https://www.example与http://www.example.com视为跨站</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
